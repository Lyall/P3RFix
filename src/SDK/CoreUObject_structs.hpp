#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreUObject

#include "Basic.hpp"


namespace SDK
{

// Enum CoreUObject.EInterpCurveMode
// NumValues: 0x0007
enum class EInterpCurveMode : uint8
{
	CIM_Linear                               = 0,
	CIM_CurveAuto                            = 1,
	CIM_Constant                             = 2,
	CIM_CurveUser                            = 3,
	CIM_CurveBreak                           = 4,
	CIM_CurveAutoClamped                     = 5,
	CIM_MAX                                  = 6,
};

// Enum CoreUObject.ERangeBoundTypes
// NumValues: 0x0004
enum class ERangeBoundTypes : uint8
{
	Exclusive                                = 0,
	Inclusive                                = 1,
	Open                                     = 2,
	ERangeBoundTypes_MAX                     = 3,
};

// Enum CoreUObject.ELocalizedTextSourceCategory
// NumValues: 0x0004
enum class ELocalizedTextSourceCategory : uint8
{
	Game                                     = 0,
	Engine                                   = 1,
	Editor                                   = 2,
	ELocalizedTextSourceCategory_MAX         = 3,
};

// Enum CoreUObject.EAutomationEventType
// NumValues: 0x0004
enum class EAutomationEventType : uint8
{
	Info                                     = 0,
	Warning                                  = 1,
	Error                                    = 2,
	EAutomationEventType_MAX                 = 3,
};

// Enum CoreUObject.EPixelFormat
// NumValues: 0x0048
enum class EPixelFormat : uint8
{
	PF_Unknown                               = 0,
	PF_A32B32G32R32F                         = 1,
	PF_B8G8R8A8                              = 2,
	PF_G8                                    = 3,
	PF_G16                                   = 4,
	PF_DXT1                                  = 5,
	PF_DXT3                                  = 6,
	PF_DXT5                                  = 7,
	PF_UYVY                                  = 8,
	PF_FloatRGB                              = 9,
	PF_FloatRGBA                             = 10,
	PF_DepthStencil                          = 11,
	PF_ShadowDepth                           = 12,
	PF_R32_FLOAT                             = 13,
	PF_G16R16                                = 14,
	PF_G16R16F                               = 15,
	PF_G16R16F_FILTER                        = 16,
	PF_G32R32F                               = 17,
	PF_A2B10G10R10                           = 18,
	PF_A16B16G16R16                          = 19,
	PF_D24                                   = 20,
	PF_R16F                                  = 21,
	PF_R16F_FILTER                           = 22,
	PF_BC5                                   = 23,
	PF_V8U8                                  = 24,
	PF_A1                                    = 25,
	PF_FloatR11G11B10                        = 26,
	PF_A8                                    = 27,
	PF_R32_UINT                              = 28,
	PF_R32_SINT                              = 29,
	PF_PVRTC2                                = 30,
	PF_PVRTC4                                = 31,
	PF_R16_UINT                              = 32,
	PF_R16_SINT                              = 33,
	PF_R16G16B16A16_UINT                     = 34,
	PF_R16G16B16A16_SINT                     = 35,
	PF_R5G6B5_UNORM                          = 36,
	PF_R8G8B8A8                              = 37,
	PF_A8R8G8B8                              = 38,
	PF_BC4                                   = 39,
	PF_R8G8                                  = 40,
	PF_ATC_RGB                               = 41,
	PF_ATC_RGBA_E                            = 42,
	PF_ATC_RGBA_I                            = 43,
	PF_X24_G8                                = 44,
	PF_ETC1                                  = 45,
	PF_ETC2_RGB                              = 46,
	PF_ETC2_RGBA                             = 47,
	PF_R32G32B32A32_UINT                     = 48,
	PF_R16G16_UINT                           = 49,
	PF_ASTC_4x4                              = 50,
	PF_ASTC_6x6                              = 51,
	PF_ASTC_8x8                              = 52,
	PF_ASTC_10x10                            = 53,
	PF_ASTC_12x12                            = 54,
	PF_BC6H                                  = 55,
	PF_BC7                                   = 56,
	PF_R8_UINT                               = 57,
	PF_L8                                    = 58,
	PF_XGXR8                                 = 59,
	PF_R8G8B8A8_UINT                         = 60,
	PF_R8G8B8A8_SNORM                        = 61,
	PF_R16G16B16A16_UNORM                    = 62,
	PF_R16G16B16A16_SNORM                    = 63,
	PF_PLATFORM_HDR_0                        = 64,
	PF_PLATFORM_HDR_1                        = 65,
	PF_PLATFORM_HDR_2                        = 66,
	PF_NV12                                  = 67,
	PF_R32G32_UINT                           = 68,
	PF_ETC2_R11_EAC                          = 69,
	PF_ETC2_RG11_EAC                         = 70,
	PF_MAX_0                                 = 72,
};

// Enum CoreUObject.ELifetimeCondition
// NumValues: 0x0010
enum class ELifetimeCondition : uint8
{
	COND_None                                = 0,
	COND_InitialOnly                         = 1,
	COND_OwnerOnly                           = 2,
	COND_SkipOwner                           = 3,
	COND_SimulatedOnly                       = 4,
	COND_AutonomousOnly                      = 5,
	COND_SimulatedOrPhysics                  = 6,
	COND_InitialOrOwner                      = 7,
	COND_Custom                              = 8,
	COND_ReplayOrOwner                       = 9,
	COND_ReplayOnly                          = 10,
	COND_SimulatedOnlyNoReplay               = 11,
	COND_SimulatedOrPhysicsNoReplay          = 12,
	COND_SkipReplay                          = 13,
	COND_Never                               = 15,
	COND_Max                                 = 16,
};

// Enum CoreUObject.EDataValidationResult
// NumValues: 0x0004
enum class EDataValidationResult : uint8
{
	Invalid                                  = 0,
	Valid                                    = 1,
	NotValidated                             = 2,
	EDataValidationResult_MAX                = 3,
};

// Enum CoreUObject.EAppMsgType
// NumValues: 0x0009
enum class EAppMsgType : uint8
{
	Ok                                       = 0,
	YesNo                                    = 1,
	OkCancel                                 = 2,
	YesNoCancel                              = 3,
	CancelRetryContinue                      = 4,
	YesNoYesAllNoAll                         = 5,
	YesNoYesAllNoAllCancel                   = 6,
	YesNoYesAll                              = 7,
	EAppMsgType_MAX                          = 8,
};

// Enum CoreUObject.EAppReturnType
// NumValues: 0x0009
enum class EAppReturnType : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	YesAll                                   = 2,
	NoAll                                    = 3,
	Cancel                                   = 4,
	Ok                                       = 5,
	Retry                                    = 6,
	Continue                                 = 7,
	EAppReturnType_MAX                       = 8,
};

// Enum CoreUObject.EPropertyAccessChangeNotifyMode
// NumValues: 0x0004
enum class EPropertyAccessChangeNotifyMode : uint8
{
	Default                                  = 0,
	Never                                    = 1,
	Always                                   = 2,
	EPropertyAccessChangeNotifyMode_MAX      = 3,
};

// Enum CoreUObject.EUnit
// NumValues: 0x0033
enum class EUnit : uint8
{
	Micrometers                              = 0,
	Millimeters                              = 1,
	Centimeters                              = 2,
	Meters                                   = 3,
	Kilometers                               = 4,
	Inches                                   = 5,
	Feet                                     = 6,
	Yards                                    = 7,
	Miles                                    = 8,
	Lightyears                               = 9,
	Degrees                                  = 10,
	Radians                                  = 11,
	MetersPerSecond                          = 12,
	KilometersPerHour                        = 13,
	MilesPerHour                             = 14,
	Celsius                                  = 15,
	Farenheit                                = 16,
	Kelvin                                   = 17,
	Micrograms                               = 18,
	Milligrams                               = 19,
	Grams                                    = 20,
	Kilograms                                = 21,
	MetricTons                               = 22,
	Ounces                                   = 23,
	Pounds                                   = 24,
	Stones                                   = 25,
	Newtons                                  = 26,
	PoundsForce                              = 27,
	KilogramsForce                           = 28,
	Hertz                                    = 29,
	Kilohertz                                = 30,
	Megahertz                                = 31,
	Gigahertz                                = 32,
	RevolutionsPerMinute                     = 33,
	Bytes                                    = 34,
	Kilobytes                                = 35,
	Megabytes                                = 36,
	Gigabytes                                = 37,
	Terabytes                                = 38,
	Lumens                                   = 39,
	Milliseconds                             = 43,
	Seconds                                  = 44,
	Minutes                                  = 45,
	Hours                                    = 46,
	Days                                     = 47,
	Months                                   = 48,
	Years                                    = 49,
	Multiplier                               = 52,
	Percentage                               = 51,
	Unspecified                              = 53,
	EUnit_MAX                                = 54,
};

// Enum CoreUObject.EMouseCursor
// NumValues: 0x000F
enum class EMouseCursor : uint8
{
	None                                     = 0,
	Default                                  = 1,
	TextEditBeam                             = 2,
	ResizeLeftRight                          = 3,
	ResizeUpDown                             = 4,
	ResizeSouthEast                          = 5,
	ResizeSouthWest                          = 6,
	CardinalCross                            = 7,
	Crosshairs                               = 8,
	Hand                                     = 9,
	GrabHand                                 = 10,
	GrabHandClosed                           = 11,
	SlashedCircle                            = 12,
	EyeDropper                               = 13,
	EMouseCursor_MAX                         = 14,
};

// Enum CoreUObject.EAxis
// NumValues: 0x0005
enum class EAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	EAxis_MAX                                = 4,
};

// Enum CoreUObject.ELogTimes
// NumValues: 0x0005
enum class ELogTimes : uint8
{
	None                                     = 0,
	UTC                                      = 1,
	SinceGStartTime                          = 2,
	Local                                    = 3,
	ELogTimes_MAX                            = 4,
};

// Enum CoreUObject.ESearchDir
// NumValues: 0x0003
enum class ESearchDir : uint8
{
	FromStart                                = 0,
	FromEnd                                  = 1,
	ESearchDir_MAX                           = 2,
};

// Enum CoreUObject.ESearchCase
// NumValues: 0x0003
enum class ESearchCase : uint8
{
	CaseSensitive                            = 0,
	IgnoreCase                               = 1,
	ESearchCase_MAX                          = 2,
};

// ScriptStruct CoreUObject.SoftObjectPath
// 0x0018 (0x0018 - 0x0000)
struct FSoftObjectPath
{
public:
	class FName                                   AssetPathName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubPathString;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftObjectPath) == 0x000008, "Wrong alignment on FSoftObjectPath");
static_assert(sizeof(FSoftObjectPath) == 0x000018, "Wrong size on FSoftObjectPath");
static_assert(offsetof(FSoftObjectPath, AssetPathName) == 0x000000, "Member 'FSoftObjectPath::AssetPathName' has a wrong offset!");
static_assert(offsetof(FSoftObjectPath, SubPathString) == 0x000008, "Member 'FSoftObjectPath::SubPathString' has a wrong offset!");

// ScriptStruct CoreUObject.AssetBundleEntry
// 0x0018 (0x0018 - 0x0000)
struct FAssetBundleEntry final
{
public:
	class FName                                   BundleName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                BundleAssets;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetBundleEntry) == 0x000008, "Wrong alignment on FAssetBundleEntry");
static_assert(sizeof(FAssetBundleEntry) == 0x000018, "Wrong size on FAssetBundleEntry");
static_assert(offsetof(FAssetBundleEntry, BundleName) == 0x000000, "Member 'FAssetBundleEntry::BundleName' has a wrong offset!");
static_assert(offsetof(FAssetBundleEntry, BundleAssets) == 0x000008, "Member 'FAssetBundleEntry::BundleAssets' has a wrong offset!");

// ScriptStruct CoreUObject.JoinabilitySettings
// 0x0014 (0x0014 - 0x0000)
struct FJoinabilitySettings final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPublicSearchable;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInvites;                                     // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinViaPresence;                                  // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinViaPresenceFriendsOnly;                       // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPartySize;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJoinabilitySettings) == 0x000004, "Wrong alignment on FJoinabilitySettings");
static_assert(sizeof(FJoinabilitySettings) == 0x000014, "Wrong size on FJoinabilitySettings");
static_assert(offsetof(FJoinabilitySettings, SessionName) == 0x000000, "Member 'FJoinabilitySettings::SessionName' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, bPublicSearchable) == 0x000008, "Member 'FJoinabilitySettings::bPublicSearchable' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, bAllowInvites) == 0x000009, "Member 'FJoinabilitySettings::bAllowInvites' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, bJoinViaPresence) == 0x00000A, "Member 'FJoinabilitySettings::bJoinViaPresence' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, bJoinViaPresenceFriendsOnly) == 0x00000B, "Member 'FJoinabilitySettings::bJoinViaPresenceFriendsOnly' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, MaxPlayers) == 0x00000C, "Member 'FJoinabilitySettings::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FJoinabilitySettings, MaxPartySize) == 0x000010, "Member 'FJoinabilitySettings::MaxPartySize' has a wrong offset!");

// ScriptStruct CoreUObject.AssetBundleData
// 0x0010 (0x0010 - 0x0000)
struct FAssetBundleData final
{
public:
	TArray<struct FAssetBundleEntry>              Bundles;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetBundleData) == 0x000008, "Wrong alignment on FAssetBundleData");
static_assert(sizeof(FAssetBundleData) == 0x000010, "Wrong size on FAssetBundleData");
static_assert(offsetof(FAssetBundleData, Bundles) == 0x000000, "Member 'FAssetBundleData::Bundles' has a wrong offset!");

// ScriptStruct CoreUObject.UniqueNetIdWrapper
// 0x0001 (0x0001 - 0x0000)
struct FUniqueNetIdWrapper
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueNetIdWrapper) == 0x000001, "Wrong alignment on FUniqueNetIdWrapper");
static_assert(sizeof(FUniqueNetIdWrapper) == 0x000001, "Wrong size on FUniqueNetIdWrapper");

// ScriptStruct CoreUObject.AssetData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FAssetData final
{
public:
	class FName                                   ObjectPath;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PackageName;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PackagePath;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetClass;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetData) == 0x000008, "Wrong alignment on FAssetData");
static_assert(sizeof(FAssetData) == 0x000060, "Wrong size on FAssetData");
static_assert(offsetof(FAssetData, ObjectPath) == 0x000000, "Member 'FAssetData::ObjectPath' has a wrong offset!");
static_assert(offsetof(FAssetData, PackageName) == 0x000008, "Member 'FAssetData::PackageName' has a wrong offset!");
static_assert(offsetof(FAssetData, PackagePath) == 0x000010, "Member 'FAssetData::PackagePath' has a wrong offset!");
static_assert(offsetof(FAssetData, AssetName) == 0x000018, "Member 'FAssetData::AssetName' has a wrong offset!");
static_assert(offsetof(FAssetData, AssetClass) == 0x000020, "Member 'FAssetData::AssetClass' has a wrong offset!");

// ScriptStruct CoreUObject.Guid
// 0x0010 (0x0010 - 0x0000)
struct FGuid final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         C;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         D;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuid) == 0x000004, "Wrong alignment on FGuid");
static_assert(sizeof(FGuid) == 0x000010, "Wrong size on FGuid");
static_assert(offsetof(FGuid, A) == 0x000000, "Member 'FGuid::A' has a wrong offset!");
static_assert(offsetof(FGuid, B) == 0x000004, "Member 'FGuid::B' has a wrong offset!");
static_assert(offsetof(FGuid, C) == 0x000008, "Member 'FGuid::C' has a wrong offset!");
static_assert(offsetof(FGuid, D) == 0x00000C, "Member 'FGuid::D' has a wrong offset!");

// ScriptStruct CoreUObject.TestUninitializedScriptStructMembersTest
// 0x0018 (0x0018 - 0x0000)
struct FTestUninitializedScriptStructMembersTest final
{
public:
	class UObject*                                UninitializedObjectReference;                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InitializedObjectReference;                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnusedValue;                                       // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestUninitializedScriptStructMembersTest) == 0x000008, "Wrong alignment on FTestUninitializedScriptStructMembersTest");
static_assert(sizeof(FTestUninitializedScriptStructMembersTest) == 0x000018, "Wrong size on FTestUninitializedScriptStructMembersTest");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, UninitializedObjectReference) == 0x000000, "Member 'FTestUninitializedScriptStructMembersTest::UninitializedObjectReference' has a wrong offset!");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, InitializedObjectReference) == 0x000008, "Member 'FTestUninitializedScriptStructMembersTest::InitializedObjectReference' has a wrong offset!");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, UnusedValue) == 0x000010, "Member 'FTestUninitializedScriptStructMembersTest::UnusedValue' has a wrong offset!");

// ScriptStruct CoreUObject.Vector
// 0x000C (0x000C - 0x0000)
struct FVector
{
public:
	using UnderlayingType = float;                                                                   // 0x0000(0x0008)(NOT AUTO-GENERATED PROPERTY)

	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	FVector& Normalize()
	{
		*this /= Magnitude();
		return *this;
	}
	FVector& operator*=(const FVector& Other)
	{
		*this = *this * Other;
		return *this;
	}
	FVector& operator*=(float Scalar)
	{
		*this = *this * Scalar;
		return *this;
	}
	FVector& operator+=(const FVector& Other)
	{
		*this = *this + Other;
		return *this;
	}
	FVector& operator-=(const FVector& Other)
	{
		*this = *this - Other;
		return *this;
	}
	FVector& operator/=(const FVector& Other)
	{
		*this = *this / Other;
		return *this;
	}
	FVector& operator/=(float Scalar)
	{
		*this = *this / Scalar;
		return *this;
	}

	UnderlayingType Dot(const FVector& Other) const
	{
		return (X * Other.X) + (Y * Other.Y) + (Z * Other.Z);
	}
	UnderlayingType GetDistanceTo(const FVector& Other) const
	{
		FVector DiffVector = Other - *this;
		return DiffVector.Magnitude();
	}
	UnderlayingType GetDistanceToInMeters(const FVector& Other) const
	{
		return GetDistanceTo(Other) * 0.01;
	}
	FVector GetNormalized() const
	{
		return *this / Magnitude();
	}
	bool IsZero() const
	{
		return X == 0.0 && Y == 0.0 && Z == 0.0;
	}
	UnderlayingType Magnitude() const
	{
		return std::sqrt((X * X) + (Y * Y) + (Z * Z));
	}
	bool operator!=(const FVector& Other) const
	{
		return X != Other.X || Y != Other.Y || Z != Other.Z;
	}
	FVector operator*(const FVector& Other) const
	{
		return { X * Other.X, Y * Other.Y, Z * Other.Z };
	}
	FVector operator*(float Scalar) const
	{
		return { X * Scalar, Y * Scalar, Z * Scalar };
	}
	FVector operator+(const FVector& Other) const
	{
		return { X + Other.X, Y + Other.Y, Z + Other.Z };
	}
	FVector operator-(const FVector& Other) const
	{
		return { X - Other.X, Y - Other.Y, Z - Other.Z };
	}
	FVector operator/(const FVector& Other) const
	{
		if (Other.X == 0.0f || Other.Y == 0.0f ||Other.Z == 0.0f)
			return *this;
	
		return { X / Other.X, Y / Other.Y, Z / Other.Z };
	}
	FVector operator/(float Scalar) const
	{
		if (Scalar == 0.0f)
			return *this;
	
		return { X / Scalar, Y / Scalar, Z / Scalar };
	}
	bool operator==(const FVector& Other) const
	{
		return X == Other.X && Y == Other.Y && Z == Other.Z;
	}
};
static_assert(alignof(FVector) == 0x000004, "Wrong alignment on FVector");
static_assert(sizeof(FVector) == 0x00000C, "Wrong size on FVector");
static_assert(offsetof(FVector, X) == 0x000000, "Member 'FVector::X' has a wrong offset!");
static_assert(offsetof(FVector, Y) == 0x000004, "Member 'FVector::Y' has a wrong offset!");
static_assert(offsetof(FVector, Z) == 0x000008, "Member 'FVector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Vector4
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x10) FVector4 final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector4) == 0x000010, "Wrong alignment on FVector4");
static_assert(sizeof(FVector4) == 0x000010, "Wrong size on FVector4");
static_assert(offsetof(FVector4, X) == 0x000000, "Member 'FVector4::X' has a wrong offset!");
static_assert(offsetof(FVector4, Y) == 0x000004, "Member 'FVector4::Y' has a wrong offset!");
static_assert(offsetof(FVector4, Z) == 0x000008, "Member 'FVector4::Z' has a wrong offset!");
static_assert(offsetof(FVector4, W) == 0x00000C, "Member 'FVector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.Vector2D
// 0x0008 (0x0008 - 0x0000)
struct FVector2D final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector2D) == 0x000004, "Wrong alignment on FVector2D");
static_assert(sizeof(FVector2D) == 0x000008, "Wrong size on FVector2D");
static_assert(offsetof(FVector2D, X) == 0x000000, "Member 'FVector2D::X' has a wrong offset!");
static_assert(offsetof(FVector2D, Y) == 0x000004, "Member 'FVector2D::Y' has a wrong offset!");

// ScriptStruct CoreUObject.TwoVectors
// 0x0018 (0x0018 - 0x0000)
struct FTwoVectors final
{
public:
	struct FVector                                V1;                                                // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V2;                                                // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTwoVectors) == 0x000004, "Wrong alignment on FTwoVectors");
static_assert(sizeof(FTwoVectors) == 0x000018, "Wrong size on FTwoVectors");
static_assert(offsetof(FTwoVectors, V1) == 0x000000, "Member 'FTwoVectors::V1' has a wrong offset!");
static_assert(offsetof(FTwoVectors, V2) == 0x00000C, "Member 'FTwoVectors::V2' has a wrong offset!");

// ScriptStruct CoreUObject.Plane
// 0x0004 (0x0010 - 0x000C)
struct alignas(0x10) FPlane final : public FVector
{
public:
	float                                         W;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlane) == 0x000010, "Wrong alignment on FPlane");
static_assert(sizeof(FPlane) == 0x000010, "Wrong size on FPlane");
static_assert(offsetof(FPlane, W) == 0x00000C, "Member 'FPlane::W' has a wrong offset!");

// ScriptStruct CoreUObject.Rotator
// 0x000C (0x000C - 0x0000)
struct FRotator final
{
public:
	float                                         Pitch;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotator) == 0x000004, "Wrong alignment on FRotator");
static_assert(sizeof(FRotator) == 0x00000C, "Wrong size on FRotator");
static_assert(offsetof(FRotator, Pitch) == 0x000000, "Member 'FRotator::Pitch' has a wrong offset!");
static_assert(offsetof(FRotator, Yaw) == 0x000004, "Member 'FRotator::Yaw' has a wrong offset!");
static_assert(offsetof(FRotator, Roll) == 0x000008, "Member 'FRotator::Roll' has a wrong offset!");

// ScriptStruct CoreUObject.Quat
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x10) FQuat final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuat) == 0x000010, "Wrong alignment on FQuat");
static_assert(sizeof(FQuat) == 0x000010, "Wrong size on FQuat");
static_assert(offsetof(FQuat, X) == 0x000000, "Member 'FQuat::X' has a wrong offset!");
static_assert(offsetof(FQuat, Y) == 0x000004, "Member 'FQuat::Y' has a wrong offset!");
static_assert(offsetof(FQuat, Z) == 0x000008, "Member 'FQuat::Z' has a wrong offset!");
static_assert(offsetof(FQuat, W) == 0x00000C, "Member 'FQuat::W' has a wrong offset!");

// ScriptStruct CoreUObject.PackedNormal
// 0x0004 (0x0004 - 0x0000)
struct FPackedNormal final
{
public:
	uint8                                         X;                                                 // 0x0000(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Y;                                                 // 0x0001(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Z;                                                 // 0x0002(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         W;                                                 // 0x0003(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedNormal) == 0x000001, "Wrong alignment on FPackedNormal");
static_assert(sizeof(FPackedNormal) == 0x000004, "Wrong size on FPackedNormal");
static_assert(offsetof(FPackedNormal, X) == 0x000000, "Member 'FPackedNormal::X' has a wrong offset!");
static_assert(offsetof(FPackedNormal, Y) == 0x000001, "Member 'FPackedNormal::Y' has a wrong offset!");
static_assert(offsetof(FPackedNormal, Z) == 0x000002, "Member 'FPackedNormal::Z' has a wrong offset!");
static_assert(offsetof(FPackedNormal, W) == 0x000003, "Member 'FPackedNormal::W' has a wrong offset!");

// ScriptStruct CoreUObject.PackedRGB10A2N
// 0x0004 (0x0004 - 0x0000)
struct FPackedRGB10A2N final
{
public:
	int32                                         Packed;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedRGB10A2N) == 0x000004, "Wrong alignment on FPackedRGB10A2N");
static_assert(sizeof(FPackedRGB10A2N) == 0x000004, "Wrong size on FPackedRGB10A2N");
static_assert(offsetof(FPackedRGB10A2N, Packed) == 0x000000, "Member 'FPackedRGB10A2N::Packed' has a wrong offset!");

// ScriptStruct CoreUObject.PackedRGBA16N
// 0x0008 (0x0008 - 0x0000)
struct FPackedRGBA16N final
{
public:
	int32                                         XY;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZW;                                                // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedRGBA16N) == 0x000004, "Wrong alignment on FPackedRGBA16N");
static_assert(sizeof(FPackedRGBA16N) == 0x000008, "Wrong size on FPackedRGBA16N");
static_assert(offsetof(FPackedRGBA16N, XY) == 0x000000, "Member 'FPackedRGBA16N::XY' has a wrong offset!");
static_assert(offsetof(FPackedRGBA16N, ZW) == 0x000004, "Member 'FPackedRGBA16N::ZW' has a wrong offset!");

// ScriptStruct CoreUObject.IntPoint
// 0x0008 (0x0008 - 0x0000)
struct FIntPoint final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntPoint) == 0x000004, "Wrong alignment on FIntPoint");
static_assert(sizeof(FIntPoint) == 0x000008, "Wrong size on FIntPoint");
static_assert(offsetof(FIntPoint, X) == 0x000000, "Member 'FIntPoint::X' has a wrong offset!");
static_assert(offsetof(FIntPoint, Y) == 0x000004, "Member 'FIntPoint::Y' has a wrong offset!");

// ScriptStruct CoreUObject.IntVector
// 0x000C (0x000C - 0x0000)
struct FIntVector final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntVector) == 0x000004, "Wrong alignment on FIntVector");
static_assert(sizeof(FIntVector) == 0x00000C, "Wrong size on FIntVector");
static_assert(offsetof(FIntVector, X) == 0x000000, "Member 'FIntVector::X' has a wrong offset!");
static_assert(offsetof(FIntVector, Y) == 0x000004, "Member 'FIntVector::Y' has a wrong offset!");
static_assert(offsetof(FIntVector, Z) == 0x000008, "Member 'FIntVector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Color
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FColor final
{
public:
	uint8                                         B;                                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         G;                                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         R;                                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         A;                                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColor) == 0x000004, "Wrong alignment on FColor");
static_assert(sizeof(FColor) == 0x000004, "Wrong size on FColor");
static_assert(offsetof(FColor, B) == 0x000000, "Member 'FColor::B' has a wrong offset!");
static_assert(offsetof(FColor, G) == 0x000001, "Member 'FColor::G' has a wrong offset!");
static_assert(offsetof(FColor, R) == 0x000002, "Member 'FColor::R' has a wrong offset!");
static_assert(offsetof(FColor, A) == 0x000003, "Member 'FColor::A' has a wrong offset!");

// ScriptStruct CoreUObject.LinearColor
// 0x0010 (0x0010 - 0x0000)
struct FLinearColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinearColor) == 0x000004, "Wrong alignment on FLinearColor");
static_assert(sizeof(FLinearColor) == 0x000010, "Wrong size on FLinearColor");
static_assert(offsetof(FLinearColor, R) == 0x000000, "Member 'FLinearColor::R' has a wrong offset!");
static_assert(offsetof(FLinearColor, G) == 0x000004, "Member 'FLinearColor::G' has a wrong offset!");
static_assert(offsetof(FLinearColor, B) == 0x000008, "Member 'FLinearColor::B' has a wrong offset!");
static_assert(offsetof(FLinearColor, A) == 0x00000C, "Member 'FLinearColor::A' has a wrong offset!");

// ScriptStruct CoreUObject.Box
// 0x001C (0x001C - 0x0000)
struct FBox final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsValid;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox) == 0x000004, "Wrong alignment on FBox");
static_assert(sizeof(FBox) == 0x00001C, "Wrong size on FBox");
static_assert(offsetof(FBox, Min) == 0x000000, "Member 'FBox::Min' has a wrong offset!");
static_assert(offsetof(FBox, Max) == 0x00000C, "Member 'FBox::Max' has a wrong offset!");
static_assert(offsetof(FBox, IsValid) == 0x000018, "Member 'FBox::IsValid' has a wrong offset!");

// ScriptStruct CoreUObject.Box2D
// 0x0014 (0x0014 - 0x0000)
struct FBox2D final
{
public:
	struct FVector2D                              Min;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Max;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsValid;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox2D) == 0x000004, "Wrong alignment on FBox2D");
static_assert(sizeof(FBox2D) == 0x000014, "Wrong size on FBox2D");
static_assert(offsetof(FBox2D, Min) == 0x000000, "Member 'FBox2D::Min' has a wrong offset!");
static_assert(offsetof(FBox2D, Max) == 0x000008, "Member 'FBox2D::Max' has a wrong offset!");
static_assert(offsetof(FBox2D, bIsValid) == 0x000010, "Member 'FBox2D::bIsValid' has a wrong offset!");

// ScriptStruct CoreUObject.BoxSphereBounds
// 0x001C (0x001C - 0x0000)
struct FBoxSphereBounds final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxSphereBounds) == 0x000004, "Wrong alignment on FBoxSphereBounds");
static_assert(sizeof(FBoxSphereBounds) == 0x00001C, "Wrong size on FBoxSphereBounds");
static_assert(offsetof(FBoxSphereBounds, Origin) == 0x000000, "Member 'FBoxSphereBounds::Origin' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds, BoxExtent) == 0x00000C, "Member 'FBoxSphereBounds::BoxExtent' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds, SphereRadius) == 0x000018, "Member 'FBoxSphereBounds::SphereRadius' has a wrong offset!");

// ScriptStruct CoreUObject.OrientedBox
// 0x003C (0x003C - 0x0000)
struct FOrientedBox final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisX;                                             // 0x000C(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisY;                                             // 0x0018(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisZ;                                             // 0x0024(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentX;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentY;                                           // 0x0034(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentZ;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrientedBox) == 0x000004, "Wrong alignment on FOrientedBox");
static_assert(sizeof(FOrientedBox) == 0x00003C, "Wrong size on FOrientedBox");
static_assert(offsetof(FOrientedBox, Center) == 0x000000, "Member 'FOrientedBox::Center' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisX) == 0x00000C, "Member 'FOrientedBox::AxisX' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisY) == 0x000018, "Member 'FOrientedBox::AxisY' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisZ) == 0x000024, "Member 'FOrientedBox::AxisZ' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentX) == 0x000030, "Member 'FOrientedBox::ExtentX' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentY) == 0x000034, "Member 'FOrientedBox::ExtentY' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentZ) == 0x000038, "Member 'FOrientedBox::ExtentZ' has a wrong offset!");

// ScriptStruct CoreUObject.Matrix
// 0x0040 (0x0040 - 0x0000)
struct FMatrix final
{
public:
	struct FPlane                                 XPlane;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 YPlane;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 ZPlane;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 WPlane;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatrix) == 0x000010, "Wrong alignment on FMatrix");
static_assert(sizeof(FMatrix) == 0x000040, "Wrong size on FMatrix");
static_assert(offsetof(FMatrix, XPlane) == 0x000000, "Member 'FMatrix::XPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, YPlane) == 0x000010, "Member 'FMatrix::YPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, ZPlane) == 0x000020, "Member 'FMatrix::ZPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, WPlane) == 0x000030, "Member 'FMatrix::WPlane' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointFloat
// 0x0014 (0x0014 - 0x0000)
struct FInterpCurvePointFloat final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutVal;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangent;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangent;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointFloat) == 0x000004, "Wrong alignment on FInterpCurvePointFloat");
static_assert(sizeof(FInterpCurvePointFloat) == 0x000014, "Wrong size on FInterpCurvePointFloat");
static_assert(offsetof(FInterpCurvePointFloat, InVal) == 0x000000, "Member 'FInterpCurvePointFloat::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, OutVal) == 0x000004, "Member 'FInterpCurvePointFloat::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, ArriveTangent) == 0x000008, "Member 'FInterpCurvePointFloat::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, LeaveTangent) == 0x00000C, "Member 'FInterpCurvePointFloat::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, InterpMode) == 0x000010, "Member 'FInterpCurvePointFloat::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveFloat
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveFloat final
{
public:
	TArray<struct FInterpCurvePointFloat>         Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveFloat) == 0x000008, "Wrong alignment on FInterpCurveFloat");
static_assert(sizeof(FInterpCurveFloat) == 0x000018, "Wrong size on FInterpCurveFloat");
static_assert(offsetof(FInterpCurveFloat, Points) == 0x000000, "Member 'FInterpCurveFloat::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveFloat, bIsLooped) == 0x000010, "Member 'FInterpCurveFloat::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveFloat, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveFloat::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointVector2D
// 0x0020 (0x0020 - 0x0000)
struct FInterpCurvePointVector2D final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutVal;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ArriveTangent;                                     // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeaveTangent;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointVector2D) == 0x000004, "Wrong alignment on FInterpCurvePointVector2D");
static_assert(sizeof(FInterpCurvePointVector2D) == 0x000020, "Wrong size on FInterpCurvePointVector2D");
static_assert(offsetof(FInterpCurvePointVector2D, InVal) == 0x000000, "Member 'FInterpCurvePointVector2D::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, OutVal) == 0x000004, "Member 'FInterpCurvePointVector2D::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, ArriveTangent) == 0x00000C, "Member 'FInterpCurvePointVector2D::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, LeaveTangent) == 0x000014, "Member 'FInterpCurvePointVector2D::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, InterpMode) == 0x00001C, "Member 'FInterpCurvePointVector2D::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveVector2D
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveVector2D final
{
public:
	TArray<struct FInterpCurvePointVector2D>      Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveVector2D) == 0x000008, "Wrong alignment on FInterpCurveVector2D");
static_assert(sizeof(FInterpCurveVector2D) == 0x000018, "Wrong size on FInterpCurveVector2D");
static_assert(offsetof(FInterpCurveVector2D, Points) == 0x000000, "Member 'FInterpCurveVector2D::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector2D, bIsLooped) == 0x000010, "Member 'FInterpCurveVector2D::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector2D, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveVector2D::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointVector
// 0x002C (0x002C - 0x0000)
struct FInterpCurvePointVector final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutVal;                                            // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArriveTangent;                                     // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveTangent;                                      // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointVector) == 0x000004, "Wrong alignment on FInterpCurvePointVector");
static_assert(sizeof(FInterpCurvePointVector) == 0x00002C, "Wrong size on FInterpCurvePointVector");
static_assert(offsetof(FInterpCurvePointVector, InVal) == 0x000000, "Member 'FInterpCurvePointVector::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, OutVal) == 0x000004, "Member 'FInterpCurvePointVector::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, ArriveTangent) == 0x000010, "Member 'FInterpCurvePointVector::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, LeaveTangent) == 0x00001C, "Member 'FInterpCurvePointVector::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, InterpMode) == 0x000028, "Member 'FInterpCurvePointVector::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveVector
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveVector final
{
public:
	TArray<struct FInterpCurvePointVector>        Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveVector) == 0x000008, "Wrong alignment on FInterpCurveVector");
static_assert(sizeof(FInterpCurveVector) == 0x000018, "Wrong size on FInterpCurveVector");
static_assert(offsetof(FInterpCurveVector, Points) == 0x000000, "Member 'FInterpCurveVector::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector, bIsLooped) == 0x000010, "Member 'FInterpCurveVector::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveVector::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointQuat
// 0x0050 (0x0050 - 0x0000)
struct FInterpCurvePointQuat final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  OutVal;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  ArriveTangent;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  LeaveTangent;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointQuat) == 0x000010, "Wrong alignment on FInterpCurvePointQuat");
static_assert(sizeof(FInterpCurvePointQuat) == 0x000050, "Wrong size on FInterpCurvePointQuat");
static_assert(offsetof(FInterpCurvePointQuat, InVal) == 0x000000, "Member 'FInterpCurvePointQuat::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, OutVal) == 0x000010, "Member 'FInterpCurvePointQuat::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, ArriveTangent) == 0x000020, "Member 'FInterpCurvePointQuat::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, LeaveTangent) == 0x000030, "Member 'FInterpCurvePointQuat::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, InterpMode) == 0x000040, "Member 'FInterpCurvePointQuat::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveQuat
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveQuat final
{
public:
	TArray<struct FInterpCurvePointQuat>          Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveQuat) == 0x000008, "Wrong alignment on FInterpCurveQuat");
static_assert(sizeof(FInterpCurveQuat) == 0x000018, "Wrong size on FInterpCurveQuat");
static_assert(offsetof(FInterpCurveQuat, Points) == 0x000000, "Member 'FInterpCurveQuat::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveQuat, bIsLooped) == 0x000010, "Member 'FInterpCurveQuat::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveQuat, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveQuat::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointTwoVectors
// 0x0050 (0x0050 - 0x0000)
struct FInterpCurvePointTwoVectors final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTwoVectors                            OutVal;                                            // 0x0004(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTwoVectors                            ArriveTangent;                                     // 0x001C(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTwoVectors                            LeaveTangent;                                      // 0x0034(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointTwoVectors) == 0x000004, "Wrong alignment on FInterpCurvePointTwoVectors");
static_assert(sizeof(FInterpCurvePointTwoVectors) == 0x000050, "Wrong size on FInterpCurvePointTwoVectors");
static_assert(offsetof(FInterpCurvePointTwoVectors, InVal) == 0x000000, "Member 'FInterpCurvePointTwoVectors::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, OutVal) == 0x000004, "Member 'FInterpCurvePointTwoVectors::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, ArriveTangent) == 0x00001C, "Member 'FInterpCurvePointTwoVectors::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, LeaveTangent) == 0x000034, "Member 'FInterpCurvePointTwoVectors::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, InterpMode) == 0x00004C, "Member 'FInterpCurvePointTwoVectors::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveTwoVectors
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveTwoVectors final
{
public:
	TArray<struct FInterpCurvePointTwoVectors>    Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveTwoVectors) == 0x000008, "Wrong alignment on FInterpCurveTwoVectors");
static_assert(sizeof(FInterpCurveTwoVectors) == 0x000018, "Wrong size on FInterpCurveTwoVectors");
static_assert(offsetof(FInterpCurveTwoVectors, Points) == 0x000000, "Member 'FInterpCurveTwoVectors::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveTwoVectors, bIsLooped) == 0x000010, "Member 'FInterpCurveTwoVectors::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveTwoVectors, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveTwoVectors::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointLinearColor
// 0x0038 (0x0038 - 0x0000)
struct FInterpCurvePointLinearColor final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutVal;                                            // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ArriveTangent;                                     // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LeaveTangent;                                      // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointLinearColor) == 0x000004, "Wrong alignment on FInterpCurvePointLinearColor");
static_assert(sizeof(FInterpCurvePointLinearColor) == 0x000038, "Wrong size on FInterpCurvePointLinearColor");
static_assert(offsetof(FInterpCurvePointLinearColor, InVal) == 0x000000, "Member 'FInterpCurvePointLinearColor::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, OutVal) == 0x000004, "Member 'FInterpCurvePointLinearColor::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, ArriveTangent) == 0x000014, "Member 'FInterpCurvePointLinearColor::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, LeaveTangent) == 0x000024, "Member 'FInterpCurvePointLinearColor::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, InterpMode) == 0x000034, "Member 'FInterpCurvePointLinearColor::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveLinearColor
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveLinearColor final
{
public:
	TArray<struct FInterpCurvePointLinearColor>   Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveLinearColor) == 0x000008, "Wrong alignment on FInterpCurveLinearColor");
static_assert(sizeof(FInterpCurveLinearColor) == 0x000018, "Wrong size on FInterpCurveLinearColor");
static_assert(offsetof(FInterpCurveLinearColor, Points) == 0x000000, "Member 'FInterpCurveLinearColor::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveLinearColor, bIsLooped) == 0x000010, "Member 'FInterpCurveLinearColor::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveLinearColor, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveLinearColor::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.Transform
// 0x0030 (0x0030 - 0x0000)
struct FTransform final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale3D;                                           // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransform) == 0x000010, "Wrong alignment on FTransform");
static_assert(sizeof(FTransform) == 0x000030, "Wrong size on FTransform");
static_assert(offsetof(FTransform, Rotation) == 0x000000, "Member 'FTransform::Rotation' has a wrong offset!");
static_assert(offsetof(FTransform, Translation) == 0x000010, "Member 'FTransform::Translation' has a wrong offset!");
static_assert(offsetof(FTransform, Scale3D) == 0x000020, "Member 'FTransform::Scale3D' has a wrong offset!");

// ScriptStruct CoreUObject.RandomStream
// 0x0008 (0x0008 - 0x0000)
struct FRandomStream final
{
public:
	int32                                         InitialSeed;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomStream) == 0x000004, "Wrong alignment on FRandomStream");
static_assert(sizeof(FRandomStream) == 0x000008, "Wrong size on FRandomStream");
static_assert(offsetof(FRandomStream, InitialSeed) == 0x000000, "Member 'FRandomStream::InitialSeed' has a wrong offset!");
static_assert(offsetof(FRandomStream, Seed) == 0x000004, "Member 'FRandomStream::Seed' has a wrong offset!");

// ScriptStruct CoreUObject.DateTime
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDateTime final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDateTime) == 0x000008, "Wrong alignment on FDateTime");
static_assert(sizeof(FDateTime) == 0x000008, "Wrong size on FDateTime");

// ScriptStruct CoreUObject.FrameNumber
// 0x0004 (0x0004 - 0x0000)
struct FFrameNumber final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameNumber) == 0x000004, "Wrong alignment on FFrameNumber");
static_assert(sizeof(FFrameNumber) == 0x000004, "Wrong size on FFrameNumber");
static_assert(offsetof(FFrameNumber, Value) == 0x000000, "Member 'FFrameNumber::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FrameRate
// 0x0008 (0x0008 - 0x0000)
struct FFrameRate final
{
public:
	int32                                         Numerator;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Denominator;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameRate) == 0x000004, "Wrong alignment on FFrameRate");
static_assert(sizeof(FFrameRate) == 0x000008, "Wrong size on FFrameRate");
static_assert(offsetof(FFrameRate, Numerator) == 0x000000, "Member 'FFrameRate::Numerator' has a wrong offset!");
static_assert(offsetof(FFrameRate, Denominator) == 0x000004, "Member 'FFrameRate::Denominator' has a wrong offset!");

// ScriptStruct CoreUObject.FrameTime
// 0x0008 (0x0008 - 0x0000)
struct FFrameTime final
{
public:
	struct FFrameNumber                           FrameNumber;                                       // 0x0000(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubFrame;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameTime) == 0x000004, "Wrong alignment on FFrameTime");
static_assert(sizeof(FFrameTime) == 0x000008, "Wrong size on FFrameTime");
static_assert(offsetof(FFrameTime, FrameNumber) == 0x000000, "Member 'FFrameTime::FrameNumber' has a wrong offset!");
static_assert(offsetof(FFrameTime, SubFrame) == 0x000004, "Member 'FFrameTime::SubFrame' has a wrong offset!");

// ScriptStruct CoreUObject.QualifiedFrameTime
// 0x0010 (0x0010 - 0x0000)
struct FQualifiedFrameTime final
{
public:
	struct FFrameTime                             Time;                                              // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameRate                             Rate;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQualifiedFrameTime) == 0x000004, "Wrong alignment on FQualifiedFrameTime");
static_assert(sizeof(FQualifiedFrameTime) == 0x000010, "Wrong size on FQualifiedFrameTime");
static_assert(offsetof(FQualifiedFrameTime, Time) == 0x000000, "Member 'FQualifiedFrameTime::Time' has a wrong offset!");
static_assert(offsetof(FQualifiedFrameTime, Rate) == 0x000008, "Member 'FQualifiedFrameTime::Rate' has a wrong offset!");

// ScriptStruct CoreUObject.Timecode
// 0x0014 (0x0014 - 0x0000)
struct FTimecode final
{
public:
	int32                                         Hours;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Frames;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropFrameFormat;                                  // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimecode) == 0x000004, "Wrong alignment on FTimecode");
static_assert(sizeof(FTimecode) == 0x000014, "Wrong size on FTimecode");
static_assert(offsetof(FTimecode, Hours) == 0x000000, "Member 'FTimecode::Hours' has a wrong offset!");
static_assert(offsetof(FTimecode, Minutes) == 0x000004, "Member 'FTimecode::Minutes' has a wrong offset!");
static_assert(offsetof(FTimecode, Seconds) == 0x000008, "Member 'FTimecode::Seconds' has a wrong offset!");
static_assert(offsetof(FTimecode, Frames) == 0x00000C, "Member 'FTimecode::Frames' has a wrong offset!");
static_assert(offsetof(FTimecode, bDropFrameFormat) == 0x000010, "Member 'FTimecode::bDropFrameFormat' has a wrong offset!");

// ScriptStruct CoreUObject.Timespan
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FTimespan final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimespan) == 0x000008, "Wrong alignment on FTimespan");
static_assert(sizeof(FTimespan) == 0x000008, "Wrong size on FTimespan");

// ScriptStruct CoreUObject.SoftClassPath
// 0x0000 (0x0018 - 0x0018)
struct FSoftClassPath final : public FSoftObjectPath
{
};
static_assert(alignof(FSoftClassPath) == 0x000008, "Wrong alignment on FSoftClassPath");
static_assert(sizeof(FSoftClassPath) == 0x000018, "Wrong size on FSoftClassPath");

// ScriptStruct CoreUObject.PrimaryAssetType
// 0x0008 (0x0008 - 0x0000)
struct FPrimaryAssetType final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimaryAssetType) == 0x000004, "Wrong alignment on FPrimaryAssetType");
static_assert(sizeof(FPrimaryAssetType) == 0x000008, "Wrong size on FPrimaryAssetType");
static_assert(offsetof(FPrimaryAssetType, Name) == 0x000000, "Member 'FPrimaryAssetType::Name' has a wrong offset!");

// ScriptStruct CoreUObject.PrimaryAssetId
// 0x0010 (0x0010 - 0x0000)
struct FPrimaryAssetId final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrimaryAssetName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimaryAssetId) == 0x000004, "Wrong alignment on FPrimaryAssetId");
static_assert(sizeof(FPrimaryAssetId) == 0x000010, "Wrong size on FPrimaryAssetId");
static_assert(offsetof(FPrimaryAssetId, PrimaryAssetType) == 0x000000, "Member 'FPrimaryAssetId::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(FPrimaryAssetId, PrimaryAssetName) == 0x000008, "Member 'FPrimaryAssetId::PrimaryAssetName' has a wrong offset!");

// ScriptStruct CoreUObject.FallbackStruct
// 0x0001 (0x0001 - 0x0000)
struct FFallbackStruct final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFallbackStruct) == 0x000001, "Wrong alignment on FFallbackStruct");
static_assert(sizeof(FFallbackStruct) == 0x000001, "Wrong size on FFallbackStruct");

// ScriptStruct CoreUObject.FloatRangeBound
// 0x0008 (0x0008 - 0x0000)
struct FFloatRangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFloatRangeBound) == 0x000004, "Wrong alignment on FFloatRangeBound");
static_assert(sizeof(FFloatRangeBound) == 0x000008, "Wrong size on FFloatRangeBound");
static_assert(offsetof(FFloatRangeBound, Type) == 0x000000, "Member 'FFloatRangeBound::Type' has a wrong offset!");
static_assert(offsetof(FFloatRangeBound, Value) == 0x000004, "Member 'FFloatRangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FloatRange
// 0x0010 (0x0010 - 0x0000)
struct FFloatRange final
{
public:
	struct FFloatRangeBound                       LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRangeBound                       UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFloatRange) == 0x000004, "Wrong alignment on FFloatRange");
static_assert(sizeof(FFloatRange) == 0x000010, "Wrong size on FFloatRange");
static_assert(offsetof(FFloatRange, LowerBound) == 0x000000, "Member 'FFloatRange::LowerBound' has a wrong offset!");
static_assert(offsetof(FFloatRange, UpperBound) == 0x000008, "Member 'FFloatRange::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.Int32RangeBound
// 0x0008 (0x0008 - 0x0000)
struct FInt32RangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInt32RangeBound) == 0x000004, "Wrong alignment on FInt32RangeBound");
static_assert(sizeof(FInt32RangeBound) == 0x000008, "Wrong size on FInt32RangeBound");
static_assert(offsetof(FInt32RangeBound, Type) == 0x000000, "Member 'FInt32RangeBound::Type' has a wrong offset!");
static_assert(offsetof(FInt32RangeBound, Value) == 0x000004, "Member 'FInt32RangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Range
// 0x0010 (0x0010 - 0x0000)
struct FInt32Range final
{
public:
	struct FInt32RangeBound                       LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInt32RangeBound                       UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInt32Range) == 0x000004, "Wrong alignment on FInt32Range");
static_assert(sizeof(FInt32Range) == 0x000010, "Wrong size on FInt32Range");
static_assert(offsetof(FInt32Range, LowerBound) == 0x000000, "Member 'FInt32Range::LowerBound' has a wrong offset!");
static_assert(offsetof(FInt32Range, UpperBound) == 0x000008, "Member 'FInt32Range::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.FrameNumberRangeBound
// 0x0008 (0x0008 - 0x0000)
struct FFrameNumberRangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFrameNumber                           Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameNumberRangeBound) == 0x000004, "Wrong alignment on FFrameNumberRangeBound");
static_assert(sizeof(FFrameNumberRangeBound) == 0x000008, "Wrong size on FFrameNumberRangeBound");
static_assert(offsetof(FFrameNumberRangeBound, Type) == 0x000000, "Member 'FFrameNumberRangeBound::Type' has a wrong offset!");
static_assert(offsetof(FFrameNumberRangeBound, Value) == 0x000004, "Member 'FFrameNumberRangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FrameNumberRange
// 0x0010 (0x0010 - 0x0000)
struct FFrameNumberRange final
{
public:
	struct FFrameNumberRangeBound                 LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFrameNumberRangeBound                 UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameNumberRange) == 0x000004, "Wrong alignment on FFrameNumberRange");
static_assert(sizeof(FFrameNumberRange) == 0x000010, "Wrong size on FFrameNumberRange");
static_assert(offsetof(FFrameNumberRange, LowerBound) == 0x000000, "Member 'FFrameNumberRange::LowerBound' has a wrong offset!");
static_assert(offsetof(FFrameNumberRange, UpperBound) == 0x000008, "Member 'FFrameNumberRange::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.FloatInterval
// 0x0008 (0x0008 - 0x0000)
struct FFloatInterval final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatInterval) == 0x000004, "Wrong alignment on FFloatInterval");
static_assert(sizeof(FFloatInterval) == 0x000008, "Wrong size on FFloatInterval");
static_assert(offsetof(FFloatInterval, Min) == 0x000000, "Member 'FFloatInterval::Min' has a wrong offset!");
static_assert(offsetof(FFloatInterval, Max) == 0x000004, "Member 'FFloatInterval::Max' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Interval
// 0x0008 (0x0008 - 0x0000)
struct FInt32Interval final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Interval) == 0x000004, "Wrong alignment on FInt32Interval");
static_assert(sizeof(FInt32Interval) == 0x000008, "Wrong size on FInt32Interval");
static_assert(offsetof(FInt32Interval, Min) == 0x000000, "Member 'FInt32Interval::Min' has a wrong offset!");
static_assert(offsetof(FInt32Interval, Max) == 0x000004, "Member 'FInt32Interval::Max' has a wrong offset!");

// ScriptStruct CoreUObject.PolyglotTextData
// 0x00B8 (0x00B8 - 0x0000)
struct FPolyglotTextData final
{
public:
	ELocalizedTextSourceCategory                  Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NativeCulture;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Namespace;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NativeString;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            LocalizedStrings;                                  // 0x0048(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsMinimalPatch;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CachedText;                                        // 0x00A0(0x0018)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPolyglotTextData) == 0x000008, "Wrong alignment on FPolyglotTextData");
static_assert(sizeof(FPolyglotTextData) == 0x0000B8, "Wrong size on FPolyglotTextData");
static_assert(offsetof(FPolyglotTextData, Category) == 0x000000, "Member 'FPolyglotTextData::Category' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, NativeCulture) == 0x000008, "Member 'FPolyglotTextData::NativeCulture' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, Namespace) == 0x000018, "Member 'FPolyglotTextData::Namespace' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, Key) == 0x000028, "Member 'FPolyglotTextData::Key' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, NativeString) == 0x000038, "Member 'FPolyglotTextData::NativeString' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, LocalizedStrings) == 0x000048, "Member 'FPolyglotTextData::LocalizedStrings' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, bIsMinimalPatch) == 0x000098, "Member 'FPolyglotTextData::bIsMinimalPatch' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, CachedText) == 0x0000A0, "Member 'FPolyglotTextData::CachedText' has a wrong offset!");

// ScriptStruct CoreUObject.AutomationEvent
// 0x0038 (0x0038 - 0x0000)
struct FAutomationEvent final
{
public:
	EAutomationEventType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Context;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Artifact;                                          // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutomationEvent) == 0x000008, "Wrong alignment on FAutomationEvent");
static_assert(sizeof(FAutomationEvent) == 0x000038, "Wrong size on FAutomationEvent");
static_assert(offsetof(FAutomationEvent, Type) == 0x000000, "Member 'FAutomationEvent::Type' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Message) == 0x000008, "Member 'FAutomationEvent::Message' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Context) == 0x000018, "Member 'FAutomationEvent::Context' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Artifact) == 0x000028, "Member 'FAutomationEvent::Artifact' has a wrong offset!");

// ScriptStruct CoreUObject.AutomationExecutionEntry
// 0x0058 (0x0058 - 0x0000)
struct FAutomationExecutionEntry final
{
public:
	struct FAutomationEvent                       Event;                                             // 0x0000(0x0038)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LineNumber;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutomationExecutionEntry) == 0x000008, "Wrong alignment on FAutomationExecutionEntry");
static_assert(sizeof(FAutomationExecutionEntry) == 0x000058, "Wrong size on FAutomationExecutionEntry");
static_assert(offsetof(FAutomationExecutionEntry, Event) == 0x000000, "Member 'FAutomationExecutionEntry::Event' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, Filename) == 0x000038, "Member 'FAutomationExecutionEntry::Filename' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, LineNumber) == 0x000048, "Member 'FAutomationExecutionEntry::LineNumber' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, Timestamp) == 0x000050, "Member 'FAutomationExecutionEntry::Timestamp' has a wrong offset!");

// ScriptStruct CoreUObject.ARFilter
// 0x00F0 (0x00F0 - 0x0000)
struct FARFilter final
{
public:
	TArray<class FName>                           PackageNames;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           PackagePaths;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ObjectPaths;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ClassNames;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             RecursiveClassesExclusionSet;                      // 0x0090(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRecursivePaths;                                   // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursiveClasses;                                 // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOnlyOnDiskAssets;                          // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0xD];                                       // 0x00E3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FARFilter) == 0x000008, "Wrong alignment on FARFilter");
static_assert(sizeof(FARFilter) == 0x0000F0, "Wrong size on FARFilter");
static_assert(offsetof(FARFilter, PackageNames) == 0x000000, "Member 'FARFilter::PackageNames' has a wrong offset!");
static_assert(offsetof(FARFilter, PackagePaths) == 0x000010, "Member 'FARFilter::PackagePaths' has a wrong offset!");
static_assert(offsetof(FARFilter, ObjectPaths) == 0x000020, "Member 'FARFilter::ObjectPaths' has a wrong offset!");
static_assert(offsetof(FARFilter, ClassNames) == 0x000030, "Member 'FARFilter::ClassNames' has a wrong offset!");
static_assert(offsetof(FARFilter, RecursiveClassesExclusionSet) == 0x000090, "Member 'FARFilter::RecursiveClassesExclusionSet' has a wrong offset!");
static_assert(offsetof(FARFilter, bRecursivePaths) == 0x0000E0, "Member 'FARFilter::bRecursivePaths' has a wrong offset!");
static_assert(offsetof(FARFilter, bRecursiveClasses) == 0x0000E1, "Member 'FARFilter::bRecursiveClasses' has a wrong offset!");
static_assert(offsetof(FARFilter, bIncludeOnlyOnDiskAssets) == 0x0000E2, "Member 'FARFilter::bIncludeOnlyOnDiskAssets' has a wrong offset!");

}

