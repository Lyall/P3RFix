#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SoundManager

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "SoundManager_structs.hpp"


namespace SDK
{

// Class SoundManager.AsyncCueSheetManager
// 0x0038 (0x0060 - 0x0028)
class UAsyncCueSheetManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnLoadCompleted;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadFailed;                                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USoundAtomCueSheet*                     CueSheet;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundAtomCueSheet* GetAtomCueSheet();
	void LoadAsync(const struct FSoftObjectPath& PathForCueSheet);
	void OnLoadCompleted__DelegateSignature();
	void OnLoadFailed__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncCueSheetManager">();
	}
	static class UAsyncCueSheetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncCueSheetManager>();
	}
};
static_assert(alignof(UAsyncCueSheetManager) == 0x000008, "Wrong alignment on UAsyncCueSheetManager");
static_assert(sizeof(UAsyncCueSheetManager) == 0x000060, "Wrong size on UAsyncCueSheetManager");
static_assert(offsetof(UAsyncCueSheetManager, OnLoadCompleted) == 0x000028, "Member 'UAsyncCueSheetManager::OnLoadCompleted' has a wrong offset!");
static_assert(offsetof(UAsyncCueSheetManager, OnLoadFailed) == 0x000038, "Member 'UAsyncCueSheetManager::OnLoadFailed' has a wrong offset!");
static_assert(offsetof(UAsyncCueSheetManager, CueSheet) == 0x000048, "Member 'UAsyncCueSheetManager::CueSheet' has a wrong offset!");

// Class SoundManager.LiveLipSync
// 0x0008 (0x0030 - 0x0028)
class ULiveLipSync final : public UObject
{
public:
	class ULipsAtomAnalyzer*                      LipsAnalyzer;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AttachSoundManager(int32 MajNum, int32 MinNum);
	bool DetachSoundManager(int32 MajNum, int32 MinNum);
	struct FCriLipsMouthInfo GetLipsyncLiveInfo();
	struct FCriLipsMorphTargetBlendAmountAsJapanese GetLipsyncLiveJapanese();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LiveLipSync">();
	}
	static class ULiveLipSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULiveLipSync>();
	}
};
static_assert(alignof(ULiveLipSync) == 0x000008, "Wrong alignment on ULiveLipSync");
static_assert(sizeof(ULiveLipSync) == 0x000030, "Wrong size on ULiveLipSync");
static_assert(offsetof(ULiveLipSync, LipsAnalyzer) == 0x000028, "Member 'ULiveLipSync::LipsAnalyzer' has a wrong offset!");

// Class SoundManager.PlayerControlBlock
// 0x0078 (0x00A0 - 0x0028)
class UPlayerControlBlock final : public UObject
{
public:
	class UAtomComponent*                         Player;                                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ULipsAtomAnalyzer*                      LipsAnalyzer;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControlBlock">();
	}
	static class UPlayerControlBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerControlBlock>();
	}
};
static_assert(alignof(UPlayerControlBlock) == 0x000008, "Wrong alignment on UPlayerControlBlock");
static_assert(sizeof(UPlayerControlBlock) == 0x0000A0, "Wrong size on UPlayerControlBlock");
static_assert(offsetof(UPlayerControlBlock, Player) == 0x000028, "Member 'UPlayerControlBlock::Player' has a wrong offset!");
static_assert(offsetof(UPlayerControlBlock, LipsAnalyzer) == 0x000090, "Member 'UPlayerControlBlock::LipsAnalyzer' has a wrong offset!");

// Class SoundManager.AcbFileControlBlock
// 0x0030 (0x0058 - 0x0028)
class UAcbFileControlBlock final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCueSheet*                     CueSheet;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UACBLoadObject*                         Loader;                                            // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AcbFileControlBlock">();
	}
	static class UAcbFileControlBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAcbFileControlBlock>();
	}
};
static_assert(alignof(UAcbFileControlBlock) == 0x000008, "Wrong alignment on UAcbFileControlBlock");
static_assert(sizeof(UAcbFileControlBlock) == 0x000058, "Wrong size on UAcbFileControlBlock");
static_assert(offsetof(UAcbFileControlBlock, CueSheet) == 0x000040, "Member 'UAcbFileControlBlock::CueSheet' has a wrong offset!");
static_assert(offsetof(UAcbFileControlBlock, Loader) == 0x000048, "Member 'UAcbFileControlBlock::Loader' has a wrong offset!");

// Class SoundManager.PlayAdxControl
// 0x0A70 (0x0A98 - 0x0028)
class UPlayAdxControl final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerControlBlock*                    MPlayerControlBlock[0x100];                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAcbFileControlBlock*                   MAcbFileControlBlock[0x40];                        // 0x0840(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A40[0x58];                                     // 0x0A40(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetNumCuePlayingCountByName(const class FString& Name_0);

	bool AttachLipsyncLive(int32 MajorNum, int32 MinorNum);
	bool CheckPauseSound(int32 PlayerMajorID, int32 PlayerMinorID);
	bool CheckPlaying(int32 PlayerMajorID, int32 PlayerMinorID);
	int32 CheckReadAcb(const class FString& Filename);
	bool CheckReadEnd(int32 bankID);
	int32 CreatePlayerBank(int32 PlayerMajorID, int32 PlayerMinorID, bool IsMulti);
	bool DetachLipsyncLive(int32 MajorNum, int32 MinorNum);
	bool FadeInBGMCategorySoundmanager(int32 FadeInTime, float FadeInVolume);
	void FadeInSndMng(int32 PlayerMajorID, int32 PlayerMinorID, int32 FadeInTime);
	bool FadeOutBGMCategorySoundManager(int32 FadeOutTime, float FadeOutVolume);
	void FadeOutSndMng(int32 PlayerMajorID, int32 PlayerMinorID, int32 FadeOutTime);
	float GetIntegratedLoudness();
	int64 GetLengthPlayerBank(int32 MajorNum, int32 MinorNum, int32 CueId);
	int64 GetLengthSoundBank(int32 bankID, int32 CueId);
	struct FCriLipsMouthInfo GetLipsyncLiveInfo(int32 MajorNum, int32 MinorNum);
	struct FCriLipsMorphTargetBlendAmountAsJapanese GetLipsyncLiveJapanese(int32 MajorNum, int32 MinorNum);
	float GetMomentaryLoudness();
	float GetShortLoudness();
	float GetTime(int32 PlayerMajorID, int32 PlayerMinorID);
	bool IsLoop(int32 PlayerMajorID, int32 PlayerMinorID);
	void PauseSound(int32 PlayerMajorID, int32 PlayerMinorID, bool Flag);
	void ReleasePlayerBank(int32 PlayerMajorID, int32 PlayerMinorID);
	void RequestFreeAcb(int32 bankID);
	int32 RequestLoadAcb(const class FString& Filename);
	void RequestSound(int32 PlayerMajorID, int32 PlayerMinorID, int32 CueId, bool IsForceChange);
	void ResetLoudness();
	void SetPlayerAcbBank(int32 PlayerMajorID, int32 PlayerMinorID, EPlayerType Type, int32 bankID);
	void StopSound(int32 PlayerMajorID, int32 PlayerMinorID);
	void StopSound_IMD(int32 PlayerMajorID, int32 PlayerMinorID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAdxControl">();
	}
	static class UPlayAdxControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAdxControl>();
	}
};
static_assert(alignof(UPlayAdxControl) == 0x000008, "Wrong alignment on UPlayAdxControl");
static_assert(sizeof(UPlayAdxControl) == 0x000A98, "Wrong size on UPlayAdxControl");
static_assert(offsetof(UPlayAdxControl, MPlayerControlBlock) == 0x000040, "Member 'UPlayAdxControl::MPlayerControlBlock' has a wrong offset!");
static_assert(offsetof(UPlayAdxControl, MAcbFileControlBlock) == 0x000840, "Member 'UPlayAdxControl::MAcbFileControlBlock' has a wrong offset!");

// Class SoundManager.ACBLoadObject
// 0x0010 (0x00C0 - 0x00B0)
class UACBLoadObject final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncCueSheetManager*                  Loader;                                            // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLoadCompleted();
	void OnLoadFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACBLoadObject">();
	}
	static class UACBLoadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACBLoadObject>();
	}
};
static_assert(alignof(UACBLoadObject) == 0x000008, "Wrong alignment on UACBLoadObject");
static_assert(sizeof(UACBLoadObject) == 0x0000C0, "Wrong size on UACBLoadObject");
static_assert(offsetof(UACBLoadObject, Loader) == 0x0000B8, "Member 'UACBLoadObject::Loader' has a wrong offset!");

// Class SoundManager.SoundManagerReadyAsyncFunction
// 0x0028 (0x0058 - 0x0030)
class USoundManagerReadyAsyncFunction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundManagerReadyAsyncFunction* SoundManagerReadyAsyncFunction(class UObject* WorldContextObject, class UPlayAdxControl* Control, int32 bankID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManagerReadyAsyncFunction">();
	}
	static class USoundManagerReadyAsyncFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManagerReadyAsyncFunction>();
	}
};
static_assert(alignof(USoundManagerReadyAsyncFunction) == 0x000008, "Wrong alignment on USoundManagerReadyAsyncFunction");
static_assert(sizeof(USoundManagerReadyAsyncFunction) == 0x000058, "Wrong size on USoundManagerReadyAsyncFunction");
static_assert(offsetof(USoundManagerReadyAsyncFunction, Completed) == 0x000030, "Member 'USoundManagerReadyAsyncFunction::Completed' has a wrong offset!");

// Class SoundManager.SoundManagerGameInstanceSubSystem
// 0x0010 (0x0040 - 0x0030)
class USoundManagerGameInstanceSubSystem final : public UGameInstanceSubsystem
{
public:
	class UPlayAdxControl*                        PlayAdxControl;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPlayAdxControl* GetPlayAdxControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManagerGameInstanceSubSystem">();
	}
	static class USoundManagerGameInstanceSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManagerGameInstanceSubSystem>();
	}
};
static_assert(alignof(USoundManagerGameInstanceSubSystem) == 0x000008, "Wrong alignment on USoundManagerGameInstanceSubSystem");
static_assert(sizeof(USoundManagerGameInstanceSubSystem) == 0x000040, "Wrong size on USoundManagerGameInstanceSubSystem");
static_assert(offsetof(USoundManagerGameInstanceSubSystem, PlayAdxControl) == 0x000030, "Member 'USoundManagerGameInstanceSubSystem::PlayAdxControl' has a wrong offset!");

}

