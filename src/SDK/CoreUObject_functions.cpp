#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreUObject

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "CoreUObject_parameters.hpp"


namespace SDK
{

// Predefined Function
// Finds a UObject in the global object array by name, optionally with ECastFlags to reduce heavy string comparison

class UObject* UObject::FindObjectFastImpl(const std::string& Name, EClassCastFlags RequiredType)
{
	for (int i = 0; i < GObjects->Num(); ++i)
	{
		UObject* Object = GObjects->GetByIndex(i);
	
		if (!Object)
			continue;
		
		if (Object->HasTypeFlag(RequiredType) && Object->GetName() == Name)
			return Object;
	}

	return nullptr;
}


// Predefined Function
// Finds a UObject in the global object array by full-name, optionally with ECastFlags to reduce heavy string comparison

class UObject* UObject::FindObjectImpl(const std::string& FullName, EClassCastFlags RequiredType)
{
	for (int i = 0; i < GObjects->Num(); ++i)
	{
		UObject* Object = GObjects->GetByIndex(i);
	
		if (!Object)
			continue;
		
		if (Object->HasTypeFlag(RequiredType) && Object->GetFullName() == FullName)
			return Object;
	}

	return nullptr;
}


// Predefined Function
// Returns the name of this object in the format 'Class Package.Outer.Object'

std::string UObject::GetFullName() const
{
	if (this && Class)
	{
		std::string Temp;

		for (UObject* NextOuter = Outer; NextOuter; NextOuter = NextOuter->Outer)
		{
			Temp = NextOuter->GetName() + "." + Temp;
		}

		std::string Name = Class->GetName();
		Name += " ";
		Name += Temp;
		Name += GetName();

		return Name;
	}

	return "None";
}


// Predefined Function
// Retuns the name of this object

std::string UObject::GetName() const
{
	return this ? Name.ToString() : "None";
}


// Predefined Function
// Checks Class->FunctionFlags for TypeFlags

bool UObject::HasTypeFlag(EClassCastFlags TypeFlags) const
{
	return (Class->CastFlags & TypeFlags);
}


// Predefined Function
// Checks a UObjects' type by TypeFlags

bool UObject::IsA(EClassCastFlags TypeFlags) const
{
	return (Class->CastFlags & TypeFlags);
}


// Predefined Function
// Checks a UObjects' type by Class

bool UObject::IsA(class UClass* TypeClass) const
{
	return Class->IsSubclassOf(TypeClass);
}


// Predefined Function
// Checks whether this object is a classes' default-object

bool UObject::IsDefaultObject() const
{
	return (Flags & EObjectFlags::ClassDefaultObject);
}


// Function CoreUObject.Object.ExecuteUbergraph
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   EntryPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObject::ExecuteUbergraph(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Object", "ExecuteUbergraph");

	Params::Object_ExecuteUbergraph Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Predefined Function
// Checks if this class has a certain base

bool UStruct::IsSubclassOf(const UStruct* Base) const
{
	if (!Base)
		return false;

	for (const UStruct* Struct = this; Struct; Struct = Struct->Super)
	{
		if (Struct == Base)
			return true;
	}

	return false;
}


// Predefined Function
// Gets a UFunction from this UClasses' 'Children' list

class UFunction* UClass::GetFunction(const std::string& ClassName, const std::string& FuncName) const
{
	for(const UStruct* Clss = this; Clss; Clss = Clss->Super)
	{
		if (Clss->GetName() != ClassName)
			continue;
			
		for (UField* Field = Clss->Children; Field; Field = Field->Next)
		{
			if(Field->HasTypeFlag(EClassCastFlags::Function) && Field->GetName() == FuncName)
				return static_cast<class UFunction*>(Field);
		}
	}

	return nullptr;
}

}

