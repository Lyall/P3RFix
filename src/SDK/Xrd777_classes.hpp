#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Xrd777

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Xrd777_structs.hpp"
#include "AnimGraphRuntime_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CriWareRuntime_classes.hpp"
#include "UMG_classes.hpp"
#include "Slate_structs.hpp"
#include "Niagara_structs.hpp"
#include "CharacterBase_classes.hpp"
#include "AIModule_classes.hpp"
#include "InputManagerPlugin_classes.hpp"
#include "DebugMenuPlugin_classes.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "OffscreenRendering_classes.hpp"


namespace SDK
{

// Class xrd777.AppActor
// 0x0058 (0x0278 - 0x0220)
class AAppActor : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EAppPauseObjectFlag                           AppPauseFlags;                                     // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PauseFrontEvent;                                   // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PauseBackEvent;                                    // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnPauseFrontEvent;                                 // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnPauseBackEvent;                                  // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class AActor* AsAActor();
	class UObject* AsUObject();
	void BeginPlay();
	void EndPlay(const EEndPlayReason EndPlayReason);

	EAppPauseObjectFlag GetAppPauseFlags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppActor">();
	}
	static class AAppActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppActor>();
	}
};
static_assert(alignof(AAppActor) == 0x000008, "Wrong alignment on AAppActor");
static_assert(sizeof(AAppActor) == 0x000278, "Wrong size on AAppActor");
static_assert(offsetof(AAppActor, AppPauseFlags) == 0x000230, "Member 'AAppActor::AppPauseFlags' has a wrong offset!");
static_assert(offsetof(AAppActor, PauseFrontEvent) == 0x000238, "Member 'AAppActor::PauseFrontEvent' has a wrong offset!");
static_assert(offsetof(AAppActor, PauseBackEvent) == 0x000248, "Member 'AAppActor::PauseBackEvent' has a wrong offset!");
static_assert(offsetof(AAppActor, UnPauseFrontEvent) == 0x000258, "Member 'AAppActor::UnPauseFrontEvent' has a wrong offset!");
static_assert(offsetof(AAppActor, UnPauseBackEvent) == 0x000268, "Member 'AAppActor::UnPauseBackEvent' has a wrong offset!");

// Class xrd777.AssistTest
// 0x0010 (0x0288 - 0x0278)
class AAssistTest final : public AAppActor
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistTest">();
	}
	static class AAssistTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAssistTest>();
	}
};
static_assert(alignof(AAssistTest) == 0x000008, "Wrong alignment on AAssistTest");
static_assert(sizeof(AAssistTest) == 0x000288, "Wrong size on AAssistTest");
static_assert(offsetof(AAssistTest, Loader_) == 0x000278, "Member 'AAssistTest::Loader_' has a wrong offset!");
static_assert(offsetof(AAssistTest, BmdAsset_) == 0x000280, "Member 'AAssistTest::BmdAsset_' has a wrong offset!");

// Class xrd777.TitleLogoActor
// 0x0070 (0x0290 - 0x0220)
class ATitleLogoActor : public AActor
{
public:
	int32                                         FadeInFrame;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutFrame;                                      // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x68];                                     // 0x0228(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAlpha();
	bool IsGameClear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleLogoActor">();
	}
	static class ATitleLogoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATitleLogoActor>();
	}
};
static_assert(alignof(ATitleLogoActor) == 0x000008, "Wrong alignment on ATitleLogoActor");
static_assert(sizeof(ATitleLogoActor) == 0x000290, "Wrong size on ATitleLogoActor");
static_assert(offsetof(ATitleLogoActor, FadeInFrame) == 0x000220, "Member 'ATitleLogoActor::FadeInFrame' has a wrong offset!");
static_assert(offsetof(ATitleLogoActor, FadeOutFrame) == 0x000224, "Member 'ATitleLogoActor::FadeOutFrame' has a wrong offset!");

// Class xrd777.BtlBoss
// 0x0008 (0x0030 - 0x0028)
class UBtlBoss : public UObject
{
public:
	class UDataTable*                             CameraTable;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBoss">();
	}
	static class UBtlBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBoss>();
	}
};
static_assert(alignof(UBtlBoss) == 0x000008, "Wrong alignment on UBtlBoss");
static_assert(sizeof(UBtlBoss) == 0x000030, "Wrong size on UBtlBoss");
static_assert(offsetof(UBtlBoss, CameraTable) == 0x000028, "Member 'UBtlBoss::CameraTable' has a wrong offset!");

// Class xrd777.AppMultiDataAsset
// 0x0000 (0x0030 - 0x0030)
class UAppMultiDataAsset : public UDataAsset
{
public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppMultiDataAsset">();
	}
	static class UAppMultiDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppMultiDataAsset>();
	}
};
static_assert(alignof(UAppMultiDataAsset) == 0x000008, "Wrong alignment on UAppMultiDataAsset");
static_assert(sizeof(UAppMultiDataAsset) == 0x000030, "Wrong size on UAppMultiDataAsset");

// Class xrd777.AntiqueShopLineUpListTable
// 0x0030 (0x0060 - 0x0030)
class UAntiqueShopLineUpListTable final : public UAppMultiDataAsset
{
public:
	TArray<struct FAntiqueShopLineUpList>         TradeData;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAntiqueShopEquipCombineSource> CombineSources;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAntiqueShopEquipCombineResult> CombineResults;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiqueShopLineUpListTable">();
	}
	static class UAntiqueShopLineUpListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiqueShopLineUpListTable>();
	}
};
static_assert(alignof(UAntiqueShopLineUpListTable) == 0x000008, "Wrong alignment on UAntiqueShopLineUpListTable");
static_assert(sizeof(UAntiqueShopLineUpListTable) == 0x000060, "Wrong size on UAntiqueShopLineUpListTable");
static_assert(offsetof(UAntiqueShopLineUpListTable, TradeData) == 0x000030, "Member 'UAntiqueShopLineUpListTable::TradeData' has a wrong offset!");
static_assert(offsetof(UAntiqueShopLineUpListTable, CombineSources) == 0x000040, "Member 'UAntiqueShopLineUpListTable::CombineSources' has a wrong offset!");
static_assert(offsetof(UAntiqueShopLineUpListTable, CombineResults) == 0x000050, "Member 'UAntiqueShopLineUpListTable::CombineResults' has a wrong offset!");

// Class xrd777.AppDataAsset
// 0x0000 (0x0030 - 0x0030)
class UAppDataAsset : public UDataAsset
{
public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppDataAsset">();
	}
	static class UAppDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppDataAsset>();
	}
};
static_assert(alignof(UAppDataAsset) == 0x000008, "Wrong alignment on UAppDataAsset");
static_assert(sizeof(UAppDataAsset) == 0x000030, "Wrong size on UAppDataAsset");

// Class xrd777.HeroParameterDataAsset
// 0x0010 (0x0040 - 0x0030)
class UHeroParameterDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FHeroParameterTable>            Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroParameterDataAsset">();
	}
	static class UHeroParameterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroParameterDataAsset>();
	}
};
static_assert(alignof(UHeroParameterDataAsset) == 0x000008, "Wrong alignment on UHeroParameterDataAsset");
static_assert(sizeof(UHeroParameterDataAsset) == 0x000040, "Wrong size on UHeroParameterDataAsset");
static_assert(offsetof(UHeroParameterDataAsset, Tables) == 0x000030, "Member 'UHeroParameterDataAsset::Tables' has a wrong offset!");

// Class xrd777.AssetLoader
// 0x0040 (0x0068 - 0x0028)
class UAssetLoader final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLoader">();
	}
	static class UAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLoader>();
	}
};
static_assert(alignof(UAssetLoader) == 0x000008, "Wrong alignment on UAssetLoader");
static_assert(sizeof(UAssetLoader) == 0x000068, "Wrong size on UAssetLoader");

// Class xrd777.ActivityDataAsset
// 0x0010 (0x0040 - 0x0030)
class UActivityDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FActivityData>                  Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityDataAsset">();
	}
	static class UActivityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityDataAsset>();
	}
};
static_assert(alignof(UActivityDataAsset) == 0x000008, "Wrong alignment on UActivityDataAsset");
static_assert(sizeof(UActivityDataAsset) == 0x000040, "Wrong size on UActivityDataAsset");
static_assert(offsetof(UActivityDataAsset, Data) == 0x000030, "Member 'UActivityDataAsset::Data' has a wrong offset!");

// Class xrd777.AppPropsAnimPackAsset
// 0x0058 (0x0088 - 0x0030)
class UAppPropsAnimPackAsset final : public UDataAsset
{
public:
	EAppPropsAnimPackType                         PackType;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UAnimSequenceBase*>         Anims;                                             // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPropsAnimPackAsset">();
	}
	static class UAppPropsAnimPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppPropsAnimPackAsset>();
	}
};
static_assert(alignof(UAppPropsAnimPackAsset) == 0x000008, "Wrong alignment on UAppPropsAnimPackAsset");
static_assert(sizeof(UAppPropsAnimPackAsset) == 0x000088, "Wrong size on UAppPropsAnimPackAsset");
static_assert(offsetof(UAppPropsAnimPackAsset, PackType) == 0x000030, "Member 'UAppPropsAnimPackAsset::PackType' has a wrong offset!");
static_assert(offsetof(UAppPropsAnimPackAsset, Anims) == 0x000038, "Member 'UAppPropsAnimPackAsset::Anims' has a wrong offset!");

// Class xrd777.SelItem
// 0x0088 (0x00B0 - 0x0028)
class USelItem : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UMsgProcWindow_Select*                  MpSelProcWindow;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelItem">();
	}
	static class USelItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelItem>();
	}
};
static_assert(alignof(USelItem) == 0x000008, "Wrong alignment on USelItem");
static_assert(sizeof(USelItem) == 0x0000B0, "Wrong size on USelItem");
static_assert(offsetof(USelItem, MpSelProcWindow) == 0x0000A0, "Member 'USelItem::MpSelProcWindow' has a wrong offset!");

// Class xrd777.SelAEventTypeA
// 0x0070 (0x0120 - 0x00B0)
class USelAEventTypeA final : public USelItem
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              PSprAsset;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutData;                                        // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelAEventTypeA">();
	}
	static class USelAEventTypeA* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelAEventTypeA>();
	}
};
static_assert(alignof(USelAEventTypeA) == 0x000008, "Wrong alignment on USelAEventTypeA");
static_assert(sizeof(USelAEventTypeA) == 0x000120, "Wrong size on USelAEventTypeA");
static_assert(offsetof(USelAEventTypeA, PSprAsset) == 0x0000D8, "Member 'USelAEventTypeA::PSprAsset' has a wrong offset!");
static_assert(offsetof(USelAEventTypeA, PAssetLoader) == 0x0000E0, "Member 'USelAEventTypeA::PAssetLoader' has a wrong offset!");
static_assert(offsetof(USelAEventTypeA, LayoutData) == 0x0000E8, "Member 'USelAEventTypeA::LayoutData' has a wrong offset!");
static_assert(offsetof(USelAEventTypeA, LayoutDataTable) == 0x0000F0, "Member 'USelAEventTypeA::LayoutDataTable' has a wrong offset!");

// Class xrd777.TaskActor
// 0x0028 (0x0248 - 0x0220)
class ATaskActor final : public AActor
{
public:
	uint8                                         Pad_220[0x28];                                     // 0x0220(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskActor">();
	}
	static class ATaskActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaskActor>();
	}
};
static_assert(alignof(ATaskActor) == 0x000008, "Wrong alignment on ATaskActor");
static_assert(sizeof(ATaskActor) == 0x000248, "Wrong size on ATaskActor");

// Class xrd777.BtlAI
// 0x08E0 (0x0B58 - 0x0278)
class ABtlAI : public AAppActor
{
public:
	uint8                                         Pad_278[0x868];                                    // 0x0278(0x0868)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlActor*                              Character;                                         // 0x0AE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlCoreComponent*                      Core;                                              // 0x0AE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBtlCommandType                               ActionType;                                        // 0x0AF0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBtlCommandType                               PrevActionType;                                    // 0x0AF1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF2[0x2];                                      // 0x0AF2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ActionID;                                          // 0x0AF4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        ActionSkillID;                                     // 0x0AF8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        ActionItemID;                                      // 0x0AFC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        PrevActionID;                                      // 0x0B00(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        MinorParam;                                        // 0x0B04(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBtlDataAttr                                  ReceiveSkillAttr;                                  // 0x0B06(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B07[0x1];                                      // 0x0B07(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABtlActor*>                      ActionTargets;                                     // 0x0B08(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABtlActor*>                      PrevActionTargets;                                 // 0x0B18(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B28[0x30];                                     // 0x0B28(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetPrevUseActionIDForActor(class ABtlActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlAI">();
	}
	static class ABtlAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlAI>();
	}
};
static_assert(alignof(ABtlAI) == 0x000008, "Wrong alignment on ABtlAI");
static_assert(sizeof(ABtlAI) == 0x000B58, "Wrong size on ABtlAI");
static_assert(offsetof(ABtlAI, Character) == 0x000AE0, "Member 'ABtlAI::Character' has a wrong offset!");
static_assert(offsetof(ABtlAI, Core) == 0x000AE8, "Member 'ABtlAI::Core' has a wrong offset!");
static_assert(offsetof(ABtlAI, ActionType) == 0x000AF0, "Member 'ABtlAI::ActionType' has a wrong offset!");
static_assert(offsetof(ABtlAI, PrevActionType) == 0x000AF1, "Member 'ABtlAI::PrevActionType' has a wrong offset!");
static_assert(offsetof(ABtlAI, ActionID) == 0x000AF4, "Member 'ABtlAI::ActionID' has a wrong offset!");
static_assert(offsetof(ABtlAI, ActionSkillID) == 0x000AF8, "Member 'ABtlAI::ActionSkillID' has a wrong offset!");
static_assert(offsetof(ABtlAI, ActionItemID) == 0x000AFC, "Member 'ABtlAI::ActionItemID' has a wrong offset!");
static_assert(offsetof(ABtlAI, PrevActionID) == 0x000B00, "Member 'ABtlAI::PrevActionID' has a wrong offset!");
static_assert(offsetof(ABtlAI, MinorParam) == 0x000B04, "Member 'ABtlAI::MinorParam' has a wrong offset!");
static_assert(offsetof(ABtlAI, ReceiveSkillAttr) == 0x000B06, "Member 'ABtlAI::ReceiveSkillAttr' has a wrong offset!");
static_assert(offsetof(ABtlAI, ActionTargets) == 0x000B08, "Member 'ABtlAI::ActionTargets' has a wrong offset!");
static_assert(offsetof(ABtlAI, PrevActionTargets) == 0x000B18, "Member 'ABtlAI::PrevActionTargets' has a wrong offset!");

// Class xrd777.UIDrawBaseActor
// 0x0040 (0x02B8 - 0x0278)
class AUIDrawBaseActor : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIDataAsset*                           ResourceDataAsset;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SyncEndEvent;                                      // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTextureRenderTarget2D* BPUICommand_GetRenderTarget(const int32 CanvasIndex);

	void AddLoadAsset(const TSoftObjectPtr<class UObject> SoftAsset);
	void BPUICommand_AtlUIBlendState(const EUIBLEND_STATE_TYPE BlendType);
	class UPlgAsset* BPUICommand_CastPlgAsset(class UObject* Asset);
	class USprAsset* BPUICommand_CastSprAsset(class UObject* Asset);
	void BPUICommand_DrawMaterial(const float X, const float Y, const float Z, const float Width, const float Height, const float Angle, const class UObject* PMaterial);
	void BPUICommand_DrawPlg(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const int32 PlgID, const float ScaleX, const float ScaleY, const float Angle, const class UPlgAsset* PlgHandle);
	void BPUICommand_DrawRect(const float X, const float Y, const float Z, const float Width, const float Height, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawRectV4(const float X, const float Y, const float Z, const float VX0, const float VY0, const float VX1, const float VY1, const float VX2, const float VY2, const float VX3, const float VY3, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawRoundRect(const float X, const float Y, const float Z, const float Width, const float Height, const int32 Round, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawScrollbar(const float X, const float Y, const float Z, const float Width, const float Height, const float ScrollRange, const int32 ScrollPos, const int32 DrawListNum, const int32 MaxListNum, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawSircle(const float X, const float Y, const float Z, const float Radius, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Antialiasing);
	void BPUICommand_DrawSpr(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const int32 SprNo, const float ScaleX, const float ScaleY, const float Angle, const class USprAsset* SprHandle, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawTexture(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float U0, const float V0, const float U1, const float V1, const class UTexture* TextureHandle, const EUI_DRAW_POINT DrawPoint);
	void BPUICommand_DrawTriangle(const float X, const float Y, const float Z, const float VX0, const float VY0, const float VX1, const float VY1, const float VX2, const float VY2, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing);
	void BPUICommand_DrawVerticalGradationRect(const float X, const float Y, const float Width, const float Height, const struct FColor& TopColor, const struct FColor& BottomColor);
	void BPUICommand_FontDraw(const float X, const float Y, const float Z, const class FString& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Scale, const float Angle, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void BPUICommand_FontDrawEx(const float X, const float Y, const float Z, const class FString& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Scale, const float Angle, const float AnglePointX, const float AnglePointY, const EUIFontStyle Style);
	void BPUICommand_FontDrawExFromFName(const float X, const float Y, const float Z, const class FName& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Scale, const float Angle, const float AnglePointX, const float AnglePointY, const EUIFontStyle Style);
	void BPUICommand_FontDrawFromFName(const float X, const float Y, const float Z, const class FName& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Scale, const float Angle, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void BPUICommand_ItalicFontDraw(const float X, const float Y, const class FString& String, const struct FColor& Color, const float Scale, const float Angle, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void BPUICommand_ScalingFontDraw(const float X, const float Y, const float Z, const class FString& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float SizeX, const float SizeY, const float Scale, const float Angle, const bool ScalingOnlyX, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style, const bool IsScaling);
	void BPUICommand_ScalingItalicFontDraw(const float X, const float Y, const class FString& String, const struct FColor& Color, const float SizeX, const float SizeY, const float Scale, const float Angle, const bool ScalingOnlyX, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void BPUICommand_SetBlendState(const EUIBlendOperation OpColor, const EUIBlendFactor SrcColor, const EUIBlendFactor DstColor, const EUIBlendOperation OpAlpha, const EUIBlendFactor SrcAlpha, const EUIBlendFactor DstAlpha);
	void BPUICommand_SetPresetBlendState(const EUIOTPRESET_BLEND_TYPE BlendType);
	void BPUICommand_SetRenderTarget(const int32 CanvasIndex);
	void BPUIDebugCommand_DrawMaterial(const float X, const float Y, const float Z, const float Width, const float Height, const float Angle, const class UMaterialInstance* PMaterialInstance);
	void BPUIDebugCommand_DrawRect(const float X, const float Y, const float Z, const float Width, const float Height, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing);
	void BPUIDebugCommand_DrawRectV4(const float X, const float Y, const float Z, const float VX0, const float VY0, const float VX1, const float VY1, const float VX2, const float VY2, const float VX3, const float VY3, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing);
	void BPUIDebugCommand_DrawSpr(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const int32 SprNo, const float ScaleX, const float ScaleY, const float Angle, const class USprAsset* SprHandle);
	void BPUIDebugCommand_DrawTexture(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float U0, const float V0, const float U1, const float V1, const class UTexture* TextureHandle);
	void BPUIDebugCommand_DrawTriangle(const float VX0, const float VY0, const float VX1, const float VY1, const float VX2, const float VY2, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float ScaleX, const float ScaleY, const float Angle, const float Antialiasing);
	class UObject* GetResourceData(const int32 Index_0);
	void LoadStart();
	bool Sync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDrawBaseActor">();
	}
	static class AUIDrawBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDrawBaseActor>();
	}
};
static_assert(alignof(AUIDrawBaseActor) == 0x000008, "Wrong alignment on AUIDrawBaseActor");
static_assert(sizeof(AUIDrawBaseActor) == 0x0002B8, "Wrong size on AUIDrawBaseActor");
static_assert(offsetof(AUIDrawBaseActor, PAssetLoader) == 0x000290, "Member 'AUIDrawBaseActor::PAssetLoader' has a wrong offset!");
static_assert(offsetof(AUIDrawBaseActor, ResourceDataAsset) == 0x000298, "Member 'AUIDrawBaseActor::ResourceDataAsset' has a wrong offset!");
static_assert(offsetof(AUIDrawBaseActor, SyncEndEvent) == 0x0002A0, "Member 'AUIDrawBaseActor::SyncEndEvent' has a wrong offset!");

// Class xrd777.UIConfigurationDraw
// 0x03D8 (0x0690 - 0x02B8)
class AUIConfigurationDraw : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x40];                                     // 0x02B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ItemDrawOffset;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x1E];                                     // 0x0300(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTerminationClose;                               // 0x031E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31F[0x21];                                     // 0x031F(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDrawBGMParam>                  BgmParams;                                         // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USprAsset*                              PKeySpr;                                           // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ConfigInSilhouetteOffset;                          // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x310];                                    // 0x0360(0x0310)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     HelpLayoutDataTable;                               // 0x0678(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     ConfigTextLayoutDataTable;                         // 0x0680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float BGMAlphaCalculation(float InTimer, float InSrcValue, float InDstValue, int32 InWaitFrame, int32 InNextWaitFrame, int32 InMoveFrame, int32 InNextMoveFrame, EAppCalculationType InAnimType);
	void BGMInAnimFinished();
	struct FVector2D BGMMoveCalculation(float InTimer, const struct FVector2D& InSrcValue, const struct FVector2D& InDstValue, int32 InWaitFrame, int32 InMoveFrame, EAppCalculationType InAnimType);
	float BGMScaleCalculation(float InTimer, float InSrcValue, float InDstValue, int32 InWaitFrame, int32 InMoveFrame, EAppCalculationType InAnimType);
	void BgmSetAnimFinished();
	void BPUICommand_DrawSpr_Ex(const float X, const float Y, const float Z, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const int32 SprNo, const float ScaleX, const float ScaleY, const float PipodX, const float PipodY, const float Angle, const class USprAsset* SprHandle);
	void Closed();
	void ConfigInAnimFinished();
	float ConvFrameToTime(int32 InFrame);
	void DrawAudioDeviceChange(float baseX, float baseY, float TextX, float TextY, uint8 TextColorR, uint8 TextColorG, uint8 TextColorB, uint8 TextColorA, float SizeX, float SizeY, const struct FDrawConfigParam& DrawConfigParam, const class USprAsset* SprHandle);
	void DrawBgmSelectText(float baseX, float baseY, float TextX, float TextY, uint8 TextColorR, uint8 TextColorG, uint8 TextColorB, uint8 TextColorA, float SizeX, float SizeY, const struct FDrawConfigParam& DrawConfigParam, struct FDrawBGMParam& DrawBGMParam, const class USprAsset* SprHandle);
	void DrawCloseWipe();
	void DrawCommonBg1();
	void DrawCommonBg2(bool IsTitle);
	void DrawGlowCore(const struct FVector2D& Offset, const struct FColor& Color, float Scale, const struct FVector2D& PlusOffset, const class USprAsset* SprHandle);
	void DrawHeroSilhouette(const struct FVector2D& Offset);
	void DrawHeroTexture(class UTexture* InTexture);
	void DrawInWipe();
	void DrawKeyConfigButtonSpr(float X, float Y, const struct FDrawConfigParam& DrawConfigParam, const struct FColor& RGBA, const class USprAsset* SprHandle);
	void DrawKeyConfigSwitcher(float X, float Y);
	void DrawNami();
	void DrawUim(class UObject* InUimAsset, float InFrame, bool* bIsMaxFrame, const class UTexture* InTexture);
	class UMaterialInterface* Get_BgMaterial();
	void GetAdjustedConfigPos(ECmpLayoutConfig InType, const struct FVector2D& Default, struct FVector2D* OutSize);
	void GetAdjustedConfigTextCol(ECmpLayoutConfigText InType, struct FVector2D* OutSize);
	bool GetAdjustedHelpBarOffset(bool InIsBGMMode, struct FVector2D* OutPosition);
	bool GetAdjustedHelpRootPosition(bool InIsBGMMode, struct FVector2D* OutPosition);
	int32 GetBgmCursorIndex();
	int32 GetBgmListTopIndex();
	int32 GetBgmSetID();
	class FString GetBGMText(int32 InSelect);
	struct FColor GetBlueBoardColor();
	class FString GetButtonLayoutText(int32 InSelect);
	class FString GetConfigTypeText(int32 InSelect);
	int32 GetCurrentIndex();
	int32 GetCursorIndex();
	class FString GetDifficultyText(int32 InSelect);
	struct FDrawConfigParam GetDrawConfigParam(int32 InMenuID);
	struct FColor GetGradation1BottomColour();
	struct FColor GetGradation1TopColour();
	struct FColor GetGradation2BottomColour();
	struct FColor GetGradation2TopColour();
	struct FDrawConfigParam GetIndexedDrawConfigParam(int32 InIndex);
	bool GetIsFisrt();
	int32 GetListNum();
	int32 GetListTopIndex();
	class FString GetOffText();
	class FString GetOnText();
	int32 GetPlayingIndex();
	class FString GetSelLangText(int32 InSelect);
	class FString GetSoundOutputText(int32 InSelect);
	bool IsBaseDiffLuna();
	bool IsBGMMode();
	bool IsConfigTypeMode();
	bool IsKeyConfig();
	bool IsScrollDrawBgmSelectText();
	bool IsTitleOpend();
	bool IsWindowShow();
	bool On_BgmSetIndexChanged(int32 InSetIndex);
	bool On_CursorIndexChanged(int32 InCursorIndex, int32 InListTopIndex);
	bool On_CursorIndexChanged_BGM(int32 InCursorIndex, int32 InListTopIndex);
	bool On_PlayingIndexChanged(int32 InPlayingIndex);
	bool On_ValueChanged(int32 InMenueID, bool InFlag, int32 InValue);
	void ProcessCompleted__DelegateSignature();
	void SetScrollBarTouchCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 DrawListNum, int32 MaxListNum, int32 ScrollPosY, int32 AddLayer, EUI_DRAW_POINT DrawPoint);
	void SetScrollPos(const struct FVector2D& InPos, float Height, float ScrollRange, int32 DrawListNum, int32 MaxListNum, int32 ScrollPosY);
	void SetScrollSize(const struct FVector2D& InSize);
	void SetScrollTouchCollision(float X, float Y, float Width, float Height, int32 AddLayer, EUI_DRAW_POINT DrawPoint);
	void SetSliderPos(int32 InMenuID, const struct FVector2D& InSliderPos);
	void SetTouchCollision(int32 Index_0, float X, float Y, float Width, float Height, int32 AddLayer, EUI_DRAW_POINT DrawPoint);
	void SetValueGaugeTouchCollision(const struct FDrawConfigParam& DrawParam, float GaugeX, float GaugeY, float GaugeWidth, float GaugeHeight, float SliderX, float SliderY);
	bool Start_CloseAnim();
	bool Start_InAnim();
	bool Start_MenuChangeAnim();
	bool Start_ToBGMAnim();
	bool Start_ToConfAnim();
	void StartCloseWipe();
	void StartInWipe(bool IsTitle);
	bool StateBGMDraw_In();
	bool StateDraw_BG();
	bool StateDraw_BGMSelect();
	bool StateDraw_Close();
	bool StateDraw_IN();
	bool StateDraw_ListItem(int32 InMenueID, int32 InListIndex);
	bool StateDraw_Main();
	bool StateDraw_Update(float DeltaTime);
	bool StateDraw_UpdateOnlyCursor(float DeltaTime);
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);
	void UpdateAnim(float DeltaTime);
	void UpdateCloseWipe(float InDeltaTime);
	void UpdateInWipe(float InDeltaTime);

	float GetUipParameter(const class FString& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigurationDraw">();
	}
	static class AUIConfigurationDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIConfigurationDraw>();
	}
};
static_assert(alignof(AUIConfigurationDraw) == 0x000008, "Wrong alignment on AUIConfigurationDraw");
static_assert(sizeof(AUIConfigurationDraw) == 0x000690, "Wrong size on AUIConfigurationDraw");
static_assert(offsetof(AUIConfigurationDraw, ItemDrawOffset) == 0x0002F8, "Member 'AUIConfigurationDraw::ItemDrawOffset' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, bIsTerminationClose) == 0x00031E, "Member 'AUIConfigurationDraw::bIsTerminationClose' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, BgmParams) == 0x000340, "Member 'AUIConfigurationDraw::BgmParams' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, PKeySpr) == 0x000350, "Member 'AUIConfigurationDraw::PKeySpr' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, ConfigInSilhouetteOffset) == 0x000358, "Member 'AUIConfigurationDraw::ConfigInSilhouetteOffset' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, LayoutDataTable) == 0x000670, "Member 'AUIConfigurationDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, HelpLayoutDataTable) == 0x000678, "Member 'AUIConfigurationDraw::HelpLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIConfigurationDraw, ConfigTextLayoutDataTable) == 0x000680, "Member 'AUIConfigurationDraw::ConfigTextLayoutDataTable' has a wrong offset!");

// Class xrd777.FldDungeonEventTransActor
// 0x0020 (0x0298 - 0x0278)
class AFldDungeonEventTransActor final : public AAppActor
{
public:
	EDungeonEventTransOriginType                  TransOriginType;                                   // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WithinTypeID;                                      // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFldDungeonLayoutStartActor*>    M_LayoutPos;                                       // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPartyTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEventTransActor">();
	}
	static class AFldDungeonEventTransActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonEventTransActor>();
	}
};
static_assert(alignof(AFldDungeonEventTransActor) == 0x000008, "Wrong alignment on AFldDungeonEventTransActor");
static_assert(sizeof(AFldDungeonEventTransActor) == 0x000298, "Wrong size on AFldDungeonEventTransActor");
static_assert(offsetof(AFldDungeonEventTransActor, TransOriginType) == 0x000278, "Member 'AFldDungeonEventTransActor::TransOriginType' has a wrong offset!");
static_assert(offsetof(AFldDungeonEventTransActor, WithinTypeID) == 0x00027C, "Member 'AFldDungeonEventTransActor::WithinTypeID' has a wrong offset!");
static_assert(offsetof(AFldDungeonEventTransActor, M_LayoutPos) == 0x000280, "Member 'AFldDungeonEventTransActor::M_LayoutPos' has a wrong offset!");

// Class xrd777.ActivityTest
// 0x0010 (0x0288 - 0x0278)
class AActivityTest final : public AAppActor
{
public:
	class UDebugMenu*                             DebugMenu_;                                        // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityTest">();
	}
	static class AActivityTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActivityTest>();
	}
};
static_assert(alignof(AActivityTest) == 0x000008, "Wrong alignment on AActivityTest");
static_assert(sizeof(AActivityTest) == 0x000288, "Wrong size on AActivityTest");
static_assert(offsetof(AActivityTest, DebugMenu_) == 0x000278, "Member 'AActivityTest::DebugMenu_' has a wrong offset!");

// Class xrd777.CommunityRankDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCommunityRankDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FCommunityRankItem>             Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityRankDataAsset">();
	}
	static class UCommunityRankDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunityRankDataAsset>();
	}
};
static_assert(alignof(UCommunityRankDataAsset) == 0x000008, "Wrong alignment on UCommunityRankDataAsset");
static_assert(sizeof(UCommunityRankDataAsset) == 0x000040, "Wrong size on UCommunityRankDataAsset");
static_assert(offsetof(UCommunityRankDataAsset, Data) == 0x000030, "Member 'UCommunityRankDataAsset::Data' has a wrong offset!");

// Class xrd777.AppLevelManager
// 0x0068 (0x0098 - 0x0030)
class UAppLevelManager final : public UGameInstanceSubsystem
{
public:
	TMap<class FName, struct FAppLevelData>       MLevelTable_;                                      // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AAppLvMngUnloadMonitorActor*>    MMonitors_;                                        // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppLevelManager">();
	}
	static class UAppLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppLevelManager>();
	}
};
static_assert(alignof(UAppLevelManager) == 0x000008, "Wrong alignment on UAppLevelManager");
static_assert(sizeof(UAppLevelManager) == 0x000098, "Wrong size on UAppLevelManager");
static_assert(offsetof(UAppLevelManager, MLevelTable_) == 0x000030, "Member 'UAppLevelManager::MLevelTable_' has a wrong offset!");
static_assert(offsetof(UAppLevelManager, MMonitors_) == 0x000080, "Member 'UAppLevelManager::MMonitors_' has a wrong offset!");

// Class xrd777.UIBaseActor
// 0x0028 (0x02A0 - 0x0278)
class AUIBaseActor : public AAppActor
{
public:
	uint8                                         Pad_278[0x28];                                     // 0x0278(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseActor">();
	}
	static class AUIBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBaseActor>();
	}
};
static_assert(alignof(AUIBaseActor) == 0x000008, "Wrong alignment on AUIBaseActor");
static_assert(sizeof(AUIBaseActor) == 0x0002A0, "Wrong size on AUIBaseActor");

// Class xrd777.UIMissingPersonActor
// 0x0000 (0x02A0 - 0x02A0)
class AUIMissingPersonActor final : public AUIBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMissingPersonActor">();
	}
	static class AUIMissingPersonActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMissingPersonActor>();
	}
};
static_assert(alignof(AUIMissingPersonActor) == 0x000008, "Wrong alignment on AUIMissingPersonActor");
static_assert(sizeof(AUIMissingPersonActor) == 0x0002A0, "Wrong size on AUIMissingPersonActor");

// Class xrd777.BPExtensionsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBPExtensionsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AttachMeshComponent(class UMeshComponent* Target, class FName SocketName, class UMeshComponent* AttachComponent);
	static class UMeshComponent* AttachSkeletalMesh(class UMeshComponent* Target, class FName SocketName, class USkeletalMesh* AttachSKMesh);
	static class UMeshComponent* AttachStaticMesh(class UMeshComponent* Target, class FName SocketName, class UStaticMesh* AttachSTMesh);
	static void ChangeSkeletalMesh(class USkeletalMeshComponent* TargetMesh, class USkeletalMesh* ChangeMesh);
	static void CommitConsoleLog(const class FString& InString);
	static void DetachSocketAttachment(class UMeshComponent* Target, class FName SocketName);
	static TArray<struct FLinearColor> GetInverseMatrix(const struct FTransform& Transform);
	static int32 GetScreenPercentage(class UPlanarReflectionComponent* InComponent);
	static void RemoveRenderMesh(class USkeletalMeshComponent* TargetMesh);
	static void SetScreenPercentage(class UPlanarReflectionComponent* InComponent, int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPExtensionsFunctionLibrary">();
	}
	static class UBPExtensionsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPExtensionsFunctionLibrary>();
	}
};
static_assert(alignof(UBPExtensionsFunctionLibrary) == 0x000008, "Wrong alignment on UBPExtensionsFunctionLibrary");
static_assert(sizeof(UBPExtensionsFunctionLibrary) == 0x000028, "Wrong size on UBPExtensionsFunctionLibrary");

// Class xrd777.AddContent
// 0x0030 (0x0058 - 0x0028)
class UAddContent final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADLCManager*                            MDlcManager;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAddContentDialog*                      MAdcDialog;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<bool>                                  GuardUnlockedContent;                              // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContent">();
	}
	static class UAddContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContent>();
	}
};
static_assert(alignof(UAddContent) == 0x000008, "Wrong alignment on UAddContent");
static_assert(sizeof(UAddContent) == 0x000058, "Wrong size on UAddContent");
static_assert(offsetof(UAddContent, MDlcManager) == 0x000038, "Member 'UAddContent::MDlcManager' has a wrong offset!");
static_assert(offsetof(UAddContent, MAdcDialog) == 0x000040, "Member 'UAddContent::MAdcDialog' has a wrong offset!");
static_assert(offsetof(UAddContent, GuardUnlockedContent) == 0x000048, "Member 'UAddContent::GuardUnlockedContent' has a wrong offset!");

// Class xrd777.AddContentDialog
// 0x0178 (0x03F0 - 0x0278)
class AAddContentDialog final : public AAppActor
{
public:
	uint8                                         Pad_278[0x160];                                    // 0x0278(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	class ADLCManager*                            MDlcManager;                                       // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIProgressBarDraw*                     MProgressBar;                                      // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentDialog">();
	}
	static class AAddContentDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAddContentDialog>();
	}
};
static_assert(alignof(AAddContentDialog) == 0x000008, "Wrong alignment on AAddContentDialog");
static_assert(sizeof(AAddContentDialog) == 0x0003F0, "Wrong size on AAddContentDialog");
static_assert(offsetof(AAddContentDialog, MDlcManager) == 0x0003D8, "Member 'AAddContentDialog::MDlcManager' has a wrong offset!");
static_assert(offsetof(AAddContentDialog, MProgressBar) == 0x0003E0, "Member 'AAddContentDialog::MProgressBar' has a wrong offset!");

// Class xrd777.UICombineCalc
// 0x0098 (0x00C0 - 0x0028)
class UUICombineCalc final : public UObject
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNormalSpreadDataAsset*                 NormalSpread_;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialSpreadDataAsset*                SpecialSpread_;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonaLiftDataAsset*                  PersonaLift_;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillAffinityDataAsset*                SkillAffinity_;                                    // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillLimitDataAsset*                   SkillLimit_;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonaConfigDataAsset*                PersonaConfig_;                                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommunityRankDataAsset*                CommunityRank_;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoonAgeProbabilityDataAsset*           MoonAgeProbability_;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCombineCounterDataAsset*               CombineCounter_;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillChangeDataAsset*                  SkillChange_;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillPackDataAsset*                    SkillPack_;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillPowerUpDataAsset*                 SkillPowerUp_;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCombineMiscDataAsset*                  CombineMisc_;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                BPCombineCalc_;                                    // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICombineCalcFunction*                 CombineCalcFunction_;                              // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDLCPersonaCombineBirthDataAsset*       DLCPersonaCombineBirth_;                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWordSortDataAsset*                     WordSortDataAsset_;                                // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICombineCalc">();
	}
	static class UUICombineCalc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICombineCalc>();
	}
};
static_assert(alignof(UUICombineCalc) == 0x000008, "Wrong alignment on UUICombineCalc");
static_assert(sizeof(UUICombineCalc) == 0x0000C0, "Wrong size on UUICombineCalc");
static_assert(offsetof(UUICombineCalc, Loader_) == 0x000028, "Member 'UUICombineCalc::Loader_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, NormalSpread_) == 0x000030, "Member 'UUICombineCalc::NormalSpread_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SpecialSpread_) == 0x000038, "Member 'UUICombineCalc::SpecialSpread_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, PersonaLift_) == 0x000040, "Member 'UUICombineCalc::PersonaLift_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SkillAffinity_) == 0x000048, "Member 'UUICombineCalc::SkillAffinity_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SkillLimit_) == 0x000050, "Member 'UUICombineCalc::SkillLimit_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, PersonaConfig_) == 0x000058, "Member 'UUICombineCalc::PersonaConfig_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, CommunityRank_) == 0x000060, "Member 'UUICombineCalc::CommunityRank_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, MoonAgeProbability_) == 0x000068, "Member 'UUICombineCalc::MoonAgeProbability_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, CombineCounter_) == 0x000070, "Member 'UUICombineCalc::CombineCounter_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SkillChange_) == 0x000078, "Member 'UUICombineCalc::SkillChange_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SkillPack_) == 0x000080, "Member 'UUICombineCalc::SkillPack_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, SkillPowerUp_) == 0x000088, "Member 'UUICombineCalc::SkillPowerUp_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, CombineMisc_) == 0x000090, "Member 'UUICombineCalc::CombineMisc_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, BPCombineCalc_) == 0x000098, "Member 'UUICombineCalc::BPCombineCalc_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, CombineCalcFunction_) == 0x0000A0, "Member 'UUICombineCalc::CombineCalcFunction_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, DLCPersonaCombineBirth_) == 0x0000A8, "Member 'UUICombineCalc::DLCPersonaCombineBirth_' has a wrong offset!");
static_assert(offsetof(UUICombineCalc, WordSortDataAsset_) == 0x0000B0, "Member 'UUICombineCalc::WordSortDataAsset_' has a wrong offset!");

// Class xrd777.AssetHolder
// 0x0070 (0x0098 - 0x0028)
class UAssetHolder final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                HoldAssets;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LoadedDelegate;                                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedAssets;                                      // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UAssetHolder*>                   ChildHolders;                                      // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChildLoadComplete(const TArray<class UObject*>& LoadedAssets_0);
	FMulticastInlineDelegateProperty_ GetLoadedDelegate();
	void LoadedDelegate__DelegateSignature();
	void LoadAsset();
	void LoadComplete();
	void UnloadAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetHolder">();
	}
	static class UAssetHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetHolder>();
	}
};
static_assert(alignof(UAssetHolder) == 0x000008, "Wrong alignment on UAssetHolder");
static_assert(sizeof(UAssetHolder) == 0x000098, "Wrong size on UAssetHolder");
static_assert(offsetof(UAssetHolder, HoldAssets) == 0x000028, "Member 'UAssetHolder::HoldAssets' has a wrong offset!");
static_assert(offsetof(UAssetHolder, LoadedDelegate) == 0x000038, "Member 'UAssetHolder::LoadedDelegate' has a wrong offset!");
static_assert(offsetof(UAssetHolder, LoadedAssets) == 0x000070, "Member 'UAssetHolder::LoadedAssets' has a wrong offset!");
static_assert(offsetof(UAssetHolder, ChildHolders) == 0x000080, "Member 'UAssetHolder::ChildHolders' has a wrong offset!");

// Class xrd777.AddContentBundleNameTableDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAddContentBundleNameTableDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAddContentsBundleNameTable>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentBundleNameTableDataAsset">();
	}
	static class UAddContentBundleNameTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentBundleNameTableDataAsset>();
	}
};
static_assert(alignof(UAddContentBundleNameTableDataAsset) == 0x000008, "Wrong alignment on UAddContentBundleNameTableDataAsset");
static_assert(sizeof(UAddContentBundleNameTableDataAsset) == 0x000040, "Wrong size on UAddContentBundleNameTableDataAsset");
static_assert(offsetof(UAddContentBundleNameTableDataAsset, Data) == 0x000030, "Member 'UAddContentBundleNameTableDataAsset::Data' has a wrong offset!");

// Class xrd777.BtlBCDCharaCameraComponent
// 0x0028 (0x00D8 - 0x00B0)
class UBtlBCDCharaCameraComponent final : public UActorComponent
{
public:
	float                                         RadiumRation;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRation;                                      // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDegree;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pan;                                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCommonCylinder;                                // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlEventAreaType                             TargetAreaType;                                    // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SocketName;                                        // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBCDCharaCameraComponent">();
	}
	static class UBtlBCDCharaCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBCDCharaCameraComponent>();
	}
};
static_assert(alignof(UBtlBCDCharaCameraComponent) == 0x000008, "Wrong alignment on UBtlBCDCharaCameraComponent");
static_assert(sizeof(UBtlBCDCharaCameraComponent) == 0x0000D8, "Wrong size on UBtlBCDCharaCameraComponent");
static_assert(offsetof(UBtlBCDCharaCameraComponent, RadiumRation) == 0x0000B0, "Member 'UBtlBCDCharaCameraComponent::RadiumRation' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, HeightRation) == 0x0000B4, "Member 'UBtlBCDCharaCameraComponent::HeightRation' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, RotateDegree) == 0x0000B8, "Member 'UBtlBCDCharaCameraComponent::RotateDegree' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, Pan) == 0x0000BC, "Member 'UBtlBCDCharaCameraComponent::Pan' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, Roll) == 0x0000C0, "Member 'UBtlBCDCharaCameraComponent::Roll' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, bUseCommonCylinder) == 0x0000C4, "Member 'UBtlBCDCharaCameraComponent::bUseCommonCylinder' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, TargetAreaType) == 0x0000C5, "Member 'UBtlBCDCharaCameraComponent::TargetAreaType' has a wrong offset!");
static_assert(offsetof(UBtlBCDCharaCameraComponent, SocketName) == 0x0000C8, "Member 'UBtlBCDCharaCameraComponent::SocketName' has a wrong offset!");

// Class xrd777.DebugViewer
// 0x0018 (0x0290 - 0x0278)
class ADebugViewer : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugMenu*                             PMenu;                                             // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugViewer">();
	}
	static class ADebugViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugViewer>();
	}
};
static_assert(alignof(ADebugViewer) == 0x000008, "Wrong alignment on ADebugViewer");
static_assert(sizeof(ADebugViewer) == 0x000290, "Wrong size on ADebugViewer");
static_assert(offsetof(ADebugViewer, PMenu) == 0x000280, "Member 'ADebugViewer::PMenu' has a wrong offset!");

// Class xrd777.VoiceActionViewer
// 0x0038 (0x02C8 - 0x0290)
class AVoiceActionViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x30];                                     // 0x0290(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIVoiceAction*                         PActionVoiceSystem;                                // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceActionViewer">();
	}
	static class AVoiceActionViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoiceActionViewer>();
	}
};
static_assert(alignof(AVoiceActionViewer) == 0x000008, "Wrong alignment on AVoiceActionViewer");
static_assert(sizeof(AVoiceActionViewer) == 0x0002C8, "Wrong size on AVoiceActionViewer");
static_assert(offsetof(AVoiceActionViewer, PActionVoiceSystem) == 0x0002C0, "Member 'AVoiceActionViewer::PActionVoiceSystem' has a wrong offset!");

// Class xrd777.AddContentEntitlementDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAddContentEntitlementDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAddContentEntitlement>         Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentEntitlementDataAsset">();
	}
	static class UAddContentEntitlementDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentEntitlementDataAsset>();
	}
};
static_assert(alignof(UAddContentEntitlementDataAsset) == 0x000008, "Wrong alignment on UAddContentEntitlementDataAsset");
static_assert(sizeof(UAddContentEntitlementDataAsset) == 0x000040, "Wrong size on UAddContentEntitlementDataAsset");
static_assert(offsetof(UAddContentEntitlementDataAsset, Data) == 0x000030, "Member 'UAddContentEntitlementDataAsset::Data' has a wrong offset!");

// Class xrd777.AgePanel
// 0x0350 (0x0378 - 0x0028)
class UAgePanel final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              _readSpr;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              _readSprAstrea;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              _readMat[0x2];                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               _readMatInst[0x2];                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  _fadeCurve;                                        // 0x0068(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x258];                                     // 0x0098(0x0258)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x80];                                     // 0x02F8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgePanel">();
	}
	static class UAgePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgePanel>();
	}
};
static_assert(alignof(UAgePanel) == 0x000008, "Wrong alignment on UAgePanel");
static_assert(sizeof(UAgePanel) == 0x000378, "Wrong size on UAgePanel");
static_assert(offsetof(UAgePanel, _readSpr) == 0x000038, "Member 'UAgePanel::_readSpr' has a wrong offset!");
static_assert(offsetof(UAgePanel, _readSprAstrea) == 0x000040, "Member 'UAgePanel::_readSprAstrea' has a wrong offset!");
static_assert(offsetof(UAgePanel, _readMat) == 0x000048, "Member 'UAgePanel::_readMat' has a wrong offset!");
static_assert(offsetof(UAgePanel, _readMatInst) == 0x000058, "Member 'UAgePanel::_readMatInst' has a wrong offset!");
static_assert(offsetof(UAgePanel, _fadeCurve) == 0x000068, "Member 'UAgePanel::_fadeCurve' has a wrong offset!");
static_assert(offsetof(UAgePanel, Loader_) == 0x0002F0, "Member 'UAgePanel::Loader_' has a wrong offset!");

// Class xrd777.FldEnemyController
// 0x0000 (0x0328 - 0x0328)
class AFldEnemyController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyController">();
	}
	static class AFldEnemyController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldEnemyController>();
	}
};
static_assert(alignof(AFldEnemyController) == 0x000008, "Wrong alignment on AFldEnemyController");
static_assert(sizeof(AFldEnemyController) == 0x000328, "Wrong size on AFldEnemyController");

// Class xrd777.BtlBossFortuneInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossFortuneInterface final : public IInterface
{
public:
	void FortuneFadein(float AnimTime);
	void FortuneFadeout(float AnimTime);
	void FortuneFlowerLoopEffectFadein(float AnimTime);
	void FortuneFlowerLoopEffectFadeout(float AnimTime);
	void StrengthFlowerLoopEffectFadeout(float AnimTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossFortuneInterface">();
	}
	static class IBtlBossFortuneInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossFortuneInterface>();
	}
};
static_assert(alignof(IBtlBossFortuneInterface) == 0x000008, "Wrong alignment on IBtlBossFortuneInterface");
static_assert(sizeof(IBtlBossFortuneInterface) == 0x000028, "Wrong size on IBtlBossFortuneInterface");

// Class xrd777.UIGetHeroParameterDraw
// 0x0A80 (0x0D20 - 0x02A0)
class AUIGetHeroParameterDraw final : public AUIBaseActor
{
public:
	class USprAsset*                              M_pEffSpr;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pNotePlg;                                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         M_pRankUpEffect;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         M_pRankUpFinishEffect;                             // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      M_pRankUpEffectComponent;                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_tagGetUIP;                                       // 0x02C8(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointUpNote                           M_tagNote[0x3];                                    // 0x0350(0x02E0)(NativeAccessSpecifierPublic)
	uint8                                         Pad_BF0[0x110];                                    // 0x0BF0(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpHeroHumanStatusDraw*                PHumanParamDraw_;                                  // 0x0D00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D08[0x18];                                     // 0x0D08(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGetHeroParameterDraw">();
	}
	static class AUIGetHeroParameterDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIGetHeroParameterDraw>();
	}
};
static_assert(alignof(AUIGetHeroParameterDraw) == 0x000008, "Wrong alignment on AUIGetHeroParameterDraw");
static_assert(sizeof(AUIGetHeroParameterDraw) == 0x000D20, "Wrong size on AUIGetHeroParameterDraw");
static_assert(offsetof(AUIGetHeroParameterDraw, M_pEffSpr) == 0x0002A0, "Member 'AUIGetHeroParameterDraw::M_pEffSpr' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_pNotePlg) == 0x0002A8, "Member 'AUIGetHeroParameterDraw::M_pNotePlg' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_pRankUpEffect) == 0x0002B0, "Member 'AUIGetHeroParameterDraw::M_pRankUpEffect' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_pRankUpFinishEffect) == 0x0002B8, "Member 'AUIGetHeroParameterDraw::M_pRankUpFinishEffect' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_pRankUpEffectComponent) == 0x0002C0, "Member 'AUIGetHeroParameterDraw::M_pRankUpEffectComponent' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_tagGetUIP) == 0x0002C8, "Member 'AUIGetHeroParameterDraw::M_tagGetUIP' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, M_tagNote) == 0x000350, "Member 'AUIGetHeroParameterDraw::M_tagNote' has a wrong offset!");
static_assert(offsetof(AUIGetHeroParameterDraw, PHumanParamDraw_) == 0x000D00, "Member 'AUIGetHeroParameterDraw::PHumanParamDraw_' has a wrong offset!");

// Class xrd777.AnimController
// 0x0038 (0x0060 - 0x0028)
class UAnimController final : public UObject
{
public:
	TArray<class FName>                           MAnimNameArray;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         MSkMeshCompArray;                                  // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   MMontageArray;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimController">();
	}
	static class UAnimController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimController>();
	}
};
static_assert(alignof(UAnimController) == 0x000008, "Wrong alignment on UAnimController");
static_assert(sizeof(UAnimController) == 0x000060, "Wrong size on UAnimController");
static_assert(offsetof(UAnimController, MAnimNameArray) == 0x000028, "Member 'UAnimController::MAnimNameArray' has a wrong offset!");
static_assert(offsetof(UAnimController, MSkMeshCompArray) == 0x000038, "Member 'UAnimController::MSkMeshCompArray' has a wrong offset!");
static_assert(offsetof(UAnimController, MMontageArray) == 0x000048, "Member 'UAnimController::MMontageArray' has a wrong offset!");

// Class xrd777.FldDungeonLayoutActor
// 0x0020 (0x0298 - 0x0278)
class AFldDungeonLayoutActor : public AAppActor
{
public:
	ELayoutType                                   LayoutType;                                        // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELayoutUsageType                              UsageType;                                         // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELayoutGroup                                  GroupNo;                                           // 0x027A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELayoutDirType                                Dir;                                               // 0x027B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpawnSelNo;                                        // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Wall;                                              // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventSpace;                                        // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_292[0x6];                                      // 0x0292(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutActor">();
	}
	static class AFldDungeonLayoutActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutActor");
static_assert(sizeof(AFldDungeonLayoutActor) == 0x000298, "Wrong size on AFldDungeonLayoutActor");
static_assert(offsetof(AFldDungeonLayoutActor, LayoutType) == 0x000278, "Member 'AFldDungeonLayoutActor::LayoutType' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, UsageType) == 0x000279, "Member 'AFldDungeonLayoutActor::UsageType' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, GroupNo) == 0x00027A, "Member 'AFldDungeonLayoutActor::GroupNo' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, Dir) == 0x00027B, "Member 'AFldDungeonLayoutActor::Dir' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, SpawnSelNo) == 0x000280, "Member 'AFldDungeonLayoutActor::SpawnSelNo' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, Wall) == 0x000290, "Member 'AFldDungeonLayoutActor::Wall' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutActor, EventSpace) == 0x000291, "Member 'AFldDungeonLayoutActor::EventSpace' has a wrong offset!");

// Class xrd777.AnimNotify_BtlPlayMontageNotify
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_BtlPlayMontageNotify : public UAnimNotify_PlayMontageNotify
{
public:
	class FName GetBattleNotifyName() const;
	void ReplaceNotifyName(class FName NewName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BtlPlayMontageNotify">();
	}
	static class UAnimNotify_BtlPlayMontageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BtlPlayMontageNotify>();
	}
};
static_assert(alignof(UAnimNotify_BtlPlayMontageNotify) == 0x000008, "Wrong alignment on UAnimNotify_BtlPlayMontageNotify");
static_assert(sizeof(UAnimNotify_BtlPlayMontageNotify) == 0x000040, "Wrong size on UAnimNotify_BtlPlayMontageNotify");

// Class xrd777.UICmmRankUpDraw
// 0x0978 (0x0C30 - 0x02B8)
class AUICmmRankUpDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              PSprAsset;                                         // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PPlgAsset;                                         // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x840];                                    // 0x02D0(0x0840)(Fixing Size After Last Property [ Dumper-7 ])
	class UFrameBufferCapture*                    CaptureTexture;                                    // 0x0B10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x0B18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              PSprKeyHelp;                                       // 0x0B20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              PSprKeyHelpButton;                                 // 0x0B28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIRankUpDraw*                          PManager;                                          // 0x0B30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B38[0xE0];                                     // 0x0B38(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x0C18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x0C20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CmmRankUpLayoutDataTable;                          // 0x0C28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsEndAnimStart();
	void StartShowReverseStar();
	void StartStarFrameAnime();
	void StartStarMainInAnime();
	void StartStarWaitAnime();
	void UICmmDrawCard(float X, float Y);
	void UICmmDrawEndDraw(float X, float Y);
	void UICmmDrawGradationBG(const struct FVector2D& VLeftPos, const struct FVector2D& VRightPos, const struct FVector2D& HLeftPos, const struct FVector2D& HRightPos);
	void UICmmDrawLetter(float X, float Y);
	void UICmmDrawOkKey(float X, float Y);
	void UICmmDrawRankStar(float BasePosX, float BasePosY);
	void UICmmReverseBG(float X, float Y);
	void Update(const float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmmRankUpDraw">();
	}
	static class AUICmmRankUpDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmmRankUpDraw>();
	}
};
static_assert(alignof(AUICmmRankUpDraw) == 0x000008, "Wrong alignment on AUICmmRankUpDraw");
static_assert(sizeof(AUICmmRankUpDraw) == 0x000C30, "Wrong size on AUICmmRankUpDraw");
static_assert(offsetof(AUICmmRankUpDraw, PSprAsset) == 0x0002C0, "Member 'AUICmmRankUpDraw::PSprAsset' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, PPlgAsset) == 0x0002C8, "Member 'AUICmmRankUpDraw::PPlgAsset' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, CaptureTexture) == 0x000B10, "Member 'AUICmmRankUpDraw::CaptureTexture' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, AnimManager) == 0x000B18, "Member 'AUICmmRankUpDraw::AnimManager' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, PSprKeyHelp) == 0x000B20, "Member 'AUICmmRankUpDraw::PSprKeyHelp' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, PSprKeyHelpButton) == 0x000B28, "Member 'AUICmmRankUpDraw::PSprKeyHelpButton' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, PManager) == 0x000B30, "Member 'AUICmmRankUpDraw::PManager' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, OkNextLayoutDataTable) == 0x000C18, "Member 'AUICmmRankUpDraw::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, OkNextMaskLayoutDataTable) == 0x000C20, "Member 'AUICmmRankUpDraw::OkNextMaskLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpDraw, CmmRankUpLayoutDataTable) == 0x000C28, "Member 'AUICmmRankUpDraw::CmmRankUpLayoutDataTable' has a wrong offset!");

// Class xrd777.AppPropsCardContainer
// 0x0038 (0x02B0 - 0x0278)
class AAppPropsCardContainer final : public AAppActor
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAppPropsCardData>              CardList;                                          // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAppPropsCore>              PersonaCardClass;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAppPropsCore>              MajorCardClass;                                    // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAppPropsCore>              MinorCardClass;                                    // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DestroyContainer(bool DestroyCardProps);
	TArray<struct FAppPropsCardData> GetCards();
	void LoadCards(const TArray<struct FAppPropsCardParam>& Params_0);
	bool SyncCards();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPropsCardContainer">();
	}
	static class AAppPropsCardContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppPropsCardContainer>();
	}
};
static_assert(alignof(AAppPropsCardContainer) == 0x000008, "Wrong alignment on AAppPropsCardContainer");
static_assert(sizeof(AAppPropsCardContainer) == 0x0002B0, "Wrong size on AAppPropsCardContainer");
static_assert(offsetof(AAppPropsCardContainer, Loader) == 0x000278, "Member 'AAppPropsCardContainer::Loader' has a wrong offset!");
static_assert(offsetof(AAppPropsCardContainer, CardList) == 0x000288, "Member 'AAppPropsCardContainer::CardList' has a wrong offset!");
static_assert(offsetof(AAppPropsCardContainer, PersonaCardClass) == 0x000298, "Member 'AAppPropsCardContainer::PersonaCardClass' has a wrong offset!");
static_assert(offsetof(AAppPropsCardContainer, MajorCardClass) == 0x0002A0, "Member 'AAppPropsCardContainer::MajorCardClass' has a wrong offset!");
static_assert(offsetof(AAppPropsCardContainer, MinorCardClass) == 0x0002A8, "Member 'AAppPropsCardContainer::MinorCardClass' has a wrong offset!");

// Class xrd777.CmmProfileDataAsset
// 0x0050 (0x0080 - 0x0030)
class UCmmProfileDataAsset final : public UAppDataAsset
{
public:
	TMap<uint16, struct FCmmProfileItem>          Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmmProfileDataAsset">();
	}
	static class UCmmProfileDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmmProfileDataAsset>();
	}
};
static_assert(alignof(UCmmProfileDataAsset) == 0x000008, "Wrong alignment on UCmmProfileDataAsset");
static_assert(sizeof(UCmmProfileDataAsset) == 0x000080, "Wrong size on UCmmProfileDataAsset");
static_assert(offsetof(UCmmProfileDataAsset, Data) == 0x000030, "Member 'UCmmProfileDataAsset::Data' has a wrong offset!");

// Class xrd777.BtlScriptAI
// 0x0020 (0x0B78 - 0x0B58)
class ABtlScriptAI final : public ABtlAI
{
public:
	class UAssetLoader*                           PLoader;                                           // 0x0B58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               PBfAsset;                                          // 0x0B60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAssetLoaded;                                      // 0x0B68(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B69[0xF];                                      // 0x0B69(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlScriptAI">();
	}
	static class ABtlScriptAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlScriptAI>();
	}
};
static_assert(alignof(ABtlScriptAI) == 0x000008, "Wrong alignment on ABtlScriptAI");
static_assert(sizeof(ABtlScriptAI) == 0x000B78, "Wrong size on ABtlScriptAI");
static_assert(offsetof(ABtlScriptAI, PLoader) == 0x000B58, "Member 'ABtlScriptAI::PLoader' has a wrong offset!");
static_assert(offsetof(ABtlScriptAI, PBfAsset) == 0x000B60, "Member 'ABtlScriptAI::PBfAsset' has a wrong offset!");
static_assert(offsetof(ABtlScriptAI, bAssetLoaded) == 0x000B68, "Member 'ABtlScriptAI::bAssetLoaded' has a wrong offset!");

// Class xrd777.UtlProcManager
// 0x0008 (0x0038 - 0x0030)
class UUtlProcManager final : public UGameInstanceSubsystem
{
public:
	class AUtlProcActor*                          MNowActor_;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtlProcManager">();
	}
	static class UUtlProcManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtlProcManager>();
	}
};
static_assert(alignof(UUtlProcManager) == 0x000008, "Wrong alignment on UUtlProcManager");
static_assert(sizeof(UUtlProcManager) == 0x000038, "Wrong size on UUtlProcManager");
static_assert(offsetof(UUtlProcManager, MNowActor_) == 0x000030, "Member 'UUtlProcManager::MNowActor_' has a wrong offset!");

// Class xrd777.AnimNotify_PlayEvtMultiMontage
// 0x0020 (0x0058 - 0x0038)
class UAnimNotify_PlayEvtMultiMontage final : public UAnimNotify
{
public:
	TArray<struct FAtlSlotMultiAnimationParam>    MontageArray;                                      // 0x0038(0x0010)(BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvtCharaAnimationType                        AnimationType;                                     // 0x0050(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStop;                                             // 0x0051(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinished(class UAnimMontage* Montage, bool bInterapt) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayEvtMultiMontage">();
	}
	static class UAnimNotify_PlayEvtMultiMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayEvtMultiMontage>();
	}
};
static_assert(alignof(UAnimNotify_PlayEvtMultiMontage) == 0x000008, "Wrong alignment on UAnimNotify_PlayEvtMultiMontage");
static_assert(sizeof(UAnimNotify_PlayEvtMultiMontage) == 0x000058, "Wrong size on UAnimNotify_PlayEvtMultiMontage");
static_assert(offsetof(UAnimNotify_PlayEvtMultiMontage, MontageArray) == 0x000038, "Member 'UAnimNotify_PlayEvtMultiMontage::MontageArray' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayEvtMultiMontage, SlotNodeName) == 0x000048, "Member 'UAnimNotify_PlayEvtMultiMontage::SlotNodeName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayEvtMultiMontage, AnimationType) == 0x000050, "Member 'UAnimNotify_PlayEvtMultiMontage::AnimationType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayEvtMultiMontage, bStop) == 0x000051, "Member 'UAnimNotify_PlayEvtMultiMontage::bStop' has a wrong offset!");

// Class xrd777.AppNpcCostume_DA
// 0x0290 (0x02C0 - 0x0030)
class UAppNpcCostume_DA final : public UDataAsset
{
public:
	int32                                         Type;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshLocation;                                      // 0x0034(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimPackID, TSoftObjectPtr<class UAppCharAnimDataAsset>> Anims;                                             // 0x0040(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAppNpcCostumePartsData                Base;                                              // 0x0090(0x00A0)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FAppNpcCostumePartsData>   CostumeSummer;                                     // 0x0130(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FAppNpcCostumePartsData>   CostumeWinter;                                     // 0x0180(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FAppNpcCostumePartsData>   Hair;                                              // 0x01D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FAppNpcCostumePartsData>   Face;                                              // 0x0220(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FAppNpcUniqueCostumeData>  Unique;                                            // 0x0270(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	void Make();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppNpcCostume_DA">();
	}
	static class UAppNpcCostume_DA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppNpcCostume_DA>();
	}
};
static_assert(alignof(UAppNpcCostume_DA) == 0x000008, "Wrong alignment on UAppNpcCostume_DA");
static_assert(sizeof(UAppNpcCostume_DA) == 0x0002C0, "Wrong size on UAppNpcCostume_DA");
static_assert(offsetof(UAppNpcCostume_DA, Type) == 0x000030, "Member 'UAppNpcCostume_DA::Type' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, MeshLocation) == 0x000034, "Member 'UAppNpcCostume_DA::MeshLocation' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, Anims) == 0x000040, "Member 'UAppNpcCostume_DA::Anims' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, Base) == 0x000090, "Member 'UAppNpcCostume_DA::Base' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, CostumeSummer) == 0x000130, "Member 'UAppNpcCostume_DA::CostumeSummer' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, CostumeWinter) == 0x000180, "Member 'UAppNpcCostume_DA::CostumeWinter' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, Hair) == 0x0001D0, "Member 'UAppNpcCostume_DA::Hair' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, Face) == 0x000220, "Member 'UAppNpcCostume_DA::Face' has a wrong offset!");
static_assert(offsetof(UAppNpcCostume_DA, Unique) == 0x000270, "Member 'UAppNpcCostume_DA::Unique' has a wrong offset!");

// Class xrd777.EvtManagerStateBase
// 0x0010 (0x0038 - 0x0028)
class UEvtManagerStateBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AAtlEvtEventManager_PauseActor*         EvtPauseActor;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtManagerStateBase">();
	}
	static class UEvtManagerStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtManagerStateBase>();
	}
};
static_assert(alignof(UEvtManagerStateBase) == 0x000008, "Wrong alignment on UEvtManagerStateBase");
static_assert(sizeof(UEvtManagerStateBase) == 0x000038, "Wrong size on UEvtManagerStateBase");
static_assert(offsetof(UEvtManagerStateBase, EvtPauseActor) == 0x000030, "Member 'UEvtManagerStateBase::EvtPauseActor' has a wrong offset!");

// Class xrd777.AppActivity
// 0x0090 (0x00C0 - 0x0030)
class UAppActivity final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivityDataAsset*                     DataAsset_;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x68];                                      // 0x0058(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppActivity">();
	}
	static class UAppActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppActivity>();
	}
};
static_assert(alignof(UAppActivity) == 0x000008, "Wrong alignment on UAppActivity");
static_assert(sizeof(UAppActivity) == 0x0000C0, "Wrong size on UAppActivity");
static_assert(offsetof(UAppActivity, Loader_) == 0x000048, "Member 'UAppActivity::Loader_' has a wrong offset!");
static_assert(offsetof(UAppActivity, DataAsset_) == 0x000050, "Member 'UAppActivity::DataAsset_' has a wrong offset!");

// Class xrd777.UIDayChange
// 0x0D08 (0x0FA8 - 0x02A0)
class AUIDayChange final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlg;                                            // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_tagUip;                                          // 0x02C8(0x0078)(NativeAccessSpecifierPublic)
	struct FDayChangeRipple                       M_tagRipple;                                       // 0x0340(0x0030)(NativeAccessSpecifierPublic)
	struct FDayChangeRipple                       M_tagLoadRipple;                                   // 0x0370(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveInAnim;                                     // 0x03A0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveInRectMaskAnim;                             // 0x03D0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCenterBlueBandMaskAnim;                     // 0x0400(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curve1DaySpeedAnim;                              // 0x0430(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveSkipSpeedAnim;                              // 0x0460(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveSuperSkipSpeedAnim;                         // 0x0490(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveCenterMoonAgeInOutAnim;                     // 0x04C0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveBigMoonAgeInOutAnim;                        // 0x04F0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCommonMoveAnim;                             // 0x0520(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveDaysGroupInAnim;                            // 0x0550(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveDayInAnim;                                  // 0x0580(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveDayOutAnim;                                 // 0x05B0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveBlueBandAnim;                               // 0x05E0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveSkipMoonAgeFadeAnim;                        // 0x0610(0x0030)(NativeAccessSpecifierPublic)
	class UDataTable*                             M_pLayoutData;                                     // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     M_pLayoutDataParam;                                // 0x0648(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0x958];                                    // 0x0650(0x0958)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDayChange">();
	}
	static class AUIDayChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDayChange>();
	}
};
static_assert(alignof(AUIDayChange) == 0x000008, "Wrong alignment on AUIDayChange");
static_assert(sizeof(AUIDayChange) == 0x000FA8, "Wrong size on AUIDayChange");
static_assert(offsetof(AUIDayChange, M_pLoader) == 0x0002B0, "Member 'AUIDayChange::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_pSpr) == 0x0002B8, "Member 'AUIDayChange::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_pPlg) == 0x0002C0, "Member 'AUIDayChange::M_pPlg' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_tagUip) == 0x0002C8, "Member 'AUIDayChange::M_tagUip' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_tagRipple) == 0x000340, "Member 'AUIDayChange::M_tagRipple' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_tagLoadRipple) == 0x000370, "Member 'AUIDayChange::M_tagLoadRipple' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveInAnim) == 0x0003A0, "Member 'AUIDayChange::M_curveInAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveInRectMaskAnim) == 0x0003D0, "Member 'AUIDayChange::M_curveInRectMaskAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveCenterBlueBandMaskAnim) == 0x000400, "Member 'AUIDayChange::M_curveCenterBlueBandMaskAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curve1DaySpeedAnim) == 0x000430, "Member 'AUIDayChange::M_curve1DaySpeedAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveSkipSpeedAnim) == 0x000460, "Member 'AUIDayChange::M_curveSkipSpeedAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveSuperSkipSpeedAnim) == 0x000490, "Member 'AUIDayChange::M_curveSuperSkipSpeedAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveCenterMoonAgeInOutAnim) == 0x0004C0, "Member 'AUIDayChange::M_curveCenterMoonAgeInOutAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveBigMoonAgeInOutAnim) == 0x0004F0, "Member 'AUIDayChange::M_curveBigMoonAgeInOutAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveCommonMoveAnim) == 0x000520, "Member 'AUIDayChange::M_curveCommonMoveAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveDaysGroupInAnim) == 0x000550, "Member 'AUIDayChange::M_curveDaysGroupInAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveDayInAnim) == 0x000580, "Member 'AUIDayChange::M_curveDayInAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveDayOutAnim) == 0x0005B0, "Member 'AUIDayChange::M_curveDayOutAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveBlueBandAnim) == 0x0005E0, "Member 'AUIDayChange::M_curveBlueBandAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_curveSkipMoonAgeFadeAnim) == 0x000610, "Member 'AUIDayChange::M_curveSkipMoonAgeFadeAnim' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_pLayoutData) == 0x000640, "Member 'AUIDayChange::M_pLayoutData' has a wrong offset!");
static_assert(offsetof(AUIDayChange, M_pLayoutDataParam) == 0x000648, "Member 'AUIDayChange::M_pLayoutDataParam' has a wrong offset!");

// Class xrd777.BtlBossErebusInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossErebusInterface final : public IInterface
{
public:
	bool IsChargeMode();
	bool IsWaitResurrectAnimation();
	void SetChargeEffect(bool IsShowCharageEffect);
	void SetIsInChargeMode(bool IsChargeMode);
	void SetWaitResurrectAnimation(bool IsWaitResurrect);
	void SpawnChargeVanishEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossErebusInterface">();
	}
	static class IBtlBossErebusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossErebusInterface>();
	}
};
static_assert(alignof(IBtlBossErebusInterface) == 0x000008, "Wrong alignment on IBtlBossErebusInterface");
static_assert(sizeof(IBtlBossErebusInterface) == 0x000028, "Wrong size on IBtlBossErebusInterface");

// Class xrd777.XRD777SaveGame
// 0x3806D0 (0x3806F8 - 0x0028)
class UXRD777SaveGame final : public USaveGame
{
public:
	struct FSaveGameHeadder                       SaveDataHeadder;                                   // 0x0028(0x00D0)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint32                                        SaveDataArea[0xE0180];                             // 0x00F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XRD777SaveGame">();
	}
	static class UXRD777SaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXRD777SaveGame>();
	}
};
static_assert(alignof(UXRD777SaveGame) == 0x000008, "Wrong alignment on UXRD777SaveGame");
static_assert(sizeof(UXRD777SaveGame) == 0x3806F8, "Wrong size on UXRD777SaveGame");
static_assert(offsetof(UXRD777SaveGame, SaveDataHeadder) == 0x000028, "Member 'UXRD777SaveGame::SaveDataHeadder' has a wrong offset!");
static_assert(offsetof(UXRD777SaveGame, SaveDataArea) == 0x0000F8, "Member 'UXRD777SaveGame::SaveDataArea' has a wrong offset!");

// Class xrd777.AppActorComponent
// 0x0018 (0x00C8 - 0x00B0)
class UAppActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EAppPauseObjectFlag                           AppPauseFlags;                                     // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* AsAActor();
	class UObject* AsUObject();
	void BeginPlay();
	void EndPlay(const EEndPlayReason EndPlayReason);

	EAppPauseObjectFlag GetAppPauseFlags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppActorComponent">();
	}
	static class UAppActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppActorComponent>();
	}
};
static_assert(alignof(UAppActorComponent) == 0x000008, "Wrong alignment on UAppActorComponent");
static_assert(sizeof(UAppActorComponent) == 0x0000C8, "Wrong size on UAppActorComponent");
static_assert(offsetof(UAppActorComponent, AppPauseFlags) == 0x0000C0, "Member 'UAppActorComponent::AppPauseFlags' has a wrong offset!");

// Class xrd777.UISceneFSM
// 0x0010 (0x0038 - 0x0028)
class UUISceneFSM final : public UObject
{
public:
	TArray<class UUIScene*>                       SceneStack_;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISceneFSM">();
	}
	static class UUISceneFSM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISceneFSM>();
	}
};
static_assert(alignof(UUISceneFSM) == 0x000008, "Wrong alignment on UUISceneFSM");
static_assert(sizeof(UUISceneFSM) == 0x000038, "Wrong size on UUISceneFSM");
static_assert(offsetof(UUISceneFSM, SceneStack_) == 0x000028, "Member 'UUISceneFSM::SceneStack_' has a wrong offset!");

// Class xrd777.DLCManager
// 0x0098 (0x0310 - 0x0278)
class alignas(0x10) ADLCManager final : public AAppActor
{
public:
	uint8                                         Pad_278[0x60];                                     // 0x0278(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader;                                      // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAddContentEntitlementDataAsset*        MAddContentEntitlementData;                        // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCManager">();
	}
	static class ADLCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADLCManager>();
	}
};
static_assert(alignof(ADLCManager) == 0x000010, "Wrong alignment on ADLCManager");
static_assert(sizeof(ADLCManager) == 0x000310, "Wrong size on ADLCManager");
static_assert(offsetof(ADLCManager, MAssetLoader) == 0x0002D8, "Member 'ADLCManager::MAssetLoader' has a wrong offset!");
static_assert(offsetof(ADLCManager, MAddContentEntitlementData) == 0x0002E0, "Member 'ADLCManager::MAddContentEntitlementData' has a wrong offset!");

// Class xrd777.AppCharAttachedPropsAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UAppCharAttachedPropsAnimNotify final : public UAnimNotify
{
public:
	int32                                         MAnimePackIndex_;                                  // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MPlayType_;                                        // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAttachedPropsAnimNotify">();
	}
	static class UAppCharAttachedPropsAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAttachedPropsAnimNotify>();
	}
};
static_assert(alignof(UAppCharAttachedPropsAnimNotify) == 0x000008, "Wrong alignment on UAppCharAttachedPropsAnimNotify");
static_assert(sizeof(UAppCharAttachedPropsAnimNotify) == 0x000040, "Wrong size on UAppCharAttachedPropsAnimNotify");
static_assert(offsetof(UAppCharAttachedPropsAnimNotify, MAnimePackIndex_) == 0x000038, "Member 'UAppCharAttachedPropsAnimNotify::MAnimePackIndex_' has a wrong offset!");
static_assert(offsetof(UAppCharAttachedPropsAnimNotify, MPlayType_) == 0x00003C, "Member 'UAppCharAttachedPropsAnimNotify::MPlayType_' has a wrong offset!");

// Class xrd777.AppAnimCtrl
// 0x0070 (0x0098 - 0x0028)
class UAppAnimCtrl final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacter>                 PCharacterClass;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             PCharacter;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          PSkeletalMesh;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASkeletalMeshActor*                     PSkelMeshAct;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 PSkMeshCompo;                                      // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAppAnimSequence>               AnimSeqAry;                                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   MMontageAry;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<float>                                 MSeqLengthAry;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppAnimCtrl">();
	}
	static class UAppAnimCtrl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppAnimCtrl>();
	}
};
static_assert(alignof(UAppAnimCtrl) == 0x000008, "Wrong alignment on UAppAnimCtrl");
static_assert(sizeof(UAppAnimCtrl) == 0x000098, "Wrong size on UAppAnimCtrl");
static_assert(offsetof(UAppAnimCtrl, PCharacterClass) == 0x000030, "Member 'UAppAnimCtrl::PCharacterClass' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, PCharacter) == 0x000038, "Member 'UAppAnimCtrl::PCharacter' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, PSkeletalMesh) == 0x000040, "Member 'UAppAnimCtrl::PSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, PSkelMeshAct) == 0x000048, "Member 'UAppAnimCtrl::PSkelMeshAct' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, PSkMeshCompo) == 0x000050, "Member 'UAppAnimCtrl::PSkMeshCompo' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, AnimSeqAry) == 0x000058, "Member 'UAppAnimCtrl::AnimSeqAry' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, MMontageAry) == 0x000068, "Member 'UAppAnimCtrl::MMontageAry' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, MSeqLengthAry) == 0x000078, "Member 'UAppAnimCtrl::MSeqLengthAry' has a wrong offset!");
static_assert(offsetof(UAppAnimCtrl, PAssetLoader) == 0x000090, "Member 'UAppAnimCtrl::PAssetLoader' has a wrong offset!");

// Class xrd777.FldLocalActorComp
// 0x0000 (0x00C8 - 0x00C8)
class UFldLocalActorComp : public UAppActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLocalActorComp">();
	}
	static class UFldLocalActorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldLocalActorComp>();
	}
};
static_assert(alignof(UFldLocalActorComp) == 0x000008, "Wrong alignment on UFldLocalActorComp");
static_assert(sizeof(UFldLocalActorComp) == 0x0000C8, "Wrong size on UFldLocalActorComp");

// Class xrd777.FldFollowerComp
// 0x00F0 (0x01B8 - 0x00C8)
class UFldFollowerComp final : public UFldLocalActorComp
{
public:
	float                                         MLengthLEAVE_START_;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLengthLEAVE_END_;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLengthAPPROACH_START_;                            // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLengthAPPROACH_END_;                              // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLengthALLAY_NEAR_;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLengthSPEAK_HERO_;                                // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MIdleMinTime_;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MIdleMaxTime_;                                     // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookMinTime_;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookMaxTime_;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSideMinTime_;                                     // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSideMaxTime_;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MInterpSpeed_;                                     // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        MFlag_;                                            // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MFollowerIndex_;                                   // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MApprouchRad_;                                     // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharacterComp*                      MCharaComp_;                                       // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      MCapsuleComp_;                                     // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            MMoveComp_;                                        // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldHitCharacter*                       MHitChild_;                                        // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldNpcComp*                            MNpcComp_;                                         // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldFollowerPointComp*                  MPointComp_;                                       // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLookAt_;                                        // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MLookTimer_;                                       // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookEndTime_;                                     // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MLookBaseLocation_;                                // 0x0144(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MLookYawDir_;                                      // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MLookCount_;                                       // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x60];                                     // 0x0158(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActoinRequest(class APawn* Player);
	void CheckEnableAction(class APawn* Player, bool* Check);
	void CleanupRequest();
	void GetAwayHeroRequest();
	void ProcInEvent(class AActor* OtherActor);
	void ProcOutEvent(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldFollowerComp">();
	}
	static class UFldFollowerComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldFollowerComp>();
	}
};
static_assert(alignof(UFldFollowerComp) == 0x000008, "Wrong alignment on UFldFollowerComp");
static_assert(sizeof(UFldFollowerComp) == 0x0001B8, "Wrong size on UFldFollowerComp");
static_assert(offsetof(UFldFollowerComp, MLengthLEAVE_START_) == 0x0000C8, "Member 'UFldFollowerComp::MLengthLEAVE_START_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLengthLEAVE_END_) == 0x0000CC, "Member 'UFldFollowerComp::MLengthLEAVE_END_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLengthAPPROACH_START_) == 0x0000D0, "Member 'UFldFollowerComp::MLengthAPPROACH_START_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLengthAPPROACH_END_) == 0x0000D4, "Member 'UFldFollowerComp::MLengthAPPROACH_END_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLengthALLAY_NEAR_) == 0x0000D8, "Member 'UFldFollowerComp::MLengthALLAY_NEAR_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLengthSPEAK_HERO_) == 0x0000DC, "Member 'UFldFollowerComp::MLengthSPEAK_HERO_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MIdleMinTime_) == 0x0000E0, "Member 'UFldFollowerComp::MIdleMinTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MIdleMaxTime_) == 0x0000E4, "Member 'UFldFollowerComp::MIdleMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookMinTime_) == 0x0000E8, "Member 'UFldFollowerComp::MLookMinTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookMaxTime_) == 0x0000EC, "Member 'UFldFollowerComp::MLookMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MSideMinTime_) == 0x0000F0, "Member 'UFldFollowerComp::MSideMinTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MSideMaxTime_) == 0x0000F4, "Member 'UFldFollowerComp::MSideMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MInterpSpeed_) == 0x0000F8, "Member 'UFldFollowerComp::MInterpSpeed_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MFlag_) == 0x0000FC, "Member 'UFldFollowerComp::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MFollowerIndex_) == 0x000100, "Member 'UFldFollowerComp::MFollowerIndex_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MApprouchRad_) == 0x000104, "Member 'UFldFollowerComp::MApprouchRad_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MCharaComp_) == 0x000108, "Member 'UFldFollowerComp::MCharaComp_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MCapsuleComp_) == 0x000110, "Member 'UFldFollowerComp::MCapsuleComp_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MMoveComp_) == 0x000118, "Member 'UFldFollowerComp::MMoveComp_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MHitChild_) == 0x000120, "Member 'UFldFollowerComp::MHitChild_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MNpcComp_) == 0x000128, "Member 'UFldFollowerComp::MNpcComp_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MPointComp_) == 0x000130, "Member 'UFldFollowerComp::MPointComp_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, bIsLookAt_) == 0x000138, "Member 'UFldFollowerComp::bIsLookAt_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookTimer_) == 0x00013C, "Member 'UFldFollowerComp::MLookTimer_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookEndTime_) == 0x000140, "Member 'UFldFollowerComp::MLookEndTime_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookBaseLocation_) == 0x000144, "Member 'UFldFollowerComp::MLookBaseLocation_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookYawDir_) == 0x000150, "Member 'UFldFollowerComp::MLookYawDir_' has a wrong offset!");
static_assert(offsetof(UFldFollowerComp, MLookCount_) == 0x000154, "Member 'UFldFollowerComp::MLookCount_' has a wrong offset!");

// Class xrd777.BtlBossLovers
// 0x0000 (0x0030 - 0x0030)
class UBtlBossLovers final : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossLovers">();
	}
	static class UBtlBossLovers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossLovers>();
	}
};
static_assert(alignof(UBtlBossLovers) == 0x000008, "Wrong alignment on UBtlBossLovers");
static_assert(sizeof(UBtlBossLovers) == 0x000030, "Wrong size on UBtlBossLovers");

// Class xrd777.UIMailIconDraw
// 0x01F0 (0x0490 - 0x02A0)
class AUIMailIconDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              Sprite_;                                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x1E0];                                    // 0x02B0(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMailIconDraw">();
	}
	static class AUIMailIconDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMailIconDraw>();
	}
};
static_assert(alignof(AUIMailIconDraw) == 0x000008, "Wrong alignment on AUIMailIconDraw");
static_assert(sizeof(AUIMailIconDraw) == 0x000490, "Wrong size on AUIMailIconDraw");
static_assert(offsetof(AUIMailIconDraw, Sprite_) == 0x0002A8, "Member 'AUIMailIconDraw::Sprite_' has a wrong offset!");

// Class xrd777.AppCharBaseComp
// 0x0250 (0x0300 - 0x00B0)
#pragma pack(push, 0x1)
class alignas(0x10) UAppCharBaseComp : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MMotionAttached_;                                  // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MMotionAttachedSocketName_;                        // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             MMotionAttachedTransform;                          // 0x00F0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          MMotionDetachPrepared_;                            // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMotionDetachPreparedTransKeep_;                   // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMotionDetachPreparedRelativeTrans_;               // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MMotionDetachPreparedRelativeRotator_;             // 0x0124(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                MMotionDetachPreparedRelativeLocation_;            // 0x0130(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x14];                                     // 0x013C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MFadeType_;                                        // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MFadeFrame_;                                       // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MFadePattern_;                                     // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x34];                                     // 0x015C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          MDelayPauseAnimReq_;                               // 0x0190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MDelayPauseAnimFlag_;                              // 0x0191(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_192[0x2];                                      // 0x0192(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MDelayPauseAnimSpeedRate_;                         // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   MBagClassPtr_;                                     // 0x0198(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MBagAttachSocketName;                              // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MBagAnimSlotName_;                                 // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAppCharBagAnimType, class UAnimSequenceBase*> MBagAnims_;                                        // 0x01D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AAppPropsCore*                          MBagActor_;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLockedLookAt_;                                  // 0x0228(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         MLockedLookAtType_;                                // 0x0229(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MLockedLookAtSpeed_;                               // 0x022C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 CostumeMesh;                                       // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HairMesh;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharFootstepsAtom*                  FootstepsAtom;                                     // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_DefaultSlot;                           // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_FacialSlot;                            // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_NeckSlot;                              // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage_TurnSlot;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage_HavBagSlot;                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAppCharCategoryType                          CategoryID;                                        // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IndexID;                                           // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CostumeID;                                         // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimPackID                                   AnimPackID;                                        // 0x028C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharAnimDataAsset*                  AnimPack;                                          // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharFaceAnimDataAsset*              FaceAnimPack;                                      // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAppCharWeaponType                            WeaponType;                                        // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponId;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AAppCharWeaponBase*>             Weapons;                                           // 0x02A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bBagEnable;                                        // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShoesID;                                           // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAppCharState                                 State;                                             // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveLocation;                                      // 0x02C4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSpeed;                                         // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTransparencyEnable;                               // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAppCharTransparency                   Transparency;                                      // 0x02D8(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ResetIkDelegate;                                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void ClearDelayPauseAnimFromMotion();
	TArray<class UMaterialInterface*> GetAllMaterial();
	class UAnimMontage* GetAnimMontageDefaultSlot();
	class FName GetBagAttachSocketName();
	TSoftClassPtr<class UClass> GetBagClassPtr();
	TArray<class AAppCharWeaponBase*> GetEffectWeapons();
	class UAppCharFootstepsAtom* GetFootstepsAtom();
	class AAppCharWeaponBase* GetWeapon();
	bool GetWeaponEnable();
	TArray<class AAppCharWeaponBase*> GetWeapons();
	bool IsBag();
	bool IsCostumeChenged();
	bool IsDelayPauseAnimFromMotion();
	bool IsLoadWeapons();
	bool IsNeckAnimation();
	bool IsPlayAnim_DefaultSlot();
	bool IsTurnAnimation();
	void Movement(const struct FVector& Location, const float Speed);
	void OverwriteTransformMotionAttachedActor(const struct FTransform& Transform);
	void PauseAnim(bool bPause, class UAnimMontage* InMontage);
	class UAnimMontage* PlayAnim(const class UAnimSequenceBase* Anim, const EAppCharAnimSlot Slot, const bool Loop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_DefaultSlot(const class UAnimSequenceBase* Anim, const bool Loop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_FacialSlot(const class UAnimSequenceBase* Anim, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_HaveBagSlot(const class UAnimSequenceBase* Anim, const class FName& SetSlotName, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_NeckSlot(const class UAnimSequenceBase* Anim, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_Pack(const int32 ID, const bool Loop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayAnim_TurnSlot(const class UAnimSequenceBase* Anim, const bool IsLoop, const float InBlendInTime, const float InBlendOutTime, const float InPlayRate, const float InBlendWeight);
	void PlayAnimationPackMotionAttachedProps(int32 InAnimePackIndex, const int32 InPlayType, const float InBlendInTime, const float InBlendOutTime, const float InPlayRate, class FName InAnimSlotName);
	class UAnimMontage* PlayAnimBagSlot_Pack(const int32 AnimId, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayFaceAnimation(EAppCharFaceAnimID FaceAnimID, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayFaceAnimIndex(int32 AnimIndex, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayHaveBagAnimation(EAppCharBagAnimType AnimType, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayNeckAnimation(int32 AnimIndex, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate);
	class UAnimMontage* PlayTurnAnimation(int32 AnimIndex, const bool IsLoop, const float InBlendInTime, const float InBlendOutTime, const float InPlayRate, const float InBlendWeight);
	void RequestDelayPauseAnimFromMotion();
	void RequestLoadWeapons();
	void RequestPauseAnimFromMotionIMD(bool IsLookAt);
	void ResetIK();
	void SetAnimMontageDefaultSlot(class UAnimMontage* AnimMontage);
	void SetAnimPackID(EAnimPackID Value);
	void SetBag(const bool Enable);
	void SetCategoryID(EAppCharCategoryType Value);
	void SetCostume();
	void SetCostumeID(int32 Value);
	void SetFadeSettingFromMotion(int32 FadeType, int32 FadeFrame, int32 FadePattern);
	void SetIndexID(int32 Value);
	void SetMotionAttachedActor(class AActor* AttachedActor);
	void SetMotionAttachedActorCore(class AActor* AttachedActor, class FName AttachedSocketName);
	void SetShoes(const bool Enable);
	void SetShoesId(const int32 ID);
	void SetupHaveBag_AfterSetCostume();
	void SetWeaponId(int32 Value);
	void SetWeaponType(const EAppCharWeaponType& Value);
	void StopAnim_DefaultSlot(float InBlendOutTime);
	void StopFaceAnimation(float InBlendOutTime);
	void StopHaveBagAnimation(float InBlendOutTime);
	void StopNeckAnimation(float InBlendOutTime);
	void StopTurnAnimation(float InBlendOutTime);

	EAnimPackID GetAnimPackID() const;
	EAppCharCategoryType GetCategoryID() const;
	int32 GetCostumeID() const;
	class USkeletalMeshComponent* GetCostumeMesh() const;
	class USkeletalMeshComponent* GetFaceMesh() const;
	class USkeletalMeshComponent* GetHairMesh() const;
	int32 GetIndexID() const;
	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharBaseComp">();
	}
	static class UAppCharBaseComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharBaseComp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UAppCharBaseComp) == 0x000010, "Wrong alignment on UAppCharBaseComp");
static_assert(sizeof(UAppCharBaseComp) == 0x000300, "Wrong size on UAppCharBaseComp");
static_assert(offsetof(UAppCharBaseComp, MMotionAttached_) == 0x0000E0, "Member 'UAppCharBaseComp::MMotionAttached_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MMotionAttachedSocketName_) == 0x0000E8, "Member 'UAppCharBaseComp::MMotionAttachedSocketName_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MMotionAttachedTransform) == 0x0000F0, "Member 'UAppCharBaseComp::MMotionAttachedTransform' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MMotionDetachPrepared_) == 0x000120, "Member 'UAppCharBaseComp::MMotionDetachPrepared_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, bMotionDetachPreparedTransKeep_) == 0x000121, "Member 'UAppCharBaseComp::bMotionDetachPreparedTransKeep_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, bMotionDetachPreparedRelativeTrans_) == 0x000122, "Member 'UAppCharBaseComp::bMotionDetachPreparedRelativeTrans_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MMotionDetachPreparedRelativeRotator_) == 0x000124, "Member 'UAppCharBaseComp::MMotionDetachPreparedRelativeRotator_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MMotionDetachPreparedRelativeLocation_) == 0x000130, "Member 'UAppCharBaseComp::MMotionDetachPreparedRelativeLocation_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MFadeType_) == 0x000150, "Member 'UAppCharBaseComp::MFadeType_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MFadeFrame_) == 0x000154, "Member 'UAppCharBaseComp::MFadeFrame_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MFadePattern_) == 0x000158, "Member 'UAppCharBaseComp::MFadePattern_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MDelayPauseAnimReq_) == 0x000190, "Member 'UAppCharBaseComp::MDelayPauseAnimReq_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MDelayPauseAnimFlag_) == 0x000191, "Member 'UAppCharBaseComp::MDelayPauseAnimFlag_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MDelayPauseAnimSpeedRate_) == 0x000194, "Member 'UAppCharBaseComp::MDelayPauseAnimSpeedRate_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MBagClassPtr_) == 0x000198, "Member 'UAppCharBaseComp::MBagClassPtr_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MBagAttachSocketName) == 0x0001C0, "Member 'UAppCharBaseComp::MBagAttachSocketName' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MBagAnimSlotName_) == 0x0001C8, "Member 'UAppCharBaseComp::MBagAnimSlotName_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MBagAnims_) == 0x0001D0, "Member 'UAppCharBaseComp::MBagAnims_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MBagActor_) == 0x000220, "Member 'UAppCharBaseComp::MBagActor_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, bIsLockedLookAt_) == 0x000228, "Member 'UAppCharBaseComp::bIsLockedLookAt_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MLockedLookAtType_) == 0x000229, "Member 'UAppCharBaseComp::MLockedLookAtType_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MLockedLookAtSpeed_) == 0x00022C, "Member 'UAppCharBaseComp::MLockedLookAtSpeed_' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, CostumeMesh) == 0x000230, "Member 'UAppCharBaseComp::CostumeMesh' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, HairMesh) == 0x000238, "Member 'UAppCharBaseComp::HairMesh' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, FaceMesh) == 0x000240, "Member 'UAppCharBaseComp::FaceMesh' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, FootstepsAtom) == 0x000248, "Member 'UAppCharBaseComp::FootstepsAtom' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimMontage_DefaultSlot) == 0x000250, "Member 'UAppCharBaseComp::AnimMontage_DefaultSlot' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimMontage_FacialSlot) == 0x000258, "Member 'UAppCharBaseComp::AnimMontage_FacialSlot' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimMontage_NeckSlot) == 0x000260, "Member 'UAppCharBaseComp::AnimMontage_NeckSlot' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimMontage_TurnSlot) == 0x000268, "Member 'UAppCharBaseComp::AnimMontage_TurnSlot' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimMontage_HavBagSlot) == 0x000278, "Member 'UAppCharBaseComp::AnimMontage_HavBagSlot' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, CategoryID) == 0x000280, "Member 'UAppCharBaseComp::CategoryID' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, IndexID) == 0x000284, "Member 'UAppCharBaseComp::IndexID' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, CostumeID) == 0x000288, "Member 'UAppCharBaseComp::CostumeID' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimPackID) == 0x00028C, "Member 'UAppCharBaseComp::AnimPackID' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, AnimPack) == 0x000290, "Member 'UAppCharBaseComp::AnimPack' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, FaceAnimPack) == 0x000298, "Member 'UAppCharBaseComp::FaceAnimPack' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, WeaponType) == 0x0002A0, "Member 'UAppCharBaseComp::WeaponType' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, WeaponId) == 0x0002A4, "Member 'UAppCharBaseComp::WeaponId' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, Weapons) == 0x0002A8, "Member 'UAppCharBaseComp::Weapons' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, bBagEnable) == 0x0002B8, "Member 'UAppCharBaseComp::bBagEnable' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, ShoesID) == 0x0002BC, "Member 'UAppCharBaseComp::ShoesID' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, State) == 0x0002C0, "Member 'UAppCharBaseComp::State' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MoveLocation) == 0x0002C4, "Member 'UAppCharBaseComp::MoveLocation' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, MoveSpeed) == 0x0002D0, "Member 'UAppCharBaseComp::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, bTransparencyEnable) == 0x0002D4, "Member 'UAppCharBaseComp::bTransparencyEnable' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, Transparency) == 0x0002D8, "Member 'UAppCharBaseComp::Transparency' has a wrong offset!");
static_assert(offsetof(UAppCharBaseComp, ResetIkDelegate) == 0x0002E8, "Member 'UAppCharBaseComp::ResetIkDelegate' has a wrong offset!");

// Class xrd777.AppCharacterComp
// 0x0070 (0x0370 - 0x0300)
class UAppCharacterComp : public UAppCharBaseComp
{
public:
	float                                         MBagMotionBlendTime_StandToRun_;                   // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MBagMotionBlendTime_RunToStand_;                   // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBagSetting_;                                    // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBagRun_;                                        // 0x0301(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MBagKeyID_;                                        // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MOverwirteBagKeyID_;                               // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBagInvalidIK_;                                  // 0x030C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBaseCore*                     Character;                                         // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedInitialize;                                   // 0x0318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharLoader*                         Loader;                                            // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AAppCharWeaponBase*>             EffectWeapons;                                     // 0x0328(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 HideMaterialIDs;                                   // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             UnlinkPhysicsDelegate;                             // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	int32                                         MSetCostumeID;                                     // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MSetWeaponType;                                    // 0x035C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MSetWeaponModelID;                                 // 0x0360(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVisibleAttachComponent(bool Visible);
	void UnlinkPhysics();

	class UCapsuleComponent* GetCapsule() const;
	class ACharacterBaseCore* GetCharacter() const;
	class UCharacterMovementComponent* GetMovement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharacterComp">();
	}
	static class UAppCharacterComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharacterComp>();
	}
};
static_assert(alignof(UAppCharacterComp) == 0x000010, "Wrong alignment on UAppCharacterComp");
static_assert(sizeof(UAppCharacterComp) == 0x000370, "Wrong size on UAppCharacterComp");
static_assert(offsetof(UAppCharacterComp, MBagMotionBlendTime_StandToRun_) == 0x0002F8, "Member 'UAppCharacterComp::MBagMotionBlendTime_StandToRun_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MBagMotionBlendTime_RunToStand_) == 0x0002FC, "Member 'UAppCharacterComp::MBagMotionBlendTime_RunToStand_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, bIsBagSetting_) == 0x000300, "Member 'UAppCharacterComp::bIsBagSetting_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, bIsBagRun_) == 0x000301, "Member 'UAppCharacterComp::bIsBagRun_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MBagKeyID_) == 0x000304, "Member 'UAppCharacterComp::MBagKeyID_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MOverwirteBagKeyID_) == 0x000308, "Member 'UAppCharacterComp::MOverwirteBagKeyID_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, bIsBagInvalidIK_) == 0x00030C, "Member 'UAppCharacterComp::bIsBagInvalidIK_' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, Character) == 0x000310, "Member 'UAppCharacterComp::Character' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, bNeedInitialize) == 0x000318, "Member 'UAppCharacterComp::bNeedInitialize' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, Loader) == 0x000320, "Member 'UAppCharacterComp::Loader' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, EffectWeapons) == 0x000328, "Member 'UAppCharacterComp::EffectWeapons' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, HideMaterialIDs) == 0x000338, "Member 'UAppCharacterComp::HideMaterialIDs' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, UnlinkPhysicsDelegate) == 0x000348, "Member 'UAppCharacterComp::UnlinkPhysicsDelegate' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MSetCostumeID) == 0x000358, "Member 'UAppCharacterComp::MSetCostumeID' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MSetWeaponType) == 0x00035C, "Member 'UAppCharacterComp::MSetWeaponType' has a wrong offset!");
static_assert(offsetof(UAppCharacterComp, MSetWeaponModelID) == 0x000360, "Member 'UAppCharacterComp::MSetWeaponModelID' has a wrong offset!");

// Class xrd777.BtlBossHangedManInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossHangedManInterface final : public IInterface
{
public:
	void FadeinHangedManEffect(float AnimTime);
	void FadeoutHangedManEffect(float AnimTime);
	void FadeoutStatueEffect(float AnimTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossHangedManInterface">();
	}
	static class IBtlBossHangedManInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossHangedManInterface>();
	}
};
static_assert(alignof(IBtlBossHangedManInterface) == 0x000008, "Wrong alignment on IBtlBossHangedManInterface");
static_assert(sizeof(IBtlBossHangedManInterface) == 0x000028, "Wrong size on IBtlBossHangedManInterface");

// Class xrd777.UIGameOverPoem
// 0x02A8 (0x0560 - 0x02B8)
class AUIGameOverPoem final : public AUIDrawBaseActor
{
public:
	struct FGameOverPoemContent                   Poem[0x4];                                         // 0x02B8(0x0080)(NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Ripple[0x3];                                       // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OpenRipplesPos[0x3];                               // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenRipplesSize[0x3];                              // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x14];                                     // 0x04F4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PLoader;                                           // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPoetryDataAsset*                     PoetryData_;                                       // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      PMaterial;                                         // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      PRippleMat;                                        // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x0530(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x20];                                     // 0x0540(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartRipple();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOverPoem">();
	}
	static class AUIGameOverPoem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIGameOverPoem>();
	}
};
static_assert(alignof(AUIGameOverPoem) == 0x000008, "Wrong alignment on AUIGameOverPoem");
static_assert(sizeof(AUIGameOverPoem) == 0x000560, "Wrong size on AUIGameOverPoem");
static_assert(offsetof(AUIGameOverPoem, Poem) == 0x0002B8, "Member 'AUIGameOverPoem::Poem' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, Ripple) == 0x0004B8, "Member 'AUIGameOverPoem::Ripple' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, OpenRipplesPos) == 0x0004D0, "Member 'AUIGameOverPoem::OpenRipplesPos' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, OpenRipplesSize) == 0x0004E8, "Member 'AUIGameOverPoem::OpenRipplesSize' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PLoader) == 0x000508, "Member 'AUIGameOverPoem::PLoader' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PoetryData_) == 0x000510, "Member 'AUIGameOverPoem::PoetryData_' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PMaterial) == 0x000518, "Member 'AUIGameOverPoem::PMaterial' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PRippleMat) == 0x000520, "Member 'AUIGameOverPoem::PRippleMat' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, AnimManager) == 0x000528, "Member 'AUIGameOverPoem::AnimManager' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PParamLayoutData) == 0x000530, "Member 'AUIGameOverPoem::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUIGameOverPoem, PLayoutDataTable) == 0x000538, "Member 'AUIGameOverPoem::PLayoutDataTable' has a wrong offset!");

// Class xrd777.AppCharacterPoolManager
// 0x0020 (0x0048 - 0x0028)
class UAppCharacterPoolManager final : public UObject
{
public:
	class UAppCharLoader*                         Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharacterPoolManager">();
	}
	static class UAppCharacterPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharacterPoolManager>();
	}
};
static_assert(alignof(UAppCharacterPoolManager) == 0x000008, "Wrong alignment on UAppCharacterPoolManager");
static_assert(sizeof(UAppCharacterPoolManager) == 0x000048, "Wrong size on UAppCharacterPoolManager");
static_assert(offsetof(UAppCharacterPoolManager, Loader) == 0x000028, "Member 'UAppCharacterPoolManager::Loader' has a wrong offset!");

// Class xrd777.UITownMapSymbolComponent
// 0x0010 (0x00D8 - 0x00C8)
class UUITownMapSymbolComponent final : public UAppActorComponent
{
public:
	class AFldAnimObj*                            FldAnimObj_;                                       // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinnedMeshComponent*                  SkinnedComponent_;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(class AFldAnimObj* FldAnimObj, class USkinnedMeshComponent* SkinnedComponent, ETownType TownType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownMapSymbolComponent">();
	}
	static class UUITownMapSymbolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITownMapSymbolComponent>();
	}
};
static_assert(alignof(UUITownMapSymbolComponent) == 0x000008, "Wrong alignment on UUITownMapSymbolComponent");
static_assert(sizeof(UUITownMapSymbolComponent) == 0x0000D8, "Wrong size on UUITownMapSymbolComponent");
static_assert(offsetof(UUITownMapSymbolComponent, FldAnimObj_) == 0x0000C8, "Member 'UUITownMapSymbolComponent::FldAnimObj_' has a wrong offset!");
static_assert(offsetof(UUITownMapSymbolComponent, SkinnedComponent_) == 0x0000D0, "Member 'UUITownMapSymbolComponent::SkinnedComponent_' has a wrong offset!");

// Class xrd777.CommunityShortcut
// 0x0028 (0x02B8 - 0x0290)
class ACommunityShortcut final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              PScript;                                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               PBfAsset;                                          // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ScriptFinishedFunction(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityShortcut">();
	}
	static class ACommunityShortcut* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommunityShortcut>();
	}
};
static_assert(alignof(ACommunityShortcut) == 0x000008, "Wrong alignment on ACommunityShortcut");
static_assert(sizeof(ACommunityShortcut) == 0x0002B8, "Wrong size on ACommunityShortcut");
static_assert(offsetof(ACommunityShortcut, PScript) == 0x0002A0, "Member 'ACommunityShortcut::PScript' has a wrong offset!");
static_assert(offsetof(ACommunityShortcut, PBfAsset) == 0x0002A8, "Member 'ACommunityShortcut::PBfAsset' has a wrong offset!");
static_assert(offsetof(ACommunityShortcut, PAssetLoader) == 0x0002B0, "Member 'ACommunityShortcut::PAssetLoader' has a wrong offset!");

// Class xrd777.AppCharAnimUnlockLookAtNotify
// 0x0000 (0x0038 - 0x0038)
class UAppCharAnimUnlockLookAtNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimUnlockLookAtNotify">();
	}
	static class UAppCharAnimUnlockLookAtNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimUnlockLookAtNotify>();
	}
};
static_assert(alignof(UAppCharAnimUnlockLookAtNotify) == 0x000008, "Wrong alignment on UAppCharAnimUnlockLookAtNotify");
static_assert(sizeof(UAppCharAnimUnlockLookAtNotify) == 0x000038, "Wrong size on UAppCharAnimUnlockLookAtNotify");

// Class xrd777.FldLocalActor
// 0x0008 (0x0280 - 0x0278)
class AFldLocalActor : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallStatePatternEndDelicate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLocalActor">();
	}
	static class AFldLocalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLocalActor>();
	}
};
static_assert(alignof(AFldLocalActor) == 0x000008, "Wrong alignment on AFldLocalActor");
static_assert(sizeof(AFldLocalActor) == 0x000280, "Wrong size on AFldLocalActor");

// Class xrd777.FldObjBase
// 0x0018 (0x0298 - 0x0280)
class AFldObjBase : public AFldLocalActor
{
public:
	class FName                                   MOnFlagName_;                                      // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldWeek                                      MOnWeek_;                                          // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnWeek_;                                        // 0x0291(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_292[0x6];                                      // 0x0292(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldObjBase">();
	}
	static class AFldObjBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldObjBase>();
	}
};
static_assert(alignof(AFldObjBase) == 0x000008, "Wrong alignment on AFldObjBase");
static_assert(sizeof(AFldObjBase) == 0x000298, "Wrong size on AFldObjBase");
static_assert(offsetof(AFldObjBase, MOnFlagName_) == 0x000280, "Member 'AFldObjBase::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AFldObjBase, MOffFlagName_) == 0x000288, "Member 'AFldObjBase::MOffFlagName_' has a wrong offset!");
static_assert(offsetof(AFldObjBase, MOnWeek_) == 0x000290, "Member 'AFldObjBase::MOnWeek_' has a wrong offset!");
static_assert(offsetof(AFldObjBase, bIsOnWeek_) == 0x000291, "Member 'AFldObjBase::bIsOnWeek_' has a wrong offset!");

// Class xrd777.FldLinkAnimObj
// 0x0048 (0x02E0 - 0x0298)
class AFldLinkAnimObj final : public AFldObjBase
{
public:
	struct FFldLaoAnimData                        MAnime_WAIT_;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldLaoAnimData                        MAnime_START_;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFldLaoAnimData>                MAnimeArray_LOOP_;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          MAnimeLoopFlag_;                                   // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldLaoAnimData                        MAnime_END_;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        MFlag_;                                            // 0x02C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MLoopIndex_;                                       // 0x02CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         MAnimeMeshList_;                                   // 0x02D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Initialize(class USkeletalMeshComponent* SkeletalMesh);
	void InitializeArray(const TArray<class USkeletalMeshComponent*>& SkeleTalMeshList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimObj">();
	}
	static class AFldLinkAnimObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLinkAnimObj>();
	}
};
static_assert(alignof(AFldLinkAnimObj) == 0x000008, "Wrong alignment on AFldLinkAnimObj");
static_assert(sizeof(AFldLinkAnimObj) == 0x0002E0, "Wrong size on AFldLinkAnimObj");
static_assert(offsetof(AFldLinkAnimObj, MAnime_WAIT_) == 0x000298, "Member 'AFldLinkAnimObj::MAnime_WAIT_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MAnime_START_) == 0x0002A0, "Member 'AFldLinkAnimObj::MAnime_START_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MAnimeArray_LOOP_) == 0x0002A8, "Member 'AFldLinkAnimObj::MAnimeArray_LOOP_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MAnimeLoopFlag_) == 0x0002B8, "Member 'AFldLinkAnimObj::MAnimeLoopFlag_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MAnime_END_) == 0x0002C0, "Member 'AFldLinkAnimObj::MAnime_END_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MFlag_) == 0x0002C8, "Member 'AFldLinkAnimObj::MFlag_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MLoopIndex_) == 0x0002CC, "Member 'AFldLinkAnimObj::MLoopIndex_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimObj, MAnimeMeshList_) == 0x0002D0, "Member 'AFldLinkAnimObj::MAnimeMeshList_' has a wrong offset!");

// Class xrd777.AppCharAnimAttachNotify
// 0x0008 (0x0040 - 0x0038)
class UAppCharAnimAttachNotify final : public UAnimNotify
{
public:
	class FName                                   MSocketName_;                                      // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimAttachNotify">();
	}
	static class UAppCharAnimAttachNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimAttachNotify>();
	}
};
static_assert(alignof(UAppCharAnimAttachNotify) == 0x000008, "Wrong alignment on UAppCharAnimAttachNotify");
static_assert(sizeof(UAppCharAnimAttachNotify) == 0x000040, "Wrong size on UAppCharAnimAttachNotify");
static_assert(offsetof(UAppCharAnimAttachNotify, MSocketName_) == 0x000038, "Member 'UAppCharAnimAttachNotify::MSocketName_' has a wrong offset!");

// Class xrd777.UICombine
// 0x03F0 (0x0418 - 0x0028)
class UUICombine final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIVelvetRoomOwner*                     M_pOwner;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x398];                                     // 0x0048(0x0398)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUIPersonaModelActor>       PBPPersonaBaseCore;                                // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PPersonaBaseCore;                                  // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppPropsCardContainer*                 PAppPropsCardContainer;                            // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StreamLevelCountDecrement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICombine">();
	}
	static class UUICombine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICombine>();
	}
};
static_assert(alignof(UUICombine) == 0x000008, "Wrong alignment on UUICombine");
static_assert(sizeof(UUICombine) == 0x000418, "Wrong size on UUICombine");
static_assert(offsetof(UUICombine, M_pOwner) == 0x000040, "Member 'UUICombine::M_pOwner' has a wrong offset!");
static_assert(offsetof(UUICombine, PAssetLoader) == 0x0003E0, "Member 'UUICombine::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UUICombine, PBPPersonaBaseCore) == 0x0003E8, "Member 'UUICombine::PBPPersonaBaseCore' has a wrong offset!");
static_assert(offsetof(UUICombine, PPersonaBaseCore) == 0x0003F0, "Member 'UUICombine::PPersonaBaseCore' has a wrong offset!");
static_assert(offsetof(UUICombine, PAppPropsCardContainer) == 0x0003F8, "Member 'UUICombine::PAppPropsCardContainer' has a wrong offset!");

// Class xrd777.AstreaPreviewHelperActor
// 0x0000 (0x0278 - 0x0278)
class AAstreaPreviewHelperActor final : public AAppActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaPreviewHelperActor">();
	}
	static class AAstreaPreviewHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAstreaPreviewHelperActor>();
	}
};
static_assert(alignof(AAstreaPreviewHelperActor) == 0x000008, "Wrong alignment on AAstreaPreviewHelperActor");
static_assert(sizeof(AAstreaPreviewHelperActor) == 0x000278, "Wrong size on AAstreaPreviewHelperActor");

// Class xrd777.WordSortDataAsset
// 0x0010 (0x0040 - 0x0030)
class UWordSortDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FWordSortTable>                 Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WordSortDataAsset">();
	}
	static class UWordSortDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWordSortDataAsset>();
	}
};
static_assert(alignof(UWordSortDataAsset) == 0x000008, "Wrong alignment on UWordSortDataAsset");
static_assert(sizeof(UWordSortDataAsset) == 0x000040, "Wrong size on UWordSortDataAsset");
static_assert(offsetof(UWordSortDataAsset, Data) == 0x000030, "Member 'UWordSortDataAsset::Data' has a wrong offset!");

// Class xrd777.BtlBossEmperorInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossEmperorInterface final : public IInterface
{
public:
	void StandingAlwaysWithPersona();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossEmperorInterface">();
	}
	static class IBtlBossEmperorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossEmperorInterface>();
	}
};
static_assert(alignof(IBtlBossEmperorInterface) == 0x000008, "Wrong alignment on IBtlBossEmperorInterface");
static_assert(sizeof(IBtlBossEmperorInterface) == 0x000028, "Wrong size on IBtlBossEmperorInterface");

// Class xrd777.Xrd777PrimaryAssetLabel
// 0x0050 (0x00B8 - 0x0068)
class UXrd777PrimaryAssetLabel final : public UPrimaryAssetLabel
{
public:
	TMap<class FString, struct FPrimaryAssetRules> PlatformRules;                                     // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Xrd777PrimaryAssetLabel">();
	}
	static class UXrd777PrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXrd777PrimaryAssetLabel>();
	}
};
static_assert(alignof(UXrd777PrimaryAssetLabel) == 0x000008, "Wrong alignment on UXrd777PrimaryAssetLabel");
static_assert(sizeof(UXrd777PrimaryAssetLabel) == 0x0000B8, "Wrong size on UXrd777PrimaryAssetLabel");
static_assert(offsetof(UXrd777PrimaryAssetLabel, PlatformRules) == 0x000068, "Member 'UXrd777PrimaryAssetLabel::PlatformRules' has a wrong offset!");

// Class xrd777.AppCharAnimDetachNotify
// 0x0048 (0x0080 - 0x0038)
class UAppCharAnimDetachNotify final : public UAnimNotify
{
public:
	bool                                          bDetachTrans_;                                     // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MRelativeTrans_;                                   // 0x0040(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRelativeTrans_;                                   // 0x0070(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimDetachNotify">();
	}
	static class UAppCharAnimDetachNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimDetachNotify>();
	}
};
static_assert(alignof(UAppCharAnimDetachNotify) == 0x000010, "Wrong alignment on UAppCharAnimDetachNotify");
static_assert(sizeof(UAppCharAnimDetachNotify) == 0x000080, "Wrong size on UAppCharAnimDetachNotify");
static_assert(offsetof(UAppCharAnimDetachNotify, bDetachTrans_) == 0x000038, "Member 'UAppCharAnimDetachNotify::bDetachTrans_' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDetachNotify, MRelativeTrans_) == 0x000040, "Member 'UAppCharAnimDetachNotify::MRelativeTrans_' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDetachNotify, bRelativeTrans_) == 0x000070, "Member 'UAppCharAnimDetachNotify::bRelativeTrans_' has a wrong offset!");

// Class xrd777.CostumeItemListTable
// 0x0010 (0x0040 - 0x0030)
class UCostumeItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FCostumeItemList>               Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CostumeItemListTable">();
	}
	static class UCostumeItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCostumeItemListTable>();
	}
};
static_assert(alignof(UCostumeItemListTable) == 0x000008, "Wrong alignment on UCostumeItemListTable");
static_assert(sizeof(UCostumeItemListTable) == 0x000040, "Wrong size on UCostumeItemListTable");
static_assert(offsetof(UCostumeItemListTable, Data) == 0x000030, "Member 'UCostumeItemListTable::Data' has a wrong offset!");

// Class xrd777.AppCharAnimDetachPrepareNotify
// 0x0048 (0x0080 - 0x0038)
class UAppCharAnimDetachPrepareNotify final : public UAnimNotify
{
public:
	bool                                          bDetachTrans_;                                     // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MRelativeTrans_;                                   // 0x0040(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRelativeTrans_;                                   // 0x0070(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimDetachPrepareNotify">();
	}
	static class UAppCharAnimDetachPrepareNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimDetachPrepareNotify>();
	}
};
static_assert(alignof(UAppCharAnimDetachPrepareNotify) == 0x000010, "Wrong alignment on UAppCharAnimDetachPrepareNotify");
static_assert(sizeof(UAppCharAnimDetachPrepareNotify) == 0x000080, "Wrong size on UAppCharAnimDetachPrepareNotify");
static_assert(offsetof(UAppCharAnimDetachPrepareNotify, bDetachTrans_) == 0x000038, "Member 'UAppCharAnimDetachPrepareNotify::bDetachTrans_' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDetachPrepareNotify, MRelativeTrans_) == 0x000040, "Member 'UAppCharAnimDetachPrepareNotify::MRelativeTrans_' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDetachPrepareNotify, bRelativeTrans_) == 0x000070, "Member 'UAppCharAnimDetachPrepareNotify::bRelativeTrans_' has a wrong offset!");

// Class xrd777.UIGenericSelectDraw
// 0x01F0 (0x04A8 - 0x02B8)
class AUIGenericSelectDraw final : public AUIDrawBaseActor
{
public:
	struct FVector2D                              Edit_PointA;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_PointD;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_PointG;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_PointH;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_TitleLogo_LoopAnima_Offset_Min;               // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_TitleLogo_LoopAnima_Offset_Max;               // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Character_LoopAnima_Offset_Min;               // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Character_LoopAnima_Offset_Max;               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Cursor_AnimationFrame;                        // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SubCursor_AnimationFrame;                     // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_1;                              // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_1_2;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_3;                              // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_3_CharacterMask_DelayFrame;     // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_4_ListItem_InFrame;             // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_4_ListItem_DelayFrame;          // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_4_Cursor_InFrame;               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimation_1_4_Cursor_DelayFrame;            // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_LoopAnima_Frame_Min;                          // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_LoopAnima_Frame_Max;                          // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_OutAnimation_3_1;                             // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_CharacterChange_In_Frame;                     // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_CharacterChange_Out_Frame;                    // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_CharacterChange_Slide_Frame;                  // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_TitleLogo_MorninColor;                        // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_TitleLogo_AfterschoolColor;                   // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_TitleLogo_NightColor;                         // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_ListAndCharacter_MorninColor;                 // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_ListAndCharacter_AfterschoolColor;            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_ListAndCharacter_NightColor;                  // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_CharacterBackPlate_MorninColor;               // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_CharacterBackPlate_AfterschoolColor;          // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_CharacterBackPlate_NightColor;                // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_RafflesiyaSelectedListTitle_NightColor;       // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Edit_RafflesiyaSelectedListMain_NightColor;        // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              PSprAsset;                                         // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PPlgAsset;                                         // 0x0360(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGenericSelectCharacterDataAsset*       PCharacterDataAsset;                               // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x78];                                     // 0x0370(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UGenericSelectSystemBase*               PSystem;                                           // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIGenericSelectCharacter*>      CharacterEnableList;                               // 0x03F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUIGenericSelectCharacter*>      CharacterDisableList;                              // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        TagGetUIP;                                         // 0x0418(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawCharacter();
	void DrawItemInfo();
	void DrawList();
	void DrawMultiplyPlates();
	void DrawTitle();
	void UpdateTimes(const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGenericSelectDraw">();
	}
	static class AUIGenericSelectDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIGenericSelectDraw>();
	}
};
static_assert(alignof(AUIGenericSelectDraw) == 0x000008, "Wrong alignment on AUIGenericSelectDraw");
static_assert(sizeof(AUIGenericSelectDraw) == 0x0004A8, "Wrong size on AUIGenericSelectDraw");
static_assert(offsetof(AUIGenericSelectDraw, Edit_PointA) == 0x0002B8, "Member 'AUIGenericSelectDraw::Edit_PointA' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_PointD) == 0x0002C0, "Member 'AUIGenericSelectDraw::Edit_PointD' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_PointG) == 0x0002C8, "Member 'AUIGenericSelectDraw::Edit_PointG' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_PointH) == 0x0002D0, "Member 'AUIGenericSelectDraw::Edit_PointH' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_TitleLogo_LoopAnima_Offset_Min) == 0x0002D8, "Member 'AUIGenericSelectDraw::Edit_TitleLogo_LoopAnima_Offset_Min' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_TitleLogo_LoopAnima_Offset_Max) == 0x0002DC, "Member 'AUIGenericSelectDraw::Edit_TitleLogo_LoopAnima_Offset_Max' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_Character_LoopAnima_Offset_Min) == 0x0002E0, "Member 'AUIGenericSelectDraw::Edit_Character_LoopAnima_Offset_Min' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_Character_LoopAnima_Offset_Max) == 0x0002E4, "Member 'AUIGenericSelectDraw::Edit_Character_LoopAnima_Offset_Max' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_Cursor_AnimationFrame) == 0x0002E8, "Member 'AUIGenericSelectDraw::Edit_Cursor_AnimationFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_SubCursor_AnimationFrame) == 0x0002EC, "Member 'AUIGenericSelectDraw::Edit_SubCursor_AnimationFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_1) == 0x0002F0, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_1' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_1_2) == 0x0002F4, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_1_2' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_3) == 0x0002F8, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_3' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_3_CharacterMask_DelayFrame) == 0x0002FC, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_3_CharacterMask_DelayFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_4_ListItem_InFrame) == 0x000300, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_4_ListItem_InFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_4_ListItem_DelayFrame) == 0x000304, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_4_ListItem_DelayFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_4_Cursor_InFrame) == 0x000308, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_4_Cursor_InFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_InAnimation_1_4_Cursor_DelayFrame) == 0x00030C, "Member 'AUIGenericSelectDraw::Edit_InAnimation_1_4_Cursor_DelayFrame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_LoopAnima_Frame_Min) == 0x000310, "Member 'AUIGenericSelectDraw::Edit_LoopAnima_Frame_Min' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_LoopAnima_Frame_Max) == 0x000314, "Member 'AUIGenericSelectDraw::Edit_LoopAnima_Frame_Max' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_OutAnimation_3_1) == 0x000318, "Member 'AUIGenericSelectDraw::Edit_OutAnimation_3_1' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterChange_In_Frame) == 0x00031C, "Member 'AUIGenericSelectDraw::Edit_CharacterChange_In_Frame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterChange_Out_Frame) == 0x000320, "Member 'AUIGenericSelectDraw::Edit_CharacterChange_Out_Frame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterChange_Slide_Frame) == 0x000324, "Member 'AUIGenericSelectDraw::Edit_CharacterChange_Slide_Frame' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_TitleLogo_MorninColor) == 0x000328, "Member 'AUIGenericSelectDraw::Edit_TitleLogo_MorninColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_TitleLogo_AfterschoolColor) == 0x00032C, "Member 'AUIGenericSelectDraw::Edit_TitleLogo_AfterschoolColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_TitleLogo_NightColor) == 0x000330, "Member 'AUIGenericSelectDraw::Edit_TitleLogo_NightColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_ListAndCharacter_MorninColor) == 0x000334, "Member 'AUIGenericSelectDraw::Edit_ListAndCharacter_MorninColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_ListAndCharacter_AfterschoolColor) == 0x000338, "Member 'AUIGenericSelectDraw::Edit_ListAndCharacter_AfterschoolColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_ListAndCharacter_NightColor) == 0x00033C, "Member 'AUIGenericSelectDraw::Edit_ListAndCharacter_NightColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterBackPlate_MorninColor) == 0x000340, "Member 'AUIGenericSelectDraw::Edit_CharacterBackPlate_MorninColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterBackPlate_AfterschoolColor) == 0x000344, "Member 'AUIGenericSelectDraw::Edit_CharacterBackPlate_AfterschoolColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_CharacterBackPlate_NightColor) == 0x000348, "Member 'AUIGenericSelectDraw::Edit_CharacterBackPlate_NightColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_RafflesiyaSelectedListTitle_NightColor) == 0x00034C, "Member 'AUIGenericSelectDraw::Edit_RafflesiyaSelectedListTitle_NightColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, Edit_RafflesiyaSelectedListMain_NightColor) == 0x000350, "Member 'AUIGenericSelectDraw::Edit_RafflesiyaSelectedListMain_NightColor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, PSprAsset) == 0x000358, "Member 'AUIGenericSelectDraw::PSprAsset' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, PPlgAsset) == 0x000360, "Member 'AUIGenericSelectDraw::PPlgAsset' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, PCharacterDataAsset) == 0x000368, "Member 'AUIGenericSelectDraw::PCharacterDataAsset' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, PSystem) == 0x0003E8, "Member 'AUIGenericSelectDraw::PSystem' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, CharacterEnableList) == 0x0003F0, "Member 'AUIGenericSelectDraw::CharacterEnableList' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, CharacterDisableList) == 0x000400, "Member 'AUIGenericSelectDraw::CharacterDisableList' has a wrong offset!");
static_assert(offsetof(AUIGenericSelectDraw, TagGetUIP) == 0x000418, "Member 'AUIGenericSelectDraw::TagGetUIP' has a wrong offset!");

// Class xrd777.AppCharAnimDataAsset
// 0x00B0 (0x00E0 - 0x0030)
class UAppCharAnimDataAsset final : public UDataAsset
{
public:
	EAnimPackID                                   PackId;                                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAppCharCategoryType                          Category;                                          // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharId;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 AnimInstance;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UClass*>                    SpecialAnimInstance;                               // 0x0040(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UAnimSequenceBase*>         Anims;                                             // 0x0090(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void Make();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimDataAsset">();
	}
	static class UAppCharAnimDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimDataAsset>();
	}
};
static_assert(alignof(UAppCharAnimDataAsset) == 0x000008, "Wrong alignment on UAppCharAnimDataAsset");
static_assert(sizeof(UAppCharAnimDataAsset) == 0x0000E0, "Wrong size on UAppCharAnimDataAsset");
static_assert(offsetof(UAppCharAnimDataAsset, PackId) == 0x000030, "Member 'UAppCharAnimDataAsset::PackId' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDataAsset, Category) == 0x000031, "Member 'UAppCharAnimDataAsset::Category' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDataAsset, CharId) == 0x000034, "Member 'UAppCharAnimDataAsset::CharId' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDataAsset, AnimInstance) == 0x000038, "Member 'UAppCharAnimDataAsset::AnimInstance' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDataAsset, SpecialAnimInstance) == 0x000040, "Member 'UAppCharAnimDataAsset::SpecialAnimInstance' has a wrong offset!");
static_assert(offsetof(UAppCharAnimDataAsset, Anims) == 0x000090, "Member 'UAppCharAnimDataAsset::Anims' has a wrong offset!");

// Class xrd777.FadeProgramBase
// 0x0018 (0x0040 - 0x0028)
class UFadeProgramBase : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeProgramBase">();
	}
	static class UFadeProgramBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeProgramBase>();
	}
};
static_assert(alignof(UFadeProgramBase) == 0x000008, "Wrong alignment on UFadeProgramBase");
static_assert(sizeof(UFadeProgramBase) == 0x000040, "Wrong size on UFadeProgramBase");

// Class xrd777.FadePgVelvetReturn
// 0x2418 (0x2458 - 0x0040)
class UFadePgVelvetReturn final : public UFadeProgramBase
{
public:
	struct FVelvetWipe                            M_velvetWipe;                                      // 0x0040(0x2418)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgVelvetReturn">();
	}
	static class UFadePgVelvetReturn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgVelvetReturn>();
	}
};
static_assert(alignof(UFadePgVelvetReturn) == 0x000008, "Wrong alignment on UFadePgVelvetReturn");
static_assert(sizeof(UFadePgVelvetReturn) == 0x002458, "Wrong size on UFadePgVelvetReturn");
static_assert(offsetof(UFadePgVelvetReturn, M_velvetWipe) == 0x000040, "Member 'UFadePgVelvetReturn::M_velvetWipe' has a wrong offset!");

// Class xrd777.AppCharAnimFadeNotify
// 0x0000 (0x0038 - 0x0038)
class UAppCharAnimFadeNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimFadeNotify">();
	}
	static class UAppCharAnimFadeNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimFadeNotify>();
	}
};
static_assert(alignof(UAppCharAnimFadeNotify) == 0x000008, "Wrong alignment on UAppCharAnimFadeNotify");
static_assert(sizeof(UAppCharAnimFadeNotify) == 0x000038, "Wrong size on UAppCharAnimFadeNotify");

// Class xrd777.AppCharAnimLockLookAtNotify
// 0x0008 (0x0040 - 0x0038)
class UAppCharAnimLockLookAtNotify final : public UAnimNotify
{
public:
	float                                         MInterpSpeed_;                                     // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimLockLookAtNotify">();
	}
	static class UAppCharAnimLockLookAtNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimLockLookAtNotify>();
	}
};
static_assert(alignof(UAppCharAnimLockLookAtNotify) == 0x000008, "Wrong alignment on UAppCharAnimLockLookAtNotify");
static_assert(sizeof(UAppCharAnimLockLookAtNotify) == 0x000040, "Wrong size on UAppCharAnimLockLookAtNotify");
static_assert(offsetof(UAppCharAnimLockLookAtNotify, MInterpSpeed_) == 0x000038, "Member 'UAppCharAnimLockLookAtNotify::MInterpSpeed_' has a wrong offset!");

// Class xrd777.PersonaLiftDataAsset
// 0x0010 (0x0040 - 0x0030)
class UPersonaLiftDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FPersonaLiftItem>               Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaLiftDataAsset">();
	}
	static class UPersonaLiftDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaLiftDataAsset>();
	}
};
static_assert(alignof(UPersonaLiftDataAsset) == 0x000008, "Wrong alignment on UPersonaLiftDataAsset");
static_assert(sizeof(UPersonaLiftDataAsset) == 0x000040, "Wrong size on UPersonaLiftDataAsset");
static_assert(offsetof(UPersonaLiftDataAsset, Data) == 0x000030, "Member 'UPersonaLiftDataAsset::Data' has a wrong offset!");

// Class xrd777.AppCharAnimStopTimingNotify
// 0x0008 (0x0040 - 0x0038)
class UAppCharAnimStopTimingNotify final : public UAnimNotify
{
public:
	bool                                          MLookAtFlag_;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharAnimStopTimingNotify">();
	}
	static class UAppCharAnimStopTimingNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharAnimStopTimingNotify>();
	}
};
static_assert(alignof(UAppCharAnimStopTimingNotify) == 0x000008, "Wrong alignment on UAppCharAnimStopTimingNotify");
static_assert(sizeof(UAppCharAnimStopTimingNotify) == 0x000040, "Wrong size on UAppCharAnimStopTimingNotify");
static_assert(offsetof(UAppCharAnimStopTimingNotify, MLookAtFlag_) == 0x000038, "Member 'UAppCharAnimStopTimingNotify::MLookAtFlag_' has a wrong offset!");

// Class xrd777.SupportBustupDataAsset
// 0x0010 (0x0040 - 0x0030)
class USupportBustupDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSupportBustupParam>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupportBustupDataAsset">();
	}
	static class USupportBustupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupportBustupDataAsset>();
	}
};
static_assert(alignof(USupportBustupDataAsset) == 0x000008, "Wrong alignment on USupportBustupDataAsset");
static_assert(sizeof(USupportBustupDataAsset) == 0x000040, "Wrong size on USupportBustupDataAsset");
static_assert(offsetof(USupportBustupDataAsset, Data) == 0x000030, "Member 'USupportBustupDataAsset::Data' has a wrong offset!");

// Class xrd777.GenericSelectCharacterDataAsset
// 0x0010 (0x0040 - 0x0030)
class UGenericSelectCharacterDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FGenericSelectCharacterTextureItem> Assets;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericSelectCharacterDataAsset">();
	}
	static class UGenericSelectCharacterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericSelectCharacterDataAsset>();
	}
};
static_assert(alignof(UGenericSelectCharacterDataAsset) == 0x000008, "Wrong alignment on UGenericSelectCharacterDataAsset");
static_assert(sizeof(UGenericSelectCharacterDataAsset) == 0x000040, "Wrong size on UGenericSelectCharacterDataAsset");
static_assert(offsetof(UGenericSelectCharacterDataAsset, Assets) == 0x000030, "Member 'UGenericSelectCharacterDataAsset::Assets' has a wrong offset!");

// Class xrd777.AppCharFaceAnimDataAsset
// 0x0058 (0x0088 - 0x0030)
class UAppCharFaceAnimDataAsset final : public UDataAsset
{
public:
	EAppCharCategoryType                          Category;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharId;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UAnimSequenceBase*>         Anims;                                             // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class FString GetAssetPath(EAppCharFaceAnimID FaceAnimID, EAppCharCategoryType CharCategory, int32 CharId_0, EAppCharAnimCategoryType AnimCategory);

	void AddExtra();
	void Make();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFaceAnimDataAsset">();
	}
	static class UAppCharFaceAnimDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFaceAnimDataAsset>();
	}
};
static_assert(alignof(UAppCharFaceAnimDataAsset) == 0x000008, "Wrong alignment on UAppCharFaceAnimDataAsset");
static_assert(sizeof(UAppCharFaceAnimDataAsset) == 0x000088, "Wrong size on UAppCharFaceAnimDataAsset");
static_assert(offsetof(UAppCharFaceAnimDataAsset, Category) == 0x000030, "Member 'UAppCharFaceAnimDataAsset::Category' has a wrong offset!");
static_assert(offsetof(UAppCharFaceAnimDataAsset, CharId) == 0x000034, "Member 'UAppCharFaceAnimDataAsset::CharId' has a wrong offset!");
static_assert(offsetof(UAppCharFaceAnimDataAsset, Anims) == 0x000038, "Member 'UAppCharFaceAnimDataAsset::Anims' has a wrong offset!");

// Class xrd777.EvtCharacterDraft
// 0x0000 (0x0280 - 0x0280)
class AEvtCharacterDraft final : public APawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtCharacterDraft">();
	}
	static class AEvtCharacterDraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvtCharacterDraft>();
	}
};
static_assert(alignof(AEvtCharacterDraft) == 0x000008, "Wrong alignment on AEvtCharacterDraft");
static_assert(sizeof(AEvtCharacterDraft) == 0x000280, "Wrong size on AEvtCharacterDraft");

// Class xrd777.AppCharFootstepsAtom
// 0x0060 (0x1100 - 0x10A0)
class UAppCharFootstepsAtom final : public UAtomComponent
{
public:
	struct FUAppCharFootstepsLabel                Lable;                                             // 0x1098(0x0020)(NativeAccessSpecifierPrivate)
	struct FUAppCharFootstepsLabel                DefaultLable;                                      // 0x10B8(0x0020)(NativeAccessSpecifierPrivate)
	class AActor*                                 OverwriteActor;                                    // 0x10D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAppCharFootstepsOverwrite>     MKeepOverwrites_;                                  // 0x10E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bEnable;                                           // 0x10F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F1[0xF];                                     // 0x10F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnable(const bool Value);
	void SetRunCue(class USoundAtomCue* Value);
	void SetWalkCue(class USoundAtomCue* Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsAtom">();
	}
	static class UAppCharFootstepsAtom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsAtom>();
	}
};
static_assert(alignof(UAppCharFootstepsAtom) == 0x000010, "Wrong alignment on UAppCharFootstepsAtom");
static_assert(sizeof(UAppCharFootstepsAtom) == 0x001100, "Wrong size on UAppCharFootstepsAtom");
static_assert(offsetof(UAppCharFootstepsAtom, Lable) == 0x001098, "Member 'UAppCharFootstepsAtom::Lable' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsAtom, DefaultLable) == 0x0010B8, "Member 'UAppCharFootstepsAtom::DefaultLable' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsAtom, OverwriteActor) == 0x0010D8, "Member 'UAppCharFootstepsAtom::OverwriteActor' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsAtom, MKeepOverwrites_) == 0x0010E0, "Member 'UAppCharFootstepsAtom::MKeepOverwrites_' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsAtom, bEnable) == 0x0010F0, "Member 'UAppCharFootstepsAtom::bEnable' has a wrong offset!");

// Class xrd777.UISaveLoad
// 0x0158 (0x03D0 - 0x0278)
class AUISaveLoad : public AAppActor
{
public:
	uint8                                         Pad_278[0x60];                                     // 0x0278(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAddContent*                            AddContentCheck;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadLayoutDataTable;                           // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadLayoutDataTableAstrea;                     // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadLayoutDataTable2;                          // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadDateLayoutDataTable;                       // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadTimeZoneLayoutDataTableAstrea;             // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataAstrea;                            // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData2;                                 // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamDateLayoutData;                              // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamTimeZoneLayoutDataAstrea;                    // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AUISystemMsgActor*                      NetworkConnectionDialog;                           // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UXrd777SaveManager*                     SaveManagerInst;                                   // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASaveLoadDraw>              DrawActorSC;                                       // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASaveLoadDraw*                          DrawActor;                                         // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x58];                                     // 0x0378(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedCloseAnim();
	void OnFinishedInAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoad">();
	}
	static class AUISaveLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISaveLoad>();
	}
};
static_assert(alignof(AUISaveLoad) == 0x000008, "Wrong alignment on AUISaveLoad");
static_assert(sizeof(AUISaveLoad) == 0x0003D0, "Wrong size on AUISaveLoad");
static_assert(offsetof(AUISaveLoad, AddContentCheck) == 0x0002D8, "Member 'AUISaveLoad::AddContentCheck' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, Loader) == 0x0002E0, "Member 'AUISaveLoad::Loader' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveLoadLayoutDataTable) == 0x0002E8, "Member 'AUISaveLoad::SaveLoadLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveLoadLayoutDataTableAstrea) == 0x0002F0, "Member 'AUISaveLoad::SaveLoadLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveLoadLayoutDataTable2) == 0x0002F8, "Member 'AUISaveLoad::SaveLoadLayoutDataTable2' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveLoadDateLayoutDataTable) == 0x000300, "Member 'AUISaveLoad::SaveLoadDateLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveLoadTimeZoneLayoutDataTableAstrea) == 0x000308, "Member 'AUISaveLoad::SaveLoadTimeZoneLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, PParamLayoutData) == 0x000310, "Member 'AUISaveLoad::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, PParamLayoutDataAstrea) == 0x000318, "Member 'AUISaveLoad::PParamLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, PParamLayoutData2) == 0x000320, "Member 'AUISaveLoad::PParamLayoutData2' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, PParamDateLayoutData) == 0x000328, "Member 'AUISaveLoad::PParamDateLayoutData' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, PParamTimeZoneLayoutDataAstrea) == 0x000330, "Member 'AUISaveLoad::PParamTimeZoneLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, NetworkConnectionDialog) == 0x000358, "Member 'AUISaveLoad::NetworkConnectionDialog' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, SaveManagerInst) == 0x000360, "Member 'AUISaveLoad::SaveManagerInst' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, DrawActorSC) == 0x000368, "Member 'AUISaveLoad::DrawActorSC' has a wrong offset!");
static_assert(offsetof(AUISaveLoad, DrawActor) == 0x000370, "Member 'AUISaveLoad::DrawActor' has a wrong offset!");

// Class xrd777.UILoadDialog
// 0x0018 (0x03E8 - 0x03D0)
class AUILoadDialog final : public AUISaveLoad
{
public:
	uint8                                         Pad_3D0[0x18];                                     // 0x03D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadDialog">();
	}
	static class AUILoadDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUILoadDialog>();
	}
};
static_assert(alignof(AUILoadDialog) == 0x000008, "Wrong alignment on AUILoadDialog");
static_assert(sizeof(AUILoadDialog) == 0x0003E8, "Wrong size on AUILoadDialog");

// Class xrd777.AppCharFootstepsDataAsset
// 0x0100 (0x0130 - 0x0030)
class UAppCharFootstepsDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FUAppCharFootstepsMajor>   Field;                                             // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<int32, struct FUAppCharFootstepsMajor>   Battle;                                            // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          CommonCue;                                         // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          NpcCue;                                            // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FUAppCharFootstepsCue>     CharCue;                                           // 0x00E0(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsDataAsset">();
	}
	static class UAppCharFootstepsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsDataAsset>();
	}
};
static_assert(alignof(UAppCharFootstepsDataAsset) == 0x000008, "Wrong alignment on UAppCharFootstepsDataAsset");
static_assert(sizeof(UAppCharFootstepsDataAsset) == 0x000130, "Wrong size on UAppCharFootstepsDataAsset");
static_assert(offsetof(UAppCharFootstepsDataAsset, Field) == 0x000030, "Member 'UAppCharFootstepsDataAsset::Field' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsDataAsset, Battle) == 0x000080, "Member 'UAppCharFootstepsDataAsset::Battle' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsDataAsset, CommonCue) == 0x0000D0, "Member 'UAppCharFootstepsDataAsset::CommonCue' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsDataAsset, NpcCue) == 0x0000D8, "Member 'UAppCharFootstepsDataAsset::NpcCue' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsDataAsset, CharCue) == 0x0000E0, "Member 'UAppCharFootstepsDataAsset::CharCue' has a wrong offset!");

// Class xrd777.FclShopBase
// 0x0120 (0x03C0 - 0x02A0)
class AFclShopBase : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0xC8];                                     // 0x02A0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              ScrActor_;                                         // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x50];                                     // 0x0370(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclShopBase">();
	}
	static class AFclShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclShopBase>();
	}
};
static_assert(alignof(AFclShopBase) == 0x000008, "Wrong alignment on AFclShopBase");
static_assert(sizeof(AFclShopBase) == 0x0003C0, "Wrong size on AFclShopBase");
static_assert(offsetof(AFclShopBase, ScrActor_) == 0x000368, "Member 'AFclShopBase::ScrActor_' has a wrong offset!");

// Class xrd777.FclSimpleShop
// 0x0160 (0x0520 - 0x03C0)
class AFclSimpleShop final : public AFclShopBase
{
public:
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASimpleShopDraw*                        ShopDraw;                                          // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    CaptureBackGround;                                 // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Tex;                                               // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PParamLayoutData;                                  // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PTextParamLayoutData;                              // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTextLayoutDataTable;                              // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0xE0];                                     // 0x0440(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclSimpleShop">();
	}
	static class AFclSimpleShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclSimpleShop>();
	}
};
static_assert(alignof(AFclSimpleShop) == 0x000008, "Wrong alignment on AFclSimpleShop");
static_assert(sizeof(AFclSimpleShop) == 0x000520, "Wrong size on AFclSimpleShop");
static_assert(offsetof(AFclSimpleShop, ShopDraw) == 0x0003D8, "Member 'AFclSimpleShop::ShopDraw' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, CaptureBackGround) == 0x0003E0, "Member 'AFclSimpleShop::CaptureBackGround' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, Tex) == 0x0003F0, "Member 'AFclSimpleShop::Tex' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, Loader_) == 0x000400, "Member 'AFclSimpleShop::Loader_' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, PParamLayoutData) == 0x000420, "Member 'AFclSimpleShop::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, PTextParamLayoutData) == 0x000428, "Member 'AFclSimpleShop::PTextParamLayoutData' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, PLayoutDataTable) == 0x000430, "Member 'AFclSimpleShop::PLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AFclSimpleShop, PTextLayoutDataTable) == 0x000438, "Member 'AFclSimpleShop::PTextLayoutDataTable' has a wrong offset!");

// Class xrd777.AppCharFootstepsTable
// 0x0120 (0x0148 - 0x0028)
class UAppCharFootstepsTable final : public UObject
{
public:
	TSoftObjectPtr<class UAppCharFootstepsDataAsset> Path;                                              // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppCharFootstepsDataAsset*             Data;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoaded;                                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0xEF];                                      // 0x0059(0x00EF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsTable">();
	}
	static class UAppCharFootstepsTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsTable>();
	}
};
static_assert(alignof(UAppCharFootstepsTable) == 0x000008, "Wrong alignment on UAppCharFootstepsTable");
static_assert(sizeof(UAppCharFootstepsTable) == 0x000148, "Wrong size on UAppCharFootstepsTable");
static_assert(offsetof(UAppCharFootstepsTable, Path) == 0x000028, "Member 'UAppCharFootstepsTable::Path' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsTable, Data) == 0x000050, "Member 'UAppCharFootstepsTable::Data' has a wrong offset!");
static_assert(offsetof(UAppCharFootstepsTable, bLoaded) == 0x000058, "Member 'UAppCharFootstepsTable::bLoaded' has a wrong offset!");

// Class xrd777.AppCharFootstepsNotify
// 0x0008 (0x0040 - 0x0038)
class UAppCharFootstepsNotify final : public UAnimNotify
{
public:
	EAppCharFootstepsType                         Type;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsNotify">();
	}
	static class UAppCharFootstepsNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsNotify>();
	}
};
static_assert(alignof(UAppCharFootstepsNotify) == 0x000008, "Wrong alignment on UAppCharFootstepsNotify");
static_assert(sizeof(UAppCharFootstepsNotify) == 0x000040, "Wrong size on UAppCharFootstepsNotify");
static_assert(offsetof(UAppCharFootstepsNotify, Type) == 0x000038, "Member 'UAppCharFootstepsNotify::Type' has a wrong offset!");

// Class xrd777.SkillPackDataAsset
// 0x0010 (0x0040 - 0x0030)
class USkillPackDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSkillPackItems>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillPackDataAsset">();
	}
	static class USkillPackDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillPackDataAsset>();
	}
};
static_assert(alignof(USkillPackDataAsset) == 0x000008, "Wrong alignment on USkillPackDataAsset");
static_assert(sizeof(USkillPackDataAsset) == 0x000040, "Wrong size on USkillPackDataAsset");
static_assert(offsetof(USkillPackDataAsset, Data) == 0x000030, "Member 'USkillPackDataAsset::Data' has a wrong offset!");

// Class xrd777.AppCharFootstepsTriggerComp_BOX
// 0x0020 (0x04A0 - 0x0480)
class UAppCharFootstepsTriggerComp_BOX final : public UBoxComponent
{
public:
	struct FUAppCharFootstepsLabel                MLabel_;                                           // 0x0478(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsTriggerComp_BOX">();
	}
	static class UAppCharFootstepsTriggerComp_BOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsTriggerComp_BOX>();
	}
};
static_assert(alignof(UAppCharFootstepsTriggerComp_BOX) == 0x000010, "Wrong alignment on UAppCharFootstepsTriggerComp_BOX");
static_assert(sizeof(UAppCharFootstepsTriggerComp_BOX) == 0x0004A0, "Wrong size on UAppCharFootstepsTriggerComp_BOX");
static_assert(offsetof(UAppCharFootstepsTriggerComp_BOX, MLabel_) == 0x000478, "Member 'UAppCharFootstepsTriggerComp_BOX::MLabel_' has a wrong offset!");

// Class xrd777.FldCharPersonalMotionComp
// 0x0048 (0x0110 - 0x00C8)
class UFldCharPersonalMotionComp final : public UFldLocalActorComp
{
public:
	float                                         MIdolTime_FIX_;                                    // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MIdolTime_RAND_;                                   // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MBlendTime_START_;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MBlendTime_END_;                                   // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharBaseComp*                       MCharComp_;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MTimer_;                                           // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMaxTime_;                                         // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           MAnimMontage_;                                     // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFldPersonalMotionData>         MMotionList_BASE_;                                 // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFldPersonalMotionData>         MMotionList_;                                      // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharPersonalMotionComp">();
	}
	static class UFldCharPersonalMotionComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharPersonalMotionComp>();
	}
};
static_assert(alignof(UFldCharPersonalMotionComp) == 0x000008, "Wrong alignment on UFldCharPersonalMotionComp");
static_assert(sizeof(UFldCharPersonalMotionComp) == 0x000110, "Wrong size on UFldCharPersonalMotionComp");
static_assert(offsetof(UFldCharPersonalMotionComp, MIdolTime_FIX_) == 0x0000C8, "Member 'UFldCharPersonalMotionComp::MIdolTime_FIX_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MIdolTime_RAND_) == 0x0000CC, "Member 'UFldCharPersonalMotionComp::MIdolTime_RAND_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MBlendTime_START_) == 0x0000D0, "Member 'UFldCharPersonalMotionComp::MBlendTime_START_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MBlendTime_END_) == 0x0000D4, "Member 'UFldCharPersonalMotionComp::MBlendTime_END_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MCharComp_) == 0x0000D8, "Member 'UFldCharPersonalMotionComp::MCharComp_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MTimer_) == 0x0000E0, "Member 'UFldCharPersonalMotionComp::MTimer_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MMaxTime_) == 0x0000E4, "Member 'UFldCharPersonalMotionComp::MMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MAnimMontage_) == 0x0000E8, "Member 'UFldCharPersonalMotionComp::MAnimMontage_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MMotionList_BASE_) == 0x0000F0, "Member 'UFldCharPersonalMotionComp::MMotionList_BASE_' has a wrong offset!");
static_assert(offsetof(UFldCharPersonalMotionComp, MMotionList_) == 0x000100, "Member 'UFldCharPersonalMotionComp::MMotionList_' has a wrong offset!");

// Class xrd777.DatObjectVisibleTable
// 0x0010 (0x0040 - 0x0030)
class UDatObjectVisibleTable final : public UAppDataAsset
{
public:
	TArray<struct FDatObjectVisibleDataTable>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatObjectVisibleTable">();
	}
	static class UDatObjectVisibleTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatObjectVisibleTable>();
	}
};
static_assert(alignof(UDatObjectVisibleTable) == 0x000008, "Wrong alignment on UDatObjectVisibleTable");
static_assert(sizeof(UDatObjectVisibleTable) == 0x000040, "Wrong size on UDatObjectVisibleTable");
static_assert(offsetof(UDatObjectVisibleTable, Data) == 0x000030, "Member 'UDatObjectVisibleTable::Data' has a wrong offset!");

// Class xrd777.AppCharFootstepsTriggerComp_CIRCLE
// 0x0020 (0x0490 - 0x0470)
class UAppCharFootstepsTriggerComp_CIRCLE final : public USphereComponent
{
public:
	struct FUAppCharFootstepsLabel                MLabel_;                                           // 0x0470(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsTriggerComp_CIRCLE">();
	}
	static class UAppCharFootstepsTriggerComp_CIRCLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharFootstepsTriggerComp_CIRCLE>();
	}
};
static_assert(alignof(UAppCharFootstepsTriggerComp_CIRCLE) == 0x000010, "Wrong alignment on UAppCharFootstepsTriggerComp_CIRCLE");
static_assert(sizeof(UAppCharFootstepsTriggerComp_CIRCLE) == 0x000490, "Wrong size on UAppCharFootstepsTriggerComp_CIRCLE");
static_assert(offsetof(UAppCharFootstepsTriggerComp_CIRCLE, MLabel_) == 0x000470, "Member 'UAppCharFootstepsTriggerComp_CIRCLE::MLabel_' has a wrong offset!");

// Class xrd777.DatTownMapRestrictions
// 0x0030 (0x0060 - 0x0030)
class UDatTownMapRestrictions final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatTownMapRestrictions">();
	}
	static class UDatTownMapRestrictions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatTownMapRestrictions>();
	}
};
static_assert(alignof(UDatTownMapRestrictions) == 0x000008, "Wrong alignment on UDatTownMapRestrictions");
static_assert(sizeof(UDatTownMapRestrictions) == 0x000060, "Wrong size on UDatTownMapRestrictions");

// Class xrd777.AppCharFootstepsTriggerVolume
// 0x0028 (0x0280 - 0x0258)
class AAppCharFootstepsTriggerVolume : public ATriggerVolume
{
public:
	struct FUAppCharFootstepsLabel                MLabel_;                                           // 0x0258(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          MTimeNoon_;                                        // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeAfternoon_;                                   // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeNight_;                                       // 0x027A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeShadow_;                                      // 0x027B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsTriggerVolume">();
	}
	static class AAppCharFootstepsTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppCharFootstepsTriggerVolume>();
	}
};
static_assert(alignof(AAppCharFootstepsTriggerVolume) == 0x000008, "Wrong alignment on AAppCharFootstepsTriggerVolume");
static_assert(sizeof(AAppCharFootstepsTriggerVolume) == 0x000280, "Wrong size on AAppCharFootstepsTriggerVolume");
static_assert(offsetof(AAppCharFootstepsTriggerVolume, MLabel_) == 0x000258, "Member 'AAppCharFootstepsTriggerVolume::MLabel_' has a wrong offset!");
static_assert(offsetof(AAppCharFootstepsTriggerVolume, MTimeNoon_) == 0x000278, "Member 'AAppCharFootstepsTriggerVolume::MTimeNoon_' has a wrong offset!");
static_assert(offsetof(AAppCharFootstepsTriggerVolume, MTimeAfternoon_) == 0x000279, "Member 'AAppCharFootstepsTriggerVolume::MTimeAfternoon_' has a wrong offset!");
static_assert(offsetof(AAppCharFootstepsTriggerVolume, MTimeNight_) == 0x00027A, "Member 'AAppCharFootstepsTriggerVolume::MTimeNight_' has a wrong offset!");
static_assert(offsetof(AAppCharFootstepsTriggerVolume, MTimeShadow_) == 0x00027B, "Member 'AAppCharFootstepsTriggerVolume::MTimeShadow_' has a wrong offset!");

// Class xrd777.AppCharFootstepsTriggerVolumeExt
// 0x0008 (0x0288 - 0x0280)
class AAppCharFootstepsTriggerVolumeExt final : public AAppCharFootstepsTriggerVolume
{
public:
	int32                                         MEnableProgressStart_;                             // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MEnableProgressEnd_;                               // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharFootstepsTriggerVolumeExt">();
	}
	static class AAppCharFootstepsTriggerVolumeExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppCharFootstepsTriggerVolumeExt>();
	}
};
static_assert(alignof(AAppCharFootstepsTriggerVolumeExt) == 0x000008, "Wrong alignment on AAppCharFootstepsTriggerVolumeExt");
static_assert(sizeof(AAppCharFootstepsTriggerVolumeExt) == 0x000288, "Wrong size on AAppCharFootstepsTriggerVolumeExt");
static_assert(offsetof(AAppCharFootstepsTriggerVolumeExt, MEnableProgressStart_) == 0x000280, "Member 'AAppCharFootstepsTriggerVolumeExt::MEnableProgressStart_' has a wrong offset!");
static_assert(offsetof(AAppCharFootstepsTriggerVolumeExt, MEnableProgressEnd_) == 0x000284, "Member 'AAppCharFootstepsTriggerVolumeExt::MEnableProgressEnd_' has a wrong offset!");

// Class xrd777.UICmpCommu
// 0x01D8 (0x0478 - 0x02A0)
class AUICmpCommu final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x168];                                    // 0x02A0(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISceneFSM*                            SceneFSM_;                                         // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpCommuList*                          CommuListScene_;                                   // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpCommuDetails*                       CommuDetailsScene_;                                // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x38];                                     // 0x0420(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpCommu*                              PParent;                                           // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpCommuModelController*               PModelController;                                  // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpCommu">();
	}
	static class AUICmpCommu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmpCommu>();
	}
};
static_assert(alignof(AUICmpCommu) == 0x000008, "Wrong alignment on AUICmpCommu");
static_assert(sizeof(AUICmpCommu) == 0x000478, "Wrong size on AUICmpCommu");
static_assert(offsetof(AUICmpCommu, SceneFSM_) == 0x000408, "Member 'AUICmpCommu::SceneFSM_' has a wrong offset!");
static_assert(offsetof(AUICmpCommu, CommuListScene_) == 0x000410, "Member 'AUICmpCommu::CommuListScene_' has a wrong offset!");
static_assert(offsetof(AUICmpCommu, CommuDetailsScene_) == 0x000418, "Member 'AUICmpCommu::CommuDetailsScene_' has a wrong offset!");
static_assert(offsetof(AUICmpCommu, PMainActor) == 0x000458, "Member 'AUICmpCommu::PMainActor' has a wrong offset!");
static_assert(offsetof(AUICmpCommu, PParent) == 0x000460, "Member 'AUICmpCommu::PParent' has a wrong offset!");
static_assert(offsetof(AUICmpCommu, PModelController) == 0x000468, "Member 'AUICmpCommu::PModelController' has a wrong offset!");

// Class xrd777.UIVoiceBase
// 0x0010 (0x02B0 - 0x02A0)
class AUIVoiceBase : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceBase">();
	}
	static class AUIVoiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceBase>();
	}
};
static_assert(alignof(AUIVoiceBase) == 0x000008, "Wrong alignment on AUIVoiceBase");
static_assert(sizeof(AUIVoiceBase) == 0x0002B0, "Wrong size on AUIVoiceBase");

// Class xrd777.UIVoiceAction
// 0x01E0 (0x0490 - 0x02B0)
class AUIVoiceAction final : public AUIVoiceBase
{
public:
	uint8                                         Pad_2B0[0x138];                                    // 0x02B0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUIVoiceActionDraw>         VoiceActionDrawSubClass;                           // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIVoiceActionDraw*                     PVoiceActionDrawActor;                             // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x0400(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader_;                                           // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x80];                                     // 0x0410(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceAction">();
	}
	static class AUIVoiceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceAction>();
	}
};
static_assert(alignof(AUIVoiceAction) == 0x000008, "Wrong alignment on AUIVoiceAction");
static_assert(sizeof(AUIVoiceAction) == 0x000490, "Wrong size on AUIVoiceAction");
static_assert(offsetof(AUIVoiceAction, VoiceActionDrawSubClass) == 0x0003E8, "Member 'AUIVoiceAction::VoiceActionDrawSubClass' has a wrong offset!");
static_assert(offsetof(AUIVoiceAction, PVoiceActionDrawActor) == 0x0003F0, "Member 'AUIVoiceAction::PVoiceActionDrawActor' has a wrong offset!");
static_assert(offsetof(AUIVoiceAction, LayoutDataTable) == 0x0003F8, "Member 'AUIVoiceAction::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIVoiceAction, PParamLayoutData) == 0x000400, "Member 'AUIVoiceAction::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAction, Loader_) == 0x000408, "Member 'AUIVoiceAction::Loader_' has a wrong offset!");

// Class xrd777.FadePgBattleResult
// 0x00D0 (0x0110 - 0x0040)
class UFadePgBattleResult : public UFadeProgramBase
{
public:
	struct FPgBtlResultWipe                       M_PgBtlResultWipe;                                 // 0x0040(0x00D0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgBattleResult">();
	}
	static class UFadePgBattleResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgBattleResult>();
	}
};
static_assert(alignof(UFadePgBattleResult) == 0x000008, "Wrong alignment on UFadePgBattleResult");
static_assert(sizeof(UFadePgBattleResult) == 0x000110, "Wrong size on UFadePgBattleResult");
static_assert(offsetof(UFadePgBattleResult, M_PgBtlResultWipe) == 0x000040, "Member 'UFadePgBattleResult::M_PgBtlResultWipe' has a wrong offset!");

// Class xrd777.AppCharLib
// 0x0000 (0x0028 - 0x0028)
class UAppCharLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMaterialInterface*> GetMaterial(const class AActor* Target);
	static class FString GetMaterialSlotName(class USkeletalMeshComponent* Target, int32 ID);
	static bool IsDungeonChara(class AActor* Target);
	static bool IsUniqueNpc(const int32 ID);
	static void SetOpacity(const class AActor* Target, const float Value);
	static void SetOpacityNiagaraOnly(const class AActor* Target, const float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharLib">();
	}
	static class UAppCharLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharLib>();
	}
};
static_assert(alignof(UAppCharLib) == 0x000008, "Wrong alignment on UAppCharLib");
static_assert(sizeof(UAppCharLib) == 0x000028, "Wrong size on UAppCharLib");

// Class xrd777.AppCharLoader
// 0x0068 (0x0090 - 0x0028)
class UAppCharLoader final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        Assets;                                            // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharLoader">();
	}
	static class UAppCharLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharLoader>();
	}
};
static_assert(alignof(UAppCharLoader) == 0x000008, "Wrong alignment on UAppCharLoader");
static_assert(sizeof(UAppCharLoader) == 0x000090, "Wrong size on UAppCharLoader");
static_assert(offsetof(UAppCharLoader, Assets) == 0x000078, "Member 'UAppCharLoader::Assets' has a wrong offset!");

// Class xrd777.UICmmRankUPAnimManager
// 0x0208 (0x0480 - 0x0278)
class AUICmmRankUPAnimManager final : public AAppActor
{
public:
	float                                         RippleTime;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RippleInitScale;                                   // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardNumFront;                                      // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardNumBack;                                       // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardScaleFront;                                    // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardScaleBack;                                     // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBGFadeIn;                                      // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBGFadeOut;                                     // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStarMainInAnime;                               // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameStartInAnimeInterval;                         // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWaitStarExpansion;                             // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWaitStarVanish;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWaitStarWait;                                  // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStartWaitAnimeInterval;                        // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameCardFadeOut;                                  // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorNormalBG3Up;                                  // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorNormalBG3Middle;                              // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorNormalBG3Down;                                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorNormalBG4;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorReverseBG3Up;                                 // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorReverseBG3Middle;                             // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorReverseBG3Down;                               // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorReverseBG4;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeMaxFadeIn;                                     // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeMaxWaitAfter;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RippleBlur;                                        // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RippleWidth;                                       // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RationGradationUI;                                 // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RationPosToOutGradationUI;                         // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RationReverseBG;                                   // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeRationReverseColorGradation;                 // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotRationGradationReverse;                         // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRationBG12;                                   // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRationBackCards;                              // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRatioBackBGCard;                               // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRatioFrontBGCard;                              // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeRationReverseColorBackCards;                 // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAllBGCard;                                 // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotRatioArcanaCard;                                // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRatioArcanaCard;                              // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisibleArcanaCardShadow;                         // 0x0334(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisibleStars;                                    // 0x0335(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateAllStars;                                    // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaAllStars;                                     // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveXRankUpTitle;                                  // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRankUpTitle;                                  // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatioLetter;                                       // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRankupStrings;                                // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRationRankupStrings;                           // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRankupMaxStrings;                             // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRankupMaxStrings;                              // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeReverseSprCommuName;                       // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveXReverseString;                                // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaReverseString;                                // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaKeyhelp;                                      // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleKeyhelp;                                      // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveAllKeyHelp;                                    // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMaskKeyHelp;                                   // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartKeyHelpIn;                                  // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartKeyHelpOut;                                 // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimationContentGameOver;                          // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaEFGameOver;                                   // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRationGameOver;                               // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaveSpeedGameOver;                                // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleWidthGameOver;                                // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleHightGameOver;                                // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeGameOver;                                      // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaNormalGameOver;                               // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveYGameOver;                                     // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRipple1;                                      // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRipple1;                                      // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRipple2;                                      // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRipple2;                                      // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaRipple3;                                      // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRipple3;                                      // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndFinalRipple;                                  // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlphaCardEffect;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             StartPoemBG1In;                                    // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartStartFrameAnime;                              // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartStartMainAnime;                               // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartStartWaitAnime;                               // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartShowStartReverse;                             // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartCardAnimePoemOut;                             // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartCardAnimeReverse;                             // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartCardAnimeRecoveryIn;                          // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartCardAnimeRecoveryTurn;                        // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartCardAnimeRecoveryOut;                         // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StartRippleGameOver;                               // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void EndCardEffect();
	void PauseGameover();
	void PlaySE(EUICmmRankUpSE SEType);
	void RestartGameover();
	void SetEndGameoverOneLine(bool Flag);
	void SetEndRecoveryAnime(bool Flag);
	void SetEndReverseInAnime(bool Flag);
	void SetEndReverseOutAnime(bool Flag);
	void SetEndReverseRankInAnime(bool Flag);
	void SetEndUIInAnime(bool Flag);
	void SetEndUIOutAnime(bool Flag);
	void SetPlayBGCardOutAnime(bool Flag);
	void SetPlayStarInAnime(bool Flag);
	void SetShowKeyHelp(bool Flag);
	void SkipContentAnime();
	void StartCardEffect();
	void StartCardInAnime();
	void StartGameOverAllAnime();
	void StartGameOverOneContentAnime();
	void StartKeyHelpInAnime();
	void StartKeyHelpOutAnime();
	void StartKeyHelpWaitAnime();
	void StartRankUpInAnime();
	void StartRankUpOutAnime();
	void StartRecoveryAnime();
	void StartReverseInAnime();
	void StartReverseOutAnime();
	void StartReverseRankInAnime();
	void StartRipple1GameOverAnime();
	void StartRipple2GameOverAnime();
	void StartRipple3GameOverAnime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmmRankUPAnimManager">();
	}
	static class AUICmmRankUPAnimManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmmRankUPAnimManager>();
	}
};
static_assert(alignof(AUICmmRankUPAnimManager) == 0x000008, "Wrong alignment on AUICmmRankUPAnimManager");
static_assert(sizeof(AUICmmRankUPAnimManager) == 0x000480, "Wrong size on AUICmmRankUPAnimManager");
static_assert(offsetof(AUICmmRankUPAnimManager, RippleTime) == 0x000278, "Member 'AUICmmRankUPAnimManager::RippleTime' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RippleInitScale) == 0x00027C, "Member 'AUICmmRankUPAnimManager::RippleInitScale' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, CardNumFront) == 0x000280, "Member 'AUICmmRankUPAnimManager::CardNumFront' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, CardNumBack) == 0x000284, "Member 'AUICmmRankUPAnimManager::CardNumBack' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, CardScaleFront) == 0x000288, "Member 'AUICmmRankUPAnimManager::CardScaleFront' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, CardScaleBack) == 0x00028C, "Member 'AUICmmRankUPAnimManager::CardScaleBack' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeBGFadeIn) == 0x000290, "Member 'AUICmmRankUPAnimManager::TimeBGFadeIn' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeBGFadeOut) == 0x000294, "Member 'AUICmmRankUPAnimManager::TimeBGFadeOut' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeStarMainInAnime) == 0x000298, "Member 'AUICmmRankUPAnimManager::TimeStarMainInAnime' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, FrameStartInAnimeInterval) == 0x00029C, "Member 'AUICmmRankUPAnimManager::FrameStartInAnimeInterval' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeWaitStarExpansion) == 0x0002A0, "Member 'AUICmmRankUPAnimManager::TimeWaitStarExpansion' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeWaitStarVanish) == 0x0002A4, "Member 'AUICmmRankUPAnimManager::TimeWaitStarVanish' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeWaitStarWait) == 0x0002A8, "Member 'AUICmmRankUPAnimManager::TimeWaitStarWait' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeStartWaitAnimeInterval) == 0x0002AC, "Member 'AUICmmRankUPAnimManager::TimeStartWaitAnimeInterval' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, FrameCardFadeOut) == 0x0002B0, "Member 'AUICmmRankUPAnimManager::FrameCardFadeOut' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorNormalBG3Up) == 0x0002B4, "Member 'AUICmmRankUPAnimManager::ColorNormalBG3Up' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorNormalBG3Middle) == 0x0002B8, "Member 'AUICmmRankUPAnimManager::ColorNormalBG3Middle' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorNormalBG3Down) == 0x0002BC, "Member 'AUICmmRankUPAnimManager::ColorNormalBG3Down' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorNormalBG4) == 0x0002C0, "Member 'AUICmmRankUPAnimManager::ColorNormalBG4' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorReverseBG3Up) == 0x0002C4, "Member 'AUICmmRankUPAnimManager::ColorReverseBG3Up' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorReverseBG3Middle) == 0x0002C8, "Member 'AUICmmRankUPAnimManager::ColorReverseBG3Middle' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorReverseBG3Down) == 0x0002CC, "Member 'AUICmmRankUPAnimManager::ColorReverseBG3Down' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ColorReverseBG4) == 0x0002D0, "Member 'AUICmmRankUPAnimManager::ColorReverseBG4' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeMaxFadeIn) == 0x0002D4, "Member 'AUICmmRankUPAnimManager::TimeMaxFadeIn' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeMaxWaitAfter) == 0x0002D8, "Member 'AUICmmRankUPAnimManager::TimeMaxWaitAfter' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RippleBlur) == 0x0002E0, "Member 'AUICmmRankUPAnimManager::RippleBlur' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RippleWidth) == 0x0002F0, "Member 'AUICmmRankUPAnimManager::RippleWidth' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RationGradationUI) == 0x000300, "Member 'AUICmmRankUPAnimManager::RationGradationUI' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RationPosToOutGradationUI) == 0x000304, "Member 'AUICmmRankUPAnimManager::RationPosToOutGradationUI' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RationReverseBG) == 0x000308, "Member 'AUICmmRankUPAnimManager::RationReverseBG' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ChangeRationReverseColorGradation) == 0x00030C, "Member 'AUICmmRankUPAnimManager::ChangeRationReverseColorGradation' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RotRationGradationReverse) == 0x000310, "Member 'AUICmmRankUPAnimManager::RotRationGradationReverse' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRationBG12) == 0x000314, "Member 'AUICmmRankUPAnimManager::AlphaRationBG12' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, SpeedRationBackCards) == 0x000318, "Member 'AUICmmRankUPAnimManager::SpeedRationBackCards' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveRatioBackBGCard) == 0x00031C, "Member 'AUICmmRankUPAnimManager::MoveRatioBackBGCard' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveRatioFrontBGCard) == 0x000320, "Member 'AUICmmRankUPAnimManager::MoveRatioFrontBGCard' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ChangeRationReverseColorBackCards) == 0x000324, "Member 'AUICmmRankUPAnimManager::ChangeRationReverseColorBackCards' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RotationAllBGCard) == 0x000328, "Member 'AUICmmRankUPAnimManager::RotationAllBGCard' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RotRatioArcanaCard) == 0x00032C, "Member 'AUICmmRankUPAnimManager::RotRatioArcanaCard' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRatioArcanaCard) == 0x000330, "Member 'AUICmmRankUPAnimManager::AlphaRatioArcanaCard' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsVisibleArcanaCardShadow) == 0x000334, "Member 'AUICmmRankUPAnimManager::IsVisibleArcanaCardShadow' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsVisibleStars) == 0x000335, "Member 'AUICmmRankUPAnimManager::IsVisibleStars' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RotateAllStars) == 0x000338, "Member 'AUICmmRankUPAnimManager::RotateAllStars' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaAllStars) == 0x00033C, "Member 'AUICmmRankUPAnimManager::AlphaAllStars' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveXRankUpTitle) == 0x000340, "Member 'AUICmmRankUPAnimManager::MoveXRankUpTitle' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRankUpTitle) == 0x000344, "Member 'AUICmmRankUPAnimManager::AlphaRankUpTitle' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, RatioLetter) == 0x000348, "Member 'AUICmmRankUPAnimManager::RatioLetter' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRankupStrings) == 0x00034C, "Member 'AUICmmRankUPAnimManager::AlphaRankupStrings' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveRationRankupStrings) == 0x000350, "Member 'AUICmmRankUPAnimManager::MoveRationRankupStrings' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRankupMaxStrings) == 0x000354, "Member 'AUICmmRankUPAnimManager::AlphaRankupMaxStrings' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveRankupMaxStrings) == 0x000358, "Member 'AUICmmRankUPAnimManager::MoveRankupMaxStrings' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsChangeReverseSprCommuName) == 0x00035C, "Member 'AUICmmRankUPAnimManager::IsChangeReverseSprCommuName' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveXReverseString) == 0x000360, "Member 'AUICmmRankUPAnimManager::MoveXReverseString' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaReverseString) == 0x000364, "Member 'AUICmmRankUPAnimManager::AlphaReverseString' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaKeyhelp) == 0x000368, "Member 'AUICmmRankUPAnimManager::AlphaKeyhelp' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleKeyhelp) == 0x00036C, "Member 'AUICmmRankUPAnimManager::ScaleKeyhelp' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveAllKeyHelp) == 0x000370, "Member 'AUICmmRankUPAnimManager::MoveAllKeyHelp' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveMaskKeyHelp) == 0x000374, "Member 'AUICmmRankUPAnimManager::MoveMaskKeyHelp' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsStartKeyHelpIn) == 0x000378, "Member 'AUICmmRankUPAnimManager::IsStartKeyHelpIn' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsStartKeyHelpOut) == 0x000379, "Member 'AUICmmRankUPAnimManager::IsStartKeyHelpOut' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AnimationContentGameOver) == 0x00037C, "Member 'AUICmmRankUPAnimManager::AnimationContentGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaEFGameOver) == 0x000380, "Member 'AUICmmRankUPAnimManager::AlphaEFGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleRationGameOver) == 0x000384, "Member 'AUICmmRankUPAnimManager::ScaleRationGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, WeaveSpeedGameOver) == 0x000388, "Member 'AUICmmRankUPAnimManager::WeaveSpeedGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleWidthGameOver) == 0x00038C, "Member 'AUICmmRankUPAnimManager::ScaleWidthGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleHightGameOver) == 0x000390, "Member 'AUICmmRankUPAnimManager::ScaleHightGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, TimeGameOver) == 0x000394, "Member 'AUICmmRankUPAnimManager::TimeGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaNormalGameOver) == 0x000398, "Member 'AUICmmRankUPAnimManager::AlphaNormalGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, MoveYGameOver) == 0x00039C, "Member 'AUICmmRankUPAnimManager::MoveYGameOver' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRipple1) == 0x0003A0, "Member 'AUICmmRankUPAnimManager::AlphaRipple1' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleRipple1) == 0x0003A4, "Member 'AUICmmRankUPAnimManager::ScaleRipple1' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRipple2) == 0x0003A8, "Member 'AUICmmRankUPAnimManager::AlphaRipple2' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleRipple2) == 0x0003AC, "Member 'AUICmmRankUPAnimManager::ScaleRipple2' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaRipple3) == 0x0003B0, "Member 'AUICmmRankUPAnimManager::AlphaRipple3' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, ScaleRipple3) == 0x0003B4, "Member 'AUICmmRankUPAnimManager::ScaleRipple3' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, IsEndFinalRipple) == 0x0003B8, "Member 'AUICmmRankUPAnimManager::IsEndFinalRipple' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, AlphaCardEffect) == 0x0003BC, "Member 'AUICmmRankUPAnimManager::AlphaCardEffect' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartPoemBG1In) == 0x0003D0, "Member 'AUICmmRankUPAnimManager::StartPoemBG1In' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartStartFrameAnime) == 0x0003E0, "Member 'AUICmmRankUPAnimManager::StartStartFrameAnime' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartStartMainAnime) == 0x0003F0, "Member 'AUICmmRankUPAnimManager::StartStartMainAnime' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartStartWaitAnime) == 0x000400, "Member 'AUICmmRankUPAnimManager::StartStartWaitAnime' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartShowStartReverse) == 0x000410, "Member 'AUICmmRankUPAnimManager::StartShowStartReverse' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartCardAnimePoemOut) == 0x000420, "Member 'AUICmmRankUPAnimManager::StartCardAnimePoemOut' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartCardAnimeReverse) == 0x000430, "Member 'AUICmmRankUPAnimManager::StartCardAnimeReverse' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartCardAnimeRecoveryIn) == 0x000440, "Member 'AUICmmRankUPAnimManager::StartCardAnimeRecoveryIn' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartCardAnimeRecoveryTurn) == 0x000450, "Member 'AUICmmRankUPAnimManager::StartCardAnimeRecoveryTurn' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartCardAnimeRecoveryOut) == 0x000460, "Member 'AUICmmRankUPAnimManager::StartCardAnimeRecoveryOut' has a wrong offset!");
static_assert(offsetof(AUICmmRankUPAnimManager, StartRippleGameOver) == 0x000470, "Member 'AUICmmRankUPAnimManager::StartRippleGameOver' has a wrong offset!");

// Class xrd777.AppCharTransparencyArea
// 0x0020 (0x0240 - 0x0220)
class AAppCharTransparencyArea : public AActor
{
public:
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobDistance;                                       // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LargeDistance;                                     // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharTransparencyArea">();
	}
	static class AAppCharTransparencyArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppCharTransparencyArea>();
	}
};
static_assert(alignof(AAppCharTransparencyArea) == 0x000008, "Wrong alignment on AAppCharTransparencyArea");
static_assert(sizeof(AAppCharTransparencyArea) == 0x000240, "Wrong size on AAppCharTransparencyArea");
static_assert(offsetof(AAppCharTransparencyArea, CapsuleComp) == 0x000220, "Member 'AAppCharTransparencyArea::CapsuleComp' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, Opacity) == 0x000228, "Member 'AAppCharTransparencyArea::Opacity' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, Speed) == 0x00022C, "Member 'AAppCharTransparencyArea::Speed' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, Distance) == 0x000230, "Member 'AAppCharTransparencyArea::Distance' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, MobDistance) == 0x000234, "Member 'AAppCharTransparencyArea::MobDistance' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, LargeDistance) == 0x000238, "Member 'AAppCharTransparencyArea::LargeDistance' has a wrong offset!");
static_assert(offsetof(AAppCharTransparencyArea, Priority) == 0x00023C, "Member 'AAppCharTransparencyArea::Priority' has a wrong offset!");

// Class xrd777.FldCrowdNpcBase
// 0x0028 (0x02A0 - 0x0278)
class AFldCrowdNpcBase final : public AAppActor
{
public:
	class UCapsuleComponent*                      CapsuleComp_;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MDispValue_;                                       // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldCrowdNpcChildParam>         MChildParam_;                                      // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static float UpdateOpacityByPlayerActor(float Opacity, class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdNpcBase">();
	}
	static class AFldCrowdNpcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCrowdNpcBase>();
	}
};
static_assert(alignof(AFldCrowdNpcBase) == 0x000008, "Wrong alignment on AFldCrowdNpcBase");
static_assert(sizeof(AFldCrowdNpcBase) == 0x0002A0, "Wrong size on AFldCrowdNpcBase");
static_assert(offsetof(AFldCrowdNpcBase, CapsuleComp_) == 0x000278, "Member 'AFldCrowdNpcBase::CapsuleComp_' has a wrong offset!");
static_assert(offsetof(AFldCrowdNpcBase, MDispValue_) == 0x000280, "Member 'AFldCrowdNpcBase::MDispValue_' has a wrong offset!");
static_assert(offsetof(AFldCrowdNpcBase, MOffFlagName_) == 0x000284, "Member 'AFldCrowdNpcBase::MOffFlagName_' has a wrong offset!");
static_assert(offsetof(AFldCrowdNpcBase, MChildParam_) == 0x000290, "Member 'AFldCrowdNpcBase::MChildParam_' has a wrong offset!");

// Class xrd777.UIMiscCinemaScopeDraw
// 0x0110 (0x03B0 - 0x02A0)
class AUIMiscCinemaScopeDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pSpr_Cinema;                                     // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlg_Cinema;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0xD8];                                     // 0x02D0(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscCinemaScopeDraw">();
	}
	static class AUIMiscCinemaScopeDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscCinemaScopeDraw>();
	}
};
static_assert(alignof(AUIMiscCinemaScopeDraw) == 0x000008, "Wrong alignment on AUIMiscCinemaScopeDraw");
static_assert(sizeof(AUIMiscCinemaScopeDraw) == 0x0003B0, "Wrong size on AUIMiscCinemaScopeDraw");
static_assert(offsetof(AUIMiscCinemaScopeDraw, M_pSpr_Cinema) == 0x0002C0, "Member 'AUIMiscCinemaScopeDraw::M_pSpr_Cinema' has a wrong offset!");
static_assert(offsetof(AUIMiscCinemaScopeDraw, M_pPlg_Cinema) == 0x0002C8, "Member 'AUIMiscCinemaScopeDraw::M_pPlg_Cinema' has a wrong offset!");
static_assert(offsetof(AUIMiscCinemaScopeDraw, Loader_) == 0x0003A8, "Member 'AUIMiscCinemaScopeDraw::Loader_' has a wrong offset!");

// Class xrd777.AppCharWeaponAnimDataAsset
// 0x0058 (0x0088 - 0x0030)
class UAppCharWeaponAnimDataAsset final : public UDataAsset
{
public:
	int32                                         WaitAnimNo;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UAnimSequenceBase*>         Anims;                                             // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharWeaponAnimDataAsset">();
	}
	static class UAppCharWeaponAnimDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCharWeaponAnimDataAsset>();
	}
};
static_assert(alignof(UAppCharWeaponAnimDataAsset) == 0x000008, "Wrong alignment on UAppCharWeaponAnimDataAsset");
static_assert(sizeof(UAppCharWeaponAnimDataAsset) == 0x000088, "Wrong size on UAppCharWeaponAnimDataAsset");
static_assert(offsetof(UAppCharWeaponAnimDataAsset, WaitAnimNo) == 0x000030, "Member 'UAppCharWeaponAnimDataAsset::WaitAnimNo' has a wrong offset!");
static_assert(offsetof(UAppCharWeaponAnimDataAsset, Anims) == 0x000038, "Member 'UAppCharWeaponAnimDataAsset::Anims' has a wrong offset!");

// Class xrd777.FldCharParamTable
// 0x0120 (0x0148 - 0x0028)
class UFldCharParamTable final : public UObject
{
public:
	TSoftObjectPtr<class UFldCharDataAsset>       Path;                                              // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldCharDataAsset*                      Data;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoaded;                                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0xEF];                                      // 0x0059(0x00EF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharParamTable">();
	}
	static class UFldCharParamTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharParamTable>();
	}
};
static_assert(alignof(UFldCharParamTable) == 0x000008, "Wrong alignment on UFldCharParamTable");
static_assert(sizeof(UFldCharParamTable) == 0x000148, "Wrong size on UFldCharParamTable");
static_assert(offsetof(UFldCharParamTable, Path) == 0x000028, "Member 'UFldCharParamTable::Path' has a wrong offset!");
static_assert(offsetof(UFldCharParamTable, Data) == 0x000050, "Member 'UFldCharParamTable::Data' has a wrong offset!");
static_assert(offsetof(UFldCharParamTable, bLoaded) == 0x000058, "Member 'UFldCharParamTable::bLoaded' has a wrong offset!");

// Class xrd777.AppCharWeaponBase
// 0x01D0 (0x0448 - 0x0278)
class AAppCharWeaponBase final : public AAppActor
{
public:
	int32                                         PlayerId;                                          // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAppCharWeaponTableRow                 WeaponTbl;                                         // 0x0290(0x0090)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   AttachSocketName;                                  // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HideMaterialID;                                    // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharWeaponAnimDataAsset*            AnimPack;                                          // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x110];                                    // 0x0338(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Event_LoadEnd();
	void PlayAnim(int32 AnimNo, bool Loop, float BlendInTime, float BlendOutTime, float InPlayRate);
	void PlayAnimSequence(class UAnimSequenceBase* PSequence, bool Loop, float BlendInTime, float BlendOutTime, float InPlayRate);

	int32 GetWaitAnimNo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCharWeaponBase">();
	}
	static class AAppCharWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppCharWeaponBase>();
	}
};
static_assert(alignof(AAppCharWeaponBase) == 0x000008, "Wrong alignment on AAppCharWeaponBase");
static_assert(sizeof(AAppCharWeaponBase) == 0x000448, "Wrong size on AAppCharWeaponBase");
static_assert(offsetof(AAppCharWeaponBase, PlayerId) == 0x000278, "Member 'AAppCharWeaponBase::PlayerId' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, Root) == 0x000280, "Member 'AAppCharWeaponBase::Root' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, Mesh) == 0x000288, "Member 'AAppCharWeaponBase::Mesh' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, WeaponTbl) == 0x000290, "Member 'AAppCharWeaponBase::WeaponTbl' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, AttachSocketName) == 0x000320, "Member 'AAppCharWeaponBase::AttachSocketName' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, HideMaterialID) == 0x000328, "Member 'AAppCharWeaponBase::HideMaterialID' has a wrong offset!");
static_assert(offsetof(AAppCharWeaponBase, AnimPack) == 0x000330, "Member 'AAppCharWeaponBase::AnimPack' has a wrong offset!");

// Class xrd777.AppCheatManager
// 0x0000 (0x0088 - 0x0088)
class UAppCheatManager final : public UCheatManager
{
public:
	void AtlAllDLCActiveFlagOff();
	void AtlAllDLCActiveFlagOn();
	void AtlAutoPlay(const class FString& OPTION);
	void AtlAutoPlayExecDungeonPassingTest(int32 BeginFloor, int32 EndFloor, bool bLoop, bool bRebuild, bool bAstrea);
	void AtlAutoPlayExecDungeonTBoxTest(int32 BeginFloor, int32 EndFloor, bool bLoop, bool bAstrea);
	void AtlAutoPlayExecEnemyAILoggingTest(int32 MinEncountID, int32 MaxEncountID);
	void AtlAutoPlayExecEnemyDropItemLoggingTest(int32 MinEncountID, int32 MaxEncountID);
	void AtlAutoPlayExecShuffleTimeTest();
	void AtlAutoPlayExecSkillMutationPowerUpTest(int32 StartIndex, int32 MaxTryCount);
	void AtlAutoPlayExecSkillMutationPowerUpUnitTest(int32 OldSkillID, int32 NewSkillID);
	void AtlAutoPlayExecSkillMutationTest(int32 SkillPackIndex, int32 MaxTryCount);
	void AtlBgmRestart();
	void AtlBgmStop();
	void AtlBtlCountdownPlay();
	void AtlBtlCountdownSetTime(int32 InSecond);
	void AtlBtlCountdownStop();
	void AtlBtlFadeManagerOldProcessEnable(bool bEnable);
	void AtlCallAlphaDebugMenu();
	void AtlCallAstreaProgress();
	void AtlCallDebugStartMenu();
	void AtlCallEvent(int32 EventMajorID, int32 EventMinorID);
	void AtlCallEventCmmu(int32 EventMaojorID, int32 EventMinorID);
	void AtlCallEventFild(int32 EventMaojorID, int32 EventMinorID);
	void AtlCallNextTime();
	void AtlDevPlayLogging(bool bEnable);
	void AtlDispAstreaProgress();
	void AtlDispCharacterPoolListToOutputLog();
	void AtlDispIsAvailableAstrea();
	void AtlDispIsPlayingAstrea();
	void AtlDispIsUsingAstreaSavedata();
	void AtlDispLoadedStreamingLevels();
	void AtlDrawPlayLog(bool bVisible);
	void AtlEventForceFinish();
	void AtlFieldCameraShakeEnd(float InTime);
	void AtlFieldCameraShakeStart(float InFrequency, float InPowerX, float InPowerY, float InTime);
	void AtlFieldChangeVisible();
	void AtlFieldPauseActorALL(bool bPaused);
	void AtlFieldPlayerPos(float X, float Y, float Z);
	void AtlFldDispCriAtomExDebugResourcesInfo();
	void AtlForceFadeIN();
	void AtlForceFadeOUT();
	void AtlForceUnpause();
	void AtlGetDayTime();
	void AtlGraphicConfigBenchmark();
	void AtlGraphicConfigFPS(int32 MaxFPS);
	void AtlGraphicConfigHardwareStat();
	void AtlGraphicConfigPreset(int32 Preset);
	void AtlGraphicConfigScreen(int32 ResX, int32 ResY, int32 ScreenMode, int32 DisplayNo);
	void AtlGraphicConfigScreenMode(int32 ScreenMode, int32 DisplayNo);
	void AtlGraphicConfigShadowQuality(int32 Quality);
	void AtlLogWorldTimeSec();
	void AtlMessageScaleNewProcessEnable(bool bEnable);
	void AtlPlanarReflectionPercentage(int32 Percent);
	void AtlRayTraceEnable(int32 Raytrace, int32 PlanarReflection);
	void AtlRushEffectRate(float Rate);
	void AtlSaveDataAccessorMask(const class FString& Mask);
	void AtlSaveDataConvert(const class FString& Mode, const class FString& SaveDataID, int32 SlotIndex);
	void AtlSetCameraTransform(float PosX, float PosY, float PosZ, float RotX, float RotY, float RotZ);
	void AtlSetDayTime(int32 Month, int32 Day, int32 Time);
	void AtlSetNextDayTime(int32 Month, int32 Day, int32 Time);
	void AtlSetWorldTimeSec(float Sec);
	void AtlSoundConfigDevice(int32 Index_0);
	void AtlSoundConfigInfo();
	void AtlStartNextProgressAstrea();
	void AtlUObjectLeakChecker(bool bEnable);
	void AtlWindowPosSaveEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCheatManager">();
	}
	static class UAppCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCheatManager>();
	}
};
static_assert(alignof(UAppCheatManager) == 0x000008, "Wrong alignment on UAppCheatManager");
static_assert(sizeof(UAppCheatManager) == 0x000088, "Wrong size on UAppCheatManager");

// Class xrd777.AppChunkInstall
// 0x0008 (0x0038 - 0x0030)
class UAppChunkInstall final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppChunkInstall">();
	}
	static class UAppChunkInstall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppChunkInstall>();
	}
};
static_assert(alignof(UAppChunkInstall) == 0x000008, "Wrong alignment on UAppChunkInstall");
static_assert(sizeof(UAppChunkInstall) == 0x000038, "Wrong size on UAppChunkInstall");

// Class xrd777.UICompleteBookRegist
// 0x0100 (0x0128 - 0x0028)
class UUICompleteBookRegist final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIVelvetRoomOwner*                     M_pOwner;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           M_pLoader;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0xD0];                                      // 0x0058(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICompleteBookRegist">();
	}
	static class UUICompleteBookRegist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICompleteBookRegist>();
	}
};
static_assert(alignof(UUICompleteBookRegist) == 0x000008, "Wrong alignment on UUICompleteBookRegist");
static_assert(sizeof(UUICompleteBookRegist) == 0x000128, "Wrong size on UUICompleteBookRegist");
static_assert(offsetof(UUICompleteBookRegist, M_pOwner) == 0x000040, "Member 'UUICompleteBookRegist::M_pOwner' has a wrong offset!");
static_assert(offsetof(UUICompleteBookRegist, M_pLoader) == 0x000048, "Member 'UUICompleteBookRegist::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUICompleteBookRegist, M_pSpr) == 0x000050, "Member 'UUICompleteBookRegist::M_pSpr' has a wrong offset!");

// Class xrd777.UIPartyPanel
// 0x0040 (0x02E0 - 0x02A0)
class AUIPartyPanel final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pPartyPanelSpr;                                  // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pPartyPanelSprAstrea;                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyPanel">();
	}
	static class AUIPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPartyPanel>();
	}
};
static_assert(alignof(AUIPartyPanel) == 0x000008, "Wrong alignment on AUIPartyPanel");
static_assert(sizeof(AUIPartyPanel) == 0x0002E0, "Wrong size on AUIPartyPanel");
static_assert(offsetof(AUIPartyPanel, M_pPartyPanelSpr) == 0x0002A8, "Member 'AUIPartyPanel::M_pPartyPanelSpr' has a wrong offset!");
static_assert(offsetof(AUIPartyPanel, M_pPartyPanelSprAstrea) == 0x0002B0, "Member 'AUIPartyPanel::M_pPartyPanelSprAstrea' has a wrong offset!");

// Class xrd777.FadePgSlideVerticalInverse
// 0x0010 (0x0050 - 0x0040)
class UFadePgSlideVerticalInverse final : public UFadeProgramBase
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgSlideVerticalInverse">();
	}
	static class UFadePgSlideVerticalInverse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgSlideVerticalInverse>();
	}
};
static_assert(alignof(UFadePgSlideVerticalInverse) == 0x000008, "Wrong alignment on UFadePgSlideVerticalInverse");
static_assert(sizeof(UFadePgSlideVerticalInverse) == 0x000050, "Wrong size on UFadePgSlideVerticalInverse");

// Class xrd777.AppKoromaruComp
// 0x0000 (0x0370 - 0x0370)
class UAppKoromaruComp final : public UAppCharacterComp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppKoromaruComp">();
	}
	static class UAppKoromaruComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppKoromaruComp>();
	}
};
static_assert(alignof(UAppKoromaruComp) == 0x000010, "Wrong alignment on UAppKoromaruComp");
static_assert(sizeof(UAppKoromaruComp) == 0x000370, "Wrong size on UAppKoromaruComp");

// Class xrd777.UICmpQuest
// 0x0030 (0x02D0 - 0x02A0)
class AUICmpQuest final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISceneFSM*                            SceneFSM_;                                         // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestElizRequest*                      ElizRequestScene_;                                 // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestDisappearList*                    DisappearListScene_;                               // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpQuest">();
	}
	static class AUICmpQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmpQuest>();
	}
};
static_assert(alignof(AUICmpQuest) == 0x000008, "Wrong alignment on AUICmpQuest");
static_assert(sizeof(AUICmpQuest) == 0x0002D0, "Wrong size on AUICmpQuest");
static_assert(offsetof(AUICmpQuest, SceneFSM_) == 0x0002B0, "Member 'AUICmpQuest::SceneFSM_' has a wrong offset!");
static_assert(offsetof(AUICmpQuest, ElizRequestScene_) == 0x0002B8, "Member 'AUICmpQuest::ElizRequestScene_' has a wrong offset!");
static_assert(offsetof(AUICmpQuest, DisappearListScene_) == 0x0002C0, "Member 'AUICmpQuest::DisappearListScene_' has a wrong offset!");
static_assert(offsetof(AUICmpQuest, PMainActor) == 0x0002C8, "Member 'AUICmpQuest::PMainActor' has a wrong offset!");

// Class xrd777.AppLvMngUnloadMonitorActor
// 0x0018 (0x0238 - 0x0220)
class AAppLvMngUnloadMonitorActor final : public AActor
{
public:
	int32                                         MUniqueId_;                                        // 0x0220(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MLevelName_;                                       // 0x0224(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppLevelManager*                       MManager_;                                         // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEndExec();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppLvMngUnloadMonitorActor">();
	}
	static class AAppLvMngUnloadMonitorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppLvMngUnloadMonitorActor>();
	}
};
static_assert(alignof(AAppLvMngUnloadMonitorActor) == 0x000008, "Wrong alignment on AAppLvMngUnloadMonitorActor");
static_assert(sizeof(AAppLvMngUnloadMonitorActor) == 0x000238, "Wrong size on AAppLvMngUnloadMonitorActor");
static_assert(offsetof(AAppLvMngUnloadMonitorActor, MUniqueId_) == 0x000220, "Member 'AAppLvMngUnloadMonitorActor::MUniqueId_' has a wrong offset!");
static_assert(offsetof(AAppLvMngUnloadMonitorActor, MLevelName_) == 0x000224, "Member 'AAppLvMngUnloadMonitorActor::MLevelName_' has a wrong offset!");
static_assert(offsetof(AAppLvMngUnloadMonitorActor, MManager_) == 0x000230, "Member 'AAppLvMngUnloadMonitorActor::MManager_' has a wrong offset!");

// Class xrd777.FldDbgEmMaker
// 0x0040 (0x0260 - 0x0220)
class AFldDbgEmMaker final : public AActor
{
public:
	class UClass*                                 EmClass;                                           // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         Bg;                                                // 0x0228(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Loaded;                                            // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          IsLoadEnded;                                       // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldEnemyHolder>                Enemy;                                             // 0x0250(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetScale(class AActor* Target, float Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDbgEmMaker">();
	}
	static class AFldDbgEmMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDbgEmMaker>();
	}
};
static_assert(alignof(AFldDbgEmMaker) == 0x000008, "Wrong alignment on AFldDbgEmMaker");
static_assert(sizeof(AFldDbgEmMaker) == 0x000260, "Wrong size on AFldDbgEmMaker");
static_assert(offsetof(AFldDbgEmMaker, EmClass) == 0x000220, "Member 'AFldDbgEmMaker::EmClass' has a wrong offset!");
static_assert(offsetof(AFldDbgEmMaker, Bg) == 0x000228, "Member 'AFldDbgEmMaker::Bg' has a wrong offset!");
static_assert(offsetof(AFldDbgEmMaker, Loaded) == 0x000238, "Member 'AFldDbgEmMaker::Loaded' has a wrong offset!");
static_assert(offsetof(AFldDbgEmMaker, IsLoadEnded) == 0x000248, "Member 'AFldDbgEmMaker::IsLoadEnded' has a wrong offset!");
static_assert(offsetof(AFldDbgEmMaker, Enemy) == 0x000250, "Member 'AFldDbgEmMaker::Enemy' has a wrong offset!");

// Class xrd777.UIVoiceConnect
// 0x0018 (0x02C8 - 0x02B0)
class AUIVoiceConnect final : public AUIVoiceBase
{
public:
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceConnect">();
	}
	static class AUIVoiceConnect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceConnect>();
	}
};
static_assert(alignof(AUIVoiceConnect) == 0x000008, "Wrong alignment on AUIVoiceConnect");
static_assert(sizeof(AUIVoiceConnect) == 0x0002C8, "Wrong size on AUIVoiceConnect");

// Class xrd777.FadePgCrossFade
// 0x0000 (0x0040 - 0x0040)
class UFadePgCrossFade final : public UFadeProgramBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgCrossFade">();
	}
	static class UFadePgCrossFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgCrossFade>();
	}
};
static_assert(alignof(UFadePgCrossFade) == 0x000008, "Wrong alignment on UFadePgCrossFade");
static_assert(sizeof(UFadePgCrossFade) == 0x000040, "Wrong size on UFadePgCrossFade");

// Class xrd777.ApplicationWindowState
// 0x0030 (0x0250 - 0x0220)
class AApplicationWindowState final : public AActor
{
public:
	uint8                                         Pad_220[0x30];                                     // 0x0220(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFocusChangeBP(const bool IsFocus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicationWindowState">();
	}
	static class AApplicationWindowState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AApplicationWindowState>();
	}
};
static_assert(alignof(AApplicationWindowState) == 0x000008, "Wrong alignment on AApplicationWindowState");
static_assert(sizeof(AApplicationWindowState) == 0x000250, "Wrong size on AApplicationWindowState");

// Class xrd777.UICmpCalendar
// 0x00A0 (0x0340 - 0x02A0)
class AUICmpCalendar final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x58];                                     // 0x02A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpCldCursor*                          DayCursor_;                                        // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICmpCalendarDraw*                     Drawer_;                                           // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUICmpCalendar>             CalendarBPClass;                                   // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpCalendar">();
	}
	static class AUICmpCalendar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmpCalendar>();
	}
};
static_assert(alignof(AUICmpCalendar) == 0x000008, "Wrong alignment on AUICmpCalendar");
static_assert(sizeof(AUICmpCalendar) == 0x000340, "Wrong size on AUICmpCalendar");
static_assert(offsetof(AUICmpCalendar, DayCursor_) == 0x0002F8, "Member 'AUICmpCalendar::DayCursor_' has a wrong offset!");
static_assert(offsetof(AUICmpCalendar, Drawer_) == 0x000300, "Member 'AUICmpCalendar::Drawer_' has a wrong offset!");
static_assert(offsetof(AUICmpCalendar, CalendarBPClass) == 0x000310, "Member 'AUICmpCalendar::CalendarBPClass' has a wrong offset!");

// Class xrd777.AppNpcComp
// 0x0040 (0x0340 - 0x0300)
class UAppNpcComp final : public UAppCharBaseComp
{
public:
	class ANpcBaseCore*                           MBaseCore_;                                        // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x30];                                     // 0x0300(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharLoader*                         Loader;                                            // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCosTexID(int32 Index_0);
	void SetFootForBP(int32 ID);

	class ANpcBaseCore* GetBaseCore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppNpcComp">();
	}
	static class UAppNpcComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppNpcComp>();
	}
};
static_assert(alignof(UAppNpcComp) == 0x000010, "Wrong alignment on UAppNpcComp");
static_assert(sizeof(UAppNpcComp) == 0x000340, "Wrong size on UAppNpcComp");
static_assert(offsetof(UAppNpcComp, MBaseCore_) == 0x0002F8, "Member 'UAppNpcComp::MBaseCore_' has a wrong offset!");
static_assert(offsetof(UAppNpcComp, Loader) == 0x000330, "Member 'UAppNpcComp::Loader' has a wrong offset!");

// Class xrd777.CmpSystemDraw
// 0x13E0 (0x1408 - 0x0028)
class UCmpSystemDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       SubMenuMateDynamicAry;                             // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x13A0];                                    // 0x0058(0x13A0)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x13F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpSystem*                             PParent;                                           // 0x1400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSystemDraw">();
	}
	static class UCmpSystemDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSystemDraw>();
	}
};
static_assert(alignof(UCmpSystemDraw) == 0x000008, "Wrong alignment on UCmpSystemDraw");
static_assert(sizeof(UCmpSystemDraw) == 0x001408, "Wrong size on UCmpSystemDraw");
static_assert(offsetof(UCmpSystemDraw, SubMenuMateDynamicAry) == 0x000048, "Member 'UCmpSystemDraw::SubMenuMateDynamicAry' has a wrong offset!");
static_assert(offsetof(UCmpSystemDraw, PMainActor) == 0x0013F8, "Member 'UCmpSystemDraw::PMainActor' has a wrong offset!");
static_assert(offsetof(UCmpSystemDraw, PParent) == 0x001400, "Member 'UCmpSystemDraw::PParent' has a wrong offset!");

// Class xrd777.AppPauseableListener
// 0x0000 (0x0028 - 0x0028)
class IAppPauseableListener final : public IInterface
{
public:
	void AppPauseableBeginPlay();
	void AppPauseableEndPlay(const EEndPlayReason EndPlayReason);
	class AActor* AsAActor();
	class UObject* AsUObject();
	void Paused(EAppPauseType Type);
	void UnPaused(EAppPauseType Type);

	EAppPauseObjectFlag GetAppPauseFlags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPauseableListener">();
	}
	static class IAppPauseableListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAppPauseableListener>();
	}
};
static_assert(alignof(IAppPauseableListener) == 0x000008, "Wrong alignment on IAppPauseableListener");
static_assert(sizeof(IAppPauseableListener) == 0x000028, "Wrong size on IAppPauseableListener");

// Class xrd777.AppPauseList
// 0x0030 (0x0058 - 0x0028)
class UAppPauseList final : public UObject
{
public:
	TArray<TScriptInterface<class IAppPauseableListener>> List;                                              // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FPauseDebugItem>                DebugList;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           WarningObjectNames;                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPauseList">();
	}
	static class UAppPauseList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppPauseList>();
	}
};
static_assert(alignof(UAppPauseList) == 0x000008, "Wrong alignment on UAppPauseList");
static_assert(sizeof(UAppPauseList) == 0x000058, "Wrong size on UAppPauseList");
static_assert(offsetof(UAppPauseList, List) == 0x000028, "Member 'UAppPauseList::List' has a wrong offset!");
static_assert(offsetof(UAppPauseList, DebugList) == 0x000038, "Member 'UAppPauseList::DebugList' has a wrong offset!");
static_assert(offsetof(UAppPauseList, WarningObjectNames) == 0x000048, "Member 'UAppPauseList::WarningObjectNames' has a wrong offset!");

// Class xrd777.TestNishidaResourceActor
// 0x0038 (0x0258 - 0x0220)
class ATestNishidaResourceActor final : public AActor
{
public:
	class UTexture*                               _HardReferenceTexture;                             // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                _SoftReferenceTexture;                             // 0x0228(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               _texture;                                          // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Load();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestNishidaResourceActor">();
	}
	static class ATestNishidaResourceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestNishidaResourceActor>();
	}
};
static_assert(alignof(ATestNishidaResourceActor) == 0x000008, "Wrong alignment on ATestNishidaResourceActor");
static_assert(sizeof(ATestNishidaResourceActor) == 0x000258, "Wrong size on ATestNishidaResourceActor");
static_assert(offsetof(ATestNishidaResourceActor, _HardReferenceTexture) == 0x000220, "Member 'ATestNishidaResourceActor::_HardReferenceTexture' has a wrong offset!");
static_assert(offsetof(ATestNishidaResourceActor, _SoftReferenceTexture) == 0x000228, "Member 'ATestNishidaResourceActor::_SoftReferenceTexture' has a wrong offset!");
static_assert(offsetof(ATestNishidaResourceActor, _texture) == 0x000250, "Member 'ATestNishidaResourceActor::_texture' has a wrong offset!");

// Class xrd777.DatRace
// 0x0010 (0x0038 - 0x0028)
class UDatRace final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             Table;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatRace">();
	}
	static class UDatRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatRace>();
	}
};
static_assert(alignof(UDatRace) == 0x000008, "Wrong alignment on UDatRace");
static_assert(sizeof(UDatRace) == 0x000038, "Wrong size on UDatRace");
static_assert(offsetof(UDatRace, Loader) == 0x000028, "Member 'UDatRace::Loader' has a wrong offset!");
static_assert(offsetof(UDatRace, Table) == 0x000030, "Member 'UDatRace::Table' has a wrong offset!");

// Class xrd777.AppPauseManagerSubsystem
// 0x0038 (0x0068 - 0x0030)
class UAppPauseManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<EAppPauseType>                         PauseFlow;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAppPauseList*                          AppPauseables;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppPauseList*                          AppPaused[0x4];                                    // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsPause(EAppPauseType* PauseType);
	void Pause(EAppPauseType InPauseType);
	void UnPause();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPauseManagerSubsystem">();
	}
	static class UAppPauseManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppPauseManagerSubsystem>();
	}
};
static_assert(alignof(UAppPauseManagerSubsystem) == 0x000008, "Wrong alignment on UAppPauseManagerSubsystem");
static_assert(sizeof(UAppPauseManagerSubsystem) == 0x000068, "Wrong size on UAppPauseManagerSubsystem");
static_assert(offsetof(UAppPauseManagerSubsystem, PauseFlow) == 0x000030, "Member 'UAppPauseManagerSubsystem::PauseFlow' has a wrong offset!");
static_assert(offsetof(UAppPauseManagerSubsystem, AppPauseables) == 0x000040, "Member 'UAppPauseManagerSubsystem::AppPauseables' has a wrong offset!");
static_assert(offsetof(UAppPauseManagerSubsystem, AppPaused) == 0x000048, "Member 'UAppPauseManagerSubsystem::AppPaused' has a wrong offset!");

// Class xrd777.MsgItem
// 0x0088 (0x00B0 - 0x0028)
class UMsgItem : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMsgItemInfo>                   MssageList;                                        // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMsgItemInfo>                   SpeakerList;                                       // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMsgProcWindowBase*                     MpMsgProcWindow;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgItem">();
	}
	static class UMsgItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgItem>();
	}
};
static_assert(alignof(UMsgItem) == 0x000008, "Wrong alignment on UMsgItem");
static_assert(sizeof(UMsgItem) == 0x0000B0, "Wrong size on UMsgItem");
static_assert(offsetof(UMsgItem, MssageList) == 0x000068, "Member 'UMsgItem::MssageList' has a wrong offset!");
static_assert(offsetof(UMsgItem, SpeakerList) == 0x000078, "Member 'UMsgItem::SpeakerList' has a wrong offset!");
static_assert(offsetof(UMsgItem, MpMsgProcWindow) == 0x000088, "Member 'UMsgItem::MpMsgProcWindow' has a wrong offset!");

// Class xrd777.MsgTutorial
// 0x0018 (0x00C8 - 0x00B0)
class UMsgTutorial final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgTutorial">();
	}
	static class UMsgTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgTutorial>();
	}
};
static_assert(alignof(UMsgTutorial) == 0x000008, "Wrong alignment on UMsgTutorial");
static_assert(sizeof(UMsgTutorial) == 0x0000C8, "Wrong size on UMsgTutorial");

// Class xrd777.AppPropsCardInterface
// 0x0000 (0x0028 - 0x0028)
class IAppPropsCardInterface final : public IInterface
{
public:
	class UMaterialInstanceDynamic* GetBackMaterial();
	class UMaterialInstanceDynamic* GetFrontMaterial();
	void TarotCardSetup(const struct FAppPropsCardParam& Param);
	bool TarotCardSync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPropsCardInterface">();
	}
	static class IAppPropsCardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAppPropsCardInterface>();
	}
};
static_assert(alignof(IAppPropsCardInterface) == 0x000008, "Wrong alignment on IAppPropsCardInterface");
static_assert(sizeof(IAppPropsCardInterface) == 0x000028, "Wrong size on IAppPropsCardInterface");

// Class xrd777.FileNameListAssets
// 0x0010 (0x0040 - 0x0030)
class UFileNameListAssets final : public UAppDataAsset
{
public:
	TArray<struct FFileNameList>                  Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileNameListAssets">();
	}
	static class UFileNameListAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileNameListAssets>();
	}
};
static_assert(alignof(UFileNameListAssets) == 0x000008, "Wrong alignment on UFileNameListAssets");
static_assert(sizeof(UFileNameListAssets) == 0x000040, "Wrong size on UFileNameListAssets");
static_assert(offsetof(UFileNameListAssets, Data) == 0x000030, "Member 'UFileNameListAssets::Data' has a wrong offset!");

// Class xrd777.PersonaStatus
// 0x03C8 (0x0640 - 0x0278)
class APersonaStatus final : public AAppActor
{
public:
	uint8                                         Pad_278[0x2A8];                                    // 0x0278(0x02A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersonaStatusSeq*                      Sequence_;                                         // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPersonaStatusListItem>         PersonaList;                                       // 0x0538(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPersonaStatusListItem>         RegistList;                                        // 0x0548(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x28];                                     // 0x0558(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class APersonaStatusDraw*                     PPersonaStatusDraw;                                // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0xB8];                                     // 0x0588(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatus">();
	}
	static class APersonaStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaStatus>();
	}
};
static_assert(alignof(APersonaStatus) == 0x000008, "Wrong alignment on APersonaStatus");
static_assert(sizeof(APersonaStatus) == 0x000640, "Wrong size on APersonaStatus");
static_assert(offsetof(APersonaStatus, Sequence_) == 0x000520, "Member 'APersonaStatus::Sequence_' has a wrong offset!");
static_assert(offsetof(APersonaStatus, PersonaList) == 0x000538, "Member 'APersonaStatus::PersonaList' has a wrong offset!");
static_assert(offsetof(APersonaStatus, RegistList) == 0x000548, "Member 'APersonaStatus::RegistList' has a wrong offset!");
static_assert(offsetof(APersonaStatus, PPersonaStatusDraw) == 0x000580, "Member 'APersonaStatus::PPersonaStatusDraw' has a wrong offset!");

// Class xrd777.AppPropsCore
// 0x0028 (0x02A0 - 0x0278)
class AAppPropsCore : public AAppActor
{
public:
	class FName                                   MOnFlagName_;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppPropsAnimPackAsset*                 MAnimePackAsset_;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CompareToHiddenCharacter(int32 LocalDataIndex, int32 ConditionalValue, EEvtConditionalBranchCompType CompareType);
	void PlayAnimationPack(int32 AnimePackIndex, const bool IsLoop, const float BlendInTime, const float BlendOutTime, const float InPlayRate, class FName AnimSlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPropsCore">();
	}
	static class AAppPropsCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppPropsCore>();
	}
};
static_assert(alignof(AAppPropsCore) == 0x000008, "Wrong alignment on AAppPropsCore");
static_assert(sizeof(AAppPropsCore) == 0x0002A0, "Wrong size on AAppPropsCore");
static_assert(offsetof(AAppPropsCore, MOnFlagName_) == 0x000278, "Member 'AAppPropsCore::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AAppPropsCore, MOffFlagName_) == 0x000280, "Member 'AAppPropsCore::MOffFlagName_' has a wrong offset!");
static_assert(offsetof(AAppPropsCore, Root) == 0x000288, "Member 'AAppPropsCore::Root' has a wrong offset!");
static_assert(offsetof(AAppPropsCore, SkeletalMesh) == 0x000290, "Member 'AAppPropsCore::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AAppPropsCore, MAnimePackAsset_) == 0x000298, "Member 'AAppPropsCore::MAnimePackAsset_' has a wrong offset!");

// Class xrd777.CmpItemSystem
// 0x0770 (0x0798 - 0x0028)
class UCmpItemSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x740];                                     // 0x0028(0x0740)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int16>                                 PartyMemberList;                                   // 0x0768(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PersonaStockIDList;                                // 0x0778(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FItemListItem>                  ItemList;                                          // 0x0788(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpItemSystem">();
	}
	static class UCmpItemSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpItemSystem>();
	}
};
static_assert(alignof(UCmpItemSystem) == 0x000008, "Wrong alignment on UCmpItemSystem");
static_assert(sizeof(UCmpItemSystem) == 0x000798, "Wrong size on UCmpItemSystem");
static_assert(offsetof(UCmpItemSystem, PartyMemberList) == 0x000768, "Member 'UCmpItemSystem::PartyMemberList' has a wrong offset!");
static_assert(offsetof(UCmpItemSystem, PersonaStockIDList) == 0x000778, "Member 'UCmpItemSystem::PersonaStockIDList' has a wrong offset!");
static_assert(offsetof(UCmpItemSystem, ItemList) == 0x000788, "Member 'UCmpItemSystem::ItemList' has a wrong offset!");

// Class xrd777.AssistViewTest
// 0x0010 (0x0288 - 0x0278)
class AAssistViewTest final : public AAppActor
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssistViewTest">();
	}
	static class AAssistViewTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAssistViewTest>();
	}
};
static_assert(alignof(AAssistViewTest) == 0x000008, "Wrong alignment on AAssistViewTest");
static_assert(sizeof(AAssistViewTest) == 0x000288, "Wrong size on AAssistViewTest");
static_assert(offsetof(AAssistViewTest, Loader_) == 0x000278, "Member 'AAssistViewTest::Loader_' has a wrong offset!");
static_assert(offsetof(AAssistViewTest, BmdAsset_) == 0x000280, "Member 'AAssistViewTest::BmdAsset_' has a wrong offset!");

// Class xrd777.KimuraDebugMenu
// 0x0008 (0x0228 - 0x0220)
class AKimuraDebugMenu final : public AActor
{
public:
	class UDebugMenu*                             Menu;                                              // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KimuraDebugMenu">();
	}
	static class AKimuraDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKimuraDebugMenu>();
	}
};
static_assert(alignof(AKimuraDebugMenu) == 0x000008, "Wrong alignment on AKimuraDebugMenu");
static_assert(sizeof(AKimuraDebugMenu) == 0x000228, "Wrong size on AKimuraDebugMenu");
static_assert(offsetof(AKimuraDebugMenu, Menu) == 0x000220, "Member 'AKimuraDebugMenu::Menu' has a wrong offset!");

// Class xrd777.AstreaEditorWork
// 0x0008 (0x0040 - 0x0038)
class UAstreaEditorWork final : public UDeveloperSettings
{
public:
	bool                                          bIsEditAstrea;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForce;                                          // 0x0039(0x0001)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaEditorWork">();
	}
	static class UAstreaEditorWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAstreaEditorWork>();
	}
};
static_assert(alignof(UAstreaEditorWork) == 0x000008, "Wrong alignment on UAstreaEditorWork");
static_assert(sizeof(UAstreaEditorWork) == 0x000040, "Wrong size on UAstreaEditorWork");
static_assert(offsetof(UAstreaEditorWork, bIsEditAstrea) == 0x000038, "Member 'UAstreaEditorWork::bIsEditAstrea' has a wrong offset!");
static_assert(offsetof(UAstreaEditorWork, bIsForce) == 0x000039, "Member 'UAstreaEditorWork::bIsForce' has a wrong offset!");

// Class xrd777.TutorialManager
// 0x0050 (0x0078 - 0x0028)
class UTutorialManager final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              PBmdAsset;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture*>                       Textures;                                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         Paths;                                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialManager">();
	}
	static class UTutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialManager>();
	}
};
static_assert(alignof(UTutorialManager) == 0x000008, "Wrong alignment on UTutorialManager");
static_assert(sizeof(UTutorialManager) == 0x000078, "Wrong size on UTutorialManager");
static_assert(offsetof(UTutorialManager, PAssetLoader) == 0x000048, "Member 'UTutorialManager::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UTutorialManager, PBmdAsset) == 0x000050, "Member 'UTutorialManager::PBmdAsset' has a wrong offset!");
static_assert(offsetof(UTutorialManager, Textures) == 0x000058, "Member 'UTutorialManager::Textures' has a wrong offset!");
static_assert(offsetof(UTutorialManager, Paths) == 0x000068, "Member 'UTutorialManager::Paths' has a wrong offset!");

// Class xrd777.TestSaveGameActor
// 0x0018 (0x0238 - 0x0220)
class ATestSaveGameActor final : public AActor
{
public:
	class UDebugMenu*                             MpTestSaveGameDebugMenu;                           // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestSaveGameActor">();
	}
	static class ATestSaveGameActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestSaveGameActor>();
	}
};
static_assert(alignof(ATestSaveGameActor) == 0x000008, "Wrong alignment on ATestSaveGameActor");
static_assert(sizeof(ATestSaveGameActor) == 0x000238, "Wrong size on ATestSaveGameActor");
static_assert(offsetof(ATestSaveGameActor, MpTestSaveGameDebugMenu) == 0x000220, "Member 'ATestSaveGameActor::MpTestSaveGameDebugMenu' has a wrong offset!");

// Class xrd777.AstreaFuncLib
// 0x0000 (0x0028 - 0x0028)
class UAstreaFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetCostumeAstreaDaily(int32 PlayerId);
	static int32 GetCurrentDesignTypeId();
	static int32 GetCurrentEpisodeHero();
	static ELibraSaveDataState GetLibraSaveDataState();
	static bool IsAbyssOfTimeField(int32 FieldMajorID, int32 FieldMinorID);
	static bool IsAstreaField(int32 FieldMajorID, int32 FieldMinorID);
	static bool IsAvailableAstrea();
	static bool IsColosseumBattle(int32 EncounterID);
	static bool IsCurrentEpisodeMember(int32 PlayerId);
	static bool IsDateUnknown();
	static bool IsDateUnknowText(const class FString& Date);
	static bool IsEnableAstreaSaveFormat();
	static bool IsExtraEpisodeMember(int32 PlayerId);
	static bool IsLongRangeAttackEnhanced();
	static bool IsMonadoBattle();
	static bool IsOpenedAddAstreaMsg();
	static bool IsOriginEpisodeMember(int32 PlayerId);
	static bool IsPlayingAstrea();
	static bool IsRequestDisplayNetworkSlot();
	static bool IsUnlockAstrea();
	static bool IsUsingAstreaPersonaBook();
	static bool IsUsingAstreaSavedata();
	static class FString ReplaceContentRootPath(const class FString& InOriginal);
	static void SetLibraSaveDataState(ELibraSaveDataState SaveDataState);
	static void SetOpenAddAstreaMsg(bool bIsOpen);
	static void SetPlayingAstrea(bool bPlaying);
	static void SetRequestDisplayNetworkSlot(bool bIsDisplay);
	static void SetUsingAstreaSaveData(bool bUsingAstrea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaFuncLib">();
	}
	static class UAstreaFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAstreaFuncLib>();
	}
};
static_assert(alignof(UAstreaFuncLib) == 0x000008, "Wrong alignment on UAstreaFuncLib");
static_assert(sizeof(UAstreaFuncLib) == 0x000028, "Wrong size on UAstreaFuncLib");

// Class xrd777.DatUIUseText
// 0x0068 (0x0090 - 0x0028)
class UDatUIUseText final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTable;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class FString>                    UIUseTextTable;                                    // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatUIUseText">();
	}
	static class UDatUIUseText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatUIUseText>();
	}
};
static_assert(alignof(UDatUIUseText) == 0x000008, "Wrong alignment on UDatUIUseText");
static_assert(sizeof(UDatUIUseText) == 0x000090, "Wrong size on UDatUIUseText");
static_assert(offsetof(UDatUIUseText, Loader) == 0x000028, "Member 'UDatUIUseText::Loader' has a wrong offset!");
static_assert(offsetof(UDatUIUseText, DataTable) == 0x000030, "Member 'UDatUIUseText::DataTable' has a wrong offset!");
static_assert(offsetof(UDatUIUseText, UIUseTextTable) == 0x000038, "Member 'UDatUIUseText::UIUseTextTable' has a wrong offset!");

// Class xrd777.PersonaStatusSeq
// 0x0008 (0x0030 - 0x0028)
class UPersonaStatusSeq : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSeq">();
	}
	static class UPersonaStatusSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSeq>();
	}
};
static_assert(alignof(UPersonaStatusSeq) == 0x000008, "Wrong alignment on UPersonaStatusSeq");
static_assert(sizeof(UPersonaStatusSeq) == 0x000030, "Wrong size on UPersonaStatusSeq");

// Class xrd777.PersonaStatusSkillListSeq
// 0x0010 (0x0040 - 0x0030)
class UPersonaStatusSkillListSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSkillListSeq">();
	}
	static class UPersonaStatusSkillListSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSkillListSeq>();
	}
};
static_assert(alignof(UPersonaStatusSkillListSeq) == 0x000008, "Wrong alignment on UPersonaStatusSkillListSeq");
static_assert(sizeof(UPersonaStatusSkillListSeq) == 0x000040, "Wrong size on UPersonaStatusSkillListSeq");

// Class xrd777.WeaponShopDrawCommon
// 0x3750 (0x3778 - 0x0028)
class UWeaponShopDrawCommon final : public UObject
{
public:
	uint8                                         Pad_28[0x3690];                                    // 0x0028(0x3690)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICloudCursorDraw*                     _pCloudCursor;                                     // 0x36B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C0[0xB8];                                    // 0x36C0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponShopDrawCommon">();
	}
	static class UWeaponShopDrawCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponShopDrawCommon>();
	}
};
static_assert(alignof(UWeaponShopDrawCommon) == 0x000008, "Wrong alignment on UWeaponShopDrawCommon");
static_assert(sizeof(UWeaponShopDrawCommon) == 0x003778, "Wrong size on UWeaponShopDrawCommon");
static_assert(offsetof(UWeaponShopDrawCommon, _pCloudCursor) == 0x0036B8, "Member 'UWeaponShopDrawCommon::_pCloudCursor' has a wrong offset!");

// Class xrd777.AstreaProgress
// 0x0008 (0x0030 - 0x0028)
class UAstreaProgress final : public UObject
{
public:
	class AAstreaProgressActor*                   ExecProgressActor_;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaProgress">();
	}
	static class UAstreaProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAstreaProgress>();
	}
};
static_assert(alignof(UAstreaProgress) == 0x000008, "Wrong alignment on UAstreaProgress");
static_assert(sizeof(UAstreaProgress) == 0x000030, "Wrong size on UAstreaProgress");
static_assert(offsetof(UAstreaProgress, ExecProgressActor_) == 0x000028, "Member 'UAstreaProgress::ExecProgressActor_' has a wrong offset!");

// Class xrd777.ArmorItemListTable
// 0x0010 (0x0040 - 0x0030)
class UArmorItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FArmorItemList>                 Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorItemListTable">();
	}
	static class UArmorItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorItemListTable>();
	}
};
static_assert(alignof(UArmorItemListTable) == 0x000008, "Wrong alignment on UArmorItemListTable");
static_assert(sizeof(UArmorItemListTable) == 0x000040, "Wrong size on UArmorItemListTable");
static_assert(offsetof(UArmorItemListTable, Data) == 0x000030, "Member 'UArmorItemListTable::Data' has a wrong offset!");

// Class xrd777.AstreaProgressActor
// 0x0030 (0x02A8 - 0x0278)
class AAstreaProgressActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 MBpClass_;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBfAsset*                               MBfAsset_;                                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAstreaProgressProcActor*               MProcActor_;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaProgressActor">();
	}
	static class AAstreaProgressActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAstreaProgressActor>();
	}
};
static_assert(alignof(AAstreaProgressActor) == 0x000008, "Wrong alignment on AAstreaProgressActor");
static_assert(sizeof(AAstreaProgressActor) == 0x0002A8, "Wrong size on AAstreaProgressActor");
static_assert(offsetof(AAstreaProgressActor, MAssetLoader_) == 0x000288, "Member 'AAstreaProgressActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AAstreaProgressActor, MBpClass_) == 0x000290, "Member 'AAstreaProgressActor::MBpClass_' has a wrong offset!");
static_assert(offsetof(AAstreaProgressActor, MBfAsset_) == 0x000298, "Member 'AAstreaProgressActor::MBfAsset_' has a wrong offset!");
static_assert(offsetof(AAstreaProgressActor, MProcActor_) == 0x0002A0, "Member 'AAstreaProgressActor::MProcActor_' has a wrong offset!");

// Class xrd777.EvtManagerStatePlaying
// 0x0000 (0x0038 - 0x0038)
class UEvtManagerStatePlaying final : public UEvtManagerStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtManagerStatePlaying">();
	}
	static class UEvtManagerStatePlaying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtManagerStatePlaying>();
	}
};
static_assert(alignof(UEvtManagerStatePlaying) == 0x000008, "Wrong alignment on UEvtManagerStatePlaying");
static_assert(sizeof(UEvtManagerStatePlaying) == 0x000038, "Wrong size on UEvtManagerStatePlaying");

// Class xrd777.AstreaProgressDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAstreaProgressDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAstreaProgressTableItem>       Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaProgressDataAsset">();
	}
	static class UAstreaProgressDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAstreaProgressDataAsset>();
	}
};
static_assert(alignof(UAstreaProgressDataAsset) == 0x000008, "Wrong alignment on UAstreaProgressDataAsset");
static_assert(sizeof(UAstreaProgressDataAsset) == 0x000040, "Wrong size on UAstreaProgressDataAsset");
static_assert(offsetof(UAstreaProgressDataAsset, Data) == 0x000030, "Member 'UAstreaProgressDataAsset::Data' has a wrong offset!");

// Class xrd777.AstreaProgressProcActor
// 0x0028 (0x02A0 - 0x0278)
class AAstreaProgressProcActor final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             EndDelegate;                                       // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              ScrActor;                                          // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallNextProgress();
	void OnFinishedAtlScr(int32 ExitType);
	void OnFinishedProc(int32 ExitType);
	void Return();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaProgressProcActor">();
	}
	static class AAstreaProgressProcActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAstreaProgressProcActor>();
	}
};
static_assert(alignof(AAstreaProgressProcActor) == 0x000008, "Wrong alignment on AAstreaProgressProcActor");
static_assert(sizeof(AAstreaProgressProcActor) == 0x0002A0, "Wrong size on AAstreaProgressProcActor");
static_assert(offsetof(AAstreaProgressProcActor, EndDelegate) == 0x000278, "Member 'AAstreaProgressProcActor::EndDelegate' has a wrong offset!");
static_assert(offsetof(AAstreaProgressProcActor, ScrActor) == 0x000290, "Member 'AAstreaProgressProcActor::ScrActor' has a wrong offset!");

// Class xrd777.TownMapTimeDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTownMapTimeDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTownMapTimeTable>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownMapTimeDataAsset">();
	}
	static class UTownMapTimeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownMapTimeDataAsset>();
	}
};
static_assert(alignof(UTownMapTimeDataAsset) == 0x000008, "Wrong alignment on UTownMapTimeDataAsset");
static_assert(sizeof(UTownMapTimeDataAsset) == 0x000040, "Wrong size on UTownMapTimeDataAsset");
static_assert(offsetof(UTownMapTimeDataAsset, Data) == 0x000030, "Member 'UTownMapTimeDataAsset::Data' has a wrong offset!");

// Class xrd777.CmpMenuBase
// 0x0010 (0x0038 - 0x0028)
class UCmpMenuBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpMenuBase">();
	}
	static class UCmpMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpMenuBase>();
	}
};
static_assert(alignof(UCmpMenuBase) == 0x000008, "Wrong alignment on UCmpMenuBase");
static_assert(sizeof(UCmpMenuBase) == 0x000038, "Wrong size on UCmpMenuBase");
static_assert(offsetof(UCmpMenuBase, PMainActor) == 0x000030, "Member 'UCmpMenuBase::PMainActor' has a wrong offset!");

// Class xrd777.CmpQuest
// 0x01F8 (0x0230 - 0x0038)
class UCmpQuest final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pSpr;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           AssetLoader_;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pCampSpr;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pCampKeySpr;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              M_pCampPlg;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x1C8];                                     // 0x0068(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpQuest">();
	}
	static class UCmpQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpQuest>();
	}
};
static_assert(alignof(UCmpQuest) == 0x000008, "Wrong alignment on UCmpQuest");
static_assert(sizeof(UCmpQuest) == 0x000230, "Wrong size on UCmpQuest");
static_assert(offsetof(UCmpQuest, M_pSpr) == 0x000040, "Member 'UCmpQuest::M_pSpr' has a wrong offset!");
static_assert(offsetof(UCmpQuest, AssetLoader_) == 0x000048, "Member 'UCmpQuest::AssetLoader_' has a wrong offset!");
static_assert(offsetof(UCmpQuest, M_pCampSpr) == 0x000050, "Member 'UCmpQuest::M_pCampSpr' has a wrong offset!");
static_assert(offsetof(UCmpQuest, M_pCampKeySpr) == 0x000058, "Member 'UCmpQuest::M_pCampKeySpr' has a wrong offset!");
static_assert(offsetof(UCmpQuest, M_pCampPlg) == 0x000060, "Member 'UCmpQuest::M_pCampPlg' has a wrong offset!");

// Class xrd777.AtlEvtActorComponent
// 0x01A0 (0x0268 - 0x00C8)
class UAtlEvtActorComponent : public UAppActorComponent
{
public:
	class AActor*                                 AttachPropActor;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlEvtLocomotionTeleportVelocityType         LocomotionTeleportVelocityType;                    // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionTeleportDistanceThreshold;               // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocomotionTeleportVelocityConstant;                // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocomotionTeleportVelocityClampMinMax;             // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LipUniqueID;                                       // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UNiagaraComponent>       HandwritingComp;                                   // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHandwritingSpawner>     HandwritingSpawner;                                // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             OwnerCharacter;                                    // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANpcBaseCore*                           OwnerNpc;                                          // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharBaseComp*                       AppCharaBaseComp;                                  // 0x0110(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAtlEvtNiagaraSystemPool               EvtNiagaraSystemPool;                              // 0x0118(0x0050)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0xF8];                                     // 0x0168(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAnimPack;                                      // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimPackID                                   OverrideAnimPackID;                                // 0x0261(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAtlEvtLocomotionVelocitySimulation;         // 0x0262(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAtlEvtBag;                                  // 0x0263(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAppCharShoesID                               ShoesID;                                           // 0x0264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CalcEvtLocomotionTeleportVelocity(const struct FVector& SimVelocity, const struct FVector& PrevSimVelocity, float VelocityRate);
	void ClearAttachPropActor();
	void CompareToHiddenCharacter(int32 LocalDataIndex, int32 ConditionalValue, EEvtConditionalBranchCompType CompareType);
	void LoadEnded();
	void ResetVelocitySimulateParam();
	void SetAttachPropActor();
	void SetEnableAtlEvtLocomotionVelocitySimulation(bool bInEnableAtlEvtLocomotionVelocitySimulation);
	void SetEnableBag(bool bInEnableAtlEvtBag);
	void SetLocomotionTeleportVelocityType(EAtlEvtLocomotionTeleportVelocityType Type);
	void SetOverrideAnimPackID(EAnimPackID InAnimPackID);
	void SetOverwriteDettachPropTransform(const struct FTransform& Transform);
	void SetShoesId(EAppCharShoesID ID);
	void SetupAnimPack();
	void SetupHeroBag();
	void SetUseAnimPack(bool bInUseAnimPack);
	class AHandwritingSpawner* SpawnHandwritingAttached(EAtlEvtHandwritingType Type, int32 LoopCount, float CameraOffset, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAttached);
	class AHandwritingSpawner* SpawnHandwritingAttachedDefaultParam(EAtlEvtHandwritingType Type, bool bAttached);

	EAtlEvtLocomotionTeleportVelocityType GetLocomotionTeleportVelocityType() const;
	EAppCharShoesID GetShoesID() const;
	bool IsEnableBag() const;
	bool IsEnableLocomotionVelocitySimulate() const;
	bool IsUseAnimPack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtActorComponent">();
	}
	static class UAtlEvtActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtActorComponent>();
	}
};
static_assert(alignof(UAtlEvtActorComponent) == 0x000008, "Wrong alignment on UAtlEvtActorComponent");
static_assert(sizeof(UAtlEvtActorComponent) == 0x000268, "Wrong size on UAtlEvtActorComponent");
static_assert(offsetof(UAtlEvtActorComponent, AttachPropActor) == 0x0000C8, "Member 'UAtlEvtActorComponent::AttachPropActor' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, LocomotionTeleportVelocityType) == 0x0000D0, "Member 'UAtlEvtActorComponent::LocomotionTeleportVelocityType' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, LocomotionTeleportDistanceThreshold) == 0x0000D4, "Member 'UAtlEvtActorComponent::LocomotionTeleportDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, LocomotionTeleportVelocityConstant) == 0x0000D8, "Member 'UAtlEvtActorComponent::LocomotionTeleportVelocityConstant' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, LocomotionTeleportVelocityClampMinMax) == 0x0000E4, "Member 'UAtlEvtActorComponent::LocomotionTeleportVelocityClampMinMax' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, LipUniqueID) == 0x0000EC, "Member 'UAtlEvtActorComponent::LipUniqueID' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, HandwritingComp) == 0x0000F0, "Member 'UAtlEvtActorComponent::HandwritingComp' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, HandwritingSpawner) == 0x0000F8, "Member 'UAtlEvtActorComponent::HandwritingSpawner' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, OwnerCharacter) == 0x000100, "Member 'UAtlEvtActorComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, OwnerNpc) == 0x000108, "Member 'UAtlEvtActorComponent::OwnerNpc' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, AppCharaBaseComp) == 0x000110, "Member 'UAtlEvtActorComponent::AppCharaBaseComp' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, EvtNiagaraSystemPool) == 0x000118, "Member 'UAtlEvtActorComponent::EvtNiagaraSystemPool' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, bUseAnimPack) == 0x000260, "Member 'UAtlEvtActorComponent::bUseAnimPack' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, OverrideAnimPackID) == 0x000261, "Member 'UAtlEvtActorComponent::OverrideAnimPackID' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, bEnableAtlEvtLocomotionVelocitySimulation) == 0x000262, "Member 'UAtlEvtActorComponent::bEnableAtlEvtLocomotionVelocitySimulation' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, bEnableAtlEvtBag) == 0x000263, "Member 'UAtlEvtActorComponent::bEnableAtlEvtBag' has a wrong offset!");
static_assert(offsetof(UAtlEvtActorComponent, ShoesID) == 0x000264, "Member 'UAtlEvtActorComponent::ShoesID' has a wrong offset!");

// Class xrd777.Loading
// 0x0020 (0x0048 - 0x0028)
class ULoading final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALoadingDraw*                           PLoadingDraw;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ALoadingDraw>               LoadingDrawClass;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void End();
	void SpawnDrawActor(class ALoadingDraw* LoadingDraw);
	void Start(ECldTimeZone Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loading">();
	}
	static class ULoading* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoading>();
	}
};
static_assert(alignof(ULoading) == 0x000008, "Wrong alignment on ULoading");
static_assert(sizeof(ULoading) == 0x000048, "Wrong size on ULoading");
static_assert(offsetof(ULoading, PLoadingDraw) == 0x000030, "Member 'ULoading::PLoadingDraw' has a wrong offset!");
static_assert(offsetof(ULoading, LoadingDrawClass) == 0x000038, "Member 'ULoading::LoadingDrawClass' has a wrong offset!");
static_assert(offsetof(ULoading, PAssetLoader) == 0x000040, "Member 'ULoading::PAssetLoader' has a wrong offset!");

// Class xrd777.AtlEvtAnswerActor
// 0x0010 (0x0288 - 0x0278)
class AAtlEvtAnswerActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AAppActor*                              MNetAnswer_;                                       // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtAnswerActor">();
	}
	static class AAtlEvtAnswerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtAnswerActor>();
	}
};
static_assert(alignof(AAtlEvtAnswerActor) == 0x000008, "Wrong alignment on AAtlEvtAnswerActor");
static_assert(sizeof(AAtlEvtAnswerActor) == 0x000288, "Wrong size on AAtlEvtAnswerActor");
static_assert(offsetof(AAtlEvtAnswerActor, MNetAnswer_) == 0x000280, "Member 'AAtlEvtAnswerActor::MNetAnswer_' has a wrong offset!");

// Class xrd777.KimuraURO
// 0x0018 (0x0238 - 0x0220)
class AKimuraURO final : public AActor
{
public:
	class ACharacter*                             Target;                                            // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 Rate;                                              // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void Apply();
	void Enable(bool F);
	void Update(const TArray<float>& V);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KimuraURO">();
	}
	static class AKimuraURO* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKimuraURO>();
	}
};
static_assert(alignof(AKimuraURO) == 0x000008, "Wrong alignment on AKimuraURO");
static_assert(sizeof(AKimuraURO) == 0x000238, "Wrong size on AKimuraURO");
static_assert(offsetof(AKimuraURO, Target) == 0x000220, "Member 'AKimuraURO::Target' has a wrong offset!");
static_assert(offsetof(AKimuraURO, Rate) == 0x000228, "Member 'AKimuraURO::Rate' has a wrong offset!");

// Class xrd777.ItemNameListTable
// 0x0010 (0x0040 - 0x0030)
class UItemNameListTable final : public UAppDataAsset
{
public:
	TArray<class FString>                         Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemNameListTable">();
	}
	static class UItemNameListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemNameListTable>();
	}
};
static_assert(alignof(UItemNameListTable) == 0x000008, "Wrong alignment on UItemNameListTable");
static_assert(sizeof(UItemNameListTable) == 0x000040, "Wrong size on UItemNameListTable");
static_assert(offsetof(UItemNameListTable, Data) == 0x000030, "Member 'UItemNameListTable::Data' has a wrong offset!");

// Class xrd777.AtlEvtHelperSettings
// 0x0008 (0x0040 - 0x0038)
class UAtlEvtHelperSettings final : public UDeveloperSettings
{
public:
	bool                                          bLoadSublevelsInAEvent;                            // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimulateDate;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtHelperSettings">();
	}
	static class UAtlEvtHelperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtHelperSettings>();
	}
};
static_assert(alignof(UAtlEvtHelperSettings) == 0x000008, "Wrong alignment on UAtlEvtHelperSettings");
static_assert(sizeof(UAtlEvtHelperSettings) == 0x000040, "Wrong size on UAtlEvtHelperSettings");
static_assert(offsetof(UAtlEvtHelperSettings, bLoadSublevelsInAEvent) == 0x000038, "Member 'UAtlEvtHelperSettings::bLoadSublevelsInAEvent' has a wrong offset!");
static_assert(offsetof(UAtlEvtHelperSettings, bUseSimulateDate) == 0x000039, "Member 'UAtlEvtHelperSettings::bUseSimulateDate' has a wrong offset!");

// Class xrd777.DungeonSoundDataAssets
// 0x0010 (0x0038 - 0x0028)
class UDungeonSoundDataAssets final : public UObject
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PDlcDungeonBgm;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSoundDataAssets">();
	}
	static class UDungeonSoundDataAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSoundDataAssets>();
	}
};
static_assert(alignof(UDungeonSoundDataAssets) == 0x000008, "Wrong alignment on UDungeonSoundDataAssets");
static_assert(sizeof(UDungeonSoundDataAssets) == 0x000038, "Wrong size on UDungeonSoundDataAssets");
static_assert(offsetof(UDungeonSoundDataAssets, PAssetLoader) == 0x000028, "Member 'UDungeonSoundDataAssets::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UDungeonSoundDataAssets, PDlcDungeonBgm) == 0x000030, "Member 'UDungeonSoundDataAssets::PDlcDungeonBgm' has a wrong offset!");

// Class xrd777.UIDataAssets
// 0x0000 (0x0028 - 0x0028)
class UUIDataAssets final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDataAssets">();
	}
	static class UUIDataAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDataAssets>();
	}
};
static_assert(alignof(UUIDataAssets) == 0x000008, "Wrong alignment on UUIDataAssets");
static_assert(sizeof(UUIDataAssets) == 0x000028, "Wrong size on UUIDataAssets");

// Class xrd777.AtlEvtEventEditHelper
// 0x0040 (0x02B8 - 0x0278)
class AAtlEvtEventEditHelper final : public AAppActor
{
public:
	bool                                          bLoadAllSublevels;                                 // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventSublevelName;                                 // 0x0280(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlEvtEventCategoryType                      EventCategoryType;                                 // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFieldEventInterpFieldCamera;                      // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldTimeZone                                  PreviewTimeZone;                                   // 0x0292(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldSeason                                    PreviewSeason;                                     // 0x0293(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewCrowd;                                     // 0x0294(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreviewCrowdMonth;                                 // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviewCrowdDay;                                   // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldTimeZone                                  PreviewCrowdTimeZone;                              // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0xB];                                      // 0x02A1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AInitReadActor>          InitReadActor;                                     // 0x02AC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadedLevelInPIE();
	void SetPreviewCrowdSettings(int32 InCrowdMonth, int32 InCrowdDay, ECldTimeZone InCrowdTimeZone, bool bInPreviewCrowd);

	bool IsRankAEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtEventEditHelper">();
	}
	static class AAtlEvtEventEditHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtEventEditHelper>();
	}
};
static_assert(alignof(AAtlEvtEventEditHelper) == 0x000008, "Wrong alignment on AAtlEvtEventEditHelper");
static_assert(sizeof(AAtlEvtEventEditHelper) == 0x0002B8, "Wrong size on AAtlEvtEventEditHelper");
static_assert(offsetof(AAtlEvtEventEditHelper, bLoadAllSublevels) == 0x000278, "Member 'AAtlEvtEventEditHelper::bLoadAllSublevels' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, EventSublevelName) == 0x000280, "Member 'AAtlEvtEventEditHelper::EventSublevelName' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, EventCategoryType) == 0x000290, "Member 'AAtlEvtEventEditHelper::EventCategoryType' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, bFieldEventInterpFieldCamera) == 0x000291, "Member 'AAtlEvtEventEditHelper::bFieldEventInterpFieldCamera' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, PreviewTimeZone) == 0x000292, "Member 'AAtlEvtEventEditHelper::PreviewTimeZone' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, PreviewSeason) == 0x000293, "Member 'AAtlEvtEventEditHelper::PreviewSeason' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, bPreviewCrowd) == 0x000294, "Member 'AAtlEvtEventEditHelper::bPreviewCrowd' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, PreviewCrowdMonth) == 0x000298, "Member 'AAtlEvtEventEditHelper::PreviewCrowdMonth' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, PreviewCrowdDay) == 0x00029C, "Member 'AAtlEvtEventEditHelper::PreviewCrowdDay' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, PreviewCrowdTimeZone) == 0x0002A0, "Member 'AAtlEvtEventEditHelper::PreviewCrowdTimeZone' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventEditHelper, InitReadActor) == 0x0002AC, "Member 'AAtlEvtEventEditHelper::InitReadActor' has a wrong offset!");

// Class xrd777.UIProgressBarDraw
// 0x00D0 (0x0388 - 0x02B8)
class AUIProgressBarDraw final : public AUIDrawBaseActor
{
public:
	class USprAsset*                              PSprAsset;                                         // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0xB8];                                     // 0x02C0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProgressBarDraw">();
	}
	static class AUIProgressBarDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIProgressBarDraw>();
	}
};
static_assert(alignof(AUIProgressBarDraw) == 0x000008, "Wrong alignment on AUIProgressBarDraw");
static_assert(sizeof(AUIProgressBarDraw) == 0x000388, "Wrong size on AUIProgressBarDraw");
static_assert(offsetof(AUIProgressBarDraw, PSprAsset) == 0x0002B8, "Member 'AUIProgressBarDraw::PSprAsset' has a wrong offset!");
static_assert(offsetof(AUIProgressBarDraw, LayoutData) == 0x000378, "Member 'AUIProgressBarDraw::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIProgressBarDraw, LayoutDataTable) == 0x000380, "Member 'AUIProgressBarDraw::LayoutDataTable' has a wrong offset!");

// Class xrd777.DatUICalendarText
// 0x0058 (0x0080 - 0x0028)
class UDatUICalendarText final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MonthTable;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DateTable;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DayOfWeekTable;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         MonthTexts;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         DateTexts;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         DayOfWeekTexts;                                    // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatUICalendarText">();
	}
	static class UDatUICalendarText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatUICalendarText>();
	}
};
static_assert(alignof(UDatUICalendarText) == 0x000008, "Wrong alignment on UDatUICalendarText");
static_assert(sizeof(UDatUICalendarText) == 0x000080, "Wrong size on UDatUICalendarText");
static_assert(offsetof(UDatUICalendarText, Loader) == 0x000028, "Member 'UDatUICalendarText::Loader' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, MonthTable) == 0x000030, "Member 'UDatUICalendarText::MonthTable' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, DateTable) == 0x000038, "Member 'UDatUICalendarText::DateTable' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, DayOfWeekTable) == 0x000040, "Member 'UDatUICalendarText::DayOfWeekTable' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, MonthTexts) == 0x000048, "Member 'UDatUICalendarText::MonthTexts' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, DateTexts) == 0x000058, "Member 'UDatUICalendarText::DateTexts' has a wrong offset!");
static_assert(offsetof(UDatUICalendarText, DayOfWeekTexts) == 0x000068, "Member 'UDatUICalendarText::DayOfWeekTexts' has a wrong offset!");

// Class xrd777.AtlEvtEventManager
// 0x00F8 (0x0370 - 0x0278)
class AAtlEvtEventManager final : public AAppActor
{
public:
	class AActor*                                 FieldCameraActor;                                  // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MovieSceneCameraActor;                             // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x1];                                      // 0x0288(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EEventManagerEventRank                        EventRank;                                         // 0x0289(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0xE];                                      // 0x028A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventSkipWidgetDelegate*               EventSkipWidget;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEventSkipWidgetDelegate>   EventSkipWidgetClass;                              // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x4];                                      // 0x02A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAtlEvtEventManagerMovieSceneOperator  MovieSceneOperator;                                // 0x02AC(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBmdAsset*                              MpBmdAsset;                                        // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                MsgUniqIDList;                                     // 0x02C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         BmdAssetMsgID;                                     // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExecutingMessageNo;                                // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x5];                                      // 0x02E0(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	EEventManagerMessageState                     MessageState;                                      // 0x02E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6[0x1A];                                     // 0x02E6(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              ScrActor;                                          // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUIBackLog*                             UIBackLogActor;                                    // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIVoiceAnswer*                         UINetAnswerActor;                                  // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieSceneSequencePlayer*              EventSequencePlayer;                               // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestedSeqClosedEventMessageID;                  // 0x0340(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEventManagerSeqControllerState               SeqControllerState;                                // 0x0344(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0xB];                                      // 0x0345(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AAtlEvtEventManager_PauseActor*         PauseControllerActor;                              // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtlEvtMoviePlayManager*                MoviePlayManager;                                  // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AtlEvt_ResumeEventSequencer();
	void BackLogFinishDelegte();
	void CloseMessage();
	void ExecuteBmdMessage(class UBmdAsset* InAsset, int32 InMessageMajorID, int32 InMessageMinorID, int32 InMessageSubID, int32 InMessagePageID, bool bInEnableMessageRef, int32 InSeqEventMessageID);
	void ExecuteBmdMessageSubtitle(class UBmdAsset* InAsset, int32 InMessageMajorID, int32 InMessageMinorID, int32 InMessageSubID, int32 InMessagePageID, int32 InDrawFrame, bool bInEnableMessageRef, int32 InSeqEventMessageID);
	void ExecuteBmdMessageSubtitleSelect(class UBmdAsset* InAsset, int32 InSelectMessageMajorID, int32 InSelectMessageMinorID, int32 InSelectMessageSubID, int32 InSelectResponceToLocalDataID);
	void ExecuteBmdMessageSubtitleWithSelect(class UBmdAsset* InAsset, int32 InMessageMajorID, int32 InMessageMinorID, int32 InMessageSubID, int32 InMessagePageID, int32 InDrawFrame, int32 InSelectMessageMajorID, int32 InSelectMessageMinorID, int32 InSelectMessageSubID, int32 InSelectResponceToLocalDataID, bool bInEnableMessageRef, int32 InSeqEventMessageID);
	void ExecuteBmdMessageWithSelect(class UBmdAsset* InAsset, int32 InMessageMajorID, int32 InMessageMinorID, int32 InMessageSubID, int32 InMessagePageID, int32 InSelectMessageMajorID, int32 InSelectMessageMinorID, int32 InSelectMessageSubID, int32 InSelectResponceToLocalDataID, bool bInEnableMessageRef, int32 InEventMessageID);
	void ExecuteMessage(class UBmdAsset* InAsset, int32 InMessageNo, int32 InEventMessageID);
	void ExecuteMessageWithSelect(class UBmdAsset* InAsset, int32 InMessageNo, int32 InSelectNo, int32 InSelectResponceToLocalDataID, int32 InSeqEventMessageID);
	int32 ExecuteMsgScript();
	void ExecuteScript(class UBfAsset* InAsset, int32 InProcNo, bool bUseBmdAssetInBfAsset, class UBmdAsset* InBmdAsset);
	int32 ExecuteSelectScript();
	void ForceClick(const struct FKey& Key, EInputEvent EventType);
	void ForcedRemoveMessage();
	void ForcedStopScript();
	bool IsPlaying();
	void OnFinishedAtlScr(int32 ExitType);
	void ResumeEventSequencer();
	void SetLocalData(int32 Index_0, int32 Data);

	int32 GetLocalData(int32 Index_0) const;
	bool IsEventRankA() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtEventManager">();
	}
	static class AAtlEvtEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtEventManager>();
	}
};
static_assert(alignof(AAtlEvtEventManager) == 0x000008, "Wrong alignment on AAtlEvtEventManager");
static_assert(sizeof(AAtlEvtEventManager) == 0x000370, "Wrong size on AAtlEvtEventManager");
static_assert(offsetof(AAtlEvtEventManager, FieldCameraActor) == 0x000278, "Member 'AAtlEvtEventManager::FieldCameraActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MovieSceneCameraActor) == 0x000280, "Member 'AAtlEvtEventManager::MovieSceneCameraActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, EventRank) == 0x000289, "Member 'AAtlEvtEventManager::EventRank' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, EventSkipWidget) == 0x000298, "Member 'AAtlEvtEventManager::EventSkipWidget' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, EventSkipWidgetClass) == 0x0002A0, "Member 'AAtlEvtEventManager::EventSkipWidgetClass' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MovieSceneOperator) == 0x0002AC, "Member 'AAtlEvtEventManager::MovieSceneOperator' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MpBmdAsset) == 0x0002B8, "Member 'AAtlEvtEventManager::MpBmdAsset' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MsgUniqIDList) == 0x0002C8, "Member 'AAtlEvtEventManager::MsgUniqIDList' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, BmdAssetMsgID) == 0x0002D8, "Member 'AAtlEvtEventManager::BmdAssetMsgID' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, ExecutingMessageNo) == 0x0002DC, "Member 'AAtlEvtEventManager::ExecutingMessageNo' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MessageState) == 0x0002E5, "Member 'AAtlEvtEventManager::MessageState' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, ScrActor) == 0x000300, "Member 'AAtlEvtEventManager::ScrActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, UIBackLogActor) == 0x000308, "Member 'AAtlEvtEventManager::UIBackLogActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, UINetAnswerActor) == 0x000318, "Member 'AAtlEvtEventManager::UINetAnswerActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, EventSequencePlayer) == 0x000330, "Member 'AAtlEvtEventManager::EventSequencePlayer' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, RequestedSeqClosedEventMessageID) == 0x000340, "Member 'AAtlEvtEventManager::RequestedSeqClosedEventMessageID' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, SeqControllerState) == 0x000344, "Member 'AAtlEvtEventManager::SeqControllerState' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, PauseControllerActor) == 0x000350, "Member 'AAtlEvtEventManager::PauseControllerActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager, MoviePlayManager) == 0x000360, "Member 'AAtlEvtEventManager::MoviePlayManager' has a wrong offset!");

// Class xrd777.WeaponShopLineUpListTable
// 0x0010 (0x0040 - 0x0030)
class UWeaponShopLineUpListTable final : public UAppDataAsset
{
public:
	TArray<struct FWeaponShopLineUpList>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponShopLineUpListTable">();
	}
	static class UWeaponShopLineUpListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponShopLineUpListTable>();
	}
};
static_assert(alignof(UWeaponShopLineUpListTable) == 0x000008, "Wrong alignment on UWeaponShopLineUpListTable");
static_assert(sizeof(UWeaponShopLineUpListTable) == 0x000040, "Wrong size on UWeaponShopLineUpListTable");
static_assert(offsetof(UWeaponShopLineUpListTable, Data) == 0x000030, "Member 'UWeaponShopLineUpListTable::Data' has a wrong offset!");

// Class xrd777.AtlEvtEventManager_PauseActor
// 0x0090 (0x0308 - 0x0278)
class AAtlEvtEventManager_PauseActor final : public AAppActor
{
public:
	class AAtlEvtEventManager*                    OwnerManagerActor;                                 // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEvtManagerStateBase*                   CurrentAtlEventState;                              // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EEvtManagerState, class UEvtManagerStateBase*> AtlEventStates;                                    // 0x0290(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AUIBackLog*                             UIBackLogActor;                                    // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedBackLog;                                 // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedNetAnswer;                               // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtEventManager_PauseActor">();
	}
	static class AAtlEvtEventManager_PauseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtEventManager_PauseActor>();
	}
};
static_assert(alignof(AAtlEvtEventManager_PauseActor) == 0x000008, "Wrong alignment on AAtlEvtEventManager_PauseActor");
static_assert(sizeof(AAtlEvtEventManager_PauseActor) == 0x000308, "Wrong size on AAtlEvtEventManager_PauseActor");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, OwnerManagerActor) == 0x000278, "Member 'AAtlEvtEventManager_PauseActor::OwnerManagerActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, CurrentAtlEventState) == 0x000288, "Member 'AAtlEvtEventManager_PauseActor::CurrentAtlEventState' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, AtlEventStates) == 0x000290, "Member 'AAtlEvtEventManager_PauseActor::AtlEventStates' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, UIBackLogActor) == 0x0002E0, "Member 'AAtlEvtEventManager_PauseActor::UIBackLogActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, OnFinishedBackLog) == 0x0002E8, "Member 'AAtlEvtEventManager_PauseActor::OnFinishedBackLog' has a wrong offset!");
static_assert(offsetof(AAtlEvtEventManager_PauseActor, OnFinishedNetAnswer) == 0x0002F8, "Member 'AAtlEvtEventManager_PauseActor::OnFinishedNetAnswer' has a wrong offset!");

// Class xrd777.FadePgCircle
// 0x0000 (0x0040 - 0x0040)
class UFadePgCircle final : public UFadeProgramBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgCircle">();
	}
	static class UFadePgCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgCircle>();
	}
};
static_assert(alignof(UFadePgCircle) == 0x000008, "Wrong alignment on UFadePgCircle");
static_assert(sizeof(UFadePgCircle) == 0x000040, "Wrong size on UFadePgCircle");

// Class xrd777.AtlEvtHandwritingDataAsset
// 0x0038 (0x0068 - 0x0030)
class UAtlEvtHandwritingDataAsset final : public UDataAsset
{
public:
	struct FAtlEvtHandwritingData                 EvtHandwritingData;                                // 0x0030(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtHandwritingDataAsset">();
	}
	static class UAtlEvtHandwritingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtHandwritingDataAsset>();
	}
};
static_assert(alignof(UAtlEvtHandwritingDataAsset) == 0x000008, "Wrong alignment on UAtlEvtHandwritingDataAsset");
static_assert(sizeof(UAtlEvtHandwritingDataAsset) == 0x000068, "Wrong size on UAtlEvtHandwritingDataAsset");
static_assert(offsetof(UAtlEvtHandwritingDataAsset, EvtHandwritingData) == 0x000030, "Member 'UAtlEvtHandwritingDataAsset::EvtHandwritingData' has a wrong offset!");

// Class xrd777.AtlEvtHandwritingSubsystem
// 0x0068 (0x0098 - 0x0030)
class UAtlEvtHandwritingSubsystem final : public UGameInstanceSubsystem
{
public:
	class UAtlEvtHandwritingDataAsset*            EvtHandwritingAsset;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAtlEvtHandwritingData>         EvtHandwritingDefaultDatas;                        // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, struct FAtlEvtHandwritingData>   EvtHandwritingDataMap;                             // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void LoadEventHandwrintingData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtHandwritingSubsystem">();
	}
	static class UAtlEvtHandwritingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtHandwritingSubsystem>();
	}
};
static_assert(alignof(UAtlEvtHandwritingSubsystem) == 0x000008, "Wrong alignment on UAtlEvtHandwritingSubsystem");
static_assert(sizeof(UAtlEvtHandwritingSubsystem) == 0x000098, "Wrong size on UAtlEvtHandwritingSubsystem");
static_assert(offsetof(UAtlEvtHandwritingSubsystem, EvtHandwritingAsset) == 0x000030, "Member 'UAtlEvtHandwritingSubsystem::EvtHandwritingAsset' has a wrong offset!");
static_assert(offsetof(UAtlEvtHandwritingSubsystem, EvtHandwritingDefaultDatas) == 0x000038, "Member 'UAtlEvtHandwritingSubsystem::EvtHandwritingDefaultDatas' has a wrong offset!");
static_assert(offsetof(UAtlEvtHandwritingSubsystem, EvtHandwritingDataMap) == 0x000048, "Member 'UAtlEvtHandwritingSubsystem::EvtHandwritingDataMap' has a wrong offset!");

// Class xrd777.BustupEnvironmentDataAsset
// 0x0050 (0x0080 - 0x0030)
class UBustupEnvironmentDataAsset final : public UAppDataAsset
{
public:
	TMap<int32, struct FBustupEnvironmentBG>      Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupEnvironmentDataAsset">();
	}
	static class UBustupEnvironmentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupEnvironmentDataAsset>();
	}
};
static_assert(alignof(UBustupEnvironmentDataAsset) == 0x000008, "Wrong alignment on UBustupEnvironmentDataAsset");
static_assert(sizeof(UBustupEnvironmentDataAsset) == 0x000080, "Wrong size on UBustupEnvironmentDataAsset");
static_assert(offsetof(UBustupEnvironmentDataAsset, Data) == 0x000030, "Member 'UBustupEnvironmentDataAsset::Data' has a wrong offset!");

// Class xrd777.UITableTypes
// 0x0000 (0x0028 - 0x0028)
class UUITableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITableTypes">();
	}
	static class UUITableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITableTypes>();
	}
};
static_assert(alignof(UUITableTypes) == 0x000008, "Wrong alignment on UUITableTypes");
static_assert(sizeof(UUITableTypes) == 0x000028, "Wrong size on UUITableTypes");

// Class xrd777.CmpStatusCharacterListDraw
// 0x0848 (0x0870 - 0x0028)
class UCmpStatusCharacterListDraw final : public UObject
{
public:
	class UUICmpStatus*                           PParent;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x838];                                     // 0x0038(0x0838)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpStatusCharacterListDraw">();
	}
	static class UCmpStatusCharacterListDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpStatusCharacterListDraw>();
	}
};
static_assert(alignof(UCmpStatusCharacterListDraw) == 0x000008, "Wrong alignment on UCmpStatusCharacterListDraw");
static_assert(sizeof(UCmpStatusCharacterListDraw) == 0x000870, "Wrong size on UCmpStatusCharacterListDraw");
static_assert(offsetof(UCmpStatusCharacterListDraw, PParent) == 0x000028, "Member 'UCmpStatusCharacterListDraw::PParent' has a wrong offset!");
static_assert(offsetof(UCmpStatusCharacterListDraw, PMainActor) == 0x000030, "Member 'UCmpStatusCharacterListDraw::PMainActor' has a wrong offset!");

// Class xrd777.AtlEvtHighStreamingLocator
// 0x0010 (0x0288 - 0x0278)
class AAtlEvtHighStreamingLocator final : public AAppActor
{
public:
	int32                                         HighStreamingLocatorID;                            // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostFactor;                                       // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocation;                                 // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetEnableHighStreaming(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtHighStreamingLocator">();
	}
	static class AAtlEvtHighStreamingLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtHighStreamingLocator>();
	}
};
static_assert(alignof(AAtlEvtHighStreamingLocator) == 0x000008, "Wrong alignment on AAtlEvtHighStreamingLocator");
static_assert(sizeof(AAtlEvtHighStreamingLocator) == 0x000288, "Wrong size on AAtlEvtHighStreamingLocator");
static_assert(offsetof(AAtlEvtHighStreamingLocator, HighStreamingLocatorID) == 0x000278, "Member 'AAtlEvtHighStreamingLocator::HighStreamingLocatorID' has a wrong offset!");
static_assert(offsetof(AAtlEvtHighStreamingLocator, BoostFactor) == 0x00027C, "Member 'AAtlEvtHighStreamingLocator::BoostFactor' has a wrong offset!");
static_assert(offsetof(AAtlEvtHighStreamingLocator, bOverrideLocation) == 0x000280, "Member 'AAtlEvtHighStreamingLocator::bOverrideLocation' has a wrong offset!");
static_assert(offsetof(AAtlEvtHighStreamingLocator, Duration) == 0x000284, "Member 'AAtlEvtHighStreamingLocator::Duration' has a wrong offset!");

// Class xrd777.MCATestActor
// 0x0038 (0x0258 - 0x0220)
class AMCATestActor final : public AActor
{
public:
	class UMcaAsset*                              M_pMcaCam0;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x20];                                     // 0x0228(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           PMayaCamera;                                       // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MCATestActor">();
	}
	static class AMCATestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMCATestActor>();
	}
};
static_assert(alignof(AMCATestActor) == 0x000008, "Wrong alignment on AMCATestActor");
static_assert(sizeof(AMCATestActor) == 0x000258, "Wrong size on AMCATestActor");
static_assert(offsetof(AMCATestActor, M_pMcaCam0) == 0x000220, "Member 'AMCATestActor::M_pMcaCam0' has a wrong offset!");
static_assert(offsetof(AMCATestActor, PMayaCamera) == 0x000248, "Member 'AMCATestActor::PMayaCamera' has a wrong offset!");

// Class xrd777.AtlEvtLevelSequenceLoadingActor
// 0x0008 (0x0228 - 0x0220)
class AAtlEvtLevelSequenceLoadingActor final : public AActor
{
public:
	class AAtlEvtLevelSequenceActor*              OwnerEvtLevelSequenceActor;                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnFinishedLoadingAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLevelSequenceLoadingActor">();
	}
	static class AAtlEvtLevelSequenceLoadingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtLevelSequenceLoadingActor>();
	}
};
static_assert(alignof(AAtlEvtLevelSequenceLoadingActor) == 0x000008, "Wrong alignment on AAtlEvtLevelSequenceLoadingActor");
static_assert(sizeof(AAtlEvtLevelSequenceLoadingActor) == 0x000228, "Wrong size on AAtlEvtLevelSequenceLoadingActor");
static_assert(offsetof(AAtlEvtLevelSequenceLoadingActor, OwnerEvtLevelSequenceActor) == 0x000220, "Member 'AAtlEvtLevelSequenceLoadingActor::OwnerEvtLevelSequenceActor' has a wrong offset!");

// Class xrd777.LoadingDraw
// 0x0508 (0x07C0 - 0x02B8)
class ALoadingDraw : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x480];                                    // 0x02B8(0x0480)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         CloudMorningColorList;                             // 0x0738(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         CloudEveningColorList;                             // 0x0748(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         CloudNightColorList;                               // 0x0758(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         CloudShadowTimeColorList;                          // 0x0768(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CloudMoveFlameSlow;                                // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudMoveFlameFast;                                // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhetherToStart;                                    // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EarlyWaitTime;                                     // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MoonPos;                                           // 0x078C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OriginPos;                                         // 0x0794(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79C[0x24];                                     // 0x079C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Draw();
	void SetTimeZone(ECldTimeZone InTimeShifting);
	void SetVisible(bool On);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingDraw">();
	}
	static class ALoadingDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadingDraw>();
	}
};
static_assert(alignof(ALoadingDraw) == 0x000008, "Wrong alignment on ALoadingDraw");
static_assert(sizeof(ALoadingDraw) == 0x0007C0, "Wrong size on ALoadingDraw");
static_assert(offsetof(ALoadingDraw, CloudMorningColorList) == 0x000738, "Member 'ALoadingDraw::CloudMorningColorList' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, CloudEveningColorList) == 0x000748, "Member 'ALoadingDraw::CloudEveningColorList' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, CloudNightColorList) == 0x000758, "Member 'ALoadingDraw::CloudNightColorList' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, CloudShadowTimeColorList) == 0x000768, "Member 'ALoadingDraw::CloudShadowTimeColorList' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, CloudMoveFlameSlow) == 0x000778, "Member 'ALoadingDraw::CloudMoveFlameSlow' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, CloudMoveFlameFast) == 0x00077C, "Member 'ALoadingDraw::CloudMoveFlameFast' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, WhetherToStart) == 0x000780, "Member 'ALoadingDraw::WhetherToStart' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, FadeTime) == 0x000784, "Member 'ALoadingDraw::FadeTime' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, EarlyWaitTime) == 0x000788, "Member 'ALoadingDraw::EarlyWaitTime' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, MoonPos) == 0x00078C, "Member 'ALoadingDraw::MoonPos' has a wrong offset!");
static_assert(offsetof(ALoadingDraw, OriginPos) == 0x000794, "Member 'ALoadingDraw::OriginPos' has a wrong offset!");

// Class xrd777.TownMapInfoNameDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTownMapInfoNameDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTownMapInfoNameTable>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownMapInfoNameDataAsset">();
	}
	static class UTownMapInfoNameDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownMapInfoNameDataAsset>();
	}
};
static_assert(alignof(UTownMapInfoNameDataAsset) == 0x000008, "Wrong alignment on UTownMapInfoNameDataAsset");
static_assert(sizeof(UTownMapInfoNameDataAsset) == 0x000040, "Wrong size on UTownMapInfoNameDataAsset");
static_assert(offsetof(UTownMapInfoNameDataAsset, Data) == 0x000030, "Member 'UTownMapInfoNameDataAsset::Data' has a wrong offset!");

// Class xrd777.FldScriptManagerCore
// 0x0030 (0x02B0 - 0x0280)
class AFldScriptManagerCore : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               MBfAsset_;                                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              MBmdAsset_;                                        // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldScriptActor*                        MScriptActor_;                                     // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldScriptManagerCore">();
	}
	static class AFldScriptManagerCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldScriptManagerCore>();
	}
};
static_assert(alignof(AFldScriptManagerCore) == 0x000008, "Wrong alignment on AFldScriptManagerCore");
static_assert(sizeof(AFldScriptManagerCore) == 0x0002B0, "Wrong size on AFldScriptManagerCore");
static_assert(offsetof(AFldScriptManagerCore, MAssetLoader_) == 0x000290, "Member 'AFldScriptManagerCore::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AFldScriptManagerCore, MBfAsset_) == 0x000298, "Member 'AFldScriptManagerCore::MBfAsset_' has a wrong offset!");
static_assert(offsetof(AFldScriptManagerCore, MBmdAsset_) == 0x0002A0, "Member 'AFldScriptManagerCore::MBmdAsset_' has a wrong offset!");
static_assert(offsetof(AFldScriptManagerCore, MScriptActor_) == 0x0002A8, "Member 'AFldScriptManagerCore::MScriptActor_' has a wrong offset!");

// Class xrd777.FldAutoRecoverMenuScript
// 0x0000 (0x02B0 - 0x02B0)
class AFldAutoRecoverMenuScript final : public AFldScriptManagerCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAutoRecoverMenuScript">();
	}
	static class AFldAutoRecoverMenuScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldAutoRecoverMenuScript>();
	}
};
static_assert(alignof(AFldAutoRecoverMenuScript) == 0x000008, "Wrong alignment on AFldAutoRecoverMenuScript");
static_assert(sizeof(AFldAutoRecoverMenuScript) == 0x0002B0, "Wrong size on AFldAutoRecoverMenuScript");

// Class xrd777.AtlEvtLevelSequenceActor
// 0x0098 (0x0340 - 0x02A8)
class AAtlEvtLevelSequenceActor final : public ALevelSequenceActor
{
public:
	EAtlLevelSequenceActorType                    AtlSequenceType;                                   // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFrameNumber>                   EvtDialogueTimeArray;                              // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlEvtLevelSequenceSound>      SoundAssetArray;                                   // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BankIDArray;                                       // 0x02D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FAtlEvtLevelSequenceEventVoice> EventVoiceAssetArray;                              // 0x02E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlEvtLevelSequenceEventSE>    EventSEAssetArray;                                 // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x4];                                      // 0x0308(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AtlFieldEventIndex;                                // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDOFInCamera;                                   // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0xF];                                      // 0x0319(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTickFromSequenceTickManager;                     // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHighSpeed(bool bEnable);
	void OnTickFromSequenceTickManager__DelegateSignature(const struct FQualifiedFrameTime& CurrentTime, const struct FQualifiedFrameTime& PreviousTime);
	void PreloadEvtDialogueTime(class UMovieSceneSequence* MovieSceneSequence, class UMovieSceneSubSection* CurrentSubSceneSection);

	bool IsCompletedLoadSoundAssets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLevelSequenceActor">();
	}
	static class AAtlEvtLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtLevelSequenceActor>();
	}
};
static_assert(alignof(AAtlEvtLevelSequenceActor) == 0x000008, "Wrong alignment on AAtlEvtLevelSequenceActor");
static_assert(sizeof(AAtlEvtLevelSequenceActor) == 0x000340, "Wrong size on AAtlEvtLevelSequenceActor");
static_assert(offsetof(AAtlEvtLevelSequenceActor, AtlSequenceType) == 0x0002A8, "Member 'AAtlEvtLevelSequenceActor::AtlSequenceType' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, EvtDialogueTimeArray) == 0x0002B0, "Member 'AAtlEvtLevelSequenceActor::EvtDialogueTimeArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, SoundAssetArray) == 0x0002C8, "Member 'AAtlEvtLevelSequenceActor::SoundAssetArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, BankIDArray) == 0x0002D8, "Member 'AAtlEvtLevelSequenceActor::BankIDArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, EventVoiceAssetArray) == 0x0002E8, "Member 'AAtlEvtLevelSequenceActor::EventVoiceAssetArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, EventSEAssetArray) == 0x0002F8, "Member 'AAtlEvtLevelSequenceActor::EventSEAssetArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, AtlFieldEventIndex) == 0x00030C, "Member 'AAtlEvtLevelSequenceActor::AtlFieldEventIndex' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, bUseDOFInCamera) == 0x000318, "Member 'AAtlEvtLevelSequenceActor::bUseDOFInCamera' has a wrong offset!");
static_assert(offsetof(AAtlEvtLevelSequenceActor, OnTickFromSequenceTickManager) == 0x000328, "Member 'AAtlEvtLevelSequenceActor::OnTickFromSequenceTickManager' has a wrong offset!");

// Class xrd777.AtlEvtLightScenarioSublevelsDataAsset
// 0x0030 (0x0060 - 0x0030)
class UAtlEvtLightScenarioSublevelsDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAtlEvtLightScenarioSublevel>   LightingIndexArray;                                // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlEvtAdditionBGSublevel>      AdditionBGSublevelArray;                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDisableAutoLoadFirstLightingScenarioLevel;        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDisableUseCurrentTimeZone;                   // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForceMonth;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceDay;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLightScenarioSublevelsDataAsset">();
	}
	static class UAtlEvtLightScenarioSublevelsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtLightScenarioSublevelsDataAsset>();
	}
};
static_assert(alignof(UAtlEvtLightScenarioSublevelsDataAsset) == 0x000008, "Wrong alignment on UAtlEvtLightScenarioSublevelsDataAsset");
static_assert(sizeof(UAtlEvtLightScenarioSublevelsDataAsset) == 0x000060, "Wrong size on UAtlEvtLightScenarioSublevelsDataAsset");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, LightingIndexArray) == 0x000030, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::LightingIndexArray' has a wrong offset!");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, AdditionBGSublevelArray) == 0x000040, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::AdditionBGSublevelArray' has a wrong offset!");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, bDisableAutoLoadFirstLightingScenarioLevel) == 0x000050, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::bDisableAutoLoadFirstLightingScenarioLevel' has a wrong offset!");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, bForceDisableUseCurrentTimeZone) == 0x000051, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::bForceDisableUseCurrentTimeZone' has a wrong offset!");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, ForceMonth) == 0x000054, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::ForceMonth' has a wrong offset!");
static_assert(offsetof(UAtlEvtLightScenarioSublevelsDataAsset, ForceDay) == 0x000058, "Member 'UAtlEvtLightScenarioSublevelsDataAsset::ForceDay' has a wrong offset!");

// Class xrd777.FldCrowdWalkManager
// 0x0040 (0x02C0 - 0x0280)
class AFldCrowdWalkManager final : public AFldLocalActor
{
public:
	uint32                                        MFlag_;                                            // 0x0280(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldCrowdWalkRouteTimer>        MRouteTimers_;                                     // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MMinTimer_;                                        // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMaxTimer_;                                        // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFldCrowdWalkRouteParam>        MRouteParam_;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldCrowdWalkBpParam>           MMobBpList_;                                       // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void SaveMobWalkInitTable(class UDataTable* InitTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdWalkManager">();
	}
	static class AFldCrowdWalkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCrowdWalkManager>();
	}
};
static_assert(alignof(AFldCrowdWalkManager) == 0x000008, "Wrong alignment on AFldCrowdWalkManager");
static_assert(sizeof(AFldCrowdWalkManager) == 0x0002C0, "Wrong size on AFldCrowdWalkManager");
static_assert(offsetof(AFldCrowdWalkManager, MFlag_) == 0x000280, "Member 'AFldCrowdWalkManager::MFlag_' has a wrong offset!");
static_assert(offsetof(AFldCrowdWalkManager, MRouteTimers_) == 0x000288, "Member 'AFldCrowdWalkManager::MRouteTimers_' has a wrong offset!");
static_assert(offsetof(AFldCrowdWalkManager, MMinTimer_) == 0x000298, "Member 'AFldCrowdWalkManager::MMinTimer_' has a wrong offset!");
static_assert(offsetof(AFldCrowdWalkManager, MMaxTimer_) == 0x00029C, "Member 'AFldCrowdWalkManager::MMaxTimer_' has a wrong offset!");
static_assert(offsetof(AFldCrowdWalkManager, MRouteParam_) == 0x0002A0, "Member 'AFldCrowdWalkManager::MRouteParam_' has a wrong offset!");
static_assert(offsetof(AFldCrowdWalkManager, MMobBpList_) == 0x0002B0, "Member 'AFldCrowdWalkManager::MMobBpList_' has a wrong offset!");

// Class xrd777.AtlEvtLightScenarioLoader
// 0x0010 (0x0288 - 0x0278)
class AAtlEvtLightScenarioLoader final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnLoadCompletedDelegate;                           // 0x0278(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnLoadCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLightScenarioLoader">();
	}
	static class AAtlEvtLightScenarioLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtLightScenarioLoader>();
	}
};
static_assert(alignof(AAtlEvtLightScenarioLoader) == 0x000008, "Wrong alignment on AAtlEvtLightScenarioLoader");
static_assert(sizeof(AAtlEvtLightScenarioLoader) == 0x000288, "Wrong size on AAtlEvtLightScenarioLoader");
static_assert(offsetof(AAtlEvtLightScenarioLoader, OnLoadCompletedDelegate) == 0x000278, "Member 'AAtlEvtLightScenarioLoader::OnLoadCompletedDelegate' has a wrong offset!");

// Class xrd777.AtlEvtLightScenarioUnloader
// 0x0010 (0x0288 - 0x0278)
class AAtlEvtLightScenarioUnloader final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnUnloadCompletedDelegate;                         // 0x0278(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnUnloadCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLightScenarioUnloader">();
	}
	static class AAtlEvtLightScenarioUnloader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtLightScenarioUnloader>();
	}
};
static_assert(alignof(AAtlEvtLightScenarioUnloader) == 0x000008, "Wrong alignment on AAtlEvtLightScenarioUnloader");
static_assert(sizeof(AAtlEvtLightScenarioUnloader) == 0x000288, "Wrong size on AAtlEvtLightScenarioUnloader");
static_assert(offsetof(AAtlEvtLightScenarioUnloader, OnUnloadCompletedDelegate) == 0x000278, "Member 'AAtlEvtLightScenarioUnloader::OnUnloadCompletedDelegate' has a wrong offset!");

// Class xrd777.UIMiscPictureDraw
// 0x0280 (0x0520 - 0x02A0)
class AUIMiscPictureDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pPicture;                                        // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x248];                                    // 0x02D8(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscPictureDraw">();
	}
	static class AUIMiscPictureDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscPictureDraw>();
	}
};
static_assert(alignof(AUIMiscPictureDraw) == 0x000008, "Wrong alignment on AUIMiscPictureDraw");
static_assert(sizeof(AUIMiscPictureDraw) == 0x000520, "Wrong size on AUIMiscPictureDraw");
static_assert(offsetof(AUIMiscPictureDraw, M_pLoader) == 0x0002C0, "Member 'AUIMiscPictureDraw::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIMiscPictureDraw, M_pSpr) == 0x0002C8, "Member 'AUIMiscPictureDraw::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscPictureDraw, M_pPicture) == 0x0002D0, "Member 'AUIMiscPictureDraw::M_pPicture' has a wrong offset!");

// Class xrd777.DatAssetOverWriteTable
// 0x0010 (0x0040 - 0x0030)
class UDatAssetOverWriteTable final : public UAppDataAsset
{
public:
	TArray<struct FDatAssetOverWriteDataTable>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAssetOverWriteTable">();
	}
	static class UDatAssetOverWriteTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAssetOverWriteTable>();
	}
};
static_assert(alignof(UDatAssetOverWriteTable) == 0x000008, "Wrong alignment on UDatAssetOverWriteTable");
static_assert(sizeof(UDatAssetOverWriteTable) == 0x000040, "Wrong size on UDatAssetOverWriteTable");
static_assert(offsetof(UDatAssetOverWriteTable, Data) == 0x000030, "Member 'UDatAssetOverWriteTable::Data' has a wrong offset!");

// Class xrd777.AtlEvtLightScenarioTransitionController
// 0x0070 (0x02E8 - 0x0278)
class AAtlEvtLightScenarioTransitionController final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnUnloadCompletedDelegate;                         // 0x0278(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlEvtLightScenarioSublevelParam> LightScenarioSublevelParamArray;                   // 0x0290(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AAtlEvtLightScenarioLoader*             LoaderActor;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAtlEvtLightScenarioUnloader*           UnloaderActor;                                     // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetLoader*                           PAssetLoader;                                      // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddLightScenario(class FName LevelName);
	void OnCompletedPreload();
	void OnLoadFinished(int32 Index_0);
	void OnUnloadFinished(int32 Index_0);
	void RemoveAllLightScenarioParam();
	void TransitionLightScenario(int32 InNextLightScenarioIndex);

	int32 GetLightScenarioNum() const;
	bool IsDoingTransition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtLightScenarioTransitionController">();
	}
	static class AAtlEvtLightScenarioTransitionController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtLightScenarioTransitionController>();
	}
};
static_assert(alignof(AAtlEvtLightScenarioTransitionController) == 0x000008, "Wrong alignment on AAtlEvtLightScenarioTransitionController");
static_assert(sizeof(AAtlEvtLightScenarioTransitionController) == 0x0002E8, "Wrong size on AAtlEvtLightScenarioTransitionController");
static_assert(offsetof(AAtlEvtLightScenarioTransitionController, OnUnloadCompletedDelegate) == 0x000278, "Member 'AAtlEvtLightScenarioTransitionController::OnUnloadCompletedDelegate' has a wrong offset!");
static_assert(offsetof(AAtlEvtLightScenarioTransitionController, LightScenarioSublevelParamArray) == 0x000290, "Member 'AAtlEvtLightScenarioTransitionController::LightScenarioSublevelParamArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtLightScenarioTransitionController, LoaderActor) == 0x0002C0, "Member 'AAtlEvtLightScenarioTransitionController::LoaderActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtLightScenarioTransitionController, UnloaderActor) == 0x0002C8, "Member 'AAtlEvtLightScenarioTransitionController::UnloaderActor' has a wrong offset!");
static_assert(offsetof(AAtlEvtLightScenarioTransitionController, PAssetLoader) == 0x0002D0, "Member 'AAtlEvtLightScenarioTransitionController::PAssetLoader' has a wrong offset!");

// Class xrd777.AtlEvtMoviePlayManager
// 0x0040 (0x0068 - 0x0028)
class UAtlEvtMoviePlayManager final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtMoviePlayManager">();
	}
	static class UAtlEvtMoviePlayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtMoviePlayManager>();
	}
};
static_assert(alignof(UAtlEvtMoviePlayManager) == 0x000008, "Wrong alignment on UAtlEvtMoviePlayManager");
static_assert(sizeof(UAtlEvtMoviePlayManager) == 0x000068, "Wrong size on UAtlEvtMoviePlayManager");

// Class xrd777.UIMiniMapDraw
// 0xF8A0 (0xF8C8 - 0x0028)
class UUIMiniMapDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pMiniMapIcon00Spr;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pMiniMapIcon01Spr;                               // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pMiniMapIcon00SprAstrea;                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pMiniMapIcon01SprAstrea;                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pPartMaskSpr;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pNoiseSpr;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               M_pMapTex;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               M_pPrevMapTex1;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               M_pPrevMapTex2;                                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               M_pPrevMapTex3;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              M_pVelvetRoomIconMat;                              // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pVelvetRoomIconMID;                              // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMiniMapIconListTable*                  M_pFldMiniMapIconTable;                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           M_pIconLoader;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           M_pMapLoader;                                      // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMiniMapAssetLoader*>            M_pMapLoaders;                                     // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x598];                                     // 0x00F0(0x0598)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_GoalIconOffsetParam;                             // 0x0688(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_700[0xEBE8];                                   // 0x0700(0xEBE8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               M_pMapParts[0x82];                                 // 0xF2E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               M_pWallTex;                                        // 0xF6F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldDungeonPartVariationDataAsset*      M_pPartVariationDataAsset;                         // 0xF700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F708[0xF0];                                    // 0xF708(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pSchoolUpDownLayoutData;                         // 0xF7F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pSchoolUpDownLayoutDataTable;                    // 0xF800(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pDormitoryUpDownLayoutData;                      // 0xF808(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pDormitoryUpDownLayoutDataTable;                 // 0xF810(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pArcadeUpDownLayoutData;                         // 0xF818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pArcadeUpDownLayoutDataTable;                    // 0xF820(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pMallUpDownLayoutData;                           // 0xF828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pMallUpDownLayoutDataTable;                      // 0xF830(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pClubUpDownLayoutData;                           // 0xF838(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pClubUpDownLayoutDataTable;                      // 0xF840(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pRyokanUpDownLayoutData;                         // 0xF848(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pRyokanUpDownLayoutDataTable;                    // 0xF850(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pHotelUpDownLayoutData;                          // 0xF858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pHotelUpDownLayoutDataTable;                     // 0xF860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pDungeonUpDownLayoutData;                        // 0xF868(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pDungeonUpDownLayoutDataTable;                   // 0xF870(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     M_pDungeonUpDownLayoutDataAstrea;                  // 0xF878(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUILayoutDataTable*>             M_pDungeonUpDownLayoutDataTableAstrea;             // 0xF888(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pIconLayoutData;                                 // 0xF898(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pIconLayoutDataTable;                            // 0xF8A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8A8[0x20];                                    // 0xF8A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Completed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMapDraw">();
	}
	static class UUIMiniMapDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMapDraw>();
	}
};
static_assert(alignof(UUIMiniMapDraw) == 0x000008, "Wrong alignment on UUIMiniMapDraw");
static_assert(sizeof(UUIMiniMapDraw) == 0x00F8C8, "Wrong size on UUIMiniMapDraw");
static_assert(offsetof(UUIMiniMapDraw, M_pMiniMapIcon00Spr) == 0x000068, "Member 'UUIMiniMapDraw::M_pMiniMapIcon00Spr' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMiniMapIcon01Spr) == 0x000070, "Member 'UUIMiniMapDraw::M_pMiniMapIcon01Spr' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMiniMapIcon00SprAstrea) == 0x000078, "Member 'UUIMiniMapDraw::M_pMiniMapIcon00SprAstrea' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMiniMapIcon01SprAstrea) == 0x000080, "Member 'UUIMiniMapDraw::M_pMiniMapIcon01SprAstrea' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pPartMaskSpr) == 0x000088, "Member 'UUIMiniMapDraw::M_pPartMaskSpr' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pNoiseSpr) == 0x000090, "Member 'UUIMiniMapDraw::M_pNoiseSpr' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMapTex) == 0x000098, "Member 'UUIMiniMapDraw::M_pMapTex' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pPrevMapTex1) == 0x0000A0, "Member 'UUIMiniMapDraw::M_pPrevMapTex1' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pPrevMapTex2) == 0x0000A8, "Member 'UUIMiniMapDraw::M_pPrevMapTex2' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pPrevMapTex3) == 0x0000B0, "Member 'UUIMiniMapDraw::M_pPrevMapTex3' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pVelvetRoomIconMat) == 0x0000B8, "Member 'UUIMiniMapDraw::M_pVelvetRoomIconMat' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pVelvetRoomIconMID) == 0x0000C0, "Member 'UUIMiniMapDraw::M_pVelvetRoomIconMID' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pFldMiniMapIconTable) == 0x0000C8, "Member 'UUIMiniMapDraw::M_pFldMiniMapIconTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pIconLoader) == 0x0000D0, "Member 'UUIMiniMapDraw::M_pIconLoader' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMapLoader) == 0x0000D8, "Member 'UUIMiniMapDraw::M_pMapLoader' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMapLoaders) == 0x0000E0, "Member 'UUIMiniMapDraw::M_pMapLoaders' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_GoalIconOffsetParam) == 0x000688, "Member 'UUIMiniMapDraw::M_GoalIconOffsetParam' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMapParts) == 0x00F2E8, "Member 'UUIMiniMapDraw::M_pMapParts' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pWallTex) == 0x00F6F8, "Member 'UUIMiniMapDraw::M_pWallTex' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pPartVariationDataAsset) == 0x00F700, "Member 'UUIMiniMapDraw::M_pPartVariationDataAsset' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pSchoolUpDownLayoutData) == 0x00F7F8, "Member 'UUIMiniMapDraw::M_pSchoolUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pSchoolUpDownLayoutDataTable) == 0x00F800, "Member 'UUIMiniMapDraw::M_pSchoolUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDormitoryUpDownLayoutData) == 0x00F808, "Member 'UUIMiniMapDraw::M_pDormitoryUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDormitoryUpDownLayoutDataTable) == 0x00F810, "Member 'UUIMiniMapDraw::M_pDormitoryUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pArcadeUpDownLayoutData) == 0x00F818, "Member 'UUIMiniMapDraw::M_pArcadeUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pArcadeUpDownLayoutDataTable) == 0x00F820, "Member 'UUIMiniMapDraw::M_pArcadeUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMallUpDownLayoutData) == 0x00F828, "Member 'UUIMiniMapDraw::M_pMallUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pMallUpDownLayoutDataTable) == 0x00F830, "Member 'UUIMiniMapDraw::M_pMallUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pClubUpDownLayoutData) == 0x00F838, "Member 'UUIMiniMapDraw::M_pClubUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pClubUpDownLayoutDataTable) == 0x00F840, "Member 'UUIMiniMapDraw::M_pClubUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pRyokanUpDownLayoutData) == 0x00F848, "Member 'UUIMiniMapDraw::M_pRyokanUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pRyokanUpDownLayoutDataTable) == 0x00F850, "Member 'UUIMiniMapDraw::M_pRyokanUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pHotelUpDownLayoutData) == 0x00F858, "Member 'UUIMiniMapDraw::M_pHotelUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pHotelUpDownLayoutDataTable) == 0x00F860, "Member 'UUIMiniMapDraw::M_pHotelUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDungeonUpDownLayoutData) == 0x00F868, "Member 'UUIMiniMapDraw::M_pDungeonUpDownLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDungeonUpDownLayoutDataTable) == 0x00F870, "Member 'UUIMiniMapDraw::M_pDungeonUpDownLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDungeonUpDownLayoutDataAstrea) == 0x00F878, "Member 'UUIMiniMapDraw::M_pDungeonUpDownLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pDungeonUpDownLayoutDataTableAstrea) == 0x00F888, "Member 'UUIMiniMapDraw::M_pDungeonUpDownLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pIconLayoutData) == 0x00F898, "Member 'UUIMiniMapDraw::M_pIconLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMiniMapDraw, M_pIconLayoutDataTable) == 0x00F8A0, "Member 'UUIMiniMapDraw::M_pIconLayoutDataTable' has a wrong offset!");

// Class xrd777.EvtTextureForOnePicture
// 0x0018 (0x0040 - 0x0028)
class UEvtTextureForOnePicture final : public UObject
{
public:
	class UTexture2D*                             Texture;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           AssetLoader;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtTextureForOnePicture">();
	}
	static class UEvtTextureForOnePicture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtTextureForOnePicture>();
	}
};
static_assert(alignof(UEvtTextureForOnePicture) == 0x000008, "Wrong alignment on UEvtTextureForOnePicture");
static_assert(sizeof(UEvtTextureForOnePicture) == 0x000040, "Wrong size on UEvtTextureForOnePicture");
static_assert(offsetof(UEvtTextureForOnePicture, Texture) == 0x000028, "Member 'UEvtTextureForOnePicture::Texture' has a wrong offset!");
static_assert(offsetof(UEvtTextureForOnePicture, AssetLoader) == 0x000030, "Member 'UEvtTextureForOnePicture::AssetLoader' has a wrong offset!");

// Class xrd777.FldCharAccessIconMngComp
// 0x0010 (0x00D8 - 0x00C8)
class UFldCharAccessIconMngComp final : public UFldLocalActorComp
{
public:
	class UAppCharBaseComp*                       MCharaBaseComp_;                                   // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MIconActor_;                                       // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharAccessIconMngComp">();
	}
	static class UFldCharAccessIconMngComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharAccessIconMngComp>();
	}
};
static_assert(alignof(UFldCharAccessIconMngComp) == 0x000008, "Wrong alignment on UFldCharAccessIconMngComp");
static_assert(sizeof(UFldCharAccessIconMngComp) == 0x0000D8, "Wrong size on UFldCharAccessIconMngComp");
static_assert(offsetof(UFldCharAccessIconMngComp, MCharaBaseComp_) == 0x0000C8, "Member 'UFldCharAccessIconMngComp::MCharaBaseComp_' has a wrong offset!");
static_assert(offsetof(UFldCharAccessIconMngComp, MIconActor_) == 0x0000D0, "Member 'UFldCharAccessIconMngComp::MIconActor_' has a wrong offset!");

// Class xrd777.UIScene
// 0x0018 (0x0040 - 0x0028)
class UUIScene : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScene">();
	}
	static class UUIScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScene>();
	}
};
static_assert(alignof(UUIScene) == 0x000008, "Wrong alignment on UUIScene");
static_assert(sizeof(UUIScene) == 0x000040, "Wrong size on UUIScene");

// Class xrd777.CmpCommuDetails
// 0x0928 (0x0968 - 0x0040)
class UCmpCommuDetails final : public UUIScene
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpCommu*                            Context_;                                          // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x848];                                     // 0x0068(0x0848)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpCommu*                            PParent;                                           // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x08B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C0[0xA8];                                     // 0x08C0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCommuDetails">();
	}
	static class UCmpCommuDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCommuDetails>();
	}
};
static_assert(alignof(UCmpCommuDetails) == 0x000008, "Wrong alignment on UCmpCommuDetails");
static_assert(sizeof(UCmpCommuDetails) == 0x000968, "Wrong size on UCmpCommuDetails");
static_assert(offsetof(UCmpCommuDetails, Context_) == 0x000060, "Member 'UCmpCommuDetails::Context_' has a wrong offset!");
static_assert(offsetof(UCmpCommuDetails, PParent) == 0x0008B0, "Member 'UCmpCommuDetails::PParent' has a wrong offset!");
static_assert(offsetof(UCmpCommuDetails, PMainActor) == 0x0008B8, "Member 'UCmpCommuDetails::PMainActor' has a wrong offset!");

// Class xrd777.AtlEvtOnePicture
// 0x0030 (0x0250 - 0x0220)
class AAtlEvtOnePicture final : public AActor
{
public:
	TArray<class UEvtTextureForOnePicture*>       TextureArray;                                      // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterial*                              Material;                                          // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           AssetLoader;                                       // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtOnePicture">();
	}
	static class AAtlEvtOnePicture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtOnePicture>();
	}
};
static_assert(alignof(AAtlEvtOnePicture) == 0x000008, "Wrong alignment on AAtlEvtOnePicture");
static_assert(sizeof(AAtlEvtOnePicture) == 0x000250, "Wrong size on AAtlEvtOnePicture");
static_assert(offsetof(AAtlEvtOnePicture, TextureArray) == 0x000220, "Member 'AAtlEvtOnePicture::TextureArray' has a wrong offset!");
static_assert(offsetof(AAtlEvtOnePicture, Material) == 0x000230, "Member 'AAtlEvtOnePicture::Material' has a wrong offset!");
static_assert(offsetof(AAtlEvtOnePicture, DynamicMaterial) == 0x000238, "Member 'AAtlEvtOnePicture::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(AAtlEvtOnePicture, AssetLoader) == 0x000240, "Member 'AAtlEvtOnePicture::AssetLoader' has a wrong offset!");

// Class xrd777.FldCameraBehaviorBase
// 0x0018 (0x00C8 - 0x00B0)
class UFldCameraBehaviorBase : public UActorComponent
{
public:
	class AFldCameraBase*                         BaseOwner;                                         // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldCameraForwardType                         ForwardType;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FreeForward;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraBehaviorBase">();
	}
	static class UFldCameraBehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraBehaviorBase>();
	}
};
static_assert(alignof(UFldCameraBehaviorBase) == 0x000008, "Wrong alignment on UFldCameraBehaviorBase");
static_assert(sizeof(UFldCameraBehaviorBase) == 0x0000C8, "Wrong size on UFldCameraBehaviorBase");
static_assert(offsetof(UFldCameraBehaviorBase, BaseOwner) == 0x0000B0, "Member 'UFldCameraBehaviorBase::BaseOwner' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorBase, ForwardType) == 0x0000B8, "Member 'UFldCameraBehaviorBase::ForwardType' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorBase, FreeForward) == 0x0000C0, "Member 'UFldCameraBehaviorBase::FreeForward' has a wrong offset!");

// Class xrd777.FldCameraBehaviorFree
// 0x01A8 (0x0270 - 0x00C8)
class UFldCameraBehaviorFree final : public UFldCameraBehaviorBase
{
public:
	class AFldCameraFree*                         DrivedOwner;                                       // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPlayerHolder                       Player;                                            // 0x00D0(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLdCameraRotParam                      YawParam;                                          // 0x00E8(0x001C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLdCameraRotParam                      PitchParam;                                        // 0x0104(0x001C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLdCameraCorrectionParam               CorrectionParam;                                   // 0x0120(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLdCameraSlopeParam                    SlopeParam;                                        // 0x0140(0x0024)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FarLength;                                         // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearLength;                                        // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x016C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomTime;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialPitch;                                      // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultMoveSpeed;                                  // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalFov;                                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashFov;                                           // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FovAnimSpeed;                                      // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtrusionSpeed;                                    // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpLimitBegin;                                      // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpLimitEnd;                                        // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpLimitLength;                                     // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                UpLimitOffset;                                     // 0x01A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownLimitBegin;                                    // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownLimitEnd;                                      // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownLimitLength;                                   // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DownLimitOffset;                                   // 0x01B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlurAmount;                                        // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PushOutOffset;                                     // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC[0x54];                                     // 0x01CC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	EFldCameraBehaviorFreeState                   State;                                             // 0x0220(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldCameraBehaviorFreeState                   NextState;                                         // 0x0224(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StoredInput;                                       // 0x0228(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimTime;                                          // 0x0234(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLdCameraParam                         ResetParam;                                        // 0x0238(0x001C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bResetDirectionOnce;                               // 0x0254(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x1B];                                     // 0x0255(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraBehaviorFree">();
	}
	static class UFldCameraBehaviorFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraBehaviorFree>();
	}
};
static_assert(alignof(UFldCameraBehaviorFree) == 0x000008, "Wrong alignment on UFldCameraBehaviorFree");
static_assert(sizeof(UFldCameraBehaviorFree) == 0x000270, "Wrong size on UFldCameraBehaviorFree");
static_assert(offsetof(UFldCameraBehaviorFree, DrivedOwner) == 0x0000C8, "Member 'UFldCameraBehaviorFree::DrivedOwner' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, Player) == 0x0000D0, "Member 'UFldCameraBehaviorFree::Player' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, YawParam) == 0x0000E8, "Member 'UFldCameraBehaviorFree::YawParam' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, PitchParam) == 0x000104, "Member 'UFldCameraBehaviorFree::PitchParam' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, CorrectionParam) == 0x000120, "Member 'UFldCameraBehaviorFree::CorrectionParam' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, SlopeParam) == 0x000140, "Member 'UFldCameraBehaviorFree::SlopeParam' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, FarLength) == 0x000164, "Member 'UFldCameraBehaviorFree::FarLength' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, NearLength) == 0x000168, "Member 'UFldCameraBehaviorFree::NearLength' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, Offset) == 0x00016C, "Member 'UFldCameraBehaviorFree::Offset' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, ZoomTime) == 0x000178, "Member 'UFldCameraBehaviorFree::ZoomTime' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, InitialPitch) == 0x00017C, "Member 'UFldCameraBehaviorFree::InitialPitch' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DefaultMoveSpeed) == 0x000180, "Member 'UFldCameraBehaviorFree::DefaultMoveSpeed' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, NormalFov) == 0x000184, "Member 'UFldCameraBehaviorFree::NormalFov' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DashFov) == 0x000188, "Member 'UFldCameraBehaviorFree::DashFov' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, FovAnimSpeed) == 0x00018C, "Member 'UFldCameraBehaviorFree::FovAnimSpeed' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, ExtrusionSpeed) == 0x000190, "Member 'UFldCameraBehaviorFree::ExtrusionSpeed' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, UpLimitBegin) == 0x000194, "Member 'UFldCameraBehaviorFree::UpLimitBegin' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, UpLimitEnd) == 0x000198, "Member 'UFldCameraBehaviorFree::UpLimitEnd' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, UpLimitLength) == 0x00019C, "Member 'UFldCameraBehaviorFree::UpLimitLength' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, UpLimitOffset) == 0x0001A0, "Member 'UFldCameraBehaviorFree::UpLimitOffset' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DownLimitBegin) == 0x0001AC, "Member 'UFldCameraBehaviorFree::DownLimitBegin' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DownLimitEnd) == 0x0001B0, "Member 'UFldCameraBehaviorFree::DownLimitEnd' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DownLimitLength) == 0x0001B4, "Member 'UFldCameraBehaviorFree::DownLimitLength' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, DownLimitOffset) == 0x0001B8, "Member 'UFldCameraBehaviorFree::DownLimitOffset' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, BlurAmount) == 0x0001C4, "Member 'UFldCameraBehaviorFree::BlurAmount' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, PushOutOffset) == 0x0001C8, "Member 'UFldCameraBehaviorFree::PushOutOffset' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, State) == 0x000220, "Member 'UFldCameraBehaviorFree::State' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, NextState) == 0x000224, "Member 'UFldCameraBehaviorFree::NextState' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, StoredInput) == 0x000228, "Member 'UFldCameraBehaviorFree::StoredInput' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, AnimTime) == 0x000234, "Member 'UFldCameraBehaviorFree::AnimTime' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, ResetParam) == 0x000238, "Member 'UFldCameraBehaviorFree::ResetParam' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFree, bResetDirectionOnce) == 0x000254, "Member 'UFldCameraBehaviorFree::bResetDirectionOnce' has a wrong offset!");

// Class xrd777.AtlEvtPreDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAtlEvtPreDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAtlEvtPreData>                 Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtPreDataAsset">();
	}
	static class UAtlEvtPreDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtPreDataAsset>();
	}
};
static_assert(alignof(UAtlEvtPreDataAsset) == 0x000008, "Wrong alignment on UAtlEvtPreDataAsset");
static_assert(sizeof(UAtlEvtPreDataAsset) == 0x000040, "Wrong size on UAtlEvtPreDataAsset");
static_assert(offsetof(UAtlEvtPreDataAsset, Data) == 0x000030, "Member 'UAtlEvtPreDataAsset::Data' has a wrong offset!");

// Class xrd777.AtlEvtPropDetachLocator
// 0x0000 (0x0278 - 0x0278)
class AAtlEvtPropDetachLocator final : public AAppActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtPropDetachLocator">();
	}
	static class AAtlEvtPropDetachLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtPropDetachLocator>();
	}
};
static_assert(alignof(AAtlEvtPropDetachLocator) == 0x000008, "Wrong alignment on AAtlEvtPropDetachLocator");
static_assert(sizeof(AAtlEvtPropDetachLocator) == 0x000278, "Wrong size on AAtlEvtPropDetachLocator");

// Class xrd777.AtlEvtSubsystem
// 0x02C0 (0x02F0 - 0x0030)
class UAtlEvtSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<uint32, struct FAtlEvtPlayingCharacterInfo> AppEvtCharactersMap;                               // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, struct FAtlEvtPlayingCharacterInfo> AppEvtLipUniqueIDCharactersMap;                    // 0x0080(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FAtlEvtSoundSEInfo>             EventSEInfoArray;                                  // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AAtlEvtLightScenarioTransitionController* LightScenarioTransitionController;                 // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEvtLocalData                          EvtLocalData;                                      // 0x00E8(0x0010)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class UAssetLoader*                           PLSAssetLoader;                                    // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                LevelSequenceObject;                               // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlaySequencerDelegate;                           // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedDelegate;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnForceFinishedDelegate;                           // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEvtHighSpeedDelegate;                            // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAtlEvtPreDataAsset*                    EvtPreDataAsset;                                   // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint32, struct FAtlEvtPreData>           EvtPreDataMap;                                     // 0x0150(0x0050)(NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UWorld>                  EventSublevelWorldObjPtr;                          // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlEvtPlayLoadSublevelInfo>    LoadedEventSublevelInfos;                          // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0xA8];                                     // 0x01C8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CurrentLoadedEventSublevels;                       // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlEvtAssetOverrideParameter>  ReserveAssetOverrideParameter;                     // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetOverrideLoader;                               // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacter>                 AssetOverrideSubClass;                             // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BagActor;                                          // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAtlEvtOnePicture*                      OnePicture;                                        // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetOT(const struct FColor& Color);

	void CallCategoryEvent(class UObject* WorldContextObject, EAtlEvtEventCategoryType CategoryType, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	void CallEvent(class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	void CallEvent_DecrementFieldLoadingCount();
	void CallEvent_InternalFinishedEvent(int32 Value);
	class AAtlEvtPlayObject* CallEvent_SpawnLoadSublevelActor(class UWorld* World, class FName* StreamTargetLevelName, const struct FAtlEvtPlayParameter& Param, struct FAtlEvtPreData* PreData, EAtlEvtSublevelType SublevelType, struct FLatentActionInfo* LatentInfo, class UObject* WorldContextObject);
	void CallEventCmmu(class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	void CallEventField(class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	void DateOffDelegate(int32 Idx);
	void EvtPlay(const class UObject* WorldContextObject, const class FString& EvtName, const class FString& InEventRank, const struct FAtlEvtPlayParameter& Param);
	void InitScriptFinishFunction(int32 ExitType);
	bool IsConditionalBranchFromLocalData(EEvtConditionalBranchCompType CompType, int32 LHS, int32 Index_0);
	TArray<class FString> MakeFieldSublevelPathList(const class UObject* WorldContextObject, EAtlEvtEventCategoryType CategoryType, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	TArray<class FString> MakeFieldSublevelPathListCmmu(const class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	TArray<class FString> MakeFieldSublevelPathListEvent(const class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	TArray<class FString> MakeFieldSublevelPathListField(const class UObject* WorldContextObject, int32 EventMajorID, int32 EventMinorID, const struct FAtlEvtPlayParameter& Param);
	void OnActorSpawnedEventSublevel(class AActor* SpawnedActor);
	void ResetLocalData();
	void SetEventPlayMode(EAtlEvtPlayMode InPlayMode);
	void SetLocalData(int32 Index_0, int32 Data);
	void SetShowCinemaScope(bool bShow);
	void TransitionLightScenarioSublevel(int32 NextLightScenarioIndex);

	bool CallEvent_IsCompleteFieldLoadingSublevel() const;
	struct FAtlEvtPlayingCharacterInfo GetAppEventCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID) const;
	uint32 GetAppEvtCharactersHash(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID) const;
	EAtlEvtPlayMode GetEventPlayMode() const;
	struct FAtlEvtPreData GetEvtPreData(EAtlEvtEventCategoryType CategoryType, int32 EventMajorID, int32 EventMinorID) const;
	uint32 GetEvtPreDataHash(EAtlEvtEventCategoryType CategoryType, int32 EventMajorID, int32 EventMinorID) const;
	class AActor* GetFirstAppEventCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID) const;
	class AActor* GetFirstAppEventCharacterByLipUniqueID(int32 LipUniqueID) const;
	const TArray<struct FAtlEvtPlayLoadSublevelInfo> GetLoadedEventSublevelInfos() const;
	int32 GetLocalData(int32 Index_0) const;
	struct FAtlEvtVisibleEventInfo GetPlayingVisibleEventInfo(const class UObject* WorldContextObject) const;
	bool IsDoingTransitionLightScenarioSublevel() const;
	bool IsEventPlayModeEditHelper() const;
	bool IsFinishedPreloadLightScenarioSublevels() const;
	bool IsHighSpeed() const;
	bool IsPlayingEvent() const;
	bool IsPlayingEventOrEditHelperMode() const;
	bool IsShowCinemaScope() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtSubsystem">();
	}
	static class UAtlEvtSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtSubsystem>();
	}
};
static_assert(alignof(UAtlEvtSubsystem) == 0x000008, "Wrong alignment on UAtlEvtSubsystem");
static_assert(sizeof(UAtlEvtSubsystem) == 0x0002F0, "Wrong size on UAtlEvtSubsystem");
static_assert(offsetof(UAtlEvtSubsystem, AppEvtCharactersMap) == 0x000030, "Member 'UAtlEvtSubsystem::AppEvtCharactersMap' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, AppEvtLipUniqueIDCharactersMap) == 0x000080, "Member 'UAtlEvtSubsystem::AppEvtLipUniqueIDCharactersMap' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, EventSEInfoArray) == 0x0000D0, "Member 'UAtlEvtSubsystem::EventSEInfoArray' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, LightScenarioTransitionController) == 0x0000E0, "Member 'UAtlEvtSubsystem::LightScenarioTransitionController' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, EvtLocalData) == 0x0000E8, "Member 'UAtlEvtSubsystem::EvtLocalData' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, PLSAssetLoader) == 0x0000F8, "Member 'UAtlEvtSubsystem::PLSAssetLoader' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, LevelSequenceObject) == 0x000100, "Member 'UAtlEvtSubsystem::LevelSequenceObject' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, OnPlaySequencerDelegate) == 0x000108, "Member 'UAtlEvtSubsystem::OnPlaySequencerDelegate' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, OnFinishedDelegate) == 0x000118, "Member 'UAtlEvtSubsystem::OnFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, OnForceFinishedDelegate) == 0x000128, "Member 'UAtlEvtSubsystem::OnForceFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, OnEvtHighSpeedDelegate) == 0x000138, "Member 'UAtlEvtSubsystem::OnEvtHighSpeedDelegate' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, EvtPreDataAsset) == 0x000148, "Member 'UAtlEvtSubsystem::EvtPreDataAsset' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, EvtPreDataMap) == 0x000150, "Member 'UAtlEvtSubsystem::EvtPreDataMap' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, EventSublevelWorldObjPtr) == 0x0001A0, "Member 'UAtlEvtSubsystem::EventSublevelWorldObjPtr' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, LoadedEventSublevelInfos) == 0x0001B8, "Member 'UAtlEvtSubsystem::LoadedEventSublevelInfos' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, CurrentLoadedEventSublevels) == 0x000270, "Member 'UAtlEvtSubsystem::CurrentLoadedEventSublevels' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, ReserveAssetOverrideParameter) == 0x000280, "Member 'UAtlEvtSubsystem::ReserveAssetOverrideParameter' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, AssetOverrideLoader) == 0x000298, "Member 'UAtlEvtSubsystem::AssetOverrideLoader' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, AssetOverrideSubClass) == 0x0002A0, "Member 'UAtlEvtSubsystem::AssetOverrideSubClass' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, BagActor) == 0x0002C8, "Member 'UAtlEvtSubsystem::BagActor' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystem, OnePicture) == 0x0002D0, "Member 'UAtlEvtSubsystem::OnePicture' has a wrong offset!");

// Class xrd777.FldDoorPointComp
// 0x0000 (0x0200 - 0x0200)
class UFldDoorPointComp final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDoorPointComp">();
	}
	static class UFldDoorPointComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDoorPointComp>();
	}
};
static_assert(alignof(UFldDoorPointComp) == 0x000010, "Wrong alignment on UFldDoorPointComp");
static_assert(sizeof(UFldDoorPointComp) == 0x000200, "Wrong size on UFldDoorPointComp");

// Class xrd777.UINameEntryDraw
// 0x00A8 (0x0360 - 0x02B8)
class AUINameEntryDraw final : public AUIDrawBaseActor
{
public:
	FMulticastInlineDelegateProperty_             OnKeyEvent;                                        // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStartInAnim;                                    // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInAnim;                                   // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutAnim;                                   // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutAnim;                                  // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKeyOutAnim;                                     // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnSceneOptionAnim;                            // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              SprData;                                           // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OffStartFrame;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InFirstStartFrame;                                 // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InSecondStartFrame;                                // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InThirdStartFrame;                                 // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InFourthStartFrame;                                // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InFirstEndFrame;                                   // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InSecondEndFrame;                                  // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InThirdEndFrame;                                   // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InFourthEndFrame;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutFirstStartFrame;                                // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutSecondStartFrame;                               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutFirstEndFrame;                                  // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutSecondEndFrame;                                 // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x44];                                     // 0x0314(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float ConvFrameToTime(int32 InFrame);
	void DrawBlueLight(const struct FVector2D& InPos, const struct FColor& InColor);
	void DrawCursor1(const struct FVector2D& InPos, const struct FColor& InColor);
	void DrawGradationScreen(const struct FVector2D& InPos, const struct FColor& InColor);
	void DrawName1Text(const struct FVector2D& InPos, const struct FColor& InColor, const struct FColor& InColorDown, const struct FColor& InColorUp);
	void DrawName2Text(const struct FVector2D& InPos, const struct FColor& InColor, const struct FColor& InColorDown, const struct FColor& InColorUp);
	void DrawOptions(const struct FVector2D& InPos, const struct FColor& InColor, const struct FVector2D& Scale, float Angle, EUI_DRAW_POINT DrawPoint);
	void DrawOptionsBase(const struct FVector2D& InPos, const struct FColor& InColor, const struct FVector2D& Scale, float Angle, EUI_DRAW_POINT DrawPoint);
	void DrawTranslation(const struct FVector2D& InPos, const struct FColor& InColor);
	struct FVector2D GetAdjustedLayoutPosition(EUINameEntryLayout InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D GetAdjustedLayoutScale(EUINameEntryLayout InLayoutId, const struct FVector2D& InDefaultScale);
	bool InitDraw_IN();
	bool InitDraw_Out();
	bool IsAllNameEntered();
	bool IsCursorName1Use();
	bool IsCursorName2Use();
	bool IsCursorPreName1Use();
	bool IsCursorPreName2Use();
	bool IsEnableOption();
	bool IsIsDeterminedByCross();
	bool IsKeyHelpGray();
	bool IsName1Entered();
	bool IsName1TypingOnKeyboard();
	bool IsName2Entered();
	bool IsName2TypingOnKeyboard();
	bool KeyHelpIn();
	bool KeyHelpOut();
	void OneTimeLockInput();
	void PlaySENameEntry();
	bool ResetDraw();
	void SetDicitionTouchCollision(const struct FVector2D& InDicitionPos, const struct FVector2D& OptionScale, const struct FVector2D& DicitionScale, EUI_DRAW_POINT DrawPoint);
	void SetNameTouchCollision(const struct FVector2D& InName1Pos, const struct FVector2D& InName2Pos);
	bool StateDraw_BG();
	bool StateDraw_Frame();
	bool StateDraw_IN();
	bool StateDraw_Out();
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINameEntryDraw">();
	}
	static class AUINameEntryDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUINameEntryDraw>();
	}
};
static_assert(alignof(AUINameEntryDraw) == 0x000008, "Wrong alignment on AUINameEntryDraw");
static_assert(sizeof(AUINameEntryDraw) == 0x000360, "Wrong size on AUINameEntryDraw");
static_assert(offsetof(AUINameEntryDraw, OnKeyEvent) == 0x0002B8, "Member 'AUINameEntryDraw::OnKeyEvent' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bIsStartInAnim) == 0x0002D0, "Member 'AUINameEntryDraw::bIsStartInAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bIsFinishInAnim) == 0x0002D1, "Member 'AUINameEntryDraw::bIsFinishInAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bIsStartOutAnim) == 0x0002D2, "Member 'AUINameEntryDraw::bIsStartOutAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bIsFinishOutAnim) == 0x0002D3, "Member 'AUINameEntryDraw::bIsFinishOutAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bIsKeyOutAnim) == 0x0002D4, "Member 'AUINameEntryDraw::bIsKeyOutAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, bReturnSceneOptionAnim) == 0x0002D5, "Member 'AUINameEntryDraw::bReturnSceneOptionAnim' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, SprData) == 0x0002D8, "Member 'AUINameEntryDraw::SprData' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, OffStartFrame) == 0x0002E0, "Member 'AUINameEntryDraw::OffStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InFirstStartFrame) == 0x0002E4, "Member 'AUINameEntryDraw::InFirstStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InSecondStartFrame) == 0x0002E8, "Member 'AUINameEntryDraw::InSecondStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InThirdStartFrame) == 0x0002EC, "Member 'AUINameEntryDraw::InThirdStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InFourthStartFrame) == 0x0002F0, "Member 'AUINameEntryDraw::InFourthStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InFirstEndFrame) == 0x0002F4, "Member 'AUINameEntryDraw::InFirstEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InSecondEndFrame) == 0x0002F8, "Member 'AUINameEntryDraw::InSecondEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InThirdEndFrame) == 0x0002FC, "Member 'AUINameEntryDraw::InThirdEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, InFourthEndFrame) == 0x000300, "Member 'AUINameEntryDraw::InFourthEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, OutFirstStartFrame) == 0x000304, "Member 'AUINameEntryDraw::OutFirstStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, OutSecondStartFrame) == 0x000308, "Member 'AUINameEntryDraw::OutSecondStartFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, OutFirstEndFrame) == 0x00030C, "Member 'AUINameEntryDraw::OutFirstEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, OutSecondEndFrame) == 0x000310, "Member 'AUINameEntryDraw::OutSecondEndFrame' has a wrong offset!");
static_assert(offsetof(AUINameEntryDraw, PLayoutDataTable) == 0x000358, "Member 'AUINameEntryDraw::PLayoutDataTable' has a wrong offset!");

// Class xrd777.AtlEvtPlayObject
// 0x0088 (0x0300 - 0x0278)
class AAtlEvtPlayObject : public AAppActor
{
public:
	class FString                                 LevelName;                                         // 0x0278(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtlEvtPlayParameter                   EvtPlayParam;                                      // 0x0288(0x0038)(Edit, NativeAccessSpecifierPublic)
	class FString                                 EventRank;                                         // 0x02C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedEventSequencer();
	void OnFinishedSceneChange();
	void OnLoadedMovieTrack();
	void OnLoadedReplaceCharacters();
	void OnLoadedReplaceCharactersCostume();
	void OnLoadEvtLevelSequence();
	void OnLoadFieldLevelStreaming();
	void OnLoadFieldLevelStreaming_DelayCompleted();
	void OnLoadFieldLevelStreaming_WaitUnpaused();
	void OnLoadLevelStreaming();
	void OnPlayEventSequencer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtPlayObject">();
	}
	static class AAtlEvtPlayObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtPlayObject>();
	}
};
static_assert(alignof(AAtlEvtPlayObject) == 0x000008, "Wrong alignment on AAtlEvtPlayObject");
static_assert(sizeof(AAtlEvtPlayObject) == 0x000300, "Wrong size on AAtlEvtPlayObject");
static_assert(offsetof(AAtlEvtPlayObject, LevelName) == 0x000278, "Member 'AAtlEvtPlayObject::LevelName' has a wrong offset!");
static_assert(offsetof(AAtlEvtPlayObject, EvtPlayParam) == 0x000288, "Member 'AAtlEvtPlayObject::EvtPlayParam' has a wrong offset!");
static_assert(offsetof(AAtlEvtPlayObject, EventRank) == 0x0002C0, "Member 'AAtlEvtPlayObject::EventRank' has a wrong offset!");
static_assert(offsetof(AAtlEvtPlayObject, LevelSequenceActor) == 0x0002E8, "Member 'AAtlEvtPlayObject::LevelSequenceActor' has a wrong offset!");

// Class xrd777.FldCharAttackLongRangeAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UFldCharAttackLongRangeAnimNotify final : public UAnimNotify
{
public:
	EFldCharAttackAnimNotifyFlag                  Flag;                                              // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharAttackLongRangeAnimNotify">();
	}
	static class UFldCharAttackLongRangeAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharAttackLongRangeAnimNotify>();
	}
};
static_assert(alignof(UFldCharAttackLongRangeAnimNotify) == 0x000008, "Wrong alignment on UFldCharAttackLongRangeAnimNotify");
static_assert(sizeof(UFldCharAttackLongRangeAnimNotify) == 0x000040, "Wrong size on UFldCharAttackLongRangeAnimNotify");
static_assert(offsetof(UFldCharAttackLongRangeAnimNotify, Flag) == 0x000038, "Member 'UFldCharAttackLongRangeAnimNotify::Flag' has a wrong offset!");
static_assert(offsetof(UFldCharAttackLongRangeAnimNotify, bEnable) == 0x00003C, "Member 'UFldCharAttackLongRangeAnimNotify::bEnable' has a wrong offset!");

// Class xrd777.AtlEvtPlayUnstreamObject
// 0x0030 (0x02A8 - 0x0278)
class AAtlEvtPlayUnstreamObject final : public AAppActor
{
public:
	class FString                                 LevelName;                                         // 0x0278(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedUnloadLevelStreaming();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtPlayUnstreamObject">();
	}
	static class AAtlEvtPlayUnstreamObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtPlayUnstreamObject>();
	}
};
static_assert(alignof(AAtlEvtPlayUnstreamObject) == 0x000008, "Wrong alignment on AAtlEvtPlayUnstreamObject");
static_assert(sizeof(AAtlEvtPlayUnstreamObject) == 0x0002A8, "Wrong size on AAtlEvtPlayUnstreamObject");
static_assert(offsetof(AAtlEvtPlayUnstreamObject, LevelName) == 0x000278, "Member 'AAtlEvtPlayUnstreamObject::LevelName' has a wrong offset!");
static_assert(offsetof(AAtlEvtPlayUnstreamObject, LevelSequenceActor) == 0x000298, "Member 'AAtlEvtPlayUnstreamObject::LevelSequenceActor' has a wrong offset!");

// Class xrd777.AtlEvtSubsystemDraft
// 0x0018 (0x0048 - 0x0030)
class UAtlEvtSubsystemDraft final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnFinishedDelegate;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         GlobalCount;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EvtPlay(const class UObject* WorldContextObject, const class FString& EvtName, const struct FAtlEvtPlayParameter& Param);
	void ResetGlobalCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtSubsystemDraft">();
	}
	static class UAtlEvtSubsystemDraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlEvtSubsystemDraft>();
	}
};
static_assert(alignof(UAtlEvtSubsystemDraft) == 0x000008, "Wrong alignment on UAtlEvtSubsystemDraft");
static_assert(sizeof(UAtlEvtSubsystemDraft) == 0x000048, "Wrong size on UAtlEvtSubsystemDraft");
static_assert(offsetof(UAtlEvtSubsystemDraft, OnFinishedDelegate) == 0x000030, "Member 'UAtlEvtSubsystemDraft::OnFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UAtlEvtSubsystemDraft, GlobalCount) == 0x000040, "Member 'UAtlEvtSubsystemDraft::GlobalCount' has a wrong offset!");

// Class xrd777.UIMiscSupportPartyPanel
// 0x0558 (0x07F8 - 0x02A0)
class AUIMiscSupportPartyPanel final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pSpr;                                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pSupportPartyPanelDT;                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x540];                                    // 0x02B8(0x0540)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscSupportPartyPanel">();
	}
	static class AUIMiscSupportPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscSupportPartyPanel>();
	}
};
static_assert(alignof(AUIMiscSupportPartyPanel) == 0x000008, "Wrong alignment on AUIMiscSupportPartyPanel");
static_assert(sizeof(AUIMiscSupportPartyPanel) == 0x0007F8, "Wrong size on AUIMiscSupportPartyPanel");
static_assert(offsetof(AUIMiscSupportPartyPanel, M_pSpr) == 0x0002A8, "Member 'AUIMiscSupportPartyPanel::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscSupportPartyPanel, M_pSupportPartyPanelDT) == 0x0002B0, "Member 'AUIMiscSupportPartyPanel::M_pSupportPartyPanelDT' has a wrong offset!");

// Class xrd777.AtlHandwritingDataAsset
// 0x0050 (0x0080 - 0x0030)
class UAtlHandwritingDataAsset final : public UDataAsset
{
public:
	TMap<EAtlEvtHandwritingType, TSoftClassPtr<class UClass>> HandwritingEffectSoftObjMap;                       // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlHandwritingDataAsset">();
	}
	static class UAtlHandwritingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlHandwritingDataAsset>();
	}
};
static_assert(alignof(UAtlHandwritingDataAsset) == 0x000008, "Wrong alignment on UAtlHandwritingDataAsset");
static_assert(sizeof(UAtlHandwritingDataAsset) == 0x000080, "Wrong size on UAtlHandwritingDataAsset");
static_assert(offsetof(UAtlHandwritingDataAsset, HandwritingEffectSoftObjMap) == 0x000030, "Member 'UAtlHandwritingDataAsset::HandwritingEffectSoftObjMap' has a wrong offset!");

// Class xrd777.CmpHeroHumanStatusDraw
// 0x4110 (0x4138 - 0x0028)
class UCmpHeroHumanStatusDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x4020];                                    // 0x0028(0x4020)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x4048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICmpStatus*                           PParent;                                           // 0x4050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4058[0xE0];                                    // 0x4058(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpHeroHumanStatusDraw">();
	}
	static class UCmpHeroHumanStatusDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpHeroHumanStatusDraw>();
	}
};
static_assert(alignof(UCmpHeroHumanStatusDraw) == 0x000008, "Wrong alignment on UCmpHeroHumanStatusDraw");
static_assert(sizeof(UCmpHeroHumanStatusDraw) == 0x004138, "Wrong size on UCmpHeroHumanStatusDraw");
static_assert(offsetof(UCmpHeroHumanStatusDraw, PMainActor) == 0x004048, "Member 'UCmpHeroHumanStatusDraw::PMainActor' has a wrong offset!");
static_assert(offsetof(UCmpHeroHumanStatusDraw, PParent) == 0x004050, "Member 'UCmpHeroHumanStatusDraw::PParent' has a wrong offset!");

// Class xrd777.AtlNiagaraActor
// 0x0008 (0x0280 - 0x0278)
class AAtlNiagaraActor final : public AAppActor
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlNiagaraActor">();
	}
	static class AAtlNiagaraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlNiagaraActor>();
	}
};
static_assert(alignof(AAtlNiagaraActor) == 0x000008, "Wrong alignment on AAtlNiagaraActor");
static_assert(sizeof(AAtlNiagaraActor) == 0x000280, "Wrong size on AAtlNiagaraActor");
static_assert(offsetof(AAtlNiagaraActor, NiagaraComponent) == 0x000278, "Member 'AAtlNiagaraActor::NiagaraComponent' has a wrong offset!");

// Class xrd777.FldCameraTransBase
// 0x0008 (0x00D0 - 0x00C8)
class UFldCameraTransBase : public UAppActorComponent
{
public:
	bool                                          bIdentifyAngle;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComplementaryAngle;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraTransBase">();
	}
	static class UFldCameraTransBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraTransBase>();
	}
};
static_assert(alignof(UFldCameraTransBase) == 0x000008, "Wrong alignment on UFldCameraTransBase");
static_assert(sizeof(UFldCameraTransBase) == 0x0000D0, "Wrong size on UFldCameraTransBase");
static_assert(offsetof(UFldCameraTransBase, bIdentifyAngle) == 0x0000C8, "Member 'UFldCameraTransBase::bIdentifyAngle' has a wrong offset!");
static_assert(offsetof(UFldCameraTransBase, ComplementaryAngle) == 0x0000CC, "Member 'UFldCameraTransBase::ComplementaryAngle' has a wrong offset!");

// Class xrd777.FldCameraTransLinear
// 0x0008 (0x00D8 - 0x00D0)
class UFldCameraTransLinear final : public UFldCameraTransBase
{
public:
	float                                         TotalTime;                                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraTransLinear">();
	}
	static class UFldCameraTransLinear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraTransLinear>();
	}
};
static_assert(alignof(UFldCameraTransLinear) == 0x000008, "Wrong alignment on UFldCameraTransLinear");
static_assert(sizeof(UFldCameraTransLinear) == 0x0000D8, "Wrong size on UFldCameraTransLinear");
static_assert(offsetof(UFldCameraTransLinear, TotalTime) == 0x0000D0, "Member 'UFldCameraTransLinear::TotalTime' has a wrong offset!");

// Class xrd777.AtlUIPlg
// 0x0100 (0x0208 - 0x0108)
class UAtlUIPlg final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0108(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UPlgAsset*                              PlgAsset;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimitiveNo;                                       // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlgScale;                                          // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x38];                                     // 0x01D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlUIPlg">();
	}
	static class UAtlUIPlg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlUIPlg>();
	}
};
static_assert(alignof(UAtlUIPlg) == 0x000008, "Wrong alignment on UAtlUIPlg");
static_assert(sizeof(UAtlUIPlg) == 0x000208, "Wrong size on UAtlUIPlg");
static_assert(offsetof(UAtlUIPlg, Brush) == 0x000108, "Member 'UAtlUIPlg::Brush' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, BrushDelegate) == 0x000190, "Member 'UAtlUIPlg::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, ColorAndOpacity) == 0x0001A0, "Member 'UAtlUIPlg::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, ColorAndOpacityDelegate) == 0x0001B0, "Member 'UAtlUIPlg::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, PlgAsset) == 0x0001C0, "Member 'UAtlUIPlg::PlgAsset' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, PrimitiveNo) == 0x0001C8, "Member 'UAtlUIPlg::PrimitiveNo' has a wrong offset!");
static_assert(offsetof(UAtlUIPlg, PlgScale) == 0x0001CC, "Member 'UAtlUIPlg::PlgScale' has a wrong offset!");

// Class xrd777.PerformanceViewer
// 0x0008 (0x0298 - 0x0290)
class APerformanceViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceViewer">();
	}
	static class APerformanceViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerformanceViewer>();
	}
};
static_assert(alignof(APerformanceViewer) == 0x000008, "Wrong alignment on APerformanceViewer");
static_assert(sizeof(APerformanceViewer) == 0x000298, "Wrong size on APerformanceViewer");

// Class xrd777.CldCmnDataActor
// 0x0020 (0x0298 - 0x0278)
class ACldCmnDataActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArcAsset*                              MArcAsset_;                                        // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldCmnDataActor">();
	}
	static class ACldCmnDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACldCmnDataActor>();
	}
};
static_assert(alignof(ACldCmnDataActor) == 0x000008, "Wrong alignment on ACldCmnDataActor");
static_assert(sizeof(ACldCmnDataActor) == 0x000298, "Wrong size on ACldCmnDataActor");
static_assert(offsetof(ACldCmnDataActor, MAssetLoader_) == 0x000288, "Member 'ACldCmnDataActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(ACldCmnDataActor, MArcAsset_) == 0x000290, "Member 'ACldCmnDataActor::MArcAsset_' has a wrong offset!");

// Class xrd777.AtlUIPrimitive
// 0x0110 (0x0218 - 0x0108)
class UAtlUIPrimitive final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0108(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      Vertexes;                                          // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indexes;                                           // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x38];                                     // 0x01E0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlUIPrimitive">();
	}
	static class UAtlUIPrimitive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlUIPrimitive>();
	}
};
static_assert(alignof(UAtlUIPrimitive) == 0x000008, "Wrong alignment on UAtlUIPrimitive");
static_assert(sizeof(UAtlUIPrimitive) == 0x000218, "Wrong size on UAtlUIPrimitive");
static_assert(offsetof(UAtlUIPrimitive, Brush) == 0x000108, "Member 'UAtlUIPrimitive::Brush' has a wrong offset!");
static_assert(offsetof(UAtlUIPrimitive, BrushDelegate) == 0x000190, "Member 'UAtlUIPrimitive::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUIPrimitive, ColorAndOpacity) == 0x0001A0, "Member 'UAtlUIPrimitive::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UAtlUIPrimitive, ColorAndOpacityDelegate) == 0x0001B0, "Member 'UAtlUIPrimitive::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUIPrimitive, Vertexes) == 0x0001C0, "Member 'UAtlUIPrimitive::Vertexes' has a wrong offset!");
static_assert(offsetof(UAtlUIPrimitive, Indexes) == 0x0001D0, "Member 'UAtlUIPrimitive::Indexes' has a wrong offset!");

// Class xrd777.AtlUITextBlock
// 0x01A0 (0x02C8 - 0x0128)
class UAtlUITextBlock final : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0128(0x0018)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0140(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EAtlUIFontStyle                               FontStyle;                                         // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextScale;                                         // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFontAdjustmentListTable*               FontAdjustmentListTable;                           // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            ColorAndOpacity;                                   // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0198(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x01A8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            StrikeBrush;                                       // 0x0200(0x0088)(NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x0290(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ShadowColorAndOpacityDelegate;                     // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x02B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWrapWithInvalidationPanel;                        // 0x02B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoWrapText;                                     // 0x02B5(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextTransformPolicy                          TextTransformPolicy;                               // 0x02B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7[0x11];                                     // 0x02B7(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicFontMaterial();
	class UMaterialInstanceDynamic* GetDynamicOutlineMaterial();
	void SetAutoWrapText(bool InAutoTextWrap);
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetFont(const struct FSlateFontInfo& InFontInfo);
	void SetMinDesiredWidth(float InMinDesiredWidth);
	void SetOpacity(float InOpacity);
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity);
	void SetShadowOffset(const struct FVector2D& InShadowOffset);
	void SetStrikeBrush(const struct FSlateBrush& InStrikeBrush);
	void SetText(const class FText& InText);
	void SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlUITextBlock">();
	}
	static class UAtlUITextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlUITextBlock>();
	}
};
static_assert(alignof(UAtlUITextBlock) == 0x000008, "Wrong alignment on UAtlUITextBlock");
static_assert(sizeof(UAtlUITextBlock) == 0x0002C8, "Wrong size on UAtlUITextBlock");
static_assert(offsetof(UAtlUITextBlock, Text) == 0x000128, "Member 'UAtlUITextBlock::Text' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, TextDelegate) == 0x000140, "Member 'UAtlUITextBlock::TextDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, FontStyle) == 0x000150, "Member 'UAtlUITextBlock::FontStyle' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, TextScale) == 0x000154, "Member 'UAtlUITextBlock::TextScale' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, FontAdjustmentListTable) == 0x000158, "Member 'UAtlUITextBlock::FontAdjustmentListTable' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, ColorAndOpacity) == 0x000170, "Member 'UAtlUITextBlock::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, ColorAndOpacityDelegate) == 0x000198, "Member 'UAtlUITextBlock::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, Font) == 0x0001A8, "Member 'UAtlUITextBlock::Font' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, StrikeBrush) == 0x000200, "Member 'UAtlUITextBlock::StrikeBrush' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, ShadowOffset) == 0x000288, "Member 'UAtlUITextBlock::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, ShadowColorAndOpacity) == 0x000290, "Member 'UAtlUITextBlock::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, ShadowColorAndOpacityDelegate) == 0x0002A0, "Member 'UAtlUITextBlock::ShadowColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, MinDesiredWidth) == 0x0002B0, "Member 'UAtlUITextBlock::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, bWrapWithInvalidationPanel) == 0x0002B4, "Member 'UAtlUITextBlock::bWrapWithInvalidationPanel' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, bAutoWrapText) == 0x0002B5, "Member 'UAtlUITextBlock::bAutoWrapText' has a wrong offset!");
static_assert(offsetof(UAtlUITextBlock, TextTransformPolicy) == 0x0002B6, "Member 'UAtlUITextBlock::TextTransformPolicy' has a wrong offset!");

// Class xrd777.ArbeitInfoDataAsset
// 0x0010 (0x0040 - 0x0030)
class UArbeitInfoDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FArbeitInfo>                    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArbeitInfoDataAsset">();
	}
	static class UArbeitInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArbeitInfoDataAsset>();
	}
};
static_assert(alignof(UArbeitInfoDataAsset) == 0x000008, "Wrong alignment on UArbeitInfoDataAsset");
static_assert(sizeof(UArbeitInfoDataAsset) == 0x000040, "Wrong size on UArbeitInfoDataAsset");
static_assert(offsetof(UArbeitInfoDataAsset, Data) == 0x000030, "Member 'UArbeitInfoDataAsset::Data' has a wrong offset!");

// Class xrd777.FldHitCore
// 0x00D0 (0x0350 - 0x0280)
class AFldHitCore : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         MOtherList_;                                       // 0x0288(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MPriority_;                                        // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MBfAssetPath_;                                     // 0x02A0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MBmdAssetPath_;                                    // 0x02B0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootComp_;                                         // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        HitComp_;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUtlProcActor>              MOverlapBluePrint_;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MOverlapKeyLock_;                                  // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUtlProcActor>              MKeyPushBluePrint_;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MActionKeyLock_;                                   // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFFldHitCoreHeroDirectType                    MHeroDirectType_;                                  // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFldHitCoreCheckIconType                      MCheckIcon_;                                       // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB[0x55];                                     // 0x02EB(0x0055)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             MActionNoticeDelegateAstrea;                       // 0x0340(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	void CleanupRequest();
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void RequestKeyPushBluePrint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitCore">();
	}
	static class AFldHitCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitCore>();
	}
};
static_assert(alignof(AFldHitCore) == 0x000008, "Wrong alignment on AFldHitCore");
static_assert(sizeof(AFldHitCore) == 0x000350, "Wrong size on AFldHitCore");
static_assert(offsetof(AFldHitCore, MOtherList_) == 0x000288, "Member 'AFldHitCore::MOtherList_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MPriority_) == 0x000298, "Member 'AFldHitCore::MPriority_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MBfAssetPath_) == 0x0002A0, "Member 'AFldHitCore::MBfAssetPath_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MBmdAssetPath_) == 0x0002B0, "Member 'AFldHitCore::MBmdAssetPath_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, RootComp_) == 0x0002C0, "Member 'AFldHitCore::RootComp_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, HitComp_) == 0x0002C8, "Member 'AFldHitCore::HitComp_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MOverlapBluePrint_) == 0x0002D0, "Member 'AFldHitCore::MOverlapBluePrint_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MOverlapKeyLock_) == 0x0002D8, "Member 'AFldHitCore::MOverlapKeyLock_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MKeyPushBluePrint_) == 0x0002E0, "Member 'AFldHitCore::MKeyPushBluePrint_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MActionKeyLock_) == 0x0002E8, "Member 'AFldHitCore::MActionKeyLock_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MHeroDirectType_) == 0x0002E9, "Member 'AFldHitCore::MHeroDirectType_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MCheckIcon_) == 0x0002EA, "Member 'AFldHitCore::MCheckIcon_' has a wrong offset!");
static_assert(offsetof(AFldHitCore, MActionNoticeDelegateAstrea) == 0x000340, "Member 'AFldHitCore::MActionNoticeDelegateAstrea' has a wrong offset!");

// Class xrd777.AtlUITriangle
// 0x0110 (0x0218 - 0x0108)
class UAtlUITriangle final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0108(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Vertexe01;                                         // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vertexe02;                                         // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vertexe03;                                         // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Antialiasing;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x3C];                                     // 0x01DC(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlUITriangle">();
	}
	static class UAtlUITriangle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlUITriangle>();
	}
};
static_assert(alignof(UAtlUITriangle) == 0x000008, "Wrong alignment on UAtlUITriangle");
static_assert(sizeof(UAtlUITriangle) == 0x000218, "Wrong size on UAtlUITriangle");
static_assert(offsetof(UAtlUITriangle, Brush) == 0x000108, "Member 'UAtlUITriangle::Brush' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, BrushDelegate) == 0x000190, "Member 'UAtlUITriangle::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, ColorAndOpacity) == 0x0001A0, "Member 'UAtlUITriangle::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, ColorAndOpacityDelegate) == 0x0001B0, "Member 'UAtlUITriangle::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, Vertexe01) == 0x0001C0, "Member 'UAtlUITriangle::Vertexe01' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, Vertexe02) == 0x0001C8, "Member 'UAtlUITriangle::Vertexe02' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, Vertexe03) == 0x0001D0, "Member 'UAtlUITriangle::Vertexe03' has a wrong offset!");
static_assert(offsetof(UAtlUITriangle, Antialiasing) == 0x0001D8, "Member 'UAtlUITriangle::Antialiasing' has a wrong offset!");

// Class xrd777.CombineMiscDataAsset
// 0x0038 (0x0068 - 0x0030)
class UCombineMiscDataAsset final : public UAppDataAsset
{
public:
	float                                         AccidentBaseRate;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoolAccidentRate;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         AccidentMinLv;                                     // 0x0038(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         AccidentMaxLv;                                     // 0x003A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillChangeBaseRate;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillBuildUpRate;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SkillChanges;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 SkillWeights;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombineMiscDataAsset">();
	}
	static class UCombineMiscDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombineMiscDataAsset>();
	}
};
static_assert(alignof(UCombineMiscDataAsset) == 0x000008, "Wrong alignment on UCombineMiscDataAsset");
static_assert(sizeof(UCombineMiscDataAsset) == 0x000068, "Wrong size on UCombineMiscDataAsset");
static_assert(offsetof(UCombineMiscDataAsset, AccidentBaseRate) == 0x000030, "Member 'UCombineMiscDataAsset::AccidentBaseRate' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, FoolAccidentRate) == 0x000034, "Member 'UCombineMiscDataAsset::FoolAccidentRate' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, AccidentMinLv) == 0x000038, "Member 'UCombineMiscDataAsset::AccidentMinLv' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, AccidentMaxLv) == 0x00003A, "Member 'UCombineMiscDataAsset::AccidentMaxLv' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, SkillChangeBaseRate) == 0x00003C, "Member 'UCombineMiscDataAsset::SkillChangeBaseRate' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, SkillBuildUpRate) == 0x000040, "Member 'UCombineMiscDataAsset::SkillBuildUpRate' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, SkillChanges) == 0x000048, "Member 'UCombineMiscDataAsset::SkillChanges' has a wrong offset!");
static_assert(offsetof(UCombineMiscDataAsset, SkillWeights) == 0x000058, "Member 'UCombineMiscDataAsset::SkillWeights' has a wrong offset!");

// Class xrd777.BasePartyPanel
// 0x0018 (0x02B8 - 0x02A0)
class ABasePartyPanel : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePartyPanel">();
	}
	static class ABasePartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePartyPanel>();
	}
};
static_assert(alignof(ABasePartyPanel) == 0x000008, "Wrong alignment on ABasePartyPanel");
static_assert(sizeof(ABasePartyPanel) == 0x0002B8, "Wrong size on ABasePartyPanel");
static_assert(offsetof(ABasePartyPanel, LayoutData) == 0x0002A8, "Member 'ABasePartyPanel::LayoutData' has a wrong offset!");
static_assert(offsetof(ABasePartyPanel, LayoutDataTable) == 0x0002B0, "Member 'ABasePartyPanel::LayoutDataTable' has a wrong offset!");

// Class xrd777.PartyPanelRecoveryEffect
// 0x11D8 (0x1200 - 0x0028)
class UPartyPanelRecoveryEffect final : public UObject
{
public:
	class USprAsset*                              M_pSpr;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveLinearColorAnimation             M_curveRecoveryEffect;                             // 0x0030(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x11A0];                                    // 0x0060(0x11A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyPanelRecoveryEffect">();
	}
	static class UPartyPanelRecoveryEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyPanelRecoveryEffect>();
	}
};
static_assert(alignof(UPartyPanelRecoveryEffect) == 0x000008, "Wrong alignment on UPartyPanelRecoveryEffect");
static_assert(sizeof(UPartyPanelRecoveryEffect) == 0x001200, "Wrong size on UPartyPanelRecoveryEffect");
static_assert(offsetof(UPartyPanelRecoveryEffect, M_pSpr) == 0x000028, "Member 'UPartyPanelRecoveryEffect::M_pSpr' has a wrong offset!");
static_assert(offsetof(UPartyPanelRecoveryEffect, M_curveRecoveryEffect) == 0x000030, "Member 'UPartyPanelRecoveryEffect::M_curveRecoveryEffect' has a wrong offset!");

// Class xrd777.BtlTutorialAstrea
// 0x0000 (0x0030 - 0x0030)
class UBtlTutorialAstrea final : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorialAstrea">();
	}
	static class UBtlTutorialAstrea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorialAstrea>();
	}
};
static_assert(alignof(UBtlTutorialAstrea) == 0x000008, "Wrong alignment on UBtlTutorialAstrea");
static_assert(sizeof(UBtlTutorialAstrea) == 0x000030, "Wrong size on UBtlTutorialAstrea");

// Class xrd777.BFL_UIPaint
// 0x0000 (0x0028 - 0x0028)
class UBFL_UIPaint final : public UBlueprintFunctionLibrary
{
public:
	static void DrawTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFL_UIPaint">();
	}
	static class UBFL_UIPaint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFL_UIPaint>();
	}
};
static_assert(alignof(UBFL_UIPaint) == 0x000008, "Wrong alignment on UBFL_UIPaint");
static_assert(sizeof(UBFL_UIPaint) == 0x000028, "Wrong size on UBFL_UIPaint");

// Class xrd777.BFLAtlEvtCharacter
// 0x0000 (0x0028 - 0x0028)
class UBFLAtlEvtCharacter final : public UBlueprintFunctionLibrary
{
public:
	static void ConstructCostume(class ACharacterBaseCore* CharacterBaseCore, EAppCharCategoryType AppCharaCategory, int32 AppCharaIndex, int32 AppCharaCostumeIndex);
	static void ConstructNPCCostume(class ANpcBaseCore* NpcBaseCore, int32 AppNpcCharaCostumeIndex, int32 NpcIndexId, int32 HairId, int32 FaceID);
	static void KoromaruAdjust(class AActor* KoromaruActor);
	static void PersonaCombineAdjust(class AActor* PersonaActor);
	static void TickLookAtEditorOnly(class ACharacter* Character, bool bShowDebugLookAtTargetLocation, const struct FVector& LookAtFinalLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLAtlEvtCharacter">();
	}
	static class UBFLAtlEvtCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLAtlEvtCharacter>();
	}
};
static_assert(alignof(UBFLAtlEvtCharacter) == 0x000008, "Wrong alignment on UBFLAtlEvtCharacter");
static_assert(sizeof(UBFLAtlEvtCharacter) == 0x000028, "Wrong size on UBFLAtlEvtCharacter");

// Class xrd777.QuestElizMessage
// 0x0068 (0x0090 - 0x0028)
class UQuestElizMessage final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestElizMessage">();
	}
	static class UQuestElizMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestElizMessage>();
	}
};
static_assert(alignof(UQuestElizMessage) == 0x000008, "Wrong alignment on UQuestElizMessage");
static_assert(sizeof(UQuestElizMessage) == 0x000090, "Wrong size on UQuestElizMessage");

// Class xrd777.UtlBpObjCore
// 0x0018 (0x0040 - 0x0028)
class UUtlBpObjCore : public UObject
{
public:
	FMulticastInlineDelegateProperty_             MEndDelegate_;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOpenLevel(class FName LevelName);
	void LoadLevel(class FName LevelName, const struct FLatentActionInfo& LatentInfo);
	void Return();
	void ReturnField();
	void StartProc();
	void UnloadLevel(class FName LevelName, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtlBpObjCore">();
	}
	static class UUtlBpObjCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtlBpObjCore>();
	}
};
static_assert(alignof(UUtlBpObjCore) == 0x000008, "Wrong alignment on UUtlBpObjCore");
static_assert(sizeof(UUtlBpObjCore) == 0x000040, "Wrong size on UUtlBpObjCore");
static_assert(offsetof(UUtlBpObjCore, MEndDelegate_) == 0x000028, "Member 'UUtlBpObjCore::MEndDelegate_' has a wrong offset!");

// Class xrd777.UtlBpObj
// 0x0000 (0x0040 - 0x0040)
class UUtlBpObj : public UUtlBpObjCore
{
public:
	void StartFadeIN(int32 Type, int32 Frame);
	void StartFadeOUT(int32 Type, int32 Frame);
	void StartScript(TSoftObjectPtr<class UBfAsset> InAsset, int32 ProcNo, const struct FLatentActionInfo& LatentInfo, int32* Result);
	void SyncFade(int32 Type, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtlBpObj">();
	}
	static class UUtlBpObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtlBpObj>();
	}
};
static_assert(alignof(UUtlBpObj) == 0x000008, "Wrong alignment on UUtlBpObj");
static_assert(sizeof(UUtlBpObj) == 0x000040, "Wrong size on UUtlBpObj");

// Class xrd777.CldSchedulerBpObject
// 0x0000 (0x0040 - 0x0040)
class UCldSchedulerBpObject final : public UUtlBpObj
{
public:
	void AfterSchool();
	void AM();
	void CallNextTime();
	void EarlyMorning();
	void Midnight();
	void Morning();
	void Night();
	void Noon();
	void PM();
	void Shadow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldSchedulerBpObject">();
	}
	static class UCldSchedulerBpObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldSchedulerBpObject>();
	}
};
static_assert(alignof(UCldSchedulerBpObject) == 0x000008, "Wrong alignment on UCldSchedulerBpObject");
static_assert(sizeof(UCldSchedulerBpObject) == 0x000040, "Wrong size on UCldSchedulerBpObject");

// Class xrd777.BFLAtlEvtHandwriting
// 0x0000 (0x0028 - 0x0028)
class UBFLAtlEvtHandwriting final : public UBlueprintFunctionLibrary
{
public:
	static class FName MakeHandwritingTypeAssetPath(EAtlEvtHandwritingType Type);
	static class FName MakeHandwritingTypeCharaParamAssetPath(EAtlEvtHandwritingType Type, EAppCharCategoryType CharacterTypeCategoryType, int32 CharaIndexID);
	static class FName MakeHandwritingTypeDefaultParamAssetPath(EAtlEvtHandwritingType Type);
	static class FName MakeHandwritingTypeName(EAtlEvtHandwritingType Type);
	static class UNiagaraComponent* SpawnHandwritingAtLocation(const class UObject* WorldContextObject, EAtlEvtHandwritingType Type, int32 LoopCount, float CameraOffset, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);
	static class UNiagaraComponent* SpawnHandwritingAttached(EAtlEvtHandwritingType Type, int32 LoopCount, float CameraOffset, class ACharacter* AttachToCharacter, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, bool bAutoDestroy, bool bAutoActivate, ENCPoolMethod PoolingMethod, bool bPreCullCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLAtlEvtHandwriting">();
	}
	static class UBFLAtlEvtHandwriting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLAtlEvtHandwriting>();
	}
};
static_assert(alignof(UBFLAtlEvtHandwriting) == 0x000008, "Wrong alignment on UBFLAtlEvtHandwriting");
static_assert(sizeof(UBFLAtlEvtHandwriting) == 0x000028, "Wrong size on UBFLAtlEvtHandwriting");

// Class xrd777.FldAtomSound
// 0x0028 (0x02A8 - 0x0280)
class AFldAtomSound : public AFldLocalActor
{
public:
	bool                                          MSeasonSpring_;                                    // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MSeasonSummer_;                                    // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MSeasonAutumn_;                                    // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MSeasonWinter_;                                    // 0x0283(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeNoon_;                                        // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeAfternoon_;                                   // 0x0285(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeNight_;                                       // 0x0286(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MTimeShadow_;                                      // 0x0287(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MOffInEvent_;                                      // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MOnFlagName_;                                      // 0x028C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0294(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AtomComponent;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckEnablePlay();
	void FadeInSound(float FadeInDuration);
	void FadeOutSound(float FadeOutDuration);
	void PlaySound();
	void StopSound();
	void StopSound_IMD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAtomSound">();
	}
	static class AFldAtomSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldAtomSound>();
	}
};
static_assert(alignof(AFldAtomSound) == 0x000008, "Wrong alignment on AFldAtomSound");
static_assert(sizeof(AFldAtomSound) == 0x0002A8, "Wrong size on AFldAtomSound");
static_assert(offsetof(AFldAtomSound, MSeasonSpring_) == 0x000280, "Member 'AFldAtomSound::MSeasonSpring_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MSeasonSummer_) == 0x000281, "Member 'AFldAtomSound::MSeasonSummer_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MSeasonAutumn_) == 0x000282, "Member 'AFldAtomSound::MSeasonAutumn_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MSeasonWinter_) == 0x000283, "Member 'AFldAtomSound::MSeasonWinter_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MTimeNoon_) == 0x000284, "Member 'AFldAtomSound::MTimeNoon_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MTimeAfternoon_) == 0x000285, "Member 'AFldAtomSound::MTimeAfternoon_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MTimeNight_) == 0x000286, "Member 'AFldAtomSound::MTimeNight_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MTimeShadow_) == 0x000287, "Member 'AFldAtomSound::MTimeShadow_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MOffInEvent_) == 0x000288, "Member 'AFldAtomSound::MOffInEvent_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MOnFlagName_) == 0x00028C, "Member 'AFldAtomSound::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, MOffFlagName_) == 0x000294, "Member 'AFldAtomSound::MOffFlagName_' has a wrong offset!");
static_assert(offsetof(AFldAtomSound, AtomComponent) == 0x0002A0, "Member 'AFldAtomSound::AtomComponent' has a wrong offset!");

// Class xrd777.AtlEvtPlayOnBindingActorObject
// 0x0010 (0x0310 - 0x0300)
class AAtlEvtPlayOnBindingActorObject final : public AAtlEvtPlayObject
{
public:
	class FString                                 EvtName;                                           // 0x0300(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnLoadBindingLevelStreaming();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlEvtPlayOnBindingActorObject">();
	}
	static class AAtlEvtPlayOnBindingActorObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlEvtPlayOnBindingActorObject>();
	}
};
static_assert(alignof(AAtlEvtPlayOnBindingActorObject) == 0x000008, "Wrong alignment on AAtlEvtPlayOnBindingActorObject");
static_assert(sizeof(AAtlEvtPlayOnBindingActorObject) == 0x000310, "Wrong size on AAtlEvtPlayOnBindingActorObject");
static_assert(offsetof(AAtlEvtPlayOnBindingActorObject, EvtName) == 0x000300, "Member 'AAtlEvtPlayOnBindingActorObject::EvtName' has a wrong offset!");

// Class xrd777.BFLAtlEvtTest
// 0x0000 (0x0028 - 0x0028)
class UBFLAtlEvtTest final : public UBlueprintFunctionLibrary
{
public:
	static void EvtPlayOnBindingActor(const class UObject* WorldContextObject, const class FString& EvtName, const class FString& SublevelOnBindingActorName, const struct FAtlEvtPlayParameter& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLAtlEvtTest">();
	}
	static class UBFLAtlEvtTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLAtlEvtTest>();
	}
};
static_assert(alignof(UBFLAtlEvtTest) == 0x000008, "Wrong alignment on UBFLAtlEvtTest");
static_assert(sizeof(UBFLAtlEvtTest) == 0x000028, "Wrong size on UBFLAtlEvtTest");

// Class xrd777.UIPoetryDataAsset
// 0x0010 (0x0040 - 0x0030)
class UUIPoetryDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FPoetryParamTable>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPoetryDataAsset">();
	}
	static class UUIPoetryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPoetryDataAsset>();
	}
};
static_assert(alignof(UUIPoetryDataAsset) == 0x000008, "Wrong alignment on UUIPoetryDataAsset");
static_assert(sizeof(UUIPoetryDataAsset) == 0x000040, "Wrong size on UUIPoetryDataAsset");
static_assert(offsetof(UUIPoetryDataAsset, Data) == 0x000030, "Member 'UUIPoetryDataAsset::Data' has a wrong offset!");

// Class xrd777.UmgDialog
// 0x0018 (0x0278 - 0x0260)
class UUmgDialog final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcScreenScale();
	bool IsChangeScreenSize();
	bool IsInputBlocked();
	bool IsStreamingTouch();
	void SetEndFlag();
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgDialog">();
	}
	static class UUmgDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgDialog>();
	}
};
static_assert(alignof(UUmgDialog) == 0x000008, "Wrong alignment on UUmgDialog");
static_assert(sizeof(UUmgDialog) == 0x000278, "Wrong size on UUmgDialog");

// Class xrd777.FldCrowdTarget
// 0x0010 (0x0238 - 0x0228)
class AFldCrowdTarget : public AMobWalkTarget
{
public:
	int32                                         MIndex_;                                           // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMobWalkCharaBaseCore*                  MMobActor_;                                        // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdTarget">();
	}
	static class AFldCrowdTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCrowdTarget>();
	}
};
static_assert(alignof(AFldCrowdTarget) == 0x000008, "Wrong alignment on AFldCrowdTarget");
static_assert(sizeof(AFldCrowdTarget) == 0x000238, "Wrong size on AFldCrowdTarget");
static_assert(offsetof(AFldCrowdTarget, MIndex_) == 0x000228, "Member 'AFldCrowdTarget::MIndex_' has a wrong offset!");
static_assert(offsetof(AFldCrowdTarget, MMobActor_) == 0x000230, "Member 'AFldCrowdTarget::MMobActor_' has a wrong offset!");

// Class xrd777.BFLBtlAnimation
// 0x0000 (0x0028 - 0x0028)
class UBFLBtlAnimation final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckMontageSectionIsLoop(class UAnimMontage* AnimMontage, class FName SectionName);
	static void CoordinateDefaultAnimPose(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimSequence* AnimSequence);
	static void ForcePoseUpdate(class USkeletalMeshComponent* SkeletalMesh);
	static class FName GetCurrentSectionName(class USkeletalMeshComponent* InSkeletalMeshComponent);
	static bool GetMontageAlignedNextSectionName(class UAnimMontage* AnimMontage, class FName SectionName, class FName* NextSectionName);
	static bool GetMontageNextSectionName(class UAnimMontage* AnimMontage, class FName SectionName, class FName* NextSectionName);
	static float GetMontageSectionLength(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* AnimMontage, class FName SectionName);
	static float GetRemainingTimeFromCurrentSection(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* AnimMontage);
	static void SetMontageAnimationSpeed(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, float PlayRate);
	static void SetMontagePositionInSection(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, class FName SectionName, float PositionInSection);
	static void StopMontageAnimation(class USkeletalMeshComponent* InSkeletalMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLBtlAnimation">();
	}
	static class UBFLBtlAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLBtlAnimation>();
	}
};
static_assert(alignof(UBFLBtlAnimation) == 0x000008, "Wrong alignment on UBFLBtlAnimation");
static_assert(sizeof(UBFLBtlAnimation) == 0x000028, "Wrong size on UBFLBtlAnimation");

// Class xrd777.BFLBtlManager
// 0x0000 (0x0028 - 0x0028)
class UBFLBtlManager final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckBattleCoreLoaded();
	static bool CheckBattleMainLoaded();
	static void ClearBattleManagerSetupFlags();
	static void MarkAsBattleCoreSetup();
	static void MarkAsBattleMainSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLBtlManager">();
	}
	static class UBFLBtlManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLBtlManager>();
	}
};
static_assert(alignof(UBFLBtlManager) == 0x000008, "Wrong alignment on UBFLBtlManager");
static_assert(sizeof(UBFLBtlManager) == 0x000028, "Wrong size on UBFLBtlManager");

// Class xrd777.NameEntryCnvCharDataAsset
// 0x0050 (0x0080 - 0x0030)
class UNameEntryCnvCharDataAsset final : public UAppDataAsset
{
public:
	TMap<uint32, class FString>                   Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NameEntryCnvCharDataAsset">();
	}
	static class UNameEntryCnvCharDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNameEntryCnvCharDataAsset>();
	}
};
static_assert(alignof(UNameEntryCnvCharDataAsset) == 0x000008, "Wrong alignment on UNameEntryCnvCharDataAsset");
static_assert(sizeof(UNameEntryCnvCharDataAsset) == 0x000080, "Wrong size on UNameEntryCnvCharDataAsset");
static_assert(offsetof(UNameEntryCnvCharDataAsset, Data) == 0x000030, "Member 'UNameEntryCnvCharDataAsset::Data' has a wrong offset!");

// Class xrd777.BFLEventMovieScene
// 0x0000 (0x0028 - 0x0028)
class UBFLEventMovieScene final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* AddPlayEvtMultiMontageAnimNotify(int32 Index_0, class UAnimMontage* NewMontage, const TArray<struct FAtlSlotMultiAnimationParam>& AnimAssets, class FName SlotNodeName, EEvtCharaAnimationType EvtCharaAnimationType, float CurrentMontageBlendOut, float NextMontageBlendIn);
	static void AddViewSlaveLocation(const struct FVector& Location, float BoostFactor, bool bOverrideLocation, float Duration);
	static int32 AllActorBinding(class AActor* BindingActor, const class FString& TargetName);
	static class UAnimMontage* CreateSlotAnimationAsDynamicMontage(class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* CreateSlotOffsetAnimationAsDynamicMontage(class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartOffsetTime, float EndOffsetTime, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class AAtlEvtEventManager* FindAtlEvtEventManager(class ULevelStreaming* TargetLevelStreaming);
	static class ALevelSequenceActor* FindLevelSequenceActor(class ULevelStreaming* TargetLevelStreaming);
	static class FName GetAnimationSlotName(EEvtCharaAnimationSlotType SlotType);
	static struct FMovieSceneObjectBindingID GetBindingID(class ALevelSequenceActor* SequenceActor, const class FString& ObjectDisplayName);
	static bool IsCondition(EEvtConditionalBranchCompType CompareType, int32 LHS, int32 RHS);
	static void LoadSublevel(const class FString& SublevelName);
	static class FName MakeSeasonSublevel(int32 FieldMajorID, int32 FieldMinorID, ECldSeason Season, bool bStreamingPath);
	static class UAnimMontage* PlaySlotAnimationAsDynamicMontageLoop(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotAnimationAsDynamicMontageLoopOnLastFrame(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotAnimationAsDynamicMontageLoopSecOnLastFrame(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartOffsetTime, float EndOffsetTime, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotAnimationAsDynamicMontageTwo(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class UAnimSequenceBase* Asset2, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotMultiAnimationAsDynamicMontage(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* BaseAnimAsset, TArray<struct FAtlSlotMultiAnimationParam>* AnimAssets, class FName SlotNodeName, EEvtCharaAnimationType EvtCharaAnimationType, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotMultiAnimationOffsetAsDynamicMontage(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* BaseAnimAsset, TArray<struct FAtlSlotMultiAnimationParam>* AnimAssets, class FName SlotNodeName, EEvtCharaAnimationType EvtCharaAnimationType, float StartOffsetTime, float EndOffsetTime, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotMultiAnimationOffsetAsDynamicMontageTwo(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* BaseAnimAsset, class UAnimSequenceBase* LoopAsset, class FName SlotNodeName, float StartOffsetTime, float EndOffsetTime, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class UAnimMontage* PlaySlotOffsetAnimationAsDynamicMontageLoop(class UAnimInstance* AnimInstance, class USkeletalMesh* Mesh, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartOffsetTime, float EndOffsetTime, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static void ResetNearClipPlane(const class UObject* WorldContextObject);
	static void SetEnableStreamingTexture(const class UObject* WorldContextObject, bool bEnable);
	static void SetNearClipPlane(const class UObject* WorldContextObject, float NearClipCm);
	static class USkeletalMeshComponent* SkeletalMeshComponentFromObject(class UObject* InObject);
	static void StopSlotAnimation(class UAnimInstance* AnimInstance, float BlendOutTime, class FName SlotNodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLEventMovieScene">();
	}
	static class UBFLEventMovieScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLEventMovieScene>();
	}
};
static_assert(alignof(UBFLEventMovieScene) == 0x000008, "Wrong alignment on UBFLEventMovieScene");
static_assert(sizeof(UBFLEventMovieScene) == 0x000028, "Wrong size on UBFLEventMovieScene");

// Class xrd777.PrgssCommonData
// 0x0018 (0x0040 - 0x0028)
class UPrgssCommonData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APrgssCmnDataActor*                     MActor_;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAstreaProgressDataAsset*               MData_;                                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrgssCommonData">();
	}
	static class UPrgssCommonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrgssCommonData>();
	}
};
static_assert(alignof(UPrgssCommonData) == 0x000008, "Wrong alignment on UPrgssCommonData");
static_assert(sizeof(UPrgssCommonData) == 0x000040, "Wrong size on UPrgssCommonData");
static_assert(offsetof(UPrgssCommonData, MActor_) == 0x000030, "Member 'UPrgssCommonData::MActor_' has a wrong offset!");
static_assert(offsetof(UPrgssCommonData, MData_) == 0x000038, "Member 'UPrgssCommonData::MData_' has a wrong offset!");

// Class xrd777.FldCommonData
// 0x0208 (0x0230 - 0x0028)
class UFldCommonData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldCmnDataActor*                       MActor_;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x80];                                      // 0x0038(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldTvProgramScript*                    MTvProgramActor_;                                  // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldMailOrderScript*                    MMailOrderActor_;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldBossBattleScript*                   MBossBattleActor_;                                 // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MTableDat_[0x17];                                  // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 MBpClass_[0x15];                                   // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCommonData">();
	}
	static class UFldCommonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCommonData>();
	}
};
static_assert(alignof(UFldCommonData) == 0x000008, "Wrong alignment on UFldCommonData");
static_assert(sizeof(UFldCommonData) == 0x000230, "Wrong size on UFldCommonData");
static_assert(offsetof(UFldCommonData, MActor_) == 0x000030, "Member 'UFldCommonData::MActor_' has a wrong offset!");
static_assert(offsetof(UFldCommonData, MTvProgramActor_) == 0x0000B8, "Member 'UFldCommonData::MTvProgramActor_' has a wrong offset!");
static_assert(offsetof(UFldCommonData, MMailOrderActor_) == 0x0000C0, "Member 'UFldCommonData::MMailOrderActor_' has a wrong offset!");
static_assert(offsetof(UFldCommonData, MBossBattleActor_) == 0x0000C8, "Member 'UFldCommonData::MBossBattleActor_' has a wrong offset!");
static_assert(offsetof(UFldCommonData, MTableDat_) == 0x0000D0, "Member 'UFldCommonData::MTableDat_' has a wrong offset!");
static_assert(offsetof(UFldCommonData, MBpClass_) == 0x000188, "Member 'UFldCommonData::MBpClass_' has a wrong offset!");

// Class xrd777.BtlActionManagerComponent
// 0x0028 (0x00F0 - 0x00C8)
class UBtlActionManagerComponent : public UAppActorComponent
{
public:
	class ABtlActor*                              ActionCommander;                                   // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBtlCommandType                               ActionType;                                        // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionID;                                          // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      ActionTargets;                                     // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UBtlTargetsManagerComponent*            TargetsManager;                                    // 0x00E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearCommand();
	void DoCommand();
	void SetCommand(class ABtlActor* Commander, EBtlCommandType Type, int32 ID);
	void SetCommander(class ABtlActor* Commander);
	void SetCommandTargets(const TArray<class ABtlActor*>& Targets);
	void SetCommandWithTargets(class ABtlActor* Commander, EBtlCommandType Type, int32 ID, const TArray<class ABtlActor*>& Targets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlActionManagerComponent">();
	}
	static class UBtlActionManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlActionManagerComponent>();
	}
};
static_assert(alignof(UBtlActionManagerComponent) == 0x000008, "Wrong alignment on UBtlActionManagerComponent");
static_assert(sizeof(UBtlActionManagerComponent) == 0x0000F0, "Wrong size on UBtlActionManagerComponent");
static_assert(offsetof(UBtlActionManagerComponent, ActionCommander) == 0x0000C8, "Member 'UBtlActionManagerComponent::ActionCommander' has a wrong offset!");
static_assert(offsetof(UBtlActionManagerComponent, ActionType) == 0x0000D0, "Member 'UBtlActionManagerComponent::ActionType' has a wrong offset!");
static_assert(offsetof(UBtlActionManagerComponent, ActionID) == 0x0000D4, "Member 'UBtlActionManagerComponent::ActionID' has a wrong offset!");
static_assert(offsetof(UBtlActionManagerComponent, ActionTargets) == 0x0000D8, "Member 'UBtlActionManagerComponent::ActionTargets' has a wrong offset!");
static_assert(offsetof(UBtlActionManagerComponent, TargetsManager) == 0x0000E8, "Member 'UBtlActionManagerComponent::TargetsManager' has a wrong offset!");

// Class xrd777.GenSelItemDefineDataAsset
// 0x0010 (0x0040 - 0x0030)
class UGenSelItemDefineDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FGenSelItemDefine>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenSelItemDefineDataAsset">();
	}
	static class UGenSelItemDefineDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenSelItemDefineDataAsset>();
	}
};
static_assert(alignof(UGenSelItemDefineDataAsset) == 0x000008, "Wrong alignment on UGenSelItemDefineDataAsset");
static_assert(sizeof(UGenSelItemDefineDataAsset) == 0x000040, "Wrong size on UGenSelItemDefineDataAsset");
static_assert(offsetof(UGenSelItemDefineDataAsset, Data) == 0x000030, "Member 'UGenSelItemDefineDataAsset::Data' has a wrong offset!");

// Class xrd777.BtlActor
// 0x107D8 (0x10A58 - 0x0280)
class ABtlActor : public APawn
{
public:
	FMulticastInlineDelegateProperty_             OnActCommand;                                      // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionStart;                                     // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowActionName;                                  // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedExpireSupport;                           // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedRecoveryFromBadStatus;                   // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedActBadStatus;                            // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSyncPersonaLoad;                                 // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBtlEventCustomEquipment               CustomEquipments;                                  // 0x02F0(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSyncSummonEnemyLoad;                             // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSyncFukaLoad;                                    // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBtlAttackType                                AttackBaseType;                                    // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x17];                                     // 0x0321(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HomePosition;                                      // 0x0338(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               HomeRotation;                                      // 0x0344(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                Position;                                          // 0x0350(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               Rotation;                                          // 0x035C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         HomePositionID;                                    // 0x0368(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InitialLocationIndexFromLeft;                      // 0x036C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnemyFlag;                                         // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          PersonaFlag;                                       // 0x0371(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          PersonaHideEmergeEffect;                           // 0x0372(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_373[0x5D];                                     // 0x0373(0x005D)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlAI*                                 AI;                                                // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlVoice*                              Voice;                                             // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlCoreComponent*                      BtlCore;                                           // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      PersonaList;                                       // 0x03E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         RequestedPersonaNum;                               // 0x03F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBtlEffectItem>                 EffectList;                                        // 0x0400(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<EBtlBadStatusIcon>                     EffectRequestList;                                 // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EBtlBadStatusIcon                             CurrentBadStatusType;                              // 0x0420(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBtlAlloutAttackResult                        AlloutAttackResult;                                // 0x0421(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBtlAttackPerformanceType                     AttackPerformanceType;                             // 0x0422(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_423[0x10635];                                  // 0x0423(0x10635)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionPlaySkillTimeline();
	void ActionPlayTheurgia();
	void ActionPrepareAct(class UBtlCoreComponent* BtlCore_0);
	void ActionPrepareSkill(class UBtlCoreComponent* BtlCore_0, const class ABtlSkill* Skill);
	void ActionReady(class UBtlCoreComponent* BtlCore_0);
	void AddStatusEffect(class UNiagaraComponent* Ref, EBtlBadStatusIcon Type, class AActor* ParentEmpActor);
	void AddStatusEffectRequestList(EBtlBadStatusIcon RequestType);
	void AddTheurgiaGauge(EBtlTheurgiaBoostType Type);
	void AdjustHomePosition();
	void AdjustPersonaLocation();
	void AffectEscape();
	void AffectGeneralAttackAnnihilation();
	void AffectGeneralAttackDamage();
	void AffectOverheat();
	void AffectRecoveryBadStatus(class UBtlCoreComponent* BtlCore_0);
	void AffectRecoveryFromEvent(float RecoveryHpRatio);
	void AffectSkillDamageRestPortion();
	struct FVector CalcClosedStandLocation(class UBtlCoreComponent* PCore, const struct FVector& Pos, float StandRange, bool CoordinateFromEnemyCenter);
	void CancelHoldup();
	void CharacterDestroy();
	bool CheckDownContinuedState();
	bool CheckExpireSupportStatus(class UBtlCoreComponent* BtlCore_0);
	bool CheckPersonaValid();
	bool CheckReady();
	bool CheckReadyCharacterBP();
	bool CheckReadyFukaForTheurgia(class ABtlActor* PFuka);
	bool CheckRecoveryFromBadStatus(class UBtlCoreComponent* BtlCore_0);
	void CleanupStatusEffect(bool Status, bool Down, bool KeepSwoon);
	void CoordinateSkillBPForSpecificSituations(class ABtlSkill* Skill);
	void CreatePersona();
	void CreateSummonEnemy();
	void DestroyEffect(class UNiagaraComponent* PNiagara);
	void DestroyFukaForTheurgia(class ABtlActor* PFuka);
	void DestroyPersona();
	void DestroyPersonaBeforeCreatePersona();
	void DoAutoSkillRecovery(bool* RecoveryValid);
	void DoBadStatusAction(bool* ActBadStatusSkillAction, bool* NeedToWaitProcess, bool* IsOverheatInterrupt);
	void DoBadStatusDamage(bool* IsDamageOccurred);
	void DoClearSupportStatus(class UBtlCoreComponent* BtlCore_0);
	void DoGeneralAttack();
	void DoNothing();
	bool DoSpecificAction();
	void DoSpecificActionActEnd();
	void DoSpecificActionAIEnd();
	void DoSpecificActionTurnEnd();
	void EndWaitTurn();
	void EnemiesLookatThisCharacter();
	class UBtlActionManagerComponent* GetActionManager();
	TArray<class ABtlActor*> GetActionTargets();
	class UAppCharBaseComp* GetCharaBPFromCode();
	EBtlAnimationType GetCurrentAnimation();
	class ABtlActor* GetPersona(int32 Index_0);
	struct FTransform GetSocketTransformFromCpp(class FName SocketName);
	class UBtlTargetsManagerComponent* GetTargetsManager();
	void HideForOtherAction(bool CriticalHindrance, bool Rapid, bool HalfMode);
	void InstantKill();
	bool IsAnimationChant();
	bool IsAnimationWait();
	void LoadFukaForTheurgia();
	void LoadModelsForAlloutAttack();
	void LoadModelsForEvent();
	void MarkAsAvoidRelocationUntilTurnEnd();
	void MarkAsCalledFirstSummonScene();
	void MarkAsHidingPersonaForSkillScene();
	void MarkAsPlayedStandbyCamera();
	void MarkReadyToDestroy();
	void PlayAbsorptionEffect();
	void PlayEnemySummonEffect();
	void PlayReflectionEffect();
	void PlayShakeAnim();
	void PlayVoiceAlloutAttackFinishCut();
	void PlayVoiceAlloutAttackFinishStart();
	void PlayVoiceAlloutAttacking();
	void PlayVoiceAlloutAttackStart();
	void PlayVoiceDead();
	void PlayVoiceFirstSummonScene();
	void PlayVoicePersonaSkill();
	void PlayVoicePersonaSkillCutin(bool IsFirstSummon);
	void PlayVoiceSkillChant();
	void PlayVoiceSkillShot();
	void PlayVoiceTakeoverReceive();
	void PlayVoiceTakeoverStart();
	void PlayVoiceTheurgia(int32 TypeIndex);
	void PlayWaitAnimation(float StartingPosition, bool UseBlendSetting, float Blend, bool IgnoreWhenSamePose);
	void PreAffectSkillDamagePortion(float PortionRatio);
	void ProcBeforeFadeinToAlloutAttackDamage();
	void ProcessBeforeCommandSelectStart();
	void RemoveEffectItem(EBtlBadStatusIcon Type);
	void RequestAddStatusEffect(EBtlBadStatusIcon Type);
	void RequestAnimation(EBtlAnimationType AnimType, float StartingPosition, bool UseBlendSetting, float Blend);
	void RequestAnimationWithNext(EBtlAnimationType AnimType, EBtlAnimationType AnimNextType);
	void RequestDamageAndDeadPerformance();
	void RequestFaceAnimation(EAppCharFaceAnimID AnimType, bool UseBlendSetting, float Blend);
	void RequestHidePlayersForEspaceSkill();
	void RequestPersonalAnimation();
	void ResetAlongWithRelocation();
	void RestoreModelsFromAlloutAttack();
	void RestoreModelsFromEvent();
	void RumbleEnemyEmerge();
	class USkeletalMeshComponent* SearchSkeletalMesh(class UObject* InObject);
	void SetActionID(int32 ActionID);
	void SetActiveMode(bool Enable);
	void SetDisableUpdateFaceAnimFromBody(bool Disable);
	void SetEventMode(bool Enable);
	void SetGeneralAttackResult(EBtlAlloutAttackResult Type);
	void SetGuard();
	void SetPersonaLocation(const struct FTransform& RelativeTrans, int32 Index_0);
	void SetPersonaWorldLocation(const struct FTransform& WorldTrans, int32 Index_0);
	void SetStatusColor(const struct FColor& Color);
	void SetupConditionForAllyEscape();
	void SetupForEventMode(bool Enable);
	void SetVisibleFromCode(bool Visible);
	void ShowActionName();
	void ShowFromHiding();
	TArray<class ABtlActor*> SpawnAllSummonEnemy();
	void SpawnCharacterBP(bool InitialHiding);
	class ABtlActor* SpawnFukaForTheurgia();
	void SpawnPersona(bool WithoutEmergeEffect);
	class ABtlActor* SpawnSummonEnemy();
	void StandbyAction();
	void StartEscape();
	void StartHoldup();
	void StopShakeAnim();
	void SummonGunTurnToTheurgiaMode();
	bool SyncModelsForAlloutAttack();
	bool SyncModelsForEvent();
	void ToEndTurn();
	void TurnOffOrgia(bool Dead);
	void UpdatePersonalAnimation();

	bool CheckActiveMode() const;
	bool CheckAlive() const;
	bool CheckAlreadyTakeover() const;
	bool CheckBackshotDisable() const;
	bool CheckBadStatusAction() const;
	bool CheckBadStatusDamage() const;
	bool CheckBadStatusEscape() const;
	bool CheckCutinOccur() const;
	bool CheckDisableUpdateFaceAnimFromBody() const;
	bool CheckEnableDeadAnimation() const;
	bool CheckEnableRotation() const;
	bool CheckEnableTakeover() const;
	bool CheckEnableTheurgiaSkillUse() const;
	bool CheckEnableTranslucence() const;
	bool CheckExistStatusEffect(EBtlBadStatusIcon Type) const;
	bool CheckExistStatusEffectRequestList(EBtlBadStatusIcon RequestType) const;
	bool CheckGeneralAttackAnnihilation() const;
	bool CheckGuest() const;
	bool CheckHiddingWeaponMode() const;
	bool CheckHidingPersonaForSkillScene() const;
	bool CheckIdle() const;
	bool CheckInAlloutSequence() const;
	bool CheckInOverheatProc() const;
	bool CheckKeepDeadAnimation() const;
	bool CheckLookatEnable() const;
	bool CheckNeedOverheatScene() const;
	bool CheckNeedToCallFirstSummonScene() const;
	bool CheckNeedToPlayPreSkillPorc() const;
	bool CheckNotSummonPersonaSkill() const;
	bool CheckPersonaAlreadyChanged() const;
	bool CheckPersonaStartWithoutEmergePerformance() const;
	bool CheckPlayableShortSkillSceneAfterCutin() const;
	bool CheckPlayableWaitAnimation() const;
	bool CheckPlayedStandbyCamera() const;
	bool CheckPriorConvExAnimSection() const;
	bool CheckProgressToHoldup() const;
	bool CheckRecoveryFromDown() const;
	bool CheckShakingWhenDownDamage() const;
	bool CheckSkillCameraCharacterHideDisable() const;
	bool CheckSkipAction() const;
	bool CheckSkipSkillChantAnim() const;
	bool CheckSkipSkillEndAnim() const;
	bool CheckSkipTurn() const;
	bool CheckTurnFromGuardCancel() const;
	bool CheckUseSkillShotSeqCam() const;
	bool CheckUsingTakeoverOtherCamera() const;
	class FName ConvExAnimSectionName(bool* Found, EBtlAnimationType Type, bool* ForceShowWeapon, struct FBtlBossAnimRequestParam* Params_0) const;
	int32 GetActionID() const;
	EBtlCommandType GetActionType() const;
	float GetAnimationBaseSpeedRatio() const;
	EBtlDataAttr GetAttackAttr() const;
	EBtlAttackPerformanceType GetAttackPerformanceType() const;
	EBtlAttackType GetAttackType() const;
	EBtlAttackWeaponAnimType GetAttackWeaponAnimType() const;
	float GetBadStatusActionWaitTime() const;
	class FName GetBadStatusEffectName(EBtlBadStatusIcon Type) const;
	int32 GetCharacterID() const;
	EBtlBadStatusIcon GetCurrentStatusEffectType() const;
	float GetExpireSupportWaitTime() const;
	EBtlAlloutAttackResult GetGeneralAttackResult() const;
	struct FVector GetHomePosition() const;
	int32 GetId() const;
	int32 GetItemID() const;
	int32 GetOriginalID() const;
	struct FTransform GetPersonaTransform(bool ForCutin) const;
	struct FTransform GetPersonaTransformFromSkillCondition(const class ABtlActor* PersonaOwner) const;
	float GetRecoveryWaitTime() const;
	EBtlSizeCategoryType GetSizeCategory() const;
	struct FBtlBossAnimRequestParam GetSkillChantAnim() const;
	struct FBtlBossAnimRequestParam GetSkillEndAnim() const;
	int32 GetSkillID() const;
	struct FBtlBossAnimRequestParam GetSkillShotAnim() const;
	int32 GetSummonEnemyID() const;
	int32 GetUID() const;
	bool IsAstreaColosseoEnemy() const;
	bool IsAstreaCutinEnemy() const;
	bool IsAttackControlledByAI() const;
	bool IsAttackFailed() const;
	bool IsAttackHit() const;
	bool IsAttackMiss() const;
	bool IsBoss() const;
	bool IsDead() const;
	bool IsDormancy() const;
	bool IsDown() const;
	bool IsDying() const;
	bool IsDyingBadStatus() const;
	bool IsEnemy() const;
	bool IsEnemyInParty() const;
	bool IsGuard() const;
	bool IsInActionTurn() const;
	bool IsInOneMore() const;
	bool IsInTakeOver() const;
	bool IsKoromaru() const;
	bool IsManualOperation() const;
	bool IsNewBattleOutfit() const;
	bool IsNewBattleOutfitForAlloutFinish() const;
	bool IsOccurringSkillAbsorption() const;
	bool IsOccurringSkillBlock() const;
	bool IsOccurringSkillReflection() const;
	bool IsOrgia() const;
	bool IsPersona() const;
	bool IsPersonaEvolved() const;
	bool IsPlayableDyingAnim() const;
	bool IsPossibleAITarget() const;
	bool IsPossibleAlloutMember() const;
	bool IsPossibleEventTarget() const;
	bool IsPossibleTakeoverTarget() const;
	bool IsRushAttack() const;
	bool IsSkillEffective() const;
	bool IsSkillFukaTheurgia() const;
	bool IsSkillHit() const;
	bool IsSkillItemDumping() const;
	bool IsSkillMixraid() const;
	bool IsSkillOrgia() const;
	bool IsSkillPhysicalType() const;
	bool IsSkillTheurgia() const;
	bool IsSkillTrafuliEscape() const;
	bool IsStrega() const;
	bool IsSummonedEnemy() const;
	bool IsUsingAllTargetSkill() const;
	bool IsUsingDamageSkill() const;
	bool IsUsingGroupTargetSkill() const;
	bool IsUsingOffensiveSkill() const;
	bool IsUsingSummonSkill() const;
	bool IsValidUnit() const;
	bool IsVelvet() const;
	bool SyncSkillTimeline() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlActor">();
	}
	static class ABtlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlActor>();
	}
};
static_assert(alignof(ABtlActor) == 0x000008, "Wrong alignment on ABtlActor");
static_assert(sizeof(ABtlActor) == 0x010A58, "Wrong size on ABtlActor");
static_assert(offsetof(ABtlActor, OnActCommand) == 0x000280, "Member 'ABtlActor::OnActCommand' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnActionStart) == 0x000290, "Member 'ABtlActor::OnActionStart' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnShowActionName) == 0x0002A0, "Member 'ABtlActor::OnShowActionName' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnFinishedExpireSupport) == 0x0002B0, "Member 'ABtlActor::OnFinishedExpireSupport' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnFinishedRecoveryFromBadStatus) == 0x0002C0, "Member 'ABtlActor::OnFinishedRecoveryFromBadStatus' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnFinishedActBadStatus) == 0x0002D0, "Member 'ABtlActor::OnFinishedActBadStatus' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnSyncPersonaLoad) == 0x0002E0, "Member 'ABtlActor::OnSyncPersonaLoad' has a wrong offset!");
static_assert(offsetof(ABtlActor, CustomEquipments) == 0x0002F0, "Member 'ABtlActor::CustomEquipments' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnSyncSummonEnemyLoad) == 0x000300, "Member 'ABtlActor::OnSyncSummonEnemyLoad' has a wrong offset!");
static_assert(offsetof(ABtlActor, OnSyncFukaLoad) == 0x000310, "Member 'ABtlActor::OnSyncFukaLoad' has a wrong offset!");
static_assert(offsetof(ABtlActor, AttackBaseType) == 0x000320, "Member 'ABtlActor::AttackBaseType' has a wrong offset!");
static_assert(offsetof(ABtlActor, HomePosition) == 0x000338, "Member 'ABtlActor::HomePosition' has a wrong offset!");
static_assert(offsetof(ABtlActor, HomeRotation) == 0x000344, "Member 'ABtlActor::HomeRotation' has a wrong offset!");
static_assert(offsetof(ABtlActor, Position) == 0x000350, "Member 'ABtlActor::Position' has a wrong offset!");
static_assert(offsetof(ABtlActor, Rotation) == 0x00035C, "Member 'ABtlActor::Rotation' has a wrong offset!");
static_assert(offsetof(ABtlActor, HomePositionID) == 0x000368, "Member 'ABtlActor::HomePositionID' has a wrong offset!");
static_assert(offsetof(ABtlActor, InitialLocationIndexFromLeft) == 0x00036C, "Member 'ABtlActor::InitialLocationIndexFromLeft' has a wrong offset!");
static_assert(offsetof(ABtlActor, EnemyFlag) == 0x000370, "Member 'ABtlActor::EnemyFlag' has a wrong offset!");
static_assert(offsetof(ABtlActor, PersonaFlag) == 0x000371, "Member 'ABtlActor::PersonaFlag' has a wrong offset!");
static_assert(offsetof(ABtlActor, PersonaHideEmergeEffect) == 0x000372, "Member 'ABtlActor::PersonaHideEmergeEffect' has a wrong offset!");
static_assert(offsetof(ABtlActor, AI) == 0x0003D0, "Member 'ABtlActor::AI' has a wrong offset!");
static_assert(offsetof(ABtlActor, Voice) == 0x0003D8, "Member 'ABtlActor::Voice' has a wrong offset!");
static_assert(offsetof(ABtlActor, BtlCore) == 0x0003E0, "Member 'ABtlActor::BtlCore' has a wrong offset!");
static_assert(offsetof(ABtlActor, PersonaList) == 0x0003E8, "Member 'ABtlActor::PersonaList' has a wrong offset!");
static_assert(offsetof(ABtlActor, RequestedPersonaNum) == 0x0003F8, "Member 'ABtlActor::RequestedPersonaNum' has a wrong offset!");
static_assert(offsetof(ABtlActor, EffectList) == 0x000400, "Member 'ABtlActor::EffectList' has a wrong offset!");
static_assert(offsetof(ABtlActor, EffectRequestList) == 0x000410, "Member 'ABtlActor::EffectRequestList' has a wrong offset!");
static_assert(offsetof(ABtlActor, CurrentBadStatusType) == 0x000420, "Member 'ABtlActor::CurrentBadStatusType' has a wrong offset!");
static_assert(offsetof(ABtlActor, AlloutAttackResult) == 0x000421, "Member 'ABtlActor::AlloutAttackResult' has a wrong offset!");
static_assert(offsetof(ABtlActor, AttackPerformanceType) == 0x000422, "Member 'ABtlActor::AttackPerformanceType' has a wrong offset!");

// Class xrd777.BtlPersonaInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlPersonaInterface final : public IInterface
{
public:
	void SetPersonaOwner(class ABtlActor* PersonaOwner);

	struct FTransform GetPersonaTransformFromSkillCondition(const class ABtlActor* PersonaOwner) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPersonaInterface">();
	}
	static class IBtlPersonaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlPersonaInterface>();
	}
};
static_assert(alignof(IBtlPersonaInterface) == 0x000008, "Wrong alignment on IBtlPersonaInterface");
static_assert(sizeof(IBtlPersonaInterface) == 0x000028, "Wrong size on IBtlPersonaInterface");

// Class xrd777.BtlAegisInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlAegisInterface final : public IInterface
{
public:
	void ClearAllAegisEffect();
	void PlayOrgiaDeadEffect();
	void SetupOrgia(bool Enable);
	void SetupOrgiaAttackEffect(bool Enable);
	void SetupOrgiaWaitingEffect(bool Enable);
	void SetupOverheat(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlAegisInterface">();
	}
	static class IBtlAegisInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlAegisInterface>();
	}
};
static_assert(alignof(IBtlAegisInterface) == 0x000008, "Wrong alignment on IBtlAegisInterface");
static_assert(sizeof(IBtlAegisInterface) == 0x000028, "Wrong size on IBtlAegisInterface");

// Class xrd777.AccsItemListTable
// 0x0010 (0x0040 - 0x0030)
class UAccsItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FAccsItemList>                  Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccsItemListTable">();
	}
	static class UAccsItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccsItemListTable>();
	}
};
static_assert(alignof(UAccsItemListTable) == 0x000008, "Wrong alignment on UAccsItemListTable");
static_assert(sizeof(UAccsItemListTable) == 0x000040, "Wrong size on UAccsItemListTable");
static_assert(offsetof(UAccsItemListTable, Data) == 0x000030, "Member 'UAccsItemListTable::Data' has a wrong offset!");

// Class xrd777.PersonaStatusSelectSkillSeq
// 0x0068 (0x0098 - 0x0030)
class UPersonaStatusSelectSkillSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSelectSkillSeq">();
	}
	static class UPersonaStatusSelectSkillSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSelectSkillSeq>();
	}
};
static_assert(alignof(UPersonaStatusSelectSkillSeq) == 0x000008, "Wrong alignment on UPersonaStatusSelectSkillSeq");
static_assert(sizeof(UPersonaStatusSelectSkillSeq) == 0x000098, "Wrong size on UPersonaStatusSelectSkillSeq");

// Class xrd777.FclWeaponShopDrawActorBase
// 0x0028 (0x02A0 - 0x0278)
class AFclWeaponShopDrawActorBase : public AAppActor
{
public:
	class UMcaAsset*                              _CurrentMcaAsset;                                  // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           _CurrentCamera;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _OldCamera;                                        // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMcaCamera(class UMcaAsset* McaAsset, bool Play);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclWeaponShopDrawActorBase">();
	}
	static class AFclWeaponShopDrawActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclWeaponShopDrawActorBase>();
	}
};
static_assert(alignof(AFclWeaponShopDrawActorBase) == 0x000008, "Wrong alignment on AFclWeaponShopDrawActorBase");
static_assert(sizeof(AFclWeaponShopDrawActorBase) == 0x0002A0, "Wrong size on AFclWeaponShopDrawActorBase");
static_assert(offsetof(AFclWeaponShopDrawActorBase, _CurrentMcaAsset) == 0x000278, "Member 'AFclWeaponShopDrawActorBase::_CurrentMcaAsset' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActorBase, _CurrentCamera) == 0x000280, "Member 'AFclWeaponShopDrawActorBase::_CurrentCamera' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActorBase, _OldCamera) == 0x000288, "Member 'AFclWeaponShopDrawActorBase::_OldCamera' has a wrong offset!");

// Class xrd777.FclAntiqueShopDrawActor
// 0x0770 (0x0A10 - 0x02A0)
class AFclAntiqueShopDrawActor final : public AFclWeaponShopDrawActorBase
{
public:
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAntiqueShopDrawCommon*                 _CommonData;                                       // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _ListUnselectedStringColor;                        // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _ListPanelColor;                                   // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _DetailPanelHyphenColor;                           // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _MatIconDisabledColor;                             // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _MatNamelDisabledColor;                            // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _MatNumberDisabledColor;                           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _BgColor;                                          // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponShopAnimParam                   _TopMenuList1stAnim;                               // 0x0308(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuListAnim;                                  // 0x0350(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuListOutAnim;                               // 0x0398(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuKanban1stAnim;                             // 0x03E0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuKanbanAnim;                                // 0x0428(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuKanbanOutAnim;                             // 0x0470(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuMoonAnim;                                  // 0x04B8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuMoonLoopAnim;                              // 0x0500(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuMoonOutAnim;                               // 0x0548(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListCursorBaseInAnim;                             // 0x0590(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListCursorInAnim;                                 // 0x05D8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListTriangleCursorInAnim;                         // 0x0620(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListTriangleCursorLoopAnim;                       // 0x0668(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CompareBaseShiftAnim;                             // 0x06B0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CompareMoonRotateAnim;                            // 0x06F8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CompareCharacterMoonRotateAnim;                   // 0x0740(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CompareOutAnim;                                   // 0x0788(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _LRCursorLoopAnim;                                 // 0x07D0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _LRCursorInputAnim;                                // 0x0818(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _UDCursorLoopAnim;                                 // 0x0860(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _UDCursorInputAnim;                                // 0x08A8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ParamUpDownAnim;                                  // 0x08F0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _SellListCursorBaseInAnim;                         // 0x0938(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _SellListCursorInAnim;                             // 0x0980(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ParamUpDownLoopAnim;                              // 0x09C8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void EventMcaCameraCombine(int32 Tag);
	void EventMcaCameraExchange(int32 Tag);
	void EventMcaCameraInit(int32 Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclAntiqueShopDrawActor">();
	}
	static class AFclAntiqueShopDrawActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclAntiqueShopDrawActor>();
	}
};
static_assert(alignof(AFclAntiqueShopDrawActor) == 0x000008, "Wrong alignment on AFclAntiqueShopDrawActor");
static_assert(sizeof(AFclAntiqueShopDrawActor) == 0x000A10, "Wrong size on AFclAntiqueShopDrawActor");
static_assert(offsetof(AFclAntiqueShopDrawActor, _CommonData) == 0x0002E0, "Member 'AFclAntiqueShopDrawActor::_CommonData' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListUnselectedStringColor) == 0x0002E8, "Member 'AFclAntiqueShopDrawActor::_ListUnselectedStringColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListPanelColor) == 0x0002EC, "Member 'AFclAntiqueShopDrawActor::_ListPanelColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _DetailPanelHyphenColor) == 0x0002F0, "Member 'AFclAntiqueShopDrawActor::_DetailPanelHyphenColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _MatIconDisabledColor) == 0x0002F4, "Member 'AFclAntiqueShopDrawActor::_MatIconDisabledColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _MatNamelDisabledColor) == 0x0002F8, "Member 'AFclAntiqueShopDrawActor::_MatNamelDisabledColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _MatNumberDisabledColor) == 0x0002FC, "Member 'AFclAntiqueShopDrawActor::_MatNumberDisabledColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _BgColor) == 0x000300, "Member 'AFclAntiqueShopDrawActor::_BgColor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuList1stAnim) == 0x000308, "Member 'AFclAntiqueShopDrawActor::_TopMenuList1stAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuListAnim) == 0x000350, "Member 'AFclAntiqueShopDrawActor::_TopMenuListAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuListOutAnim) == 0x000398, "Member 'AFclAntiqueShopDrawActor::_TopMenuListOutAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuKanban1stAnim) == 0x0003E0, "Member 'AFclAntiqueShopDrawActor::_TopMenuKanban1stAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuKanbanAnim) == 0x000428, "Member 'AFclAntiqueShopDrawActor::_TopMenuKanbanAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuKanbanOutAnim) == 0x000470, "Member 'AFclAntiqueShopDrawActor::_TopMenuKanbanOutAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuMoonAnim) == 0x0004B8, "Member 'AFclAntiqueShopDrawActor::_TopMenuMoonAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuMoonLoopAnim) == 0x000500, "Member 'AFclAntiqueShopDrawActor::_TopMenuMoonLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _TopMenuMoonOutAnim) == 0x000548, "Member 'AFclAntiqueShopDrawActor::_TopMenuMoonOutAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListCursorBaseInAnim) == 0x000590, "Member 'AFclAntiqueShopDrawActor::_ListCursorBaseInAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListCursorInAnim) == 0x0005D8, "Member 'AFclAntiqueShopDrawActor::_ListCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListTriangleCursorInAnim) == 0x000620, "Member 'AFclAntiqueShopDrawActor::_ListTriangleCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ListTriangleCursorLoopAnim) == 0x000668, "Member 'AFclAntiqueShopDrawActor::_ListTriangleCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _CompareBaseShiftAnim) == 0x0006B0, "Member 'AFclAntiqueShopDrawActor::_CompareBaseShiftAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _CompareMoonRotateAnim) == 0x0006F8, "Member 'AFclAntiqueShopDrawActor::_CompareMoonRotateAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _CompareCharacterMoonRotateAnim) == 0x000740, "Member 'AFclAntiqueShopDrawActor::_CompareCharacterMoonRotateAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _CompareOutAnim) == 0x000788, "Member 'AFclAntiqueShopDrawActor::_CompareOutAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _LRCursorLoopAnim) == 0x0007D0, "Member 'AFclAntiqueShopDrawActor::_LRCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _LRCursorInputAnim) == 0x000818, "Member 'AFclAntiqueShopDrawActor::_LRCursorInputAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _UDCursorLoopAnim) == 0x000860, "Member 'AFclAntiqueShopDrawActor::_UDCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _UDCursorInputAnim) == 0x0008A8, "Member 'AFclAntiqueShopDrawActor::_UDCursorInputAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ParamUpDownAnim) == 0x0008F0, "Member 'AFclAntiqueShopDrawActor::_ParamUpDownAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _SellListCursorBaseInAnim) == 0x000938, "Member 'AFclAntiqueShopDrawActor::_SellListCursorBaseInAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _SellListCursorInAnim) == 0x000980, "Member 'AFclAntiqueShopDrawActor::_SellListCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShopDrawActor, _ParamUpDownLoopAnim) == 0x0009C8, "Member 'AFclAntiqueShopDrawActor::_ParamUpDownLoopAnim' has a wrong offset!");

// Class xrd777.BtlAiScriptWatcher
// 0x0020 (0x0298 - 0x0278)
class ABtlAiScriptWatcher final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlAI*                                 AI;                                                // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBtlActionManagerComponent*             ActionManager;                                     // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlActor*                              Character;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlAiScriptWatcher">();
	}
	static class ABtlAiScriptWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlAiScriptWatcher>();
	}
};
static_assert(alignof(ABtlAiScriptWatcher) == 0x000008, "Wrong alignment on ABtlAiScriptWatcher");
static_assert(sizeof(ABtlAiScriptWatcher) == 0x000298, "Wrong size on ABtlAiScriptWatcher");
static_assert(offsetof(ABtlAiScriptWatcher, AI) == 0x000280, "Member 'ABtlAiScriptWatcher::AI' has a wrong offset!");
static_assert(offsetof(ABtlAiScriptWatcher, ActionManager) == 0x000288, "Member 'ABtlAiScriptWatcher::ActionManager' has a wrong offset!");
static_assert(offsetof(ABtlAiScriptWatcher, Character) == 0x000290, "Member 'ABtlAiScriptWatcher::Character' has a wrong offset!");

// Class xrd777.DungeonAssetData
// 0x0058 (0x0080 - 0x0028)
class UDungeonAssetData final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pObject;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonAssetData*                      M_pSyncData;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonAssetData">();
	}
	static class UDungeonAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonAssetData>();
	}
};
static_assert(alignof(UDungeonAssetData) == 0x000008, "Wrong alignment on UDungeonAssetData");
static_assert(sizeof(UDungeonAssetData) == 0x000080, "Wrong size on UDungeonAssetData");
static_assert(offsetof(UDungeonAssetData, M_pObject) == 0x000050, "Member 'UDungeonAssetData::M_pObject' has a wrong offset!");
static_assert(offsetof(UDungeonAssetData, M_pSyncData) == 0x000078, "Member 'UDungeonAssetData::M_pSyncData' has a wrong offset!");

// Class xrd777.BtlManualAI
// 0x0000 (0x0B58 - 0x0B58)
class ABtlManualAI final : public ABtlAI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlManualAI">();
	}
	static class ABtlManualAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlManualAI>();
	}
};
static_assert(alignof(ABtlManualAI) == 0x000008, "Wrong alignment on ABtlManualAI");
static_assert(sizeof(ABtlManualAI) == 0x000B58, "Wrong size on ABtlManualAI");

// Class xrd777.VeveWork
// 0x0010 (0x0038 - 0x0028)
class UVeveWork final : public UObject
{
public:
	class UDataTable*                             PTable;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VeveWork">();
	}
	static class UVeveWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVeveWork>();
	}
};
static_assert(alignof(UVeveWork) == 0x000008, "Wrong alignment on UVeveWork");
static_assert(sizeof(UVeveWork) == 0x000038, "Wrong size on UVeveWork");
static_assert(offsetof(UVeveWork, PTable) == 0x000028, "Member 'UVeveWork::PTable' has a wrong offset!");

// Class xrd777.FldDailyMenuScript
// 0x0008 (0x02B8 - 0x02B0)
class AFldDailyMenuScript final : public AFldScriptManagerCore
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDailyMenuScript">();
	}
	static class AFldDailyMenuScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDailyMenuScript>();
	}
};
static_assert(alignof(AFldDailyMenuScript) == 0x000008, "Wrong alignment on AFldDailyMenuScript");
static_assert(sizeof(AFldDailyMenuScript) == 0x0002B8, "Wrong size on AFldDailyMenuScript");

// Class xrd777.BtlAIManagerComponent
// 0x0000 (0x00B0 - 0x00B0)
class UBtlAIManagerComponent final : public UActorComponent
{
public:
	void DetermineAIAction(class UBtlActionManagerComponent* ActionManager, class ABtlActor* Commander);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlAIManagerComponent">();
	}
	static class UBtlAIManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlAIManagerComponent>();
	}
};
static_assert(alignof(UBtlAIManagerComponent) == 0x000008, "Wrong alignment on UBtlAIManagerComponent");
static_assert(sizeof(UBtlAIManagerComponent) == 0x0000B0, "Wrong size on UBtlAIManagerComponent");

// Class xrd777.DatBagEnableTable
// 0x0010 (0x0040 - 0x0030)
class UDatBagEnableTable final : public UAppDataAsset
{
public:
	TArray<struct FDatBagEnableDataTable>         Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatBagEnableTable">();
	}
	static class UDatBagEnableTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatBagEnableTable>();
	}
};
static_assert(alignof(UDatBagEnableTable) == 0x000008, "Wrong alignment on UDatBagEnableTable");
static_assert(sizeof(UDatBagEnableTable) == 0x000040, "Wrong size on UDatBagEnableTable");
static_assert(offsetof(UDatBagEnableTable, Data) == 0x000030, "Member 'UDatBagEnableTable::Data' has a wrong offset!");

// Class xrd777.BtlBCDMoveCameraComponent
// 0x0008 (0x00B8 - 0x00B0)
class UBtlBCDMoveCameraComponent final : public UActorComponent
{
public:
	float                                         BlendAlpha;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlCutsceneMoveMode                          MoveMode;                                          // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBCDMoveCameraComponent">();
	}
	static class UBtlBCDMoveCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBCDMoveCameraComponent>();
	}
};
static_assert(alignof(UBtlBCDMoveCameraComponent) == 0x000008, "Wrong alignment on UBtlBCDMoveCameraComponent");
static_assert(sizeof(UBtlBCDMoveCameraComponent) == 0x0000B8, "Wrong size on UBtlBCDMoveCameraComponent");
static_assert(offsetof(UBtlBCDMoveCameraComponent, BlendAlpha) == 0x0000B0, "Member 'UBtlBCDMoveCameraComponent::BlendAlpha' has a wrong offset!");
static_assert(offsetof(UBtlBCDMoveCameraComponent, MoveMode) == 0x0000B4, "Member 'UBtlBCDMoveCameraComponent::MoveMode' has a wrong offset!");

// Class xrd777.PersonaStatusCommentarySeq
// 0x0018 (0x0048 - 0x0030)
class UPersonaStatusCommentarySeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusCommentarySeq">();
	}
	static class UPersonaStatusCommentarySeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusCommentarySeq>();
	}
};
static_assert(alignof(UPersonaStatusCommentarySeq) == 0x000008, "Wrong alignment on UPersonaStatusCommentarySeq");
static_assert(sizeof(UPersonaStatusCommentarySeq) == 0x000048, "Wrong size on UPersonaStatusCommentarySeq");

// Class xrd777.DatTheurgia
// 0x0028 (0x0050 - 0x0028)
class UDatTheurgia final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableTheurgiaBoost;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableTheurgiaBoostBoss;                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableMixraidRelease;                               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              TheurgiaFlavorText;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatTheurgia">();
	}
	static class UDatTheurgia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatTheurgia>();
	}
};
static_assert(alignof(UDatTheurgia) == 0x000008, "Wrong alignment on UDatTheurgia");
static_assert(sizeof(UDatTheurgia) == 0x000050, "Wrong size on UDatTheurgia");
static_assert(offsetof(UDatTheurgia, Loader) == 0x000028, "Member 'UDatTheurgia::Loader' has a wrong offset!");
static_assert(offsetof(UDatTheurgia, TableTheurgiaBoost) == 0x000030, "Member 'UDatTheurgia::TableTheurgiaBoost' has a wrong offset!");
static_assert(offsetof(UDatTheurgia, TableTheurgiaBoostBoss) == 0x000038, "Member 'UDatTheurgia::TableTheurgiaBoostBoss' has a wrong offset!");
static_assert(offsetof(UDatTheurgia, TableMixraidRelease) == 0x000040, "Member 'UDatTheurgia::TableMixraidRelease' has a wrong offset!");
static_assert(offsetof(UDatTheurgia, TheurgiaFlavorText) == 0x000048, "Member 'UDatTheurgia::TheurgiaFlavorText' has a wrong offset!");

// Class xrd777.BtlBossChariot
// 0x0010 (0x0040 - 0x0030)
class UBtlBossChariot final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossChariot">();
	}
	static class UBtlBossChariot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossChariot>();
	}
};
static_assert(alignof(UBtlBossChariot) == 0x000008, "Wrong alignment on UBtlBossChariot");
static_assert(sizeof(UBtlBossChariot) == 0x000040, "Wrong size on UBtlBossChariot");

// Class xrd777.BtlBossElizabeth
// 0x0008 (0x0038 - 0x0030)
class UBtlBossElizabeth final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossElizabeth">();
	}
	static class UBtlBossElizabeth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossElizabeth>();
	}
};
static_assert(alignof(UBtlBossElizabeth) == 0x000008, "Wrong alignment on UBtlBossElizabeth");
static_assert(sizeof(UBtlBossElizabeth) == 0x000038, "Wrong size on UBtlBossElizabeth");

// Class xrd777.EvitemItemListTable
// 0x0010 (0x0040 - 0x0030)
class UEvitemItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FEvitemItemList>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvitemItemListTable">();
	}
	static class UEvitemItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvitemItemListTable>();
	}
};
static_assert(alignof(UEvitemItemListTable) == 0x000008, "Wrong alignment on UEvitemItemListTable");
static_assert(sizeof(UEvitemItemListTable) == 0x000040, "Wrong size on UEvitemItemListTable");
static_assert(offsetof(UEvitemItemListTable, Data) == 0x000030, "Member 'UEvitemItemListTable::Data' has a wrong offset!");

// Class xrd777.BtlBossEmperor
// 0x0008 (0x0038 - 0x0030)
class UBtlBossEmperor final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossEmperor">();
	}
	static class UBtlBossEmperor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossEmperor>();
	}
};
static_assert(alignof(UBtlBossEmperor) == 0x000008, "Wrong alignment on UBtlBossEmperor");
static_assert(sizeof(UBtlBossEmperor) == 0x000038, "Wrong size on UBtlBossEmperor");

// Class xrd777.BtlBossErebus
// 0x0010 (0x0040 - 0x0030)
class UBtlBossErebus final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossErebus">();
	}
	static class UBtlBossErebus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossErebus>();
	}
};
static_assert(alignof(UBtlBossErebus) == 0x000008, "Wrong alignment on UBtlBossErebus");
static_assert(sizeof(UBtlBossErebus) == 0x000040, "Wrong size on UBtlBossErebus");

// Class xrd777.FldCharArea
// 0x0010 (0x0230 - 0x0220)
class AFldCharArea final : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          AreaComp;                                          // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharArea">();
	}
	static class AFldCharArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCharArea>();
	}
};
static_assert(alignof(AFldCharArea) == 0x000008, "Wrong alignment on AFldCharArea");
static_assert(sizeof(AFldCharArea) == 0x000230, "Wrong size on AFldCharArea");
static_assert(offsetof(AFldCharArea, RootComp) == 0x000220, "Member 'AFldCharArea::RootComp' has a wrong offset!");
static_assert(offsetof(AFldCharArea, AreaComp) == 0x000228, "Member 'AFldCharArea::AreaComp' has a wrong offset!");

// Class xrd777.BtlBossFortune
// 0x0010 (0x0040 - 0x0030)
class UBtlBossFortune final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlCoreComponent*                      PSavedCore;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ProcAfterReturnRoulette();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossFortune">();
	}
	static class UBtlBossFortune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossFortune>();
	}
};
static_assert(alignof(UBtlBossFortune) == 0x000008, "Wrong alignment on UBtlBossFortune");
static_assert(sizeof(UBtlBossFortune) == 0x000040, "Wrong size on UBtlBossFortune");
static_assert(offsetof(UBtlBossFortune, PSavedCore) == 0x000038, "Member 'UBtlBossFortune::PSavedCore' has a wrong offset!");

// Class xrd777.UIResources
// 0x00B8 (0x00E8 - 0x0030)
class UUIResources final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        Assets_;                                           // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x80];                                      // 0x0050(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             HandwritingLayoutData_;                            // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFontStyleAsset*                        FontStyleAsset_;                                   // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFont*                                  SystemFont_;                                       // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIResources">();
	}
	static class UUIResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIResources>();
	}
};
static_assert(alignof(UUIResources) == 0x000008, "Wrong alignment on UUIResources");
static_assert(sizeof(UUIResources) == 0x0000E8, "Wrong size on UUIResources");
static_assert(offsetof(UUIResources, Loader_) == 0x000038, "Member 'UUIResources::Loader_' has a wrong offset!");
static_assert(offsetof(UUIResources, Assets_) == 0x000040, "Member 'UUIResources::Assets_' has a wrong offset!");
static_assert(offsetof(UUIResources, HandwritingLayoutData_) == 0x0000D0, "Member 'UUIResources::HandwritingLayoutData_' has a wrong offset!");
static_assert(offsetof(UUIResources, FontStyleAsset_) == 0x0000D8, "Member 'UUIResources::FontStyleAsset_' has a wrong offset!");
static_assert(offsetof(UUIResources, SystemFont_) == 0x0000E0, "Member 'UUIResources::SystemFont_' has a wrong offset!");

// Class xrd777.DbgCmpStatusTest
// 0x0010 (0x0288 - 0x0278)
class ADbgCmpStatusTest final : public AAppActor
{
public:
	class UUICmpStatus*                           Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DbgCmpStatusTest">();
	}
	static class ADbgCmpStatusTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADbgCmpStatusTest>();
	}
};
static_assert(alignof(ADbgCmpStatusTest) == 0x000008, "Wrong alignment on ADbgCmpStatusTest");
static_assert(sizeof(ADbgCmpStatusTest) == 0x000288, "Wrong size on ADbgCmpStatusTest");
static_assert(offsetof(ADbgCmpStatusTest, Actor_) == 0x000278, "Member 'ADbgCmpStatusTest::Actor_' has a wrong offset!");
static_assert(offsetof(ADbgCmpStatusTest, DebugMenu_) == 0x000280, "Member 'ADbgCmpStatusTest::DebugMenu_' has a wrong offset!");

// Class xrd777.BtlBossHangedMan
// 0x0020 (0x0050 - 0x0030)
class UBtlBossHangedMan final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossHangedMan">();
	}
	static class UBtlBossHangedMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossHangedMan>();
	}
};
static_assert(alignof(UBtlBossHangedMan) == 0x000008, "Wrong alignment on UBtlBossHangedMan");
static_assert(sizeof(UBtlBossHangedMan) == 0x000050, "Wrong size on UBtlBossHangedMan");

// Class xrd777.BtlBossHermit
// 0x0018 (0x0048 - 0x0030)
class UBtlBossHermit final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossHermit">();
	}
	static class UBtlBossHermit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossHermit>();
	}
};
static_assert(alignof(UBtlBossHermit) == 0x000008, "Wrong alignment on UBtlBossHermit");
static_assert(sizeof(UBtlBossHermit) == 0x000048, "Wrong size on UBtlBossHermit");

// Class xrd777.FldBpFuncLib
// 0x0000 (0x0028 - 0x0028)
class UFldBpFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void CallFieldKeyFreeEventLevel(int32 FieldMajorID, int32 FieldMinorID, int32 TotalDay, ECldTimeZone TimeZone, int32 EventId, int32 PlayerStartID);
	static void CallFieldLevel(int32 FieldMajorID, int32 FieldMinorID, int32 TotalDay, ECldTimeZone TimeZone, int32 StartID);
	static void CheckLoadedCommonData(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CheckLoadedCommonDataSyncBlock();
	static void CheckRegistedSubLevel(const class UObject* WorldContextObject, const class FString& LevelName, EFldBpRetBool* Result);
	static void FldCommitViewports();
	static void FldDispCriAtomExDebugResourcesInfo();
	static class AActor* FldGetPlayerActor();
	static void FldLibUpdateCmmNpcLayoutTable(class UDataTable* SubLevelTable, class UDataTable* DataTable);
	static void FldLibUpdateNpcLayoutTable(class UDataTable* SubLevelTable, class UDataTable* DataTable);
	static void FldSetDisableNpcActor(int32 NpcMajorID, int32 NpcMinorID, bool ToHide);
	static void FldSoundManagerSetAisacValue_FRONT_VELVETROOM(float ControlValue);
	static int32 GetLocalCounter(class FName CntName);
	static void GetLocalFlag(class FName FlagName, EFldBpRetFlag* RetFlag);
	static EFldLoadPersistentType GetPersistentType(int32 FieldMajorID, int32 FieldMinorID);
	static bool HideSubLevellOrigin(const class UObject* WorldContextObject, const class FString& LevelAssetPath);
	static void RequestLoadSubLevelOrigin(const class UObject* WorldContextObject, const class FString& LevelAssetPath);
	static void RequestUnloadSubLevellOrigin(const class UObject* WorldContextObject, const class FString& LevelAssetPath);
	static void SetLocalCounter(class FName CntName, int32 Value);
	static void SetLocalFlag(class FName FlagName, bool OnOff);
	static void SetSkelMeshCompUpdateAnimationInEditor(class USkeletalMeshComponent* Component, const bool NewUpdateState);
	static bool ShowSubLevellOrigin(const class UObject* WorldContextObject, const class FString& LevelAssetPath);
	static void StartFadeIN(int32 Type, int32 Frame, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void StartFadeOUT(int32 Type, int32 Frame, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void SyncFade(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldBpFuncLib">();
	}
	static class UFldBpFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldBpFuncLib>();
	}
};
static_assert(alignof(UFldBpFuncLib) == 0x000008, "Wrong alignment on UFldBpFuncLib");
static_assert(sizeof(UFldBpFuncLib) == 0x000028, "Wrong size on UFldBpFuncLib");

// Class xrd777.CldDateDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCldDateDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FCldDateTableItem>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldDateDataAsset">();
	}
	static class UCldDateDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldDateDataAsset>();
	}
};
static_assert(alignof(UCldDateDataAsset) == 0x000008, "Wrong alignment on UCldDateDataAsset");
static_assert(sizeof(UCldDateDataAsset) == 0x000040, "Wrong size on UCldDateDataAsset");
static_assert(offsetof(UCldDateDataAsset, Data) == 0x000030, "Member 'UCldDateDataAsset::Data' has a wrong offset!");

// Class xrd777.UIDataInheritanceActor
// 0x0048 (0x02C0 - 0x0278)
class AUIDataInheritanceActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AUILoadDialog*                          SaveLoadUI;                                        // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADifficultySelectionActor*              DifficultySelection;                               // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADifficultySelectionActor>  DifficultySelectionSC;                             // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAddContent*                            AddContentCheck;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallStatePatternEndDelicate();
	void OnSelectedChoise();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDataInheritanceActor">();
	}
	static class AUIDataInheritanceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDataInheritanceActor>();
	}
};
static_assert(alignof(AUIDataInheritanceActor) == 0x000008, "Wrong alignment on AUIDataInheritanceActor");
static_assert(sizeof(AUIDataInheritanceActor) == 0x0002C0, "Wrong size on AUIDataInheritanceActor");
static_assert(offsetof(AUIDataInheritanceActor, SaveLoadUI) == 0x000288, "Member 'AUIDataInheritanceActor::SaveLoadUI' has a wrong offset!");
static_assert(offsetof(AUIDataInheritanceActor, Loader) == 0x000290, "Member 'AUIDataInheritanceActor::Loader' has a wrong offset!");
static_assert(offsetof(AUIDataInheritanceActor, DifficultySelection) == 0x000298, "Member 'AUIDataInheritanceActor::DifficultySelection' has a wrong offset!");
static_assert(offsetof(AUIDataInheritanceActor, DifficultySelectionSC) == 0x0002A0, "Member 'AUIDataInheritanceActor::DifficultySelectionSC' has a wrong offset!");
static_assert(offsetof(AUIDataInheritanceActor, AddContentCheck) == 0x0002A8, "Member 'AUIDataInheritanceActor::AddContentCheck' has a wrong offset!");

// Class xrd777.BtlBossHermitInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossHermitInterface final : public IInterface
{
public:
	void SetVisibleChargeEffect(bool Visible, bool StrongEffect);
	void SetVisibleChargeEffectFromLevel(bool Visible, int32 Level);
	void SetVisibleChargeStartEffect(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossHermitInterface">();
	}
	static class IBtlBossHermitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossHermitInterface>();
	}
};
static_assert(alignof(IBtlBossHermitInterface) == 0x000008, "Wrong alignment on IBtlBossHermitInterface");
static_assert(sizeof(IBtlBossHermitInterface) == 0x000028, "Wrong size on IBtlBossHermitInterface");

// Class xrd777.FldAnimalCompCore
// 0x00A8 (0x0170 - 0x00C8)
#pragma pack(push, 0x1)
class alignas(0x10) UFldAnimalCompCore : public UFldLocalActorComp
{
public:
	int32                                         MIndex_;                                           // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEscape_;                                        // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotComeBack_;                                   // 0x00CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MSceneOutTimeFix_;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSceneOutTimeRnd_;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MEscapeRadius_;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFldAnimalParam                        MParamater_;                                       // 0x00DC(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MEscapeVector_;                                    // 0x00F4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AAppPropsCore*                          MOwnerAnimal_;                                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MInitDisp_;                                        // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0xF];                                      // 0x0111(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MInitTransform_;                                   // 0x0120(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFldAnimalHit*                          MEscapeHit_;                                       // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         MOverlapTargets_;                                  // 0x0158(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class AAppPropsCore* CreateAnimalActor(class UWorld* InWorld, int32 InIndex, TSubclassOf<class AAppPropsCore> InClassPtr, const struct FTransform& InTransform, class AActor* InOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimalCompCore">();
	}
	static class UFldAnimalCompCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldAnimalCompCore>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFldAnimalCompCore) == 0x000010, "Wrong alignment on UFldAnimalCompCore");
static_assert(sizeof(UFldAnimalCompCore) == 0x000170, "Wrong size on UFldAnimalCompCore");
static_assert(offsetof(UFldAnimalCompCore, MIndex_) == 0x0000C8, "Member 'UFldAnimalCompCore::MIndex_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, bIsEscape_) == 0x0000CC, "Member 'UFldAnimalCompCore::bIsEscape_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, bIsNotComeBack_) == 0x0000CD, "Member 'UFldAnimalCompCore::bIsNotComeBack_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MSceneOutTimeFix_) == 0x0000D0, "Member 'UFldAnimalCompCore::MSceneOutTimeFix_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MSceneOutTimeRnd_) == 0x0000D4, "Member 'UFldAnimalCompCore::MSceneOutTimeRnd_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MEscapeRadius_) == 0x0000D8, "Member 'UFldAnimalCompCore::MEscapeRadius_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MParamater_) == 0x0000DC, "Member 'UFldAnimalCompCore::MParamater_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MEscapeVector_) == 0x0000F4, "Member 'UFldAnimalCompCore::MEscapeVector_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MOwnerAnimal_) == 0x000108, "Member 'UFldAnimalCompCore::MOwnerAnimal_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MInitDisp_) == 0x000110, "Member 'UFldAnimalCompCore::MInitDisp_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MInitTransform_) == 0x000120, "Member 'UFldAnimalCompCore::MInitTransform_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MEscapeHit_) == 0x000150, "Member 'UFldAnimalCompCore::MEscapeHit_' has a wrong offset!");
static_assert(offsetof(UFldAnimalCompCore, MOverlapTargets_) == 0x000158, "Member 'UFldAnimalCompCore::MOverlapTargets_' has a wrong offset!");

// Class xrd777.FldAnimalComp_CAT
// 0x00E0 (0x0250 - 0x0170)
class UFldAnimalComp_CAT final : public UFldAnimalCompCore
{
public:
	TArray<struct FFldCatMotionList>              MMotionPattern_;                                   // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MEscapeTime_;                                      // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MEscapeDist_;                                      // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MComebackDist_;                                    // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEscapeYawFixed_;                                  // 0x0184(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MEscapeFixedYaw_;                                  // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoWalkAway_;                                    // 0x018C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MAutoWalkAwayTimeFix_;                             // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAutoWalkAwayTimeRnd_;                             // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAutoWalkAwayYaw_;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAutoWalkAwayDist_;                                // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixedMove_;                                       // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFixedMoveTimeFix_;                                // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFixedMoveTimeRnd_;                                // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MFixedMoveTransform_;                              // 0x01B0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x70];                                     // 0x01E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimalComp_CAT">();
	}
	static class UFldAnimalComp_CAT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldAnimalComp_CAT>();
	}
};
static_assert(alignof(UFldAnimalComp_CAT) == 0x000010, "Wrong alignment on UFldAnimalComp_CAT");
static_assert(sizeof(UFldAnimalComp_CAT) == 0x000250, "Wrong size on UFldAnimalComp_CAT");
static_assert(offsetof(UFldAnimalComp_CAT, MMotionPattern_) == 0x000168, "Member 'UFldAnimalComp_CAT::MMotionPattern_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MEscapeTime_) == 0x000178, "Member 'UFldAnimalComp_CAT::MEscapeTime_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MEscapeDist_) == 0x00017C, "Member 'UFldAnimalComp_CAT::MEscapeDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MComebackDist_) == 0x000180, "Member 'UFldAnimalComp_CAT::MComebackDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, bEscapeYawFixed_) == 0x000184, "Member 'UFldAnimalComp_CAT::bEscapeYawFixed_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MEscapeFixedYaw_) == 0x000188, "Member 'UFldAnimalComp_CAT::MEscapeFixedYaw_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, bAutoWalkAway_) == 0x00018C, "Member 'UFldAnimalComp_CAT::bAutoWalkAway_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MAutoWalkAwayTimeFix_) == 0x000190, "Member 'UFldAnimalComp_CAT::MAutoWalkAwayTimeFix_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MAutoWalkAwayTimeRnd_) == 0x000194, "Member 'UFldAnimalComp_CAT::MAutoWalkAwayTimeRnd_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MAutoWalkAwayYaw_) == 0x000198, "Member 'UFldAnimalComp_CAT::MAutoWalkAwayYaw_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MAutoWalkAwayDist_) == 0x00019C, "Member 'UFldAnimalComp_CAT::MAutoWalkAwayDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, bFixedMove_) == 0x0001A0, "Member 'UFldAnimalComp_CAT::bFixedMove_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MFixedMoveTimeFix_) == 0x0001A4, "Member 'UFldAnimalComp_CAT::MFixedMoveTimeFix_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MFixedMoveTimeRnd_) == 0x0001A8, "Member 'UFldAnimalComp_CAT::MFixedMoveTimeRnd_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_CAT, MFixedMoveTransform_) == 0x0001B0, "Member 'UFldAnimalComp_CAT::MFixedMoveTransform_' has a wrong offset!");

// Class xrd777.BtlBossHierophant
// 0x0000 (0x0030 - 0x0030)
class UBtlBossHierophant final : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossHierophant">();
	}
	static class UBtlBossHierophant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossHierophant>();
	}
};
static_assert(alignof(UBtlBossHierophant) == 0x000008, "Wrong alignment on UBtlBossHierophant");
static_assert(sizeof(UBtlBossHierophant) == 0x000030, "Wrong size on UBtlBossHierophant");

// Class xrd777.UIDungeonTransfer
// 0x06A8 (0x0948 - 0x02A0)
class AUIDungeonTransfer final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pSpr;                                            // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr_BG;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlg;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pTable;                                          // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pLayoutData;                                     // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIDungeonTransferData*                 M_Data;                                            // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUIDungeonTransferData>     DataAsset;                                         // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x5F8];                                    // 0x02F0(0x05F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x58];                                     // 0x08F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDungeonTransfer">();
	}
	static class AUIDungeonTransfer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDungeonTransfer>();
	}
};
static_assert(alignof(AUIDungeonTransfer) == 0x000008, "Wrong alignment on AUIDungeonTransfer");
static_assert(sizeof(AUIDungeonTransfer) == 0x000948, "Wrong size on AUIDungeonTransfer");
static_assert(offsetof(AUIDungeonTransfer, Loader) == 0x0002B0, "Member 'AUIDungeonTransfer::Loader' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_pSpr) == 0x0002B8, "Member 'AUIDungeonTransfer::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_pSpr_BG) == 0x0002C0, "Member 'AUIDungeonTransfer::M_pSpr_BG' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_pPlg) == 0x0002C8, "Member 'AUIDungeonTransfer::M_pPlg' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_pTable) == 0x0002D0, "Member 'AUIDungeonTransfer::M_pTable' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_pLayoutData) == 0x0002D8, "Member 'AUIDungeonTransfer::M_pLayoutData' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, M_Data) == 0x0002E0, "Member 'AUIDungeonTransfer::M_Data' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, DataAsset) == 0x0002E8, "Member 'AUIDungeonTransfer::DataAsset' has a wrong offset!");
static_assert(offsetof(AUIDungeonTransfer, LayoutDataTable) == 0x0008E8, "Member 'AUIDungeonTransfer::LayoutDataTable' has a wrong offset!");

// Class xrd777.BtlBossTeammates
// 0x0000 (0x0030 - 0x0030)
class UBtlBossTeammates : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossTeammates">();
	}
	static class UBtlBossTeammates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossTeammates>();
	}
};
static_assert(alignof(UBtlBossTeammates) == 0x000008, "Wrong alignment on UBtlBossTeammates");
static_assert(sizeof(UBtlBossTeammates) == 0x000030, "Wrong size on UBtlBossTeammates");

// Class xrd777.FldHitCharacter
// 0x0118 (0x0468 - 0x0350)
class AFldHitCharacter : public AFldHitCore
{
public:
	class UShapeComponent*                        CollisionComp_;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFldHitCharaModelParam>         MCharaModelParam_;                                 // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFldHitCharaIconType                          MIconType_;                                        // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIconPlural_;                                      // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldHitCharaIconParam>          MChangeIconParam_;                                 // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFldHitCharaIconAttachedType                  MIconAttachedType_;                                // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MIconDirectLocationMODEL_;                         // 0x0384(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconDirectLocationMODEL_;                         // 0x0390(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MReadedFlagName_;                                  // 0x0394(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MFloorIndex_;                                      // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MLookHeroOverlap_;                                 // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MSpeakMotionKeyPush_;                              // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MLookHeroKeyPush_;                                 // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MFaceingHeroKeyPush_;                              // 0x03A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldHitCharaHeroMotion                        MHeroMotionKeyPush_;                               // 0x03A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MReturnBaseRotator_;                               // 0x03A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A6[0x2];                                      // 0x03A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterBaseCore>         MCharaBaseClass_;                                  // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ANpcBaseCore>               MNpcBaseClass_;                                    // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int16, class UFldNpcComp*>               MCharaModelList_;                                  // 0x03B8(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 MIconActor_;                                       // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MMoveActor_;                                       // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MHeroProcActor_;                                   // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MDispName_;                                        // 0x0420(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bChangedRotator_;                                  // 0x0430(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MBaseRotator_;                                     // 0x0434(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UFldHitCharaIdleTalkComp*               MIdleTalkComp_;                                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldHitCharaIdleBehaviorComp*           MIdleBehaviorComp_;                                // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsIdleBehaviorCreated_;                           // 0x0450(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGetAwayPrevAction_;                               // 0x0451(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_452[0x16];                                     // 0x0452(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndDelicate_ProcHeroPrevAction();
	void EndDelicate_ReturnBaseRotator();
	void EndDelicate_RotationToPlayer();
	void EndDelicate_SyncMotion();
	class UFldNpcComp* GetCharaModelNpcComp(int32 ModelIndex);
	int32 GetCharaModelNum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitCharacter">();
	}
	static class AFldHitCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitCharacter>();
	}
};
static_assert(alignof(AFldHitCharacter) == 0x000008, "Wrong alignment on AFldHitCharacter");
static_assert(sizeof(AFldHitCharacter) == 0x000468, "Wrong size on AFldHitCharacter");
static_assert(offsetof(AFldHitCharacter, CollisionComp_) == 0x000350, "Member 'AFldHitCharacter::CollisionComp_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MCharaModelParam_) == 0x000358, "Member 'AFldHitCharacter::MCharaModelParam_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIconType_) == 0x000368, "Member 'AFldHitCharacter::MIconType_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIconPlural_) == 0x000369, "Member 'AFldHitCharacter::MIconPlural_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MChangeIconParam_) == 0x000370, "Member 'AFldHitCharacter::MChangeIconParam_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIconAttachedType_) == 0x000380, "Member 'AFldHitCharacter::MIconAttachedType_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIconDirectLocationMODEL_) == 0x000384, "Member 'AFldHitCharacter::MIconDirectLocationMODEL_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, bIconDirectLocationMODEL_) == 0x000390, "Member 'AFldHitCharacter::bIconDirectLocationMODEL_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MReadedFlagName_) == 0x000394, "Member 'AFldHitCharacter::MReadedFlagName_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MFloorIndex_) == 0x00039C, "Member 'AFldHitCharacter::MFloorIndex_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MLookHeroOverlap_) == 0x0003A0, "Member 'AFldHitCharacter::MLookHeroOverlap_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MSpeakMotionKeyPush_) == 0x0003A1, "Member 'AFldHitCharacter::MSpeakMotionKeyPush_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MLookHeroKeyPush_) == 0x0003A2, "Member 'AFldHitCharacter::MLookHeroKeyPush_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MFaceingHeroKeyPush_) == 0x0003A3, "Member 'AFldHitCharacter::MFaceingHeroKeyPush_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MHeroMotionKeyPush_) == 0x0003A4, "Member 'AFldHitCharacter::MHeroMotionKeyPush_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MReturnBaseRotator_) == 0x0003A5, "Member 'AFldHitCharacter::MReturnBaseRotator_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MCharaBaseClass_) == 0x0003A8, "Member 'AFldHitCharacter::MCharaBaseClass_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MNpcBaseClass_) == 0x0003B0, "Member 'AFldHitCharacter::MNpcBaseClass_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MCharaModelList_) == 0x0003B8, "Member 'AFldHitCharacter::MCharaModelList_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIconActor_) == 0x000408, "Member 'AFldHitCharacter::MIconActor_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MMoveActor_) == 0x000410, "Member 'AFldHitCharacter::MMoveActor_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MHeroProcActor_) == 0x000418, "Member 'AFldHitCharacter::MHeroProcActor_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MDispName_) == 0x000420, "Member 'AFldHitCharacter::MDispName_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, bChangedRotator_) == 0x000430, "Member 'AFldHitCharacter::bChangedRotator_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MBaseRotator_) == 0x000434, "Member 'AFldHitCharacter::MBaseRotator_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIdleTalkComp_) == 0x000440, "Member 'AFldHitCharacter::MIdleTalkComp_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, MIdleBehaviorComp_) == 0x000448, "Member 'AFldHitCharacter::MIdleBehaviorComp_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, bIsIdleBehaviorCreated_) == 0x000450, "Member 'AFldHitCharacter::bIsIdleBehaviorCreated_' has a wrong offset!");
static_assert(offsetof(AFldHitCharacter, bGetAwayPrevAction_) == 0x000451, "Member 'AFldHitCharacter::bGetAwayPrevAction_' has a wrong offset!");

// Class xrd777.FldCmmActor
// 0x0030 (0x0498 - 0x0468)
class AFldCmmActor final : public AFldHitCharacter
{
public:
	int32                                         MUniqueId_;                                        // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldCmmNpcType                                MType_;                                            // 0x046C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MNameIndex_;                                       // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MNotMapInfoDisp_;                                  // 0x0474(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MMapIconDirectLocation_;                           // 0x0478(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMapIconDirectLocation_;                           // 0x0484(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MOnFlagName_;                                      // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCmmActor">();
	}
	static class AFldCmmActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCmmActor>();
	}
};
static_assert(alignof(AFldCmmActor) == 0x000008, "Wrong alignment on AFldCmmActor");
static_assert(sizeof(AFldCmmActor) == 0x000498, "Wrong size on AFldCmmActor");
static_assert(offsetof(AFldCmmActor, MUniqueId_) == 0x000468, "Member 'AFldCmmActor::MUniqueId_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MType_) == 0x00046C, "Member 'AFldCmmActor::MType_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MNameIndex_) == 0x000470, "Member 'AFldCmmActor::MNameIndex_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MNotMapInfoDisp_) == 0x000474, "Member 'AFldCmmActor::MNotMapInfoDisp_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MMapIconDirectLocation_) == 0x000478, "Member 'AFldCmmActor::MMapIconDirectLocation_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, bMapIconDirectLocation_) == 0x000484, "Member 'AFldCmmActor::bMapIconDirectLocation_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MOnFlagName_) == 0x000488, "Member 'AFldCmmActor::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AFldCmmActor, MOffFlagName_) == 0x000490, "Member 'AFldCmmActor::MOffFlagName_' has a wrong offset!");

// Class xrd777.BtlBossJunpeiKoromaru
// 0x0040 (0x0070 - 0x0030)
class UBtlBossJunpeiKoromaru final : public UBtlBossTeammates
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossJunpeiKoromaru">();
	}
	static class UBtlBossJunpeiKoromaru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossJunpeiKoromaru>();
	}
};
static_assert(alignof(UBtlBossJunpeiKoromaru) == 0x000008, "Wrong alignment on UBtlBossJunpeiKoromaru");
static_assert(sizeof(UBtlBossJunpeiKoromaru) == 0x000070, "Wrong size on UBtlBossJunpeiKoromaru");

// Class xrd777.DatDlcDungeonBgmTable
// 0x0010 (0x0040 - 0x0030)
class UDatDlcDungeonBgmTable final : public UAppDataAsset
{
public:
	TArray<struct FDatDlcDungeonBgmTableData>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatDlcDungeonBgmTable">();
	}
	static class UDatDlcDungeonBgmTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatDlcDungeonBgmTable>();
	}
};
static_assert(alignof(UDatDlcDungeonBgmTable) == 0x000008, "Wrong alignment on UDatDlcDungeonBgmTable");
static_assert(sizeof(UDatDlcDungeonBgmTable) == 0x000040, "Wrong size on UDatDlcDungeonBgmTable");
static_assert(offsetof(UDatDlcDungeonBgmTable, Data) == 0x000030, "Member 'UDatDlcDungeonBgmTable::Data' has a wrong offset!");

// Class xrd777.BtlBossMagician
// 0x0008 (0x0038 - 0x0030)
class UBtlBossMagician final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossMagician">();
	}
	static class UBtlBossMagician* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossMagician>();
	}
};
static_assert(alignof(UBtlBossMagician) == 0x000008, "Wrong alignment on UBtlBossMagician");
static_assert(sizeof(UBtlBossMagician) == 0x000038, "Wrong size on UBtlBossMagician");

// Class xrd777.BtlBossMetis
// 0x0020 (0x0050 - 0x0030)
class UBtlBossMetis final : public UBtlBossTeammates
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossMetis">();
	}
	static class UBtlBossMetis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossMetis>();
	}
};
static_assert(alignof(UBtlBossMetis) == 0x000008, "Wrong alignment on UBtlBossMetis");
static_assert(sizeof(UBtlBossMetis) == 0x000050, "Wrong size on UBtlBossMetis");

// Class xrd777.UIHeroParameterStatusDraw
// 0x0000 (0x02B8 - 0x02B8)
class AUIHeroParameterStatusDraw final : public AUIDrawBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHeroParameterStatusDraw">();
	}
	static class AUIHeroParameterStatusDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIHeroParameterStatusDraw>();
	}
};
static_assert(alignof(AUIHeroParameterStatusDraw) == 0x000008, "Wrong alignment on AUIHeroParameterStatusDraw");
static_assert(sizeof(AUIHeroParameterStatusDraw) == 0x0002B8, "Wrong size on AUIHeroParameterStatusDraw");

// Class xrd777.BtlBossMitsuruYukari
// 0x0040 (0x0070 - 0x0030)
class UBtlBossMitsuruYukari final : public UBtlBossTeammates
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossMitsuruYukari">();
	}
	static class UBtlBossMitsuruYukari* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossMitsuruYukari>();
	}
};
static_assert(alignof(UBtlBossMitsuruYukari) == 0x000008, "Wrong alignment on UBtlBossMitsuruYukari");
static_assert(sizeof(UBtlBossMitsuruYukari) == 0x000070, "Wrong size on UBtlBossMitsuruYukari");

// Class xrd777.FldCameraBase
// 0x0050 (0x0270 - 0x0220)
class AFldCameraBase : public AActor
{
public:
	class USceneComponent*                        YawSceneComp;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PitchSceneComp;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraComp;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCameraHitBase*                      HitRef;                                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPlayerHolder                       PlayerRef;                                         // 0x0240(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCurrent;                                        // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Input;                                             // 0x025C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZoom;                                             // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraBase">();
	}
	static class AFldCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraBase>();
	}
};
static_assert(alignof(AFldCameraBase) == 0x000008, "Wrong alignment on AFldCameraBase");
static_assert(sizeof(AFldCameraBase) == 0x000270, "Wrong size on AFldCameraBase");
static_assert(offsetof(AFldCameraBase, YawSceneComp) == 0x000220, "Member 'AFldCameraBase::YawSceneComp' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, PitchSceneComp) == 0x000228, "Member 'AFldCameraBase::PitchSceneComp' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, CameraComp) == 0x000230, "Member 'AFldCameraBase::CameraComp' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, HitRef) == 0x000238, "Member 'AFldCameraBase::HitRef' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, PlayerRef) == 0x000240, "Member 'AFldCameraBase::PlayerRef' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, bIsCurrent) == 0x000258, "Member 'AFldCameraBase::bIsCurrent' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, Input) == 0x00025C, "Member 'AFldCameraBase::Input' has a wrong offset!");
static_assert(offsetof(AFldCameraBase, bZoom) == 0x000268, "Member 'AFldCameraBase::bZoom' has a wrong offset!");

// Class xrd777.FldCameraFree
// 0x0008 (0x0278 - 0x0270)
class AFldCameraFree : public AFldCameraBase
{
public:
	class UFldCameraBehaviorFree*                 Behavior;                                          // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraFree">();
	}
	static class AFldCameraFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraFree>();
	}
};
static_assert(alignof(AFldCameraFree) == 0x000008, "Wrong alignment on AFldCameraFree");
static_assert(sizeof(AFldCameraFree) == 0x000278, "Wrong size on AFldCameraFree");
static_assert(offsetof(AFldCameraFree, Behavior) == 0x000270, "Member 'AFldCameraFree::Behavior' has a wrong offset!");

// Class xrd777.DatEnemy
// 0x0020 (0x0048 - 0x0028)
class UDatEnemy final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableEnemy;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableName;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableAttr;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEnemy">();
	}
	static class UDatEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEnemy>();
	}
};
static_assert(alignof(UDatEnemy) == 0x000008, "Wrong alignment on UDatEnemy");
static_assert(sizeof(UDatEnemy) == 0x000048, "Wrong size on UDatEnemy");
static_assert(offsetof(UDatEnemy, Loader) == 0x000028, "Member 'UDatEnemy::Loader' has a wrong offset!");
static_assert(offsetof(UDatEnemy, TableEnemy) == 0x000030, "Member 'UDatEnemy::TableEnemy' has a wrong offset!");
static_assert(offsetof(UDatEnemy, TableName) == 0x000038, "Member 'UDatEnemy::TableName' has a wrong offset!");
static_assert(offsetof(UDatEnemy, TableAttr) == 0x000040, "Member 'UDatEnemy::TableAttr' has a wrong offset!");

// Class xrd777.BtlBossNyxAvatar
// 0x0008 (0x0038 - 0x0030)
class UBtlBossNyxAvatar final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossNyxAvatar">();
	}
	static class UBtlBossNyxAvatar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossNyxAvatar>();
	}
};
static_assert(alignof(UBtlBossNyxAvatar) == 0x000008, "Wrong alignment on UBtlBossNyxAvatar");
static_assert(sizeof(UBtlBossNyxAvatar) == 0x000038, "Wrong size on UBtlBossNyxAvatar");

// Class xrd777.BtlBossNyxAvatarInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossNyxAvatarInterface final : public IInterface
{
public:
	void FadeoutFeatherAnim(float AnimSeconds);
	void FadeoutWeaponEffect(float AnimSeconds);
	void PlayFeatherAnim(float AnimSeconds);
	void SetVisibleWeaponEffect(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossNyxAvatarInterface">();
	}
	static class IBtlBossNyxAvatarInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossNyxAvatarInterface>();
	}
};
static_assert(alignof(IBtlBossNyxAvatarInterface) == 0x000008, "Wrong alignment on IBtlBossNyxAvatarInterface");
static_assert(sizeof(IBtlBossNyxAvatarInterface) == 0x000028, "Wrong size on IBtlBossNyxAvatarInterface");

// Class xrd777.MovieSceneEvtSeqTimeJumpControllerSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtSeqTimeJumpControllerSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtSeqTimeJumpControllerSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtSeqTimeJumpControllerSection">();
	}
	static class UMovieSceneEvtSeqTimeJumpControllerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtSeqTimeJumpControllerSection>();
	}
};
static_assert(alignof(UMovieSceneEvtSeqTimeJumpControllerSection) == 0x000008, "Wrong alignment on UMovieSceneEvtSeqTimeJumpControllerSection");
static_assert(sizeof(UMovieSceneEvtSeqTimeJumpControllerSection) == 0x000170, "Wrong size on UMovieSceneEvtSeqTimeJumpControllerSection");
static_assert(offsetof(UMovieSceneEvtSeqTimeJumpControllerSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtSeqTimeJumpControllerSection::EventData' has a wrong offset!");

// Class xrd777.BustupDraw
// 0x00C8 (0x00F0 - 0x0028)
class UBustupDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupObject*                          BustupObject_;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBustupObject*                          PrevBustupObject_;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBustupObjectBuffer>            ObjectBuffer_;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x98];                                      // 0x0058(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupDraw">();
	}
	static class UBustupDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupDraw>();
	}
};
static_assert(alignof(UBustupDraw) == 0x000008, "Wrong alignment on UBustupDraw");
static_assert(sizeof(UBustupDraw) == 0x0000F0, "Wrong size on UBustupDraw");
static_assert(offsetof(UBustupDraw, BustupObject_) == 0x000038, "Member 'UBustupDraw::BustupObject_' has a wrong offset!");
static_assert(offsetof(UBustupDraw, PrevBustupObject_) == 0x000040, "Member 'UBustupDraw::PrevBustupObject_' has a wrong offset!");
static_assert(offsetof(UBustupDraw, ObjectBuffer_) == 0x000048, "Member 'UBustupDraw::ObjectBuffer_' has a wrong offset!");

// Class xrd777.BtlBossNyxCore
// 0x0258 (0x0288 - 0x0030)
class UBtlBossNyxCore final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x258];                                     // 0x0030(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossNyxCore">();
	}
	static class UBtlBossNyxCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossNyxCore>();
	}
};
static_assert(alignof(UBtlBossNyxCore) == 0x000008, "Wrong alignment on UBtlBossNyxCore");
static_assert(sizeof(UBtlBossNyxCore) == 0x000288, "Wrong size on UBtlBossNyxCore");

// Class xrd777.PersonaStatusViewer
// 0x0068 (0x02F8 - 0x0290)
class APersonaStatusViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x50];                                     // 0x0290(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPersonaStatusListItem>         StatusList;                                        // 0x02E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PPersonaStatus;                                    // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusViewer">();
	}
	static class APersonaStatusViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaStatusViewer>();
	}
};
static_assert(alignof(APersonaStatusViewer) == 0x000008, "Wrong alignment on APersonaStatusViewer");
static_assert(sizeof(APersonaStatusViewer) == 0x0002F8, "Wrong size on APersonaStatusViewer");
static_assert(offsetof(APersonaStatusViewer, StatusList) == 0x0002E0, "Member 'APersonaStatusViewer::StatusList' has a wrong offset!");
static_assert(offsetof(APersonaStatusViewer, PPersonaStatus) == 0x0002F0, "Member 'APersonaStatusViewer::PPersonaStatus' has a wrong offset!");

// Class xrd777.BtlBossNyxCoreInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossNyxCoreInterface final : public IInterface
{
public:
	void LoadHeroAnimationForNyxCore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossNyxCoreInterface">();
	}
	static class IBtlBossNyxCoreInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossNyxCoreInterface>();
	}
};
static_assert(alignof(IBtlBossNyxCoreInterface) == 0x000008, "Wrong alignment on IBtlBossNyxCoreInterface");
static_assert(sizeof(IBtlBossNyxCoreInterface) == 0x000028, "Wrong size on IBtlBossNyxCoreInterface");

// Class xrd777.CmpEquip
// 0x02F8 (0x0330 - 0x0038)
class UCmpEquip final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x240];                                     // 0x0038(0x0240)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpEquipSystem*                        PSystem;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpEquipDraw*                          PDraw;                                             // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0xA8];                                     // 0x0288(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpEquip">();
	}
	static class UCmpEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpEquip>();
	}
};
static_assert(alignof(UCmpEquip) == 0x000008, "Wrong alignment on UCmpEquip");
static_assert(sizeof(UCmpEquip) == 0x000330, "Wrong size on UCmpEquip");
static_assert(offsetof(UCmpEquip, PSystem) == 0x000278, "Member 'UCmpEquip::PSystem' has a wrong offset!");
static_assert(offsetof(UCmpEquip, PDraw) == 0x000280, "Member 'UCmpEquip::PDraw' has a wrong offset!");

// Class xrd777.BtlBossPriestess
// 0x0008 (0x0038 - 0x0030)
class UBtlBossPriestess final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TimeoverEventEndCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossPriestess">();
	}
	static class UBtlBossPriestess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossPriestess>();
	}
};
static_assert(alignof(UBtlBossPriestess) == 0x000008, "Wrong alignment on UBtlBossPriestess");
static_assert(sizeof(UBtlBossPriestess) == 0x000038, "Wrong size on UBtlBossPriestess");

// Class xrd777.FldCameraHitBase
// 0x0068 (0x02E0 - 0x0278)
class AFldCameraHitBase : public AAppActor
{
public:
	class UFldCameraTransBase*                    Transition;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLdCameraLockAtParam                   LockAtYaw;                                         // 0x0280(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLdCameraLockAtParam                   LockAtPitch;                                       // 0x028C(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          LockAtForward;                                     // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x47];                                     // 0x0299(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraHitBase">();
	}
	static class AFldCameraHitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraHitBase>();
	}
};
static_assert(alignof(AFldCameraHitBase) == 0x000008, "Wrong alignment on AFldCameraHitBase");
static_assert(sizeof(AFldCameraHitBase) == 0x0002E0, "Wrong size on AFldCameraHitBase");
static_assert(offsetof(AFldCameraHitBase, Transition) == 0x000278, "Member 'AFldCameraHitBase::Transition' has a wrong offset!");
static_assert(offsetof(AFldCameraHitBase, LockAtYaw) == 0x000280, "Member 'AFldCameraHitBase::LockAtYaw' has a wrong offset!");
static_assert(offsetof(AFldCameraHitBase, LockAtPitch) == 0x00028C, "Member 'AFldCameraHitBase::LockAtPitch' has a wrong offset!");
static_assert(offsetof(AFldCameraHitBase, LockAtForward) == 0x000298, "Member 'AFldCameraHitBase::LockAtForward' has a wrong offset!");

// Class xrd777.FldCameraHitBox
// 0x0030 (0x0310 - 0x02E0)
class AFldCameraHitBox final : public AFldCameraHitBase
{
public:
	class UBoxComponent*                          Box;                                               // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCameraFixed*                        Camera;                                            // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraHitBox">();
	}
	static class AFldCameraHitBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraHitBox>();
	}
};
static_assert(alignof(AFldCameraHitBox) == 0x000008, "Wrong alignment on AFldCameraHitBox");
static_assert(sizeof(AFldCameraHitBox) == 0x000310, "Wrong size on AFldCameraHitBox");
static_assert(offsetof(AFldCameraHitBox, Box) == 0x0002E0, "Member 'AFldCameraHitBox::Box' has a wrong offset!");
static_assert(offsetof(AFldCameraHitBox, Camera) == 0x0002E8, "Member 'AFldCameraHitBox::Camera' has a wrong offset!");

// Class xrd777.PadRumble
// 0x0058 (0x0080 - 0x0028)
class UPadRumble final : public UObject
{
public:
	class UForceFeedbackEffect*                   HaveRumble;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UForceFeedbackEffect*                   HaveRumble2;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UForceFeedbackEffect*                   ProgramEffect;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PadRumble">();
	}
	static class UPadRumble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPadRumble>();
	}
};
static_assert(alignof(UPadRumble) == 0x000008, "Wrong alignment on UPadRumble");
static_assert(sizeof(UPadRumble) == 0x000080, "Wrong size on UPadRumble");
static_assert(offsetof(UPadRumble, HaveRumble) == 0x000028, "Member 'UPadRumble::HaveRumble' has a wrong offset!");
static_assert(offsetof(UPadRumble, HaveRumble2) == 0x000030, "Member 'UPadRumble::HaveRumble2' has a wrong offset!");
static_assert(offsetof(UPadRumble, ProgramEffect) == 0x000038, "Member 'UPadRumble::ProgramEffect' has a wrong offset!");

// Class xrd777.BtlBossSanadaAmada
// 0x0040 (0x0070 - 0x0030)
class UBtlBossSanadaAmada final : public UBtlBossTeammates
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossSanadaAmada">();
	}
	static class UBtlBossSanadaAmada* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossSanadaAmada>();
	}
};
static_assert(alignof(UBtlBossSanadaAmada) == 0x000008, "Wrong alignment on UBtlBossSanadaAmada");
static_assert(sizeof(UBtlBossSanadaAmada) == 0x000070, "Wrong size on UBtlBossSanadaAmada");

// Class xrd777.BtlBossShadowHero
// 0x0008 (0x0038 - 0x0030)
class UBtlBossShadowHero final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossShadowHero">();
	}
	static class UBtlBossShadowHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossShadowHero>();
	}
};
static_assert(alignof(UBtlBossShadowHero) == 0x000008, "Wrong alignment on UBtlBossShadowHero");
static_assert(sizeof(UBtlBossShadowHero) == 0x000038, "Wrong size on UBtlBossShadowHero");

// Class xrd777.BtlBossStregaBase
// 0x0008 (0x0038 - 0x0030)
class UBtlBossStregaBase : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaBase">();
	}
	static class UBtlBossStregaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaBase>();
	}
};
static_assert(alignof(UBtlBossStregaBase) == 0x000008, "Wrong alignment on UBtlBossStregaBase");
static_assert(sizeof(UBtlBossStregaBase) == 0x000038, "Wrong size on UBtlBossStregaBase");

// Class xrd777.MovieSceneEvtSeqControllerSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtSeqControllerSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtSeqControllerSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtSeqControllerSection">();
	}
	static class UMovieSceneEvtSeqControllerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtSeqControllerSection>();
	}
};
static_assert(alignof(UMovieSceneEvtSeqControllerSection) == 0x000008, "Wrong alignment on UMovieSceneEvtSeqControllerSection");
static_assert(sizeof(UMovieSceneEvtSeqControllerSection) == 0x000170, "Wrong size on UMovieSceneEvtSeqControllerSection");
static_assert(offsetof(UMovieSceneEvtSeqControllerSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtSeqControllerSection::EventData' has a wrong offset!");

// Class xrd777.DatPlayerNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatPlayerNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPlayerNameOne>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerNameTable">();
	}
	static class UDatPlayerNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerNameTable>();
	}
};
static_assert(alignof(UDatPlayerNameTable) == 0x000008, "Wrong alignment on UDatPlayerNameTable");
static_assert(sizeof(UDatPlayerNameTable) == 0x000040, "Wrong size on UDatPlayerNameTable");
static_assert(offsetof(UDatPlayerNameTable, Data) == 0x000030, "Member 'UDatPlayerNameTable::Data' has a wrong offset!");

// Class xrd777.BtlBossStregaJin
// 0x0018 (0x0050 - 0x0038)
class UBtlBossStregaJin final : public UBtlBossStregaBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaJin">();
	}
	static class UBtlBossStregaJin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaJin>();
	}
};
static_assert(alignof(UBtlBossStregaJin) == 0x000008, "Wrong alignment on UBtlBossStregaJin");
static_assert(sizeof(UBtlBossStregaJin) == 0x000050, "Wrong size on UBtlBossStregaJin");

// Class xrd777.BtlBossStregaTakaya
// 0x0018 (0x0050 - 0x0038)
class UBtlBossStregaTakaya final : public UBtlBossStregaBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaTakaya">();
	}
	static class UBtlBossStregaTakaya* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaTakaya>();
	}
};
static_assert(alignof(UBtlBossStregaTakaya) == 0x000008, "Wrong alignment on UBtlBossStregaTakaya");
static_assert(sizeof(UBtlBossStregaTakaya) == 0x000050, "Wrong size on UBtlBossStregaTakaya");

// Class xrd777.OdagakiTestMenu
// 0x0010 (0x0288 - 0x0278)
class AOdagakiTestMenu final : public AAppActor
{
public:
	class AActor*                                 _Actor;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             _DebugMenu;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OdagakiTestMenu">();
	}
	static class AOdagakiTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOdagakiTestMenu>();
	}
};
static_assert(alignof(AOdagakiTestMenu) == 0x000008, "Wrong alignment on AOdagakiTestMenu");
static_assert(sizeof(AOdagakiTestMenu) == 0x000288, "Wrong size on AOdagakiTestMenu");
static_assert(offsetof(AOdagakiTestMenu, _Actor) == 0x000278, "Member 'AOdagakiTestMenu::_Actor' has a wrong offset!");
static_assert(offsetof(AOdagakiTestMenu, _DebugMenu) == 0x000280, "Member 'AOdagakiTestMenu::_DebugMenu' has a wrong offset!");

// Class xrd777.BtlBossStregaTakayaJin
// 0x0028 (0x0060 - 0x0038)
class UBtlBossStregaTakayaJin final : public UBtlBossStregaBase
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaTakayaJin">();
	}
	static class UBtlBossStregaTakayaJin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaTakayaJin>();
	}
};
static_assert(alignof(UBtlBossStregaTakayaJin) == 0x000008, "Wrong alignment on UBtlBossStregaTakayaJin");
static_assert(sizeof(UBtlBossStregaTakayaJin) == 0x000060, "Wrong size on UBtlBossStregaTakayaJin");

// Class xrd777.RankUpTest
// 0x00A8 (0x0320 - 0x0278)
class ARankUpTest final : public AAppActor
{
public:
	uint8                                         Pad_278[0x98];                                     // 0x0278(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class AAppActor*                              Actor;                                             // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu;                                         // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankUpTest">();
	}
	static class ARankUpTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARankUpTest>();
	}
};
static_assert(alignof(ARankUpTest) == 0x000008, "Wrong alignment on ARankUpTest");
static_assert(sizeof(ARankUpTest) == 0x000320, "Wrong size on ARankUpTest");
static_assert(offsetof(ARankUpTest, Actor) == 0x000310, "Member 'ARankUpTest::Actor' has a wrong offset!");
static_assert(offsetof(ARankUpTest, DebugMenu) == 0x000318, "Member 'ARankUpTest::DebugMenu' has a wrong offset!");

// Class xrd777.BtlBossStregaChidori
// 0x0000 (0x0038 - 0x0038)
class UBtlBossStregaChidori final : public UBtlBossStregaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaChidori">();
	}
	static class UBtlBossStregaChidori* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaChidori>();
	}
};
static_assert(alignof(UBtlBossStregaChidori) == 0x000008, "Wrong alignment on UBtlBossStregaChidori");
static_assert(sizeof(UBtlBossStregaChidori) == 0x000038, "Wrong size on UBtlBossStregaChidori");

// Class xrd777.BtlSupportInfoBase
// 0x0048 (0x0070 - 0x0028)
class UBtlSupportInfoBase : public UObject
{
public:
	class UBtlSupportInfoMessage*                 SupportInfoMessage;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportInfoBase">();
	}
	static class UBtlSupportInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportInfoBase>();
	}
};
static_assert(alignof(UBtlSupportInfoBase) == 0x000008, "Wrong alignment on UBtlSupportInfoBase");
static_assert(sizeof(UBtlSupportInfoBase) == 0x000070, "Wrong size on UBtlSupportInfoBase");
static_assert(offsetof(UBtlSupportInfoBase, SupportInfoMessage) == 0x000028, "Member 'UBtlSupportInfoBase::SupportInfoMessage' has a wrong offset!");

// Class xrd777.BtlSupportInfoMituru
// 0x0000 (0x0070 - 0x0070)
class UBtlSupportInfoMituru final : public UBtlSupportInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportInfoMituru">();
	}
	static class UBtlSupportInfoMituru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportInfoMituru>();
	}
};
static_assert(alignof(UBtlSupportInfoMituru) == 0x000008, "Wrong alignment on UBtlSupportInfoMituru");
static_assert(sizeof(UBtlSupportInfoMituru) == 0x000070, "Wrong size on UBtlSupportInfoMituru");

// Class xrd777.BtlBossStregaInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossStregaInterface final : public IInterface
{
public:
	void PlayJinDrugLoopEffect(bool IsFadeIn, float FadeTime);
	void SetTakayaTheurgiaMode(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaInterface">();
	}
	static class IBtlBossStregaInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossStregaInterface>();
	}
};
static_assert(alignof(IBtlBossStregaInterface) == 0x000008, "Wrong alignment on IBtlBossStregaInterface");
static_assert(sizeof(IBtlBossStregaInterface) == 0x000028, "Wrong size on IBtlBossStregaInterface");

// Class xrd777.PreloadVolume
// 0x0030 (0x0288 - 0x0258)
class APreloadVolume final : public ATriggerVolume
{
public:
	TArray<struct FSoftObjectPath>                PreloadAssets;                                     // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedAssets;                                      // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void LoadComplete();
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreloadVolume">();
	}
	static class APreloadVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreloadVolume>();
	}
};
static_assert(alignof(APreloadVolume) == 0x000008, "Wrong alignment on APreloadVolume");
static_assert(sizeof(APreloadVolume) == 0x000288, "Wrong size on APreloadVolume");
static_assert(offsetof(APreloadVolume, PreloadAssets) == 0x000258, "Member 'APreloadVolume::PreloadAssets' has a wrong offset!");
static_assert(offsetof(APreloadVolume, LoadedAssets) == 0x000278, "Member 'APreloadVolume::LoadedAssets' has a wrong offset!");

// Class xrd777.BtlBossStregaTakayaJoined
// 0x0000 (0x0038 - 0x0038)
class UBtlBossStregaTakayaJoined final : public UBtlBossStregaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaTakayaJoined">();
	}
	static class UBtlBossStregaTakayaJoined* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaTakayaJoined>();
	}
};
static_assert(alignof(UBtlBossStregaTakayaJoined) == 0x000008, "Wrong alignment on UBtlBossStregaTakayaJoined");
static_assert(sizeof(UBtlBossStregaTakayaJoined) == 0x000038, "Wrong size on UBtlBossStregaTakayaJoined");

// Class xrd777.BtlBossUraBoss
// 0x0010 (0x0040 - 0x0030)
class UBtlBossUraBoss final : public UBtlBoss
{
public:
	class UBtlCoreComponent*                      BattleCore;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossUraBoss">();
	}
	static class UBtlBossUraBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossUraBoss>();
	}
};
static_assert(alignof(UBtlBossUraBoss) == 0x000008, "Wrong alignment on UBtlBossUraBoss");
static_assert(sizeof(UBtlBossUraBoss) == 0x000040, "Wrong size on UBtlBossUraBoss");
static_assert(offsetof(UBtlBossUraBoss, BattleCore) == 0x000030, "Member 'UBtlBossUraBoss::BattleCore' has a wrong offset!");

// Class xrd777.CmpCommuCardAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UCmpCommuCardAnimInstance : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             RootYawEvent;                                      // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCommuCardAnimInstance">();
	}
	static class UCmpCommuCardAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCommuCardAnimInstance>();
	}
};
static_assert(alignof(UCmpCommuCardAnimInstance) == 0x000010, "Wrong alignment on UCmpCommuCardAnimInstance");
static_assert(sizeof(UCmpCommuCardAnimInstance) == 0x0002D0, "Wrong size on UCmpCommuCardAnimInstance");
static_assert(offsetof(UCmpCommuCardAnimInstance, RootYawEvent) == 0x0002B8, "Member 'UCmpCommuCardAnimInstance::RootYawEvent' has a wrong offset!");

// Class xrd777.BtlBossUraBossInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlBossUraBossInterface final : public IInterface
{
public:
	void AttachGunModel(bool IsAttachGunModel);
	void AttachSkillCamera(class AActor* InCameraActor);
	bool IsUsingCutinFlag();
	void SetIsUsingCutin(bool IsUsingCutin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossUraBossInterface">();
	}
	static class IBtlBossUraBossInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlBossUraBossInterface>();
	}
};
static_assert(alignof(IBtlBossUraBossInterface) == 0x000008, "Wrong alignment on IBtlBossUraBossInterface");
static_assert(sizeof(IBtlBossUraBossInterface) == 0x000028, "Wrong size on IBtlBossUraBossInterface");

// Class xrd777.NishidaTestMenu
// 0x0010 (0x0288 - 0x0278)
class ANishidaTestMenu final : public AAppActor
{
public:
	class AActor*                                 Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NishidaTestMenu">();
	}
	static class ANishidaTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANishidaTestMenu>();
	}
};
static_assert(alignof(ANishidaTestMenu) == 0x000008, "Wrong alignment on ANishidaTestMenu");
static_assert(sizeof(ANishidaTestMenu) == 0x000288, "Wrong size on ANishidaTestMenu");
static_assert(offsetof(ANishidaTestMenu, Actor_) == 0x000278, "Member 'ANishidaTestMenu::Actor_' has a wrong offset!");
static_assert(offsetof(ANishidaTestMenu, DebugMenu_) == 0x000280, "Member 'ANishidaTestMenu::DebugMenu_' has a wrong offset!");

// Class xrd777.DatSupportInfo
// 0x0018 (0x0040 - 0x0028)
class UDatSupportInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableSupportInfo;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSupportInfo">();
	}
	static class UDatSupportInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSupportInfo>();
	}
};
static_assert(alignof(UDatSupportInfo) == 0x000008, "Wrong alignment on UDatSupportInfo");
static_assert(sizeof(UDatSupportInfo) == 0x000040, "Wrong size on UDatSupportInfo");
static_assert(offsetof(UDatSupportInfo, Loader) == 0x000030, "Member 'UDatSupportInfo::Loader' has a wrong offset!");
static_assert(offsetof(UDatSupportInfo, TableSupportInfo) == 0x000038, "Member 'UDatSupportInfo::TableSupportInfo' has a wrong offset!");

// Class xrd777.BtlBossUraBossHeartless
// 0x0010 (0x0040 - 0x0030)
class UBtlBossUraBossHeartless final : public UBtlBoss
{
public:
	class UBtlCoreComponent*                      BattleCore;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossUraBossHeartless">();
	}
	static class UBtlBossUraBossHeartless* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossUraBossHeartless>();
	}
};
static_assert(alignof(UBtlBossUraBossHeartless) == 0x000008, "Wrong alignment on UBtlBossUraBossHeartless");
static_assert(sizeof(UBtlBossUraBossHeartless) == 0x000040, "Wrong size on UBtlBossUraBossHeartless");
static_assert(offsetof(UBtlBossUraBossHeartless, BattleCore) == 0x000030, "Member 'UBtlBossUraBossHeartless::BattleCore' has a wrong offset!");

// Class xrd777.BtlCalcBase
// 0x0218 (0x0490 - 0x0278)
class ABtlCalcBase : public AAppActor
{
public:
	int32                                         DamageMax;                                         // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalMin;                                       // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalMax;                                       // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalPlayerDamageRate;                          // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalEnemyDamageRate;                           // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockdownRateAttackingDownCharacter;               // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccuracyMin;                                       // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccuracyMax;                                       // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadStatusAccuracyMin;                              // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadStatusAccuracyMax;                              // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EscapeSuccessRateMin;                              // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EscapeSuccessRateMax;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EscapeTurn;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DyingHPRatio;                                      // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsChargePowerRate;                            // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicChargePowerRate;                              // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsChargePowerRateTheurgia;                    // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicChargePowerRateTheurgia;                      // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadStatusRecoveryPlayerRate;                       // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadStatusRecoveryEnemyRate;                        // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardProtectRatio;                                 // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRatioToDown;                                 // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupportTurnMax;                                    // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharmBoosterDamageRatioToCharm;                    // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDamageBonusToDown;                            // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BadHitRatioBonus;                                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMikiri;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoShinMikiri;                                    // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBooster;                                       // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHighBooster;                                   // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMegaBooster;                                   // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBoosterMax;                                    // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAlloutBooster;                                 // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBadStatusBooster;                              // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBadStatusSwoonBooster;                         // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoCounterOccur;                                  // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoHeavyCounterOccur;                             // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoHyperCounterOccur;                             // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoGrowthLowExpRatio;                             // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoGrowthMiddleExpRatio;                          // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoGrowthhightExpRatio;                           // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHPRecoveryRatio_1;                             // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHPRecoveryRatio_2;                             // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHPRecoveryRatio_3;                             // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSPRecoveryValue_1;                             // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSPRecoveryValue_2;                             // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSPRecoveryValue_3;                             // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSPRecoveryValue_AddEffect_1;                   // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSPRecoveryValue_AddEffect_2;                   // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAddExp_Ration_1;                               // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAddExp_Ration_2;                               // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTakeoverBooster;                               // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTakeoverHighBooster;                           // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSingleTargetBooster;                           // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMultiTargetBooster;                            // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoAddCritical;                                   // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoAddCriticalHigh;                               // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRWeakBooster;                                // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRWeakHighBooster;                            // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRCriticalBooster;                            // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRCriticalHighBooster;                        // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoTGRAddCritical;                                // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoTGRAddCriticalHigh;                            // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRPowerBoostAmplify;                          // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRPowerBoostHighAmplify;                      // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRAddCriticalToBadStatus;                     // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRAddCriticalHighToBadStatus;                 // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRWeakProtecter;                              // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRWeakHighProtecter;                          // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRPhisicsBooster;                             // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRPhisicsHighBooster;                         // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRSPHeal;                                     // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRSPHighHeal;                                 // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TGRGaugeLowHPRatio;                                // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TGRGaugeLowSPRatio;                                // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TGRExpBonusRatio;                                  // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TGRGaugeBonusRatio;                                // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TGRGaugeBonusHighRatio;                            // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnSWOON;                                      // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnCHARM;                                      // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnCHARM;                                      // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnUPSET;                                      // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnUPSET;                                      // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnPANIC;                                      // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnPANIC;                                      // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnFEAR;                                       // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnFEAR;                                       // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnANGER;                                      // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnANGER;                                      // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnFREEZE;                                     // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnFREEZE;                                     // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTurnSHOCK;                                      // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTurnSHOCK;                                      // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTurnOVERLIMIT;                              // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTurnOVERHEAT;                               // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalByUPSET;                                // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalByPANIC;                                // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalByFEAR;                                 // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalBySHOCK;                                // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalByFREEZE;                               // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCriticalBySWOON;                                // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoisonMaxDamage;                                   // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoisonDamageRatio;                                 // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccuracyRatioByANGER;                              // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackSwoonDownRatio;                              // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalSkillSwoonDownRatio;                       // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSkillSwoonDownRatio;                        // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TheurgiaSkillSwoonDownRatio;                       // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoNothingRatioByFEAR;                              // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MajorArcanaRationByStrong;                         // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MajorArcanaRationByRare;                           // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MustAppearMajorEncount;                            // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShufflePersonaBonusExpRation;                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MajorArcanaBasicRation;                            // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinorArcanaBasicRation;                            // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersonaArcanaBasicRation;                          // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShuffleTimeAlloutBooster;                          // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShuffleTimeChariotIncreaseHeroHp;                  // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShuffleTimeHermitIncreaseHeroSP;                   // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShuffleTimeFortuneIncreasePartyHp;                 // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShuffleTimeStrengthIncreasePartySp;                // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBattleNumNotContinualPlayingFukaCutin;          // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBtlCalcParamAstrea*                    AstreaParam;                                       // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OneMoreCount;                                      // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OneMoreCountEnemy;                                 // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcAccuracyRate();
	float CalcAllOutAttackDamage();
	float CalcBadStatusHitRate();
	float CalcBadStatusRecoveryRate();
	float CalcCriticalHitRate();
	float CalcDownRate();
	float CalcEscapeRate();
	float CalcExpPersonaLevelUp(float Level, float DefaultLevel);
	float CalcHealRecovery();
	float CalcMagicDamage();
	float CalcPhysicalDamage();
	float CalcRushDamage();
	float CalcTheurgiaSkillDamage();
	float GetAllOutAttackSwoonRate();
	float GetDamageRateToEnemy();
	float GetDamageRateToPlayer();
	int32 GetDownAgilityForEnemy();
	float GetEnemyCriticalDamageRate();
	float GetEnemyWeakDamageRate();
	float GetExpRate();
	float GetMoneyRate();
	float GetPlayerCriticalDamageRate();
	float GetPlayerWeakDamageRate();
	float GetSaleMerchMoneyRate();

	float AttackRatioByANGER() const;
	float AttackRatioByOVERLIMIT() const;
	float AttackRatioByUPSET() const;
	bool CheckAttackerIsEnemy() const;
	bool CheckSkillIsAttack() const;
	bool CheckTargetIsEnemy() const;
	float DamageRatioByANGER() const;
	float DamageRatioByOVERHEAT() const;
	float DamageRatioByOVERLIMIT() const;
	float DamageRatioByUPSET() const;
	int32 GetAttackSupportRatio(bool IsPlayer, int32 Point) const;
	int32 GetDefenseSupportRatio(bool IsPlayer, int32 Point) const;
	EBtlGameDifficulty GetDifficulty() const;
	float GetFullmoonSkillPowerRatio(int32 MoonAge) const;
	float GetLevelAccuracyRatio(int32 LevelAttacker, int32 LevelTarget) const;
	float GetLevelDamageBossRatio(int32 LevelAttacker, int32 LevelTarget) const;
	float GetLevelDamageRatio(int32 LevelAttacker, int32 LevelTarget) const;
	float GetLevelExpRatio(int32 LevelDifference) const;
	int32 GetMagicBonusDamage(int32 MagicAttacker) const;
	int32 GetMagicBonusRecovery(int32 MagicAttacker) const;
	float GetNewmoonSkillPowerRatio(int32 MoonAge) const;
	float GetParam(EBtlCalcParamType Type, int32 Param) const;
	float GetShuffleTimeMajorPercent(int32 EncountNumFromLastMajor) const;
	int32 GetShuffleTimeOccurPercent() const;
	int32 GetSpeedSupportRatio(bool IsPlayer, int32 Point) const;
	float RecoveryRatioFromANGER() const;
	float RecoveryRatioFromCHARM() const;
	float RecoveryRatioFromFEAR() const;
	float RecoveryRatioFromPANIC() const;
	float RecoveryRatioFromUPSET() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCalcBase">();
	}
	static class ABtlCalcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlCalcBase>();
	}
};
static_assert(alignof(ABtlCalcBase) == 0x000008, "Wrong alignment on ABtlCalcBase");
static_assert(sizeof(ABtlCalcBase) == 0x000490, "Wrong size on ABtlCalcBase");
static_assert(offsetof(ABtlCalcBase, DamageMax) == 0x000278, "Member 'ABtlCalcBase::DamageMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, CriticalMin) == 0x00027C, "Member 'ABtlCalcBase::CriticalMin' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, CriticalMax) == 0x000280, "Member 'ABtlCalcBase::CriticalMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, CriticalPlayerDamageRate) == 0x000284, "Member 'ABtlCalcBase::CriticalPlayerDamageRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, CriticalEnemyDamageRate) == 0x000288, "Member 'ABtlCalcBase::CriticalEnemyDamageRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, KnockdownRateAttackingDownCharacter) == 0x00028C, "Member 'ABtlCalcBase::KnockdownRateAttackingDownCharacter' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AccuracyMin) == 0x000290, "Member 'ABtlCalcBase::AccuracyMin' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AccuracyMax) == 0x000294, "Member 'ABtlCalcBase::AccuracyMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, BadStatusAccuracyMin) == 0x000298, "Member 'ABtlCalcBase::BadStatusAccuracyMin' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, BadStatusAccuracyMax) == 0x00029C, "Member 'ABtlCalcBase::BadStatusAccuracyMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, EscapeSuccessRateMin) == 0x0002A0, "Member 'ABtlCalcBase::EscapeSuccessRateMin' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, EscapeSuccessRateMax) == 0x0002A4, "Member 'ABtlCalcBase::EscapeSuccessRateMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, EscapeTurn) == 0x0002A8, "Member 'ABtlCalcBase::EscapeTurn' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, DyingHPRatio) == 0x0002AC, "Member 'ABtlCalcBase::DyingHPRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PhysicsChargePowerRate) == 0x0002B0, "Member 'ABtlCalcBase::PhysicsChargePowerRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MagicChargePowerRate) == 0x0002B4, "Member 'ABtlCalcBase::MagicChargePowerRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PhysicsChargePowerRateTheurgia) == 0x0002B8, "Member 'ABtlCalcBase::PhysicsChargePowerRateTheurgia' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MagicChargePowerRateTheurgia) == 0x0002BC, "Member 'ABtlCalcBase::MagicChargePowerRateTheurgia' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, BadStatusRecoveryPlayerRate) == 0x0002C0, "Member 'ABtlCalcBase::BadStatusRecoveryPlayerRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, BadStatusRecoveryEnemyRate) == 0x0002C4, "Member 'ABtlCalcBase::BadStatusRecoveryEnemyRate' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, GuardProtectRatio) == 0x0002C8, "Member 'ABtlCalcBase::GuardProtectRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, DamageRatioToDown) == 0x0002CC, "Member 'ABtlCalcBase::DamageRatioToDown' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, SupportTurnMax) == 0x0002D0, "Member 'ABtlCalcBase::SupportTurnMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, CharmBoosterDamageRatioToCharm) == 0x0002D4, "Member 'ABtlCalcBase::CharmBoosterDamageRatioToCharm' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, SkillDamageBonusToDown) == 0x0002D8, "Member 'ABtlCalcBase::SkillDamageBonusToDown' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, BadHitRatioBonus) == 0x0002DC, "Member 'ABtlCalcBase::BadHitRatioBonus' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoMikiri) == 0x0002E0, "Member 'ABtlCalcBase::AutoMikiri' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoShinMikiri) == 0x0002E4, "Member 'ABtlCalcBase::AutoShinMikiri' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoBooster) == 0x0002E8, "Member 'ABtlCalcBase::AutoBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHighBooster) == 0x0002EC, "Member 'ABtlCalcBase::AutoHighBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoMegaBooster) == 0x0002F0, "Member 'ABtlCalcBase::AutoMegaBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoBoosterMax) == 0x0002F4, "Member 'ABtlCalcBase::AutoBoosterMax' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoAlloutBooster) == 0x0002F8, "Member 'ABtlCalcBase::AutoAlloutBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoBadStatusBooster) == 0x0002FC, "Member 'ABtlCalcBase::AutoBadStatusBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoBadStatusSwoonBooster) == 0x000300, "Member 'ABtlCalcBase::AutoBadStatusSwoonBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoCounterOccur) == 0x000304, "Member 'ABtlCalcBase::AutoCounterOccur' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHeavyCounterOccur) == 0x000308, "Member 'ABtlCalcBase::AutoHeavyCounterOccur' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHyperCounterOccur) == 0x00030C, "Member 'ABtlCalcBase::AutoHyperCounterOccur' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoGrowthLowExpRatio) == 0x000310, "Member 'ABtlCalcBase::AutoGrowthLowExpRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoGrowthMiddleExpRatio) == 0x000314, "Member 'ABtlCalcBase::AutoGrowthMiddleExpRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoGrowthhightExpRatio) == 0x000318, "Member 'ABtlCalcBase::AutoGrowthhightExpRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHPRecoveryRatio_1) == 0x00031C, "Member 'ABtlCalcBase::AutoHPRecoveryRatio_1' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHPRecoveryRatio_2) == 0x000320, "Member 'ABtlCalcBase::AutoHPRecoveryRatio_2' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoHPRecoveryRatio_3) == 0x000324, "Member 'ABtlCalcBase::AutoHPRecoveryRatio_3' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSPRecoveryValue_1) == 0x000328, "Member 'ABtlCalcBase::AutoSPRecoveryValue_1' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSPRecoveryValue_2) == 0x00032C, "Member 'ABtlCalcBase::AutoSPRecoveryValue_2' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSPRecoveryValue_3) == 0x000330, "Member 'ABtlCalcBase::AutoSPRecoveryValue_3' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSPRecoveryValue_AddEffect_1) == 0x000334, "Member 'ABtlCalcBase::AutoSPRecoveryValue_AddEffect_1' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSPRecoveryValue_AddEffect_2) == 0x000338, "Member 'ABtlCalcBase::AutoSPRecoveryValue_AddEffect_2' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoAddExp_Ration_1) == 0x00033C, "Member 'ABtlCalcBase::AutoAddExp_Ration_1' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoAddExp_Ration_2) == 0x000340, "Member 'ABtlCalcBase::AutoAddExp_Ration_2' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTakeoverBooster) == 0x000344, "Member 'ABtlCalcBase::AutoTakeoverBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTakeoverHighBooster) == 0x000348, "Member 'ABtlCalcBase::AutoTakeoverHighBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoSingleTargetBooster) == 0x00034C, "Member 'ABtlCalcBase::AutoSingleTargetBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoMultiTargetBooster) == 0x000350, "Member 'ABtlCalcBase::AutoMultiTargetBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoAddCritical) == 0x000354, "Member 'ABtlCalcBase::AutoAddCritical' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoAddCriticalHigh) == 0x000358, "Member 'ABtlCalcBase::AutoAddCriticalHigh' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRWeakBooster) == 0x00035C, "Member 'ABtlCalcBase::AutoTGRWeakBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRWeakHighBooster) == 0x000360, "Member 'ABtlCalcBase::AutoTGRWeakHighBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRCriticalBooster) == 0x000364, "Member 'ABtlCalcBase::AutoTGRCriticalBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRCriticalHighBooster) == 0x000368, "Member 'ABtlCalcBase::AutoTGRCriticalHighBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRAddCritical) == 0x00036C, "Member 'ABtlCalcBase::AutoTGRAddCritical' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRAddCriticalHigh) == 0x000370, "Member 'ABtlCalcBase::AutoTGRAddCriticalHigh' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRPowerBoostAmplify) == 0x000374, "Member 'ABtlCalcBase::AutoTGRPowerBoostAmplify' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRPowerBoostHighAmplify) == 0x000378, "Member 'ABtlCalcBase::AutoTGRPowerBoostHighAmplify' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRAddCriticalToBadStatus) == 0x00037C, "Member 'ABtlCalcBase::AutoTGRAddCriticalToBadStatus' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRAddCriticalHighToBadStatus) == 0x000380, "Member 'ABtlCalcBase::AutoTGRAddCriticalHighToBadStatus' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRWeakProtecter) == 0x000384, "Member 'ABtlCalcBase::AutoTGRWeakProtecter' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRWeakHighProtecter) == 0x000388, "Member 'ABtlCalcBase::AutoTGRWeakHighProtecter' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRPhisicsBooster) == 0x00038C, "Member 'ABtlCalcBase::AutoTGRPhisicsBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRPhisicsHighBooster) == 0x000390, "Member 'ABtlCalcBase::AutoTGRPhisicsHighBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRSPHeal) == 0x000394, "Member 'ABtlCalcBase::AutoTGRSPHeal' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AutoTGRSPHighHeal) == 0x000398, "Member 'ABtlCalcBase::AutoTGRSPHighHeal' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TGRGaugeLowHPRatio) == 0x00039C, "Member 'ABtlCalcBase::TGRGaugeLowHPRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TGRGaugeLowSPRatio) == 0x0003A0, "Member 'ABtlCalcBase::TGRGaugeLowSPRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TGRExpBonusRatio) == 0x0003A4, "Member 'ABtlCalcBase::TGRExpBonusRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TGRGaugeBonusRatio) == 0x0003A8, "Member 'ABtlCalcBase::TGRGaugeBonusRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TGRGaugeBonusHighRatio) == 0x0003AC, "Member 'ABtlCalcBase::TGRGaugeBonusHighRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnSWOON) == 0x0003B0, "Member 'ABtlCalcBase::MaxTurnSWOON' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnCHARM) == 0x0003B4, "Member 'ABtlCalcBase::MaxTurnCHARM' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnCHARM) == 0x0003B8, "Member 'ABtlCalcBase::MinTurnCHARM' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnUPSET) == 0x0003BC, "Member 'ABtlCalcBase::MaxTurnUPSET' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnUPSET) == 0x0003C0, "Member 'ABtlCalcBase::MinTurnUPSET' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnPANIC) == 0x0003C4, "Member 'ABtlCalcBase::MaxTurnPANIC' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnPANIC) == 0x0003C8, "Member 'ABtlCalcBase::MinTurnPANIC' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnFEAR) == 0x0003CC, "Member 'ABtlCalcBase::MaxTurnFEAR' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnFEAR) == 0x0003D0, "Member 'ABtlCalcBase::MinTurnFEAR' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnANGER) == 0x0003D4, "Member 'ABtlCalcBase::MaxTurnANGER' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnANGER) == 0x0003D8, "Member 'ABtlCalcBase::MinTurnANGER' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnFREEZE) == 0x0003DC, "Member 'ABtlCalcBase::MaxTurnFREEZE' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnFREEZE) == 0x0003E0, "Member 'ABtlCalcBase::MinTurnFREEZE' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxTurnSHOCK) == 0x0003E4, "Member 'ABtlCalcBase::MaxTurnSHOCK' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinTurnSHOCK) == 0x0003E8, "Member 'ABtlCalcBase::MinTurnSHOCK' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, DefaultTurnOVERLIMIT) == 0x0003EC, "Member 'ABtlCalcBase::DefaultTurnOVERLIMIT' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, DefaultTurnOVERHEAT) == 0x0003F0, "Member 'ABtlCalcBase::DefaultTurnOVERHEAT' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalByUPSET) == 0x0003F4, "Member 'ABtlCalcBase::AddCriticalByUPSET' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalByPANIC) == 0x0003F8, "Member 'ABtlCalcBase::AddCriticalByPANIC' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalByFEAR) == 0x0003FC, "Member 'ABtlCalcBase::AddCriticalByFEAR' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalBySHOCK) == 0x000400, "Member 'ABtlCalcBase::AddCriticalBySHOCK' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalByFREEZE) == 0x000404, "Member 'ABtlCalcBase::AddCriticalByFREEZE' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AddCriticalBySWOON) == 0x000408, "Member 'ABtlCalcBase::AddCriticalBySWOON' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PoisonMaxDamage) == 0x00040C, "Member 'ABtlCalcBase::PoisonMaxDamage' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PoisonDamageRatio) == 0x000410, "Member 'ABtlCalcBase::PoisonDamageRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AccuracyRatioByANGER) == 0x000414, "Member 'ABtlCalcBase::AccuracyRatioByANGER' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AttackSwoonDownRatio) == 0x000418, "Member 'ABtlCalcBase::AttackSwoonDownRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PhysicalSkillSwoonDownRatio) == 0x00041C, "Member 'ABtlCalcBase::PhysicalSkillSwoonDownRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MagicalSkillSwoonDownRatio) == 0x000420, "Member 'ABtlCalcBase::MagicalSkillSwoonDownRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, TheurgiaSkillSwoonDownRatio) == 0x000424, "Member 'ABtlCalcBase::TheurgiaSkillSwoonDownRatio' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, DoNothingRatioByFEAR) == 0x000428, "Member 'ABtlCalcBase::DoNothingRatioByFEAR' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MajorArcanaRationByStrong) == 0x00042C, "Member 'ABtlCalcBase::MajorArcanaRationByStrong' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MajorArcanaRationByRare) == 0x000430, "Member 'ABtlCalcBase::MajorArcanaRationByRare' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MustAppearMajorEncount) == 0x000434, "Member 'ABtlCalcBase::MustAppearMajorEncount' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShufflePersonaBonusExpRation) == 0x000438, "Member 'ABtlCalcBase::ShufflePersonaBonusExpRation' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MajorArcanaBasicRation) == 0x00043C, "Member 'ABtlCalcBase::MajorArcanaBasicRation' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MinorArcanaBasicRation) == 0x000440, "Member 'ABtlCalcBase::MinorArcanaBasicRation' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, PersonaArcanaBasicRation) == 0x000444, "Member 'ABtlCalcBase::PersonaArcanaBasicRation' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShuffleTimeAlloutBooster) == 0x000448, "Member 'ABtlCalcBase::ShuffleTimeAlloutBooster' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShuffleTimeChariotIncreaseHeroHp) == 0x00044C, "Member 'ABtlCalcBase::ShuffleTimeChariotIncreaseHeroHp' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShuffleTimeHermitIncreaseHeroSP) == 0x000450, "Member 'ABtlCalcBase::ShuffleTimeHermitIncreaseHeroSP' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShuffleTimeFortuneIncreasePartyHp) == 0x000454, "Member 'ABtlCalcBase::ShuffleTimeFortuneIncreasePartyHp' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, ShuffleTimeStrengthIncreasePartySp) == 0x000458, "Member 'ABtlCalcBase::ShuffleTimeStrengthIncreasePartySp' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, MaxBattleNumNotContinualPlayingFukaCutin) == 0x00045C, "Member 'ABtlCalcBase::MaxBattleNumNotContinualPlayingFukaCutin' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, AstreaParam) == 0x000460, "Member 'ABtlCalcBase::AstreaParam' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, OneMoreCount) == 0x000468, "Member 'ABtlCalcBase::OneMoreCount' has a wrong offset!");
static_assert(offsetof(ABtlCalcBase, OneMoreCountEnemy) == 0x00046C, "Member 'ABtlCalcBase::OneMoreCountEnemy' has a wrong offset!");

// Class xrd777.TitleStateBase
// 0x0010 (0x0038 - 0x0028)
class UTitleStateBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATitleActor*                            TitleActor;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateBase">();
	}
	static class UTitleStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateBase>();
	}
};
static_assert(alignof(UTitleStateBase) == 0x000008, "Wrong alignment on UTitleStateBase");
static_assert(sizeof(UTitleStateBase) == 0x000038, "Wrong size on UTitleStateBase");
static_assert(offsetof(UTitleStateBase, TitleActor) == 0x000030, "Member 'UTitleStateBase::TitleActor' has a wrong offset!");

// Class xrd777.TitleStateLoadGame
// 0x0010 (0x0048 - 0x0038)
class UTitleStateLoadGame final : public UTitleStateBase
{
public:
	class AUISaveLoad*                            SaveLoadUI;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateLoadGame">();
	}
	static class UTitleStateLoadGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateLoadGame>();
	}
};
static_assert(alignof(UTitleStateLoadGame) == 0x000008, "Wrong alignment on UTitleStateLoadGame");
static_assert(sizeof(UTitleStateLoadGame) == 0x000048, "Wrong size on UTitleStateLoadGame");
static_assert(offsetof(UTitleStateLoadGame, SaveLoadUI) == 0x000038, "Member 'UTitleStateLoadGame::SaveLoadUI' has a wrong offset!");

// Class xrd777.ConfigBGMSelectDialog
// 0x00C0 (0x00E8 - 0x0028)
class UConfigBGMSelectDialog final : public UObject
{
public:
	uint8                                         Pad_28[0xC0];                                      // 0x0028(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigBGMSelectDialog">();
	}
	static class UConfigBGMSelectDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigBGMSelectDialog>();
	}
};
static_assert(alignof(UConfigBGMSelectDialog) == 0x000008, "Wrong alignment on UConfigBGMSelectDialog");
static_assert(sizeof(UConfigBGMSelectDialog) == 0x0000E8, "Wrong size on UConfigBGMSelectDialog");

// Class xrd777.BtlFormula
// 0x0028 (0x02A0 - 0x0278)
class ABtlFormula final : public AAppActor
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlCalcBase*                           Calc;                                              // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlCalcBase>               CalcAsset;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBtlCalcParamAstrea>        AstreaParamAsset;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlFormula">();
	}
	static class ABtlFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlFormula>();
	}
};
static_assert(alignof(ABtlFormula) == 0x000008, "Wrong alignment on ABtlFormula");
static_assert(sizeof(ABtlFormula) == 0x0002A0, "Wrong size on ABtlFormula");
static_assert(offsetof(ABtlFormula, Loader) == 0x000278, "Member 'ABtlFormula::Loader' has a wrong offset!");
static_assert(offsetof(ABtlFormula, Calc) == 0x000288, "Member 'ABtlFormula::Calc' has a wrong offset!");
static_assert(offsetof(ABtlFormula, CalcAsset) == 0x000290, "Member 'ABtlFormula::CalcAsset' has a wrong offset!");
static_assert(offsetof(ABtlFormula, AstreaParamAsset) == 0x000298, "Member 'ABtlFormula::AstreaParamAsset' has a wrong offset!");

// Class xrd777.SeqBpFuncLib
// 0x0000 (0x0028 - 0x0028)
class USeqBpFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void CallAstreaProgress();
	static void CallBattle(int32 EncountID, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CallCalendar();
	static void CallEvent(int32 EventMajor, int32 EventMinor, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CallEventCmm(int32 EventMajor, int32 EventMinor, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CallField(int32 FieldMajor, int32 FieldMinor, int32 PlayerStartID);
	static void CallItemShop(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CallKeyfreeEvent(int32 FieldMajor, int32 FieldMinor, int32 KeyfreeEventID, int32 PlayerStartID);
	static void CallTitle();
	static void CallWeaponShop(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static bool CheckAstreaProgressOver(int32 CheckProgress);
	static void GoToTartarus();
	static void StartGameSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeqBpFuncLib">();
	}
	static class USeqBpFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeqBpFuncLib>();
	}
};
static_assert(alignof(USeqBpFuncLib) == 0x000008, "Wrong alignment on USeqBpFuncLib");
static_assert(sizeof(USeqBpFuncLib) == 0x000028, "Wrong size on USeqBpFuncLib");

// Class xrd777.BtlCalcParamAstrea
// 0x0060 (0x0088 - 0x0028)
class UBtlCalcParamAstrea : public UObject
{
public:
	float                                         AutoTGRSisterBooster;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRSisterHighBooster;                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoTGRMegamiDamageBooster;                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            MajorArcanaGetLimitAstrea;                         // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCalcParamAstrea">();
	}
	static class UBtlCalcParamAstrea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlCalcParamAstrea>();
	}
};
static_assert(alignof(UBtlCalcParamAstrea) == 0x000008, "Wrong alignment on UBtlCalcParamAstrea");
static_assert(sizeof(UBtlCalcParamAstrea) == 0x000088, "Wrong size on UBtlCalcParamAstrea");
static_assert(offsetof(UBtlCalcParamAstrea, AutoTGRSisterBooster) == 0x000028, "Member 'UBtlCalcParamAstrea::AutoTGRSisterBooster' has a wrong offset!");
static_assert(offsetof(UBtlCalcParamAstrea, AutoTGRSisterHighBooster) == 0x00002C, "Member 'UBtlCalcParamAstrea::AutoTGRSisterHighBooster' has a wrong offset!");
static_assert(offsetof(UBtlCalcParamAstrea, AutoTGRMegamiDamageBooster) == 0x000030, "Member 'UBtlCalcParamAstrea::AutoTGRMegamiDamageBooster' has a wrong offset!");
static_assert(offsetof(UBtlCalcParamAstrea, MajorArcanaGetLimitAstrea) == 0x000038, "Member 'UBtlCalcParamAstrea::MajorArcanaGetLimitAstrea' has a wrong offset!");

// Class xrd777.BtlTutorialBase
// 0x0000 (0x0030 - 0x0030)
class UBtlTutorialBase : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorialBase">();
	}
	static class UBtlTutorialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorialBase>();
	}
};
static_assert(alignof(UBtlTutorialBase) == 0x000008, "Wrong alignment on UBtlTutorialBase");
static_assert(sizeof(UBtlTutorialBase) == 0x000030, "Wrong size on UBtlTutorialBase");

// Class xrd777.BtlTutorial3rd
// 0x0000 (0x0030 - 0x0030)
class UBtlTutorial3rd final : public UBtlTutorialBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorial3rd">();
	}
	static class UBtlTutorial3rd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorial3rd>();
	}
};
static_assert(alignof(UBtlTutorial3rd) == 0x000008, "Wrong alignment on UBtlTutorial3rd");
static_assert(sizeof(UBtlTutorial3rd) == 0x000030, "Wrong size on UBtlTutorial3rd");

// Class xrd777.BtlCamera
// 0x0020 (0x0240 - 0x0220)
class ABtlCamera final : public AActor
{
public:
	class ABtlActor*                              CameraMainCharacter;                               // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABtlActor*>                      CameraTargets;                                     // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ACineCameraActor*                       MainCamera;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class ABtlActor* GetCameraMainCharacter();
	TArray<class ABtlActor*> GetCameraTargets();
	void SetCameraMainCharacter(class ABtlActor* CameraMainCharacter_0);
	void SetCameraTargets(const TArray<class ABtlActor*>& Targets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCamera">();
	}
	static class ABtlCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlCamera>();
	}
};
static_assert(alignof(ABtlCamera) == 0x000008, "Wrong alignment on ABtlCamera");
static_assert(sizeof(ABtlCamera) == 0x000240, "Wrong size on ABtlCamera");
static_assert(offsetof(ABtlCamera, CameraMainCharacter) == 0x000220, "Member 'ABtlCamera::CameraMainCharacter' has a wrong offset!");
static_assert(offsetof(ABtlCamera, CameraTargets) == 0x000228, "Member 'ABtlCamera::CameraTargets' has a wrong offset!");
static_assert(offsetof(ABtlCamera, MainCamera) == 0x000238, "Member 'ABtlCamera::MainCamera' has a wrong offset!");

// Class xrd777.RightsNotation
// 0x0110 (0x0388 - 0x0278)
class ARightsNotation final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARightsNotationDraw>        PLoadDrawClass;                                    // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARightsNotationDraw*                    PDrawClass;                                        // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               PCaptureTex;                                       // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    PCaptureBackGround;                                // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x58];                                     // 0x02D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LicenseTextData;                                   // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  LicenseFont;                                       // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x40];                                     // 0x0348(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightsNotation">();
	}
	static class ARightsNotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARightsNotation>();
	}
};
static_assert(alignof(ARightsNotation) == 0x000008, "Wrong alignment on ARightsNotation");
static_assert(sizeof(ARightsNotation) == 0x000388, "Wrong size on ARightsNotation");
static_assert(offsetof(ARightsNotation, M_pLoader) == 0x000288, "Member 'ARightsNotation::M_pLoader' has a wrong offset!");
static_assert(offsetof(ARightsNotation, PLoadDrawClass) == 0x0002A8, "Member 'ARightsNotation::PLoadDrawClass' has a wrong offset!");
static_assert(offsetof(ARightsNotation, PAssetLoader) == 0x0002B0, "Member 'ARightsNotation::PAssetLoader' has a wrong offset!");
static_assert(offsetof(ARightsNotation, PDrawClass) == 0x0002B8, "Member 'ARightsNotation::PDrawClass' has a wrong offset!");
static_assert(offsetof(ARightsNotation, PCaptureTex) == 0x0002C0, "Member 'ARightsNotation::PCaptureTex' has a wrong offset!");
static_assert(offsetof(ARightsNotation, PCaptureBackGround) == 0x0002C8, "Member 'ARightsNotation::PCaptureBackGround' has a wrong offset!");
static_assert(offsetof(ARightsNotation, LicenseTextData) == 0x000328, "Member 'ARightsNotation::LicenseTextData' has a wrong offset!");
static_assert(offsetof(ARightsNotation, LicenseFont) == 0x000340, "Member 'ARightsNotation::LicenseFont' has a wrong offset!");

// Class xrd777.BtlCompensation
// 0x0050 (0x0078 - 0x0028)
class UBtlCompensation final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCompensation">();
	}
	static class UBtlCompensation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlCompensation>();
	}
};
static_assert(alignof(UBtlCompensation) == 0x000008, "Wrong alignment on UBtlCompensation");
static_assert(sizeof(UBtlCompensation) == 0x000078, "Wrong size on UBtlCompensation");

// Class xrd777.BtlCoreComponent
// 0x04C0 (0x0570 - 0x00B0)
class UBtlCoreComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnBattleHasFinished;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRelocation;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUIVisibleON;                                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUIVisibleOFF;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUICaptureON;                                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUICaptureOFF;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBGVisibleON;                                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBGVisibleOFF;                                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerVisibleON;                                 // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerVisibleOFF;                                // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnemyVisibleON;                                  // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnemyVisibleOFF;                                 // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLogTurnStart;                                    // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLogActStart;                                     // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AInitReadActor>          InitReadActor;                                     // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        FormationData;                                     // 0x0198(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FormationTable;                                    // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBtlEventCutsceneController*            BtlCutscene;                                       // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlBoss*                               Boss;                                              // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlCountdown*                          Countdown;                                         // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlEventController*                    BtlEventController;                                // 0x01D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBtlResidentDataBase*                   ResidentData;                                      // 0x01D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlayerLocationRoot;                                // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EnemyLocationRoot;                                 // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EnemyAttachRoot;                                   // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlActor*                              EnemyTurnTableRotationTargetCharacter;             // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBtlEnvironmentBase*                    BtlEnvironmentComponent;                           // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlFadeManager*                        FadeManager;                                       // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlShakeManager*                       ShakeManager;                                      // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             HasFinishedResidentLoad;                           // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             HasFinishedPerformerLoad;                          // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             HasFinishedSerialEncountLoad;                      // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             HasFinishedEnemyLoad;                              // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x4];                                      // 0x0258(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SummonEnemyCount;                                  // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x30];                                     // 0x0260(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleElapsedTime;                                 // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BattleDeltaTime;                                   // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBtlEncountParam                       EncountParameter;                                  // 0x0298(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         EncountIndex;                                      // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBtlFinishResult                              BattleResult;                                      // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlActor*                              CurrentAction;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlActor*                              EventMainAction;                                   // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlActor*                              LatestAction;                                      // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlActor*                              ActionRequestedEscape;                             // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      ActionList;                                        // 0x02E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      PlayerList;                                        // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      EnemyList;                                         // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABtlActor>>          PlayerDataStockList;                               // 0x0318(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABtlActor>>          PlayerDataAddedStockList;                          // 0x0338(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAppActor>                  DebugMonitorData;                                  // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int16>                                 PlayerDataAddedIDList;                             // 0x0350(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABtlActor>>          EnemyDataStockList;                                // 0x0368(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABtlActor>>          EnemyDataSummonStockList;                          // 0x0388(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<int16>                                 EnemyDataSummonIDList;                             // 0x0398(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABtlActor>>          PersonaDataStockList;                              // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlCompensation*                       Compensation;                                      // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlOrder*                              Order;                                             // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlPhase*                              CurrentPhase;                                      // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RequestChangePhase;                                // 0x03E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlPhase*                              RequestedNextPhase;                                // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AAppActor*>                      UtensilEffectList;                                 // 0x03F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 HomeFormation;                                     // 0x0400(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlResultResourceManager*              ResultResource;                                    // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedResidentData;                                // 0x0418(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedBattleData;                                  // 0x0419(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedAllyData;                                    // 0x041A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedEnemyData;                                   // 0x041B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedPersonaData;                                 // 0x041C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedSummonEnemyData;                             // 0x041D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedAddedPlayerData;                             // 0x041E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedEncSerial;                                   // 0x041F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedDebugMonitor;                                // 0x0420(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderEnemy;                                       // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderPersona;                                     // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderSummonEnemy;                                 // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderAddedPlayer;                                 // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderSerialEncount;                               // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderDebugMonitor;                                // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlSupportInfoBase*                    SupportInfo;                                       // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        InitialEquipedPersonaID;                           // 0x0468(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46A[0xA6];                                     // 0x046A(0x00A6)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TutorialRequestList;                               // 0x0510(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AAppActor*                              DebugWindow;                                       // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppActor*                              DebugMonitor;                                      // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppActor*                              DebugSkillSelect;                                  // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ModeName;                                          // 0x0538(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DebugStateString;                                  // 0x0548(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 DebugLatestCamera;                                 // 0x0558(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUtensilEffect(class AAppActor* Target);
	void AffectHighAnalyze(class ABtlActor* PTarget);
	void AffectRetry();
	void BattleFadeIn(bool ForceRapid);
	void BattleFadeOut(bool ForceRapid, bool White);
	bool BattleFadeOutSync();
	void BeginLoadingRecord(EBtlLoadingTimeCategory Category);
	void CallCapture();
	void CallDebugMonitor();
	void CallDebugSkillSelect();
	void CallDebugWindow();
	void CallInfoForSerialEncount();
	void CallResultCapture();
	bool CheckBattleInProgress();
	bool CheckBattleProgressToNextBattle();
	bool CheckEventBattleFinish();
	bool CheckKnockedoutHero();
	void ClearUIForSerialEncount();
	void ClearUtensilEffect();
	void CoordinateBattleCondition(const struct FBtlEncountParam& EncountParam);
	struct FBtlEncountParam CoordinateEncountParam(const struct FBtlEncountParam& Encount);
	void DebugAllCharacterToDown();
	void DebugAllCharacterToDying();
	void DebugSetCustomDamage(int32 Damage);
	void DeleteCapture();
	void DestroyAllBattleActor();
	void DoInterruptProcessEscape();
	void FadeoutBGM(int32 FadeFrame);
	void FinalizeActionTurn();
	void FinalProcessAfterGameover();
	void FinishLoadingRecord(EBtlLoadingTimeCategory Category);
	class ABtlActor* GetAction();
	TArray<class ABtlActor*> GetAllCharacterList();
	class UDataTable* GetBossCameraTable();
	struct FBtlEncountParam GetEncountParamForBP();
	class FString GetEnemyFormationName();
	TArray<class ABtlActor*> GetEnemyList();
	class ABtlActor* GetEventMainAction();
	class ABtlActor* GetHero();
	class ABtlActor* GetNextAction(int32 Index_0);
	class ABtlPhase* GetPhase();
	TArray<class ABtlActor*> GetPlayerList();
	class ABtlActor* GetResultMainPlayer();
	void InitializeBattle();
	void InitializeBattleForNextBattle();
	void InitializeOrder();
	void InitProcessBeforeFirstTurn();
	void LoadData(const struct FBtlEncountParam& EncountParam);
	void LoadDataForSerialEncount();
	void LoadEnemyData(const struct FBtlEncountParam& EncountParam);
	void LoadResidentData(const struct FBtlEncountParam& EncountParam);
	void MarkAsPlayedFukaCutin();
	void MarkAsPlayedShadowExChantCam();
	void MarkAsUICommand();
	void PlayHighAnalyzeEvent();
	void PlayInfoAlloutAttackSuggestion();
	void PlayInfoFukaCutin();
	void PlayInfoGameover();
	void ProcAfterAllCharacterSpawned();
	void ProcAfterLoad();
	void ProcAheadOfRetrySequence();
	void ProcBeforeLoad();
	void ProcessBeforeStartNextTurn();
	void ProgressOrder();
	void RegisterTakeoverCharacter(class ABtlActor* Target, class ABtlActor* TakeoverFrom);
	void Relocation(bool PlayerOnly);
	void RelocationCustom(EBtlRelocationType Type);
	void RelocationRequestOnBCDPlay(bool Enable);
	void RemoveUtensilEffect(class AAppActor* Target);
	void RequestBGM(EBtlBGMType Type);
	void RequestClearUtensilEffectWithRelocation();
	void RequestCutinAging(bool Enable);
	bool RequestEncountProcess();
	void RequestPartyPanelVisible(bool Visible);
	void RequestRushMode(bool Enable);
	void RequestSituationHelp(class ABtlActor* PEmploy, EBtlJyokyohelpType Type);
	void RequestSummonEnemies();
	void RestoreGameCondition();
	void SetAnalyzeMode(bool Enable);
	void SetBattleTimeDilation(float Rate);
	void SetBGMTheurgiaMode(bool Enable);
	void SetDebugLatestCamera(const class FString& Str);
	void SetDebugStateString(const class FString& Str);
	void SetEncountParam(const struct FBtlEncountParam& Encount);
	void SetPersonaStatusMode(bool Enable);
	void SetPhase(class ABtlPhase* NextPhase);
	void SetRushDisable(bool Disable);
	void SetRushMode(bool Enable);
	void SetupDebugKill(bool* RejectDebugKillRequest);
	struct FBtlEncountParam SetupIndependentBattle(const struct FBtlEncountParam& EncountParam);
	void ShowDebugData();
	void SpawnCharacters(bool InitialHiding);
	bool SyncInfoGameover();
	bool SyncReadyIndependentBattle();
	void TheurgiaDebugSetup();
	void ToggleSkillEditMode();

	bool CheckAlloutResult() const;
	bool CheckAllowEnemyAttackBackshotCamera() const;
	bool CheckAnyInterruptProcessBetweenTurn() const;
	bool CheckCutinAging() const;
	bool CheckDecideRetry() const;
	bool CheckEnableActEndEvent() const;
	bool CheckEnableActEndProc() const;
	bool CheckEnableFukaCutin() const;
	bool CheckEnableRelocationClosedFormation() const;
	bool CheckEnemyLoadFinished() const;
	bool CheckHasHighAnalyzeEvent() const;
	bool CheckHighAnalyzeEnable() const;
	bool CheckHighAnalyzeUnlocked() const;
	bool CheckIgnoreShowingCharacterAtPreAct() const;
	bool CheckInAllout() const;
	bool CheckInRush() const;
	bool CheckInterruptProcessEscape() const;
	bool CheckIsSerialEncountBattle() const;
	bool CheckLineFormation() const;
	bool CheckNeedResult() const;
	bool CheckNeedTurningTable() const;
	bool CheckPlayableDesignedCommonAttackCamera() const;
	bool CheckPlayingEventScript() const;
	bool CheckRequestRushMode() const;
	bool CheckRushDisable() const;
	bool CheckRushSwitchable() const;
	bool CheckShadowExChantCamMustPlay() const;
	bool CheckShaffleTimeAllowed() const;
	bool CheckShuffleTimeOccurrence() const;
	bool CheckSuspendTurnProgress() const;
	bool CheckUsableFukaTheurgia() const;
	bool CheckUsableRetry() const;
	bool CheckUseQuickEncount() const;
	bool CheckValidFukaTheurgia() const;
	int32 DebugGetCustomDamage() const;
	int32 GetDebugCalcFlag() const;
	class FString GetDebugLatestCamera() const;
	class FString GetDebugModeName() const;
	class FString GetDebugStateString() const;
	float GetDeltaTime() const;
	float GetElapsedTime() const;
	EBtlPhaseType GetPhaseType() const;
	bool IsDisableSequenceCamera() const;
	bool IsEventBattle() const;
	bool IsEventResult(bool* IsCaptureResult) const;
	bool IsNeedToFinale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCoreComponent">();
	}
	static class UBtlCoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlCoreComponent>();
	}
};
static_assert(alignof(UBtlCoreComponent) == 0x000008, "Wrong alignment on UBtlCoreComponent");
static_assert(sizeof(UBtlCoreComponent) == 0x000570, "Wrong size on UBtlCoreComponent");
static_assert(offsetof(UBtlCoreComponent, OnBattleHasFinished) == 0x0000B0, "Member 'UBtlCoreComponent::OnBattleHasFinished' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnRelocation) == 0x0000C0, "Member 'UBtlCoreComponent::OnRelocation' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnUIVisibleON) == 0x0000D0, "Member 'UBtlCoreComponent::OnUIVisibleON' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnUIVisibleOFF) == 0x0000E0, "Member 'UBtlCoreComponent::OnUIVisibleOFF' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnUICaptureON) == 0x0000F0, "Member 'UBtlCoreComponent::OnUICaptureON' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnUICaptureOFF) == 0x000100, "Member 'UBtlCoreComponent::OnUICaptureOFF' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnBGVisibleON) == 0x000110, "Member 'UBtlCoreComponent::OnBGVisibleON' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnBGVisibleOFF) == 0x000120, "Member 'UBtlCoreComponent::OnBGVisibleOFF' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnPlayerVisibleON) == 0x000130, "Member 'UBtlCoreComponent::OnPlayerVisibleON' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnPlayerVisibleOFF) == 0x000140, "Member 'UBtlCoreComponent::OnPlayerVisibleOFF' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnEnemyVisibleON) == 0x000150, "Member 'UBtlCoreComponent::OnEnemyVisibleON' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnEnemyVisibleOFF) == 0x000160, "Member 'UBtlCoreComponent::OnEnemyVisibleOFF' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnLogTurnStart) == 0x000170, "Member 'UBtlCoreComponent::OnLogTurnStart' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, OnLogActStart) == 0x000180, "Member 'UBtlCoreComponent::OnLogActStart' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, InitReadActor) == 0x000190, "Member 'UBtlCoreComponent::InitReadActor' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, FormationData) == 0x000198, "Member 'UBtlCoreComponent::FormationData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, FormationTable) == 0x0001B0, "Member 'UBtlCoreComponent::FormationTable' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BtlCutscene) == 0x0001B8, "Member 'UBtlCoreComponent::BtlCutscene' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, Boss) == 0x0001C0, "Member 'UBtlCoreComponent::Boss' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, Countdown) == 0x0001C8, "Member 'UBtlCoreComponent::Countdown' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BtlEventController) == 0x0001D0, "Member 'UBtlCoreComponent::BtlEventController' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ResidentData) == 0x0001D8, "Member 'UBtlCoreComponent::ResidentData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PlayerLocationRoot) == 0x0001E0, "Member 'UBtlCoreComponent::PlayerLocationRoot' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyLocationRoot) == 0x0001E8, "Member 'UBtlCoreComponent::EnemyLocationRoot' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyAttachRoot) == 0x0001F0, "Member 'UBtlCoreComponent::EnemyAttachRoot' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyTurnTableRotationTargetCharacter) == 0x0001F8, "Member 'UBtlCoreComponent::EnemyTurnTableRotationTargetCharacter' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BtlEnvironmentComponent) == 0x000200, "Member 'UBtlCoreComponent::BtlEnvironmentComponent' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, FadeManager) == 0x000208, "Member 'UBtlCoreComponent::FadeManager' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ShakeManager) == 0x000210, "Member 'UBtlCoreComponent::ShakeManager' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, HasFinishedResidentLoad) == 0x000218, "Member 'UBtlCoreComponent::HasFinishedResidentLoad' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, HasFinishedPerformerLoad) == 0x000228, "Member 'UBtlCoreComponent::HasFinishedPerformerLoad' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, HasFinishedSerialEncountLoad) == 0x000238, "Member 'UBtlCoreComponent::HasFinishedSerialEncountLoad' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, HasFinishedEnemyLoad) == 0x000248, "Member 'UBtlCoreComponent::HasFinishedEnemyLoad' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, SummonEnemyCount) == 0x00025C, "Member 'UBtlCoreComponent::SummonEnemyCount' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BattleElapsedTime) == 0x000290, "Member 'UBtlCoreComponent::BattleElapsedTime' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BattleDeltaTime) == 0x000294, "Member 'UBtlCoreComponent::BattleDeltaTime' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EncountParameter) == 0x000298, "Member 'UBtlCoreComponent::EncountParameter' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EncountIndex) == 0x0002BC, "Member 'UBtlCoreComponent::EncountIndex' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, BattleResult) == 0x0002C0, "Member 'UBtlCoreComponent::BattleResult' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, CurrentAction) == 0x0002C8, "Member 'UBtlCoreComponent::CurrentAction' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EventMainAction) == 0x0002D0, "Member 'UBtlCoreComponent::EventMainAction' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LatestAction) == 0x0002D8, "Member 'UBtlCoreComponent::LatestAction' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ActionRequestedEscape) == 0x0002E0, "Member 'UBtlCoreComponent::ActionRequestedEscape' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ActionList) == 0x0002E8, "Member 'UBtlCoreComponent::ActionList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PlayerList) == 0x0002F8, "Member 'UBtlCoreComponent::PlayerList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyList) == 0x000308, "Member 'UBtlCoreComponent::EnemyList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PlayerDataStockList) == 0x000318, "Member 'UBtlCoreComponent::PlayerDataStockList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PlayerDataAddedStockList) == 0x000338, "Member 'UBtlCoreComponent::PlayerDataAddedStockList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugMonitorData) == 0x000348, "Member 'UBtlCoreComponent::DebugMonitorData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PlayerDataAddedIDList) == 0x000350, "Member 'UBtlCoreComponent::PlayerDataAddedIDList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyDataStockList) == 0x000368, "Member 'UBtlCoreComponent::EnemyDataStockList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyDataSummonStockList) == 0x000388, "Member 'UBtlCoreComponent::EnemyDataSummonStockList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, EnemyDataSummonIDList) == 0x000398, "Member 'UBtlCoreComponent::EnemyDataSummonIDList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, PersonaDataStockList) == 0x0003B0, "Member 'UBtlCoreComponent::PersonaDataStockList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, Compensation) == 0x0003C8, "Member 'UBtlCoreComponent::Compensation' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, Order) == 0x0003D0, "Member 'UBtlCoreComponent::Order' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, CurrentPhase) == 0x0003D8, "Member 'UBtlCoreComponent::CurrentPhase' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, RequestChangePhase) == 0x0003E0, "Member 'UBtlCoreComponent::RequestChangePhase' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, RequestedNextPhase) == 0x0003E8, "Member 'UBtlCoreComponent::RequestedNextPhase' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, UtensilEffectList) == 0x0003F0, "Member 'UBtlCoreComponent::UtensilEffectList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, HomeFormation) == 0x000400, "Member 'UBtlCoreComponent::HomeFormation' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ResultResource) == 0x000410, "Member 'UBtlCoreComponent::ResultResource' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedResidentData) == 0x000418, "Member 'UBtlCoreComponent::LoadedResidentData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedBattleData) == 0x000419, "Member 'UBtlCoreComponent::LoadedBattleData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedAllyData) == 0x00041A, "Member 'UBtlCoreComponent::LoadedAllyData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedEnemyData) == 0x00041B, "Member 'UBtlCoreComponent::LoadedEnemyData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedPersonaData) == 0x00041C, "Member 'UBtlCoreComponent::LoadedPersonaData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedSummonEnemyData) == 0x00041D, "Member 'UBtlCoreComponent::LoadedSummonEnemyData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedAddedPlayerData) == 0x00041E, "Member 'UBtlCoreComponent::LoadedAddedPlayerData' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedEncSerial) == 0x00041F, "Member 'UBtlCoreComponent::LoadedEncSerial' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoadedDebugMonitor) == 0x000420, "Member 'UBtlCoreComponent::LoadedDebugMonitor' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, Loader) == 0x000428, "Member 'UBtlCoreComponent::Loader' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderEnemy) == 0x000430, "Member 'UBtlCoreComponent::LoaderEnemy' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderPersona) == 0x000438, "Member 'UBtlCoreComponent::LoaderPersona' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderSummonEnemy) == 0x000440, "Member 'UBtlCoreComponent::LoaderSummonEnemy' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderAddedPlayer) == 0x000448, "Member 'UBtlCoreComponent::LoaderAddedPlayer' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderSerialEncount) == 0x000450, "Member 'UBtlCoreComponent::LoaderSerialEncount' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, LoaderDebugMonitor) == 0x000458, "Member 'UBtlCoreComponent::LoaderDebugMonitor' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, SupportInfo) == 0x000460, "Member 'UBtlCoreComponent::SupportInfo' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, InitialEquipedPersonaID) == 0x000468, "Member 'UBtlCoreComponent::InitialEquipedPersonaID' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, TutorialRequestList) == 0x000510, "Member 'UBtlCoreComponent::TutorialRequestList' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugWindow) == 0x000520, "Member 'UBtlCoreComponent::DebugWindow' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugMonitor) == 0x000528, "Member 'UBtlCoreComponent::DebugMonitor' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugSkillSelect) == 0x000530, "Member 'UBtlCoreComponent::DebugSkillSelect' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, ModeName) == 0x000538, "Member 'UBtlCoreComponent::ModeName' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugStateString) == 0x000548, "Member 'UBtlCoreComponent::DebugStateString' has a wrong offset!");
static_assert(offsetof(UBtlCoreComponent, DebugLatestCamera) == 0x000558, "Member 'UBtlCoreComponent::DebugLatestCamera' has a wrong offset!");

// Class xrd777.CmpItemDraw
// 0x05E0 (0x0608 - 0x0028)
class UCmpItemDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x5C8];                                     // 0x0040(0x05C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpItemDraw">();
	}
	static class UCmpItemDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpItemDraw>();
	}
};
static_assert(alignof(UCmpItemDraw) == 0x000008, "Wrong alignment on UCmpItemDraw");
static_assert(sizeof(UCmpItemDraw) == 0x000608, "Wrong size on UCmpItemDraw");
static_assert(offsetof(UCmpItemDraw, PMainActor) == 0x000038, "Member 'UCmpItemDraw::PMainActor' has a wrong offset!");

// Class xrd777.BtlManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IBtlManagerInterface final : public IInterface
{
public:
	void MarkAsBtlCoreIsReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlManagerInterface">();
	}
	static class IBtlManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBtlManagerInterface>();
	}
};
static_assert(alignof(IBtlManagerInterface) == 0x000008, "Wrong alignment on IBtlManagerInterface");
static_assert(sizeof(IBtlManagerInterface) == 0x000028, "Wrong size on IBtlManagerInterface");

// Class xrd777.TitleStateDebugScript
// 0x0000 (0x0038 - 0x0038)
class UTitleStateDebugScript final : public UTitleStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateDebugScript">();
	}
	static class UTitleStateDebugScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateDebugScript>();
	}
};
static_assert(alignof(UTitleStateDebugScript) == 0x000008, "Wrong alignment on UTitleStateDebugScript");
static_assert(sizeof(UTitleStateDebugScript) == 0x000038, "Wrong size on UTitleStateDebugScript");

// Class xrd777.CmpMainLoadActor
// 0x0010 (0x0288 - 0x0278)
class ACmpMainLoadActor final : public AAppActor
{
public:
	class UCampLoadSequenceBase*                  PSequence;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PParent;                                           // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpMainLoadActor">();
	}
	static class ACmpMainLoadActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACmpMainLoadActor>();
	}
};
static_assert(alignof(ACmpMainLoadActor) == 0x000008, "Wrong alignment on ACmpMainLoadActor");
static_assert(sizeof(ACmpMainLoadActor) == 0x000288, "Wrong size on ACmpMainLoadActor");
static_assert(offsetof(ACmpMainLoadActor, PSequence) == 0x000278, "Member 'ACmpMainLoadActor::PSequence' has a wrong offset!");
static_assert(offsetof(ACmpMainLoadActor, PParent) == 0x000280, "Member 'ACmpMainLoadActor::PParent' has a wrong offset!");

// Class xrd777.BtlCountdown
// 0x0018 (0x0290 - 0x0278)
class ABtlCountdown final : public AAppActor
{
public:
	float                                         Timer;                                             // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlay;                                            // 0x0280(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0281(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimation;                                       // 0x0282(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_283[0x1];                                      // 0x0283(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationLerp;                                     // 0x0284(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationStartTime;                                // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationEndTime;                                  // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PullTime(float Time);
	void SetVisible(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlCountdown">();
	}
	static class ABtlCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlCountdown>();
	}
};
static_assert(alignof(ABtlCountdown) == 0x000008, "Wrong alignment on ABtlCountdown");
static_assert(sizeof(ABtlCountdown) == 0x000290, "Wrong size on ABtlCountdown");
static_assert(offsetof(ABtlCountdown, Timer) == 0x000278, "Member 'ABtlCountdown::Timer' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, Speed) == 0x00027C, "Member 'ABtlCountdown::Speed' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, IsPlay) == 0x000280, "Member 'ABtlCountdown::IsPlay' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, IsVisible) == 0x000281, "Member 'ABtlCountdown::IsVisible' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, IsAnimation) == 0x000282, "Member 'ABtlCountdown::IsAnimation' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, AnimationLerp) == 0x000284, "Member 'ABtlCountdown::AnimationLerp' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, AnimationStartTime) == 0x000288, "Member 'ABtlCountdown::AnimationStartTime' has a wrong offset!");
static_assert(offsetof(ABtlCountdown, AnimationEndTime) == 0x00028C, "Member 'ABtlCountdown::AnimationEndTime' has a wrong offset!");

// Class xrd777.BtlDataAssets
// 0x0000 (0x0028 - 0x0028)
class UBtlDataAssets final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlDataAssets">();
	}
	static class UBtlDataAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlDataAssets>();
	}
};
static_assert(alignof(UBtlDataAssets) == 0x000008, "Wrong alignment on UBtlDataAssets");
static_assert(sizeof(UBtlDataAssets) == 0x000028, "Wrong size on UBtlDataAssets");

// Class xrd777.TitleStatePressWait_Astrea
// 0x0020 (0x0058 - 0x0038)
class UTitleStatePressWait_Astrea final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStatePressWait_Astrea">();
	}
	static class UTitleStatePressWait_Astrea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStatePressWait_Astrea>();
	}
};
static_assert(alignof(UTitleStatePressWait_Astrea) == 0x000008, "Wrong alignment on UTitleStatePressWait_Astrea");
static_assert(sizeof(UTitleStatePressWait_Astrea) == 0x000058, "Wrong size on UTitleStatePressWait_Astrea");

// Class xrd777.DatBtlCommon
// 0x0028 (0x0050 - 0x0028)
class UDatBtlCommon final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             Table;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableCalcPANICDropItem;                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableCalcPANICUseItem;                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableEncountEnemyBadPercent;                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatBtlCommon">();
	}
	static class UDatBtlCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatBtlCommon>();
	}
};
static_assert(alignof(UDatBtlCommon) == 0x000008, "Wrong alignment on UDatBtlCommon");
static_assert(sizeof(UDatBtlCommon) == 0x000050, "Wrong size on UDatBtlCommon");
static_assert(offsetof(UDatBtlCommon, Loader) == 0x000028, "Member 'UDatBtlCommon::Loader' has a wrong offset!");
static_assert(offsetof(UDatBtlCommon, Table) == 0x000030, "Member 'UDatBtlCommon::Table' has a wrong offset!");
static_assert(offsetof(UDatBtlCommon, TableCalcPANICDropItem) == 0x000038, "Member 'UDatBtlCommon::TableCalcPANICDropItem' has a wrong offset!");
static_assert(offsetof(UDatBtlCommon, TableCalcPANICUseItem) == 0x000040, "Member 'UDatBtlCommon::TableCalcPANICUseItem' has a wrong offset!");
static_assert(offsetof(UDatBtlCommon, TableEncountEnemyBadPercent) == 0x000048, "Member 'UDatBtlCommon::TableEncountEnemyBadPercent' has a wrong offset!");

// Class xrd777.DatPlayerMaxHPSPTable
// 0x0010 (0x0040 - 0x0030)
class UDatPlayerMaxHPSPTable : public UAppDataAsset
{
public:
	TArray<struct FDatPlayerMaxHPSPBunch>         Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerMaxHPSPTable">();
	}
	static class UDatPlayerMaxHPSPTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerMaxHPSPTable>();
	}
};
static_assert(alignof(UDatPlayerMaxHPSPTable) == 0x000008, "Wrong alignment on UDatPlayerMaxHPSPTable");
static_assert(sizeof(UDatPlayerMaxHPSPTable) == 0x000040, "Wrong size on UDatPlayerMaxHPSPTable");
static_assert(offsetof(UDatPlayerMaxHPSPTable, Data) == 0x000030, "Member 'UDatPlayerMaxHPSPTable::Data' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaPackAnimationSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtCharaPackAnimationSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtCharaPackAnimationSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPackAnimationSection">();
	}
	static class UMovieSceneEvtCharaPackAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPackAnimationSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPackAnimationSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPackAnimationSection");
static_assert(sizeof(UMovieSceneEvtCharaPackAnimationSection) == 0x000170, "Wrong size on UMovieSceneEvtCharaPackAnimationSection");
static_assert(offsetof(UMovieSceneEvtCharaPackAnimationSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtCharaPackAnimationSection::EventData' has a wrong offset!");

// Class xrd777.DatPlayerMaxHPSPTableExtra
// 0x0000 (0x0040 - 0x0040)
class UDatPlayerMaxHPSPTableExtra final : public UDatPlayerMaxHPSPTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerMaxHPSPTableExtra">();
	}
	static class UDatPlayerMaxHPSPTableExtra* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerMaxHPSPTableExtra>();
	}
};
static_assert(alignof(UDatPlayerMaxHPSPTableExtra) == 0x000008, "Wrong alignment on UDatPlayerMaxHPSPTableExtra");
static_assert(sizeof(UDatPlayerMaxHPSPTableExtra) == 0x000040, "Wrong size on UDatPlayerMaxHPSPTableExtra");

// Class xrd777.BustupController
// 0x0018 (0x0040 - 0x0028)
class UBustupController final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupModel*                           PModel;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupController">();
	}
	static class UBustupController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupController>();
	}
};
static_assert(alignof(UBustupController) == 0x000008, "Wrong alignment on UBustupController");
static_assert(sizeof(UBustupController) == 0x000040, "Wrong size on UBustupController");
static_assert(offsetof(UBustupController, PModel) == 0x000030, "Member 'UBustupController::PModel' has a wrong offset!");

// Class xrd777.DatPlayerLevelUpTable
// 0x0010 (0x0040 - 0x0030)
class UDatPlayerLevelUpTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPlayerLevelUpDataRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerLevelUpTable">();
	}
	static class UDatPlayerLevelUpTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerLevelUpTable>();
	}
};
static_assert(alignof(UDatPlayerLevelUpTable) == 0x000008, "Wrong alignment on UDatPlayerLevelUpTable");
static_assert(sizeof(UDatPlayerLevelUpTable) == 0x000040, "Wrong size on UDatPlayerLevelUpTable");
static_assert(offsetof(UDatPlayerLevelUpTable, Data) == 0x000030, "Member 'UDatPlayerLevelUpTable::Data' has a wrong offset!");

// Class xrd777.ShdParameter
// 0x0000 (0x0028 - 0x0028)
class UShdParameter final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShdParameter">();
	}
	static class UShdParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShdParameter>();
	}
};
static_assert(alignof(UShdParameter) == 0x000008, "Wrong alignment on UShdParameter");
static_assert(sizeof(UShdParameter) == 0x000028, "Wrong size on UShdParameter");

// Class xrd777.DatEncountTable
// 0x0010 (0x0040 - 0x0030)
class UDatEncountTable final : public UAppDataAsset
{
public:
	TArray<struct FDatEncountDataRecord>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEncountTable">();
	}
	static class UDatEncountTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEncountTable>();
	}
};
static_assert(alignof(UDatEncountTable) == 0x000008, "Wrong alignment on UDatEncountTable");
static_assert(sizeof(UDatEncountTable) == 0x000040, "Wrong size on UDatEncountTable");
static_assert(offsetof(UDatEncountTable, Data) == 0x000030, "Member 'UDatEncountTable::Data' has a wrong offset!");

// Class xrd777.DatEnemyTable
// 0x0010 (0x0040 - 0x0030)
class UDatEnemyTable final : public UAppDataAsset
{
public:
	TArray<struct FDatEnemyDataRecord>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEnemyTable">();
	}
	static class UDatEnemyTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEnemyTable>();
	}
};
static_assert(alignof(UDatEnemyTable) == 0x000008, "Wrong alignment on UDatEnemyTable");
static_assert(sizeof(UDatEnemyTable) == 0x000040, "Wrong size on UDatEnemyTable");
static_assert(offsetof(UDatEnemyTable, Data) == 0x000030, "Member 'UDatEnemyTable::Data' has a wrong offset!");

// Class xrd777.BtlTutorial1st
// 0x0008 (0x0038 - 0x0030)
class UBtlTutorial1st final : public UBtlTutorialBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorial1st">();
	}
	static class UBtlTutorial1st* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorial1st>();
	}
};
static_assert(alignof(UBtlTutorial1st) == 0x000008, "Wrong alignment on UBtlTutorial1st");
static_assert(sizeof(UBtlTutorial1st) == 0x000038, "Wrong size on UBtlTutorial1st");

// Class xrd777.DatEnemyAnalyzeSyncTable
// 0x0010 (0x0040 - 0x0030)
class UDatEnemyAnalyzeSyncTable final : public UAppDataAsset
{
public:
	TArray<struct FDatEnemyAnalyzeSyncDataRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEnemyAnalyzeSyncTable">();
	}
	static class UDatEnemyAnalyzeSyncTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEnemyAnalyzeSyncTable>();
	}
};
static_assert(alignof(UDatEnemyAnalyzeSyncTable) == 0x000008, "Wrong alignment on UDatEnemyAnalyzeSyncTable");
static_assert(sizeof(UDatEnemyAnalyzeSyncTable) == 0x000040, "Wrong size on UDatEnemyAnalyzeSyncTable");
static_assert(offsetof(UDatEnemyAnalyzeSyncTable, Data) == 0x000030, "Member 'UDatEnemyAnalyzeSyncTable::Data' has a wrong offset!");

// Class xrd777.TitleStatePhotosensitiveCaution
// 0x00B0 (0x00E8 - 0x0038)
class UTitleStatePhotosensitiveCaution final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0xB0];                                      // 0x0038(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStatePhotosensitiveCaution">();
	}
	static class UTitleStatePhotosensitiveCaution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStatePhotosensitiveCaution>();
	}
};
static_assert(alignof(UTitleStatePhotosensitiveCaution) == 0x000008, "Wrong alignment on UTitleStatePhotosensitiveCaution");
static_assert(sizeof(UTitleStatePhotosensitiveCaution) == 0x0000E8, "Wrong size on UTitleStatePhotosensitiveCaution");

// Class xrd777.BtlVoice
// 0x0048 (0x0070 - 0x0028)
class UBtlVoice : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlActor*                              Character;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlCoreComponent*                      Core;                                              // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlVoicePlayWatcher*                   Watcher;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndLipsyncWatcher();
	void StartLipyncWatcher();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlVoice">();
	}
	static class UBtlVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlVoice>();
	}
};
static_assert(alignof(UBtlVoice) == 0x000008, "Wrong alignment on UBtlVoice");
static_assert(sizeof(UBtlVoice) == 0x000070, "Wrong size on UBtlVoice");
static_assert(offsetof(UBtlVoice, Character) == 0x000058, "Member 'UBtlVoice::Character' has a wrong offset!");
static_assert(offsetof(UBtlVoice, Core) == 0x000060, "Member 'UBtlVoice::Core' has a wrong offset!");
static_assert(offsetof(UBtlVoice, Watcher) == 0x000068, "Member 'UBtlVoice::Watcher' has a wrong offset!");

// Class xrd777.BtlPcVoice
// 0x0000 (0x0070 - 0x0070)
class UBtlPcVoice final : public UBtlVoice
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPcVoice">();
	}
	static class UBtlPcVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlPcVoice>();
	}
};
static_assert(alignof(UBtlPcVoice) == 0x000008, "Wrong alignment on UBtlPcVoice");
static_assert(sizeof(UBtlPcVoice) == 0x000070, "Wrong size on UBtlPcVoice");

// Class xrd777.DatEnemyNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatEnemyNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatEnemyName>                  Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEnemyNameTable">();
	}
	static class UDatEnemyNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEnemyNameTable>();
	}
};
static_assert(alignof(UDatEnemyNameTable) == 0x000008, "Wrong alignment on UDatEnemyNameTable");
static_assert(sizeof(UDatEnemyNameTable) == 0x000040, "Wrong size on UDatEnemyNameTable");
static_assert(offsetof(UDatEnemyNameTable, Data) == 0x000030, "Member 'UDatEnemyNameTable::Data' has a wrong offset!");

// Class xrd777.DatPersonaTable
// 0x0010 (0x0040 - 0x0030)
class UDatPersonaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPersonaDataRecord>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPersonaTable">();
	}
	static class UDatPersonaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPersonaTable>();
	}
};
static_assert(alignof(UDatPersonaTable) == 0x000008, "Wrong alignment on UDatPersonaTable");
static_assert(sizeof(UDatPersonaTable) == 0x000040, "Wrong size on UDatPersonaTable");
static_assert(offsetof(UDatPersonaTable, Data) == 0x000030, "Member 'UDatPersonaTable::Data' has a wrong offset!");

// Class xrd777.SaveLoadDraw
// 0x0080 (0x0338 - 0x02B8)
class ASaveLoadDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x34];                                     // 0x02B8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BootMode;                                          // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartInAnim;                                    // 0x02F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUseCapture;                                     // 0x02F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOpenCamp;                                       // 0x02F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUseScrollBar;                                   // 0x02F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartCloseAnim;                                 // 0x02F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CursorIndex;                                       // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ListTopIndex;                                      // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveSlotItem>                  SaveSlotItems;                                     // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	ESaveDrawOpenType                             OpenType;                                          // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllSlotNum;                                        // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CheckOverListIndex;                                // 0x0320(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInheritanceLoad;                                // 0x0324(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_325[0x13];                                     // 0x0325(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D AdjustedDateLayoutPos(ESaveLoadDateLayout InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D AdjustedLayout2Pos(ESaveLoadLayout2 InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D AdjustedLayoutPos(ESaveLoadLayout InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D AdjustedLayoutPosAstrea(ESaveLoadLayoutAstrea InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D AdjustedTimeZoneLayoutPosAstrea(ESaveLoadTimeZoneLayoutAstrea InLayoutId, const struct FVector2D& InDefaultPos);
	void CallOnFinishedCloseAnim();
	void CallOnFinishedInAnim();
	float ConvFrameToTime(int32 InFrame);
	void DrawTextureEx(const float X, const float Y, const float Width, const float Height, const class UTexture* TextureHandle, const EUI_DRAW_POINT DrawPoint);
	int32 GetDebugDay(int32 InDay);
	int32 GetDebugMonth(int32 InMonth);
	int32 GetSelDebugDay(int32 InDay);
	int32 GetSelDebugMonth(int32 InMonth);
	bool IsCheckedNetworkSave();
	bool IsDayZeroPaddingLanguages(int32 InMonth);
	bool IsDebugDrawClearData();
	bool IsMonthDayDisplayLanguages();
	void LocationNameDraw(const float X, const float Y, const float Z, const class FString& String, const uint8 R, const uint8 G, const uint8 B, const uint8 A, const float Scale, const float Angle, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void PlayListInSE();
	void PLNameFontDraw(const float X, const float Y, const class FString& String, const struct FColor& Color, const float Scale, const float Angle, const EUI_DRAW_POINT DrawPoint, const EUIFontStyle Style);
	void ProcessCompleted__DelegateSignature();
	void SetScrollBarBaseCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 ScrollPos, int32 DrawListNum, int32 MaxListNum, EUI_DRAW_POINT DrawPoint);
	void SetScrollBarCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 ScrollPos, int32 DrawListNum, int32 MaxListNum, EUI_DRAW_POINT DrawPoint);
	void SetScrollBarSliderCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 ScrollPos, int32 DrawListNum, int32 MaxListNum, EUI_DRAW_POINT DrawPoint);
	void SetTouchCollision(int32 Index_0, bool IsSelected, float X, float Y, float Width, float Height, EUI_DRAW_POINT DrawPoint);
	bool StateDraw_BG();
	bool StateDraw_Close();
	bool StateDraw_SaveDataList();
	bool StateDraw_Update(float DeltaTime);
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadDraw">();
	}
	static class ASaveLoadDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASaveLoadDraw>();
	}
};
static_assert(alignof(ASaveLoadDraw) == 0x000008, "Wrong alignment on ASaveLoadDraw");
static_assert(sizeof(ASaveLoadDraw) == 0x000338, "Wrong size on ASaveLoadDraw");
static_assert(offsetof(ASaveLoadDraw, BootMode) == 0x0002EC, "Member 'ASaveLoadDraw::BootMode' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsStartInAnim) == 0x0002F0, "Member 'ASaveLoadDraw::bIsStartInAnim' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsUseCapture) == 0x0002F1, "Member 'ASaveLoadDraw::bIsUseCapture' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsOpenCamp) == 0x0002F2, "Member 'ASaveLoadDraw::bIsOpenCamp' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsUseScrollBar) == 0x0002F3, "Member 'ASaveLoadDraw::bIsUseScrollBar' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsStartCloseAnim) == 0x0002F4, "Member 'ASaveLoadDraw::bIsStartCloseAnim' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, CursorIndex) == 0x0002F8, "Member 'ASaveLoadDraw::CursorIndex' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, ListTopIndex) == 0x0002FC, "Member 'ASaveLoadDraw::ListTopIndex' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, CurrentIndex) == 0x000300, "Member 'ASaveLoadDraw::CurrentIndex' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, SaveSlotItems) == 0x000308, "Member 'ASaveLoadDraw::SaveSlotItems' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, OpenType) == 0x000318, "Member 'ASaveLoadDraw::OpenType' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, AllSlotNum) == 0x00031C, "Member 'ASaveLoadDraw::AllSlotNum' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, CheckOverListIndex) == 0x000320, "Member 'ASaveLoadDraw::CheckOverListIndex' has a wrong offset!");
static_assert(offsetof(ASaveLoadDraw, bIsInheritanceLoad) == 0x000324, "Member 'ASaveLoadDraw::bIsInheritanceLoad' has a wrong offset!");

// Class xrd777.CmpCharacterStatusDraw
// 0x0EE8 (0x0F10 - 0x0028)
class UCmpCharacterStatusDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpHeroHumanStatusDraw*                HumanParamDraw_;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICmpStatus*                           PParent;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xEC0];                                     // 0x0050(0x0EC0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCharacterStatusDraw">();
	}
	static class UCmpCharacterStatusDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCharacterStatusDraw>();
	}
};
static_assert(alignof(UCmpCharacterStatusDraw) == 0x000008, "Wrong alignment on UCmpCharacterStatusDraw");
static_assert(sizeof(UCmpCharacterStatusDraw) == 0x000F10, "Wrong size on UCmpCharacterStatusDraw");
static_assert(offsetof(UCmpCharacterStatusDraw, HumanParamDraw_) == 0x000038, "Member 'UCmpCharacterStatusDraw::HumanParamDraw_' has a wrong offset!");
static_assert(offsetof(UCmpCharacterStatusDraw, PParent) == 0x000040, "Member 'UCmpCharacterStatusDraw::PParent' has a wrong offset!");
static_assert(offsetof(UCmpCharacterStatusDraw, PMainActor) == 0x000048, "Member 'UCmpCharacterStatusDraw::PMainActor' has a wrong offset!");

// Class xrd777.DatPersonaNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatPersonaNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPersonaName>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPersonaNameTable">();
	}
	static class UDatPersonaNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPersonaNameTable>();
	}
};
static_assert(alignof(UDatPersonaNameTable) == 0x000008, "Wrong alignment on UDatPersonaNameTable");
static_assert(sizeof(UDatPersonaNameTable) == 0x000040, "Wrong size on UDatPersonaNameTable");
static_assert(offsetof(UDatPersonaNameTable, Data) == 0x000030, "Member 'UDatPersonaNameTable::Data' has a wrong offset!");

// Class xrd777.DatSkillNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatSkillNameTable final : public UAppDataAsset
{
public:
	TArray<class FText>                           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSkillNameTable">();
	}
	static class UDatSkillNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSkillNameTable>();
	}
};
static_assert(alignof(UDatSkillNameTable) == 0x000008, "Wrong alignment on UDatSkillNameTable");
static_assert(sizeof(UDatSkillNameTable) == 0x000040, "Wrong size on UDatSkillNameTable");
static_assert(offsetof(UDatSkillNameTable, Data) == 0x000030, "Member 'UDatSkillNameTable::Data' has a wrong offset!");

// Class xrd777.DatSkillTable
// 0x0010 (0x0040 - 0x0030)
class UDatSkillTable final : public UAppDataAsset
{
public:
	TArray<struct FDatSkillTableRecord>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSkillTable">();
	}
	static class UDatSkillTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSkillTable>();
	}
};
static_assert(alignof(UDatSkillTable) == 0x000008, "Wrong alignment on UDatSkillTable");
static_assert(sizeof(UDatSkillTable) == 0x000040, "Wrong size on UDatSkillTable");
static_assert(offsetof(UDatSkillTable, Data) == 0x000030, "Member 'UDatSkillTable::Data' has a wrong offset!");

// Class xrd777.UIDialogBase
// 0x0038 (0x02B0 - 0x0278)
class AUIDialogBase : public AAppActor
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DialogMessage;                                     // 0x0298(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDialogBase">();
	}
	static class AUIDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDialogBase>();
	}
};
static_assert(alignof(AUIDialogBase) == 0x000008, "Wrong alignment on AUIDialogBase");
static_assert(sizeof(AUIDialogBase) == 0x0002B0, "Wrong size on AUIDialogBase");
static_assert(offsetof(AUIDialogBase, DialogMessage) == 0x000298, "Member 'AUIDialogBase::DialogMessage' has a wrong offset!");

// Class xrd777.APPGameModeBase
// 0x0000 (0x02C0 - 0x02C0)
class AAPPGameModeBase final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"APPGameModeBase">();
	}
	static class AAPPGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAPPGameModeBase>();
	}
};
static_assert(alignof(AAPPGameModeBase) == 0x000008, "Wrong alignment on AAPPGameModeBase");
static_assert(sizeof(AAPPGameModeBase) == 0x0002C0, "Wrong size on AAPPGameModeBase");

// Class xrd777.FldDbgNpcMaker
// 0x0058 (0x0278 - 0x0220)
class AFldDbgNpcMaker final : public AActor
{
public:
	class UClass*                                 NpcClass;                                          // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 NpcIDs;                                            // 0x0228(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         NpcPoints;                                         // 0x0238(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class APawn*>                          NpcActors;                                         // 0x0248(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	EAnimPackID                                   AnimPackID;                                        // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Loaded;                                            // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          IsLoad;                                            // 0x0270(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APawn* GetNpcActor() const;
	const TArray<class APawn*> GetNpcActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDbgNpcMaker">();
	}
	static class AFldDbgNpcMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDbgNpcMaker>();
	}
};
static_assert(alignof(AFldDbgNpcMaker) == 0x000008, "Wrong alignment on AFldDbgNpcMaker");
static_assert(sizeof(AFldDbgNpcMaker) == 0x000278, "Wrong size on AFldDbgNpcMaker");
static_assert(offsetof(AFldDbgNpcMaker, NpcClass) == 0x000220, "Member 'AFldDbgNpcMaker::NpcClass' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, NpcIDs) == 0x000228, "Member 'AFldDbgNpcMaker::NpcIDs' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, NpcPoints) == 0x000238, "Member 'AFldDbgNpcMaker::NpcPoints' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, NpcActors) == 0x000248, "Member 'AFldDbgNpcMaker::NpcActors' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, AnimPackID) == 0x000258, "Member 'AFldDbgNpcMaker::AnimPackID' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, Loaded) == 0x000260, "Member 'AFldDbgNpcMaker::Loaded' has a wrong offset!");
static_assert(offsetof(AFldDbgNpcMaker, IsLoad) == 0x000270, "Member 'AFldDbgNpcMaker::IsLoad' has a wrong offset!");

// Class xrd777.DatSkillNormalTable
// 0x0010 (0x0040 - 0x0030)
class UDatSkillNormalTable final : public UAppDataAsset
{
public:
	TArray<struct FDatNormalSkillTableRecord>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSkillNormalTable">();
	}
	static class UDatSkillNormalTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSkillNormalTable>();
	}
};
static_assert(alignof(UDatSkillNormalTable) == 0x000008, "Wrong alignment on UDatSkillNormalTable");
static_assert(sizeof(UDatSkillNormalTable) == 0x000040, "Wrong size on UDatSkillNormalTable");
static_assert(offsetof(UDatSkillNormalTable, Data) == 0x000030, "Member 'UDatSkillNormalTable::Data' has a wrong offset!");

// Class xrd777.DatAffinityTable
// 0x0010 (0x0040 - 0x0030)
class UDatAffinityTable final : public UAppDataAsset
{
public:
	TArray<struct FDatAffinityDataRecord>         Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAffinityTable">();
	}
	static class UDatAffinityTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAffinityTable>();
	}
};
static_assert(alignof(UDatAffinityTable) == 0x000008, "Wrong alignment on UDatAffinityTable");
static_assert(sizeof(UDatAffinityTable) == 0x000040, "Wrong size on UDatAffinityTable");
static_assert(offsetof(UDatAffinityTable, Data) == 0x000030, "Member 'UDatAffinityTable::Data' has a wrong offset!");

// Class xrd777.UIPoetryRippleDataAsset
// 0x0010 (0x0040 - 0x0030)
class UUIPoetryRippleDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FPoetryRipplesParam>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPoetryRippleDataAsset">();
	}
	static class UUIPoetryRippleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPoetryRippleDataAsset>();
	}
};
static_assert(alignof(UUIPoetryRippleDataAsset) == 0x000008, "Wrong alignment on UUIPoetryRippleDataAsset");
static_assert(sizeof(UUIPoetryRippleDataAsset) == 0x000040, "Wrong size on UUIPoetryRippleDataAsset");
static_assert(offsetof(UUIPoetryRippleDataAsset, Data) == 0x000030, "Member 'UUIPoetryRippleDataAsset::Data' has a wrong offset!");

// Class xrd777.DatAttrNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatAttrNameTable final : public UAppDataAsset
{
public:
	TArray<class FText>                           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAttrNameTable">();
	}
	static class UDatAttrNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAttrNameTable>();
	}
};
static_assert(alignof(UDatAttrNameTable) == 0x000008, "Wrong alignment on UDatAttrNameTable");
static_assert(sizeof(UDatAttrNameTable) == 0x000040, "Wrong size on UDatAttrNameTable");
static_assert(offsetof(UDatAttrNameTable, Data) == 0x000030, "Member 'UDatAttrNameTable::Data' has a wrong offset!");

// Class xrd777.sainoTestEditManager
// 0x0008 (0x0298 - 0x0290)
class ASainoTestEditManager final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"sainoTestEditManager">();
	}
	static class ASainoTestEditManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASainoTestEditManager>();
	}
};
static_assert(alignof(ASainoTestEditManager) == 0x000008, "Wrong alignment on ASainoTestEditManager");
static_assert(sizeof(ASainoTestEditManager) == 0x000298, "Wrong size on ASainoTestEditManager");

// Class xrd777.AppCalculaterComponent
// 0x0000 (0x00B0 - 0x00B0)
class UAppCalculaterComponent final : public UActorComponent
{
public:
	float BPCommand_CalculationUpdate(const float DeltaTime, struct FAppCalculaterComponentWork& Work, const bool IsReverse, const bool IsLoop, const bool IsReset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppCalculaterComponent">();
	}
	static class UAppCalculaterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppCalculaterComponent>();
	}
};
static_assert(alignof(UAppCalculaterComponent) == 0x000008, "Wrong alignment on UAppCalculaterComponent");
static_assert(sizeof(UAppCalculaterComponent) == 0x0000B0, "Wrong size on UAppCalculaterComponent");

// Class xrd777.DatPersonaGrowthTable
// 0x0010 (0x0040 - 0x0030)
class UDatPersonaGrowthTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPersonaGrowthDataRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPersonaGrowthTable">();
	}
	static class UDatPersonaGrowthTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPersonaGrowthTable>();
	}
};
static_assert(alignof(UDatPersonaGrowthTable) == 0x000008, "Wrong alignment on UDatPersonaGrowthTable");
static_assert(sizeof(UDatPersonaGrowthTable) == 0x000040, "Wrong size on UDatPersonaGrowthTable");
static_assert(offsetof(UDatPersonaGrowthTable, Data) == 0x000030, "Member 'UDatPersonaGrowthTable::Data' has a wrong offset!");

// Class xrd777.DatAllyPersonaGrowthTable
// 0x0010 (0x0040 - 0x0030)
class UDatAllyPersonaGrowthTable final : public UAppMultiDataAsset
{
public:
	TArray<struct FDatAllyPersonaGrowthDataRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAllyPersonaGrowthTable">();
	}
	static class UDatAllyPersonaGrowthTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAllyPersonaGrowthTable>();
	}
};
static_assert(alignof(UDatAllyPersonaGrowthTable) == 0x000008, "Wrong alignment on UDatAllyPersonaGrowthTable");
static_assert(sizeof(UDatAllyPersonaGrowthTable) == 0x000040, "Wrong size on UDatAllyPersonaGrowthTable");
static_assert(offsetof(UDatAllyPersonaGrowthTable, Data) == 0x000030, "Member 'UDatAllyPersonaGrowthTable::Data' has a wrong offset!");

// Class xrd777.SimpleShopDraw
// 0x02D0 (0x0690 - 0x03C0)
class ASimpleShopDraw final : public AFclShopBase
{
public:
	uint8                                         Pad_3C0[0x28];                                     // 0x03C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              SprData;                                           // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr_Common;                                     // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USprAsset*>                      M_ShimpleShop;                                     // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr_ShimpleShop;                                // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlg_ShimpleShop;                                // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SaveItemNum;                                       // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x28];                                     // 0x0428(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASimpleShopDraw>            ShimpleShopDrawClass;                              // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PLoader;                                           // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemShopLineUpListTable*               LineupTable_;                                      // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x1F8];                                    // 0x0468(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Tex;                                               // 0x0660(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    CaptureBackGround;                                 // 0x0668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_670[0x20];                                     // 0x0670(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleShopDraw">();
	}
	static class ASimpleShopDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleShopDraw>();
	}
};
static_assert(alignof(ASimpleShopDraw) == 0x000008, "Wrong alignment on ASimpleShopDraw");
static_assert(sizeof(ASimpleShopDraw) == 0x000690, "Wrong size on ASimpleShopDraw");
static_assert(offsetof(ASimpleShopDraw, SprData) == 0x0003E8, "Member 'ASimpleShopDraw::SprData' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, M_pSpr_Common) == 0x0003F0, "Member 'ASimpleShopDraw::M_pSpr_Common' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, M_ShimpleShop) == 0x0003F8, "Member 'ASimpleShopDraw::M_ShimpleShop' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, M_pSpr_ShimpleShop) == 0x000408, "Member 'ASimpleShopDraw::M_pSpr_ShimpleShop' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, M_pPlg_ShimpleShop) == 0x000410, "Member 'ASimpleShopDraw::M_pPlg_ShimpleShop' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, SaveItemNum) == 0x000418, "Member 'ASimpleShopDraw::SaveItemNum' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, ShimpleShopDrawClass) == 0x000450, "Member 'ASimpleShopDraw::ShimpleShopDrawClass' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, PLoader) == 0x000458, "Member 'ASimpleShopDraw::PLoader' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, LineupTable_) == 0x000460, "Member 'ASimpleShopDraw::LineupTable_' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, Tex) == 0x000660, "Member 'ASimpleShopDraw::Tex' has a wrong offset!");
static_assert(offsetof(ASimpleShopDraw, CaptureBackGround) == 0x000668, "Member 'ASimpleShopDraw::CaptureBackGround' has a wrong offset!");

// Class xrd777.CmpEquipSystem
// 0x0048 (0x0070 - 0x0028)
class UCmpEquipSystem final : public UObject
{
public:
	TArray<int16>                                 PartyMemberList;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEquipListItem>                 EquipList;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEquipListItem>                 LastEquipList;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpEquip*                              PParent;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpEquipSystem">();
	}
	static class UCmpEquipSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpEquipSystem>();
	}
};
static_assert(alignof(UCmpEquipSystem) == 0x000008, "Wrong alignment on UCmpEquipSystem");
static_assert(sizeof(UCmpEquipSystem) == 0x000070, "Wrong size on UCmpEquipSystem");
static_assert(offsetof(UCmpEquipSystem, PartyMemberList) == 0x000028, "Member 'UCmpEquipSystem::PartyMemberList' has a wrong offset!");
static_assert(offsetof(UCmpEquipSystem, EquipList) == 0x000038, "Member 'UCmpEquipSystem::EquipList' has a wrong offset!");
static_assert(offsetof(UCmpEquipSystem, LastEquipList) == 0x000048, "Member 'UCmpEquipSystem::LastEquipList' has a wrong offset!");
static_assert(offsetof(UCmpEquipSystem, PMainActor) == 0x000060, "Member 'UCmpEquipSystem::PMainActor' has a wrong offset!");
static_assert(offsetof(UCmpEquipSystem, PParent) == 0x000068, "Member 'UCmpEquipSystem::PParent' has a wrong offset!");

// Class xrd777.DatSupportInfoTable
// 0x0010 (0x0040 - 0x0030)
class UDatSupportInfoTable final : public UAppDataAsset
{
public:
	TArray<struct FDatSupportInfoTableRecord>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSupportInfoTable">();
	}
	static class UDatSupportInfoTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSupportInfoTable>();
	}
};
static_assert(alignof(UDatSupportInfoTable) == 0x000008, "Wrong alignment on UDatSupportInfoTable");
static_assert(sizeof(UDatSupportInfoTable) == 0x000040, "Wrong size on UDatSupportInfoTable");
static_assert(offsetof(UDatSupportInfoTable, Data) == 0x000030, "Member 'UDatSupportInfoTable::Data' has a wrong offset!");

// Class xrd777.FldCameraSpline
// 0x0000 (0x0270 - 0x0270)
class AFldCameraSpline final : public AFldCameraBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraSpline">();
	}
	static class AFldCameraSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraSpline>();
	}
};
static_assert(alignof(AFldCameraSpline) == 0x000008, "Wrong alignment on AFldCameraSpline");
static_assert(sizeof(AFldCameraSpline) == 0x000270, "Wrong size on AFldCameraSpline");

// Class xrd777.DatRaceTable
// 0x0010 (0x0040 - 0x0030)
class UDatRaceTable final : public UAppDataAsset
{
public:
	TArray<struct FDatRaceTableRecord>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatRaceTable">();
	}
	static class UDatRaceTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatRaceTable>();
	}
};
static_assert(alignof(UDatRaceTable) == 0x000008, "Wrong alignment on UDatRaceTable");
static_assert(sizeof(UDatRaceTable) == 0x000040, "Wrong size on UDatRaceTable");
static_assert(offsetof(UDatRaceTable, Data) == 0x000030, "Member 'UDatRaceTable::Data' has a wrong offset!");

// Class xrd777.Xrd777SaveManager
// 0x0050 (0x0078 - 0x0028)
class UXrd777SaveManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTCSSaveData*                           TCSSaveData;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UXRD777SaveGame*                        NetworkSaveInstance;                               // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Xrd777SaveManager">();
	}
	static class UXrd777SaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXrd777SaveManager>();
	}
};
static_assert(alignof(UXrd777SaveManager) == 0x000008, "Wrong alignment on UXrd777SaveManager");
static_assert(sizeof(UXrd777SaveManager) == 0x000078, "Wrong size on UXrd777SaveManager");
static_assert(offsetof(UXrd777SaveManager, TCSSaveData) == 0x000058, "Member 'UXrd777SaveManager::TCSSaveData' has a wrong offset!");
static_assert(offsetof(UXrd777SaveManager, NetworkSaveInstance) == 0x000070, "Member 'UXrd777SaveManager::NetworkSaveInstance' has a wrong offset!");

// Class xrd777.CldBindingEventActor
// 0x0050 (0x02C8 - 0x0278)
class ACldBindingEventActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCldBindingData>                MBindList_;                                        // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallStatePatternEndDelicate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldBindingEventActor">();
	}
	static class ACldBindingEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACldBindingEventActor>();
	}
};
static_assert(alignof(ACldBindingEventActor) == 0x000008, "Wrong alignment on ACldBindingEventActor");
static_assert(sizeof(ACldBindingEventActor) == 0x0002C8, "Wrong size on ACldBindingEventActor");
static_assert(offsetof(ACldBindingEventActor, MAssetLoader_) == 0x0002A8, "Member 'ACldBindingEventActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(ACldBindingEventActor, MBindList_) == 0x0002B0, "Member 'ACldBindingEventActor::MBindList_' has a wrong offset!");

// Class xrd777.DatShuffleChoiceMinorArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleChoiceMinorArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleChoiceMinorArcanaRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleChoiceMinorArcanaTable">();
	}
	static class UDatShuffleChoiceMinorArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleChoiceMinorArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleChoiceMinorArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleChoiceMinorArcanaTable");
static_assert(sizeof(UDatShuffleChoiceMinorArcanaTable) == 0x000040, "Wrong size on UDatShuffleChoiceMinorArcanaTable");
static_assert(offsetof(UDatShuffleChoiceMinorArcanaTable, Data) == 0x000030, "Member 'UDatShuffleChoiceMinorArcanaTable::Data' has a wrong offset!");

// Class xrd777.UIFieldPartyPanel
// 0x0038 (0x02F0 - 0x02B8)
class AUIFieldPartyPanel final : public ABasePartyPanel
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSprAstrea;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFieldHeadPanel>                M_aHeadPanelList;                                  // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPartyPanelRecoveryEffect*              M_pRecoveryEffect;                                 // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldPartyPanel">();
	}
	static class AUIFieldPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIFieldPartyPanel>();
	}
};
static_assert(alignof(AUIFieldPartyPanel) == 0x000008, "Wrong alignment on AUIFieldPartyPanel");
static_assert(sizeof(AUIFieldPartyPanel) == 0x0002F0, "Wrong size on AUIFieldPartyPanel");
static_assert(offsetof(AUIFieldPartyPanel, M_pLoader) == 0x0002C0, "Member 'AUIFieldPartyPanel::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIFieldPartyPanel, M_pSpr) == 0x0002C8, "Member 'AUIFieldPartyPanel::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIFieldPartyPanel, M_pSprAstrea) == 0x0002D0, "Member 'AUIFieldPartyPanel::M_pSprAstrea' has a wrong offset!");
static_assert(offsetof(AUIFieldPartyPanel, M_aHeadPanelList) == 0x0002D8, "Member 'AUIFieldPartyPanel::M_aHeadPanelList' has a wrong offset!");
static_assert(offsetof(AUIFieldPartyPanel, M_pRecoveryEffect) == 0x0002E8, "Member 'AUIFieldPartyPanel::M_pRecoveryEffect' has a wrong offset!");

// Class xrd777.FileNameManager
// 0x0020 (0x0048 - 0x0028)
class UFileNameManager final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableFileName;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUFileNameManagerrActor*                MActor_;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileNameManager">();
	}
	static class UFileNameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileNameManager>();
	}
};
static_assert(alignof(UFileNameManager) == 0x000008, "Wrong alignment on UFileNameManager");
static_assert(sizeof(UFileNameManager) == 0x000048, "Wrong size on UFileNameManager");
static_assert(offsetof(UFileNameManager, Loader) == 0x000028, "Member 'UFileNameManager::Loader' has a wrong offset!");
static_assert(offsetof(UFileNameManager, TableFileName) == 0x000030, "Member 'UFileNameManager::TableFileName' has a wrong offset!");
static_assert(offsetof(UFileNameManager, MActor_) == 0x000040, "Member 'UFileNameManager::MActor_' has a wrong offset!");

// Class xrd777.DatShuffleChoiceMajorArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleChoiceMajorArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleChoiceMajorArcanaRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleChoiceMajorArcanaTable">();
	}
	static class UDatShuffleChoiceMajorArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleChoiceMajorArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleChoiceMajorArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleChoiceMajorArcanaTable");
static_assert(sizeof(UDatShuffleChoiceMajorArcanaTable) == 0x000040, "Wrong size on UDatShuffleChoiceMajorArcanaTable");
static_assert(offsetof(UDatShuffleChoiceMajorArcanaTable, Data) == 0x000030, "Member 'UDatShuffleChoiceMajorArcanaTable::Data' has a wrong offset!");

// Class xrd777.DatShufflePersonaArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShufflePersonaArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShufflePersonaArcanaRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShufflePersonaArcanaTable">();
	}
	static class UDatShufflePersonaArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShufflePersonaArcanaTable>();
	}
};
static_assert(alignof(UDatShufflePersonaArcanaTable) == 0x000008, "Wrong alignment on UDatShufflePersonaArcanaTable");
static_assert(sizeof(UDatShufflePersonaArcanaTable) == 0x000040, "Wrong size on UDatShufflePersonaArcanaTable");
static_assert(offsetof(UDatShufflePersonaArcanaTable, Data) == 0x000030, "Member 'UDatShufflePersonaArcanaTable::Data' has a wrong offset!");

// Class xrd777.UIDialogSingle
// 0x0020 (0x02D0 - 0x02B0)
class AUIDialogSingle final : public AUIDialogBase
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstChoices;                                      // 0x02C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDialogSingle">();
	}
	static class AUIDialogSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDialogSingle>();
	}
};
static_assert(alignof(AUIDialogSingle) == 0x000008, "Wrong alignment on AUIDialogSingle");
static_assert(sizeof(AUIDialogSingle) == 0x0002D0, "Wrong size on AUIDialogSingle");
static_assert(offsetof(AUIDialogSingle, FirstChoices) == 0x0002C0, "Member 'AUIDialogSingle::FirstChoices' has a wrong offset!");

// Class xrd777.DatShuffleCoinArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleCoinArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleCoinArcanaRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleCoinArcanaTable">();
	}
	static class UDatShuffleCoinArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleCoinArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleCoinArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleCoinArcanaTable");
static_assert(sizeof(UDatShuffleCoinArcanaTable) == 0x000040, "Wrong size on UDatShuffleCoinArcanaTable");
static_assert(offsetof(UDatShuffleCoinArcanaTable, Data) == 0x000030, "Member 'UDatShuffleCoinArcanaTable::Data' has a wrong offset!");

// Class xrd777.ErrorDialog
// 0x0018 (0x0040 - 0x0028)
class UErrorDialog final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ErrorDialog">();
	}
	static class UErrorDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UErrorDialog>();
	}
};
static_assert(alignof(UErrorDialog) == 0x000008, "Wrong alignment on UErrorDialog");
static_assert(sizeof(UErrorDialog) == 0x000040, "Wrong size on UErrorDialog");

// Class xrd777.CampSceneCapture
// 0x0000 (0x0238 - 0x0238)
class ACampSceneCapture : public ASceneCapture2D
{
public:
	void InAnimationStart();
	void LoopAnimationStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampSceneCapture">();
	}
	static class ACampSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampSceneCapture>();
	}
};
static_assert(alignof(ACampSceneCapture) == 0x000008, "Wrong alignment on ACampSceneCapture");
static_assert(sizeof(ACampSceneCapture) == 0x000238, "Wrong size on ACampSceneCapture");

// Class xrd777.DatShuffleCupArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleCupArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleCupArcanaRecord>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleCupArcanaTable">();
	}
	static class UDatShuffleCupArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleCupArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleCupArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleCupArcanaTable");
static_assert(sizeof(UDatShuffleCupArcanaTable) == 0x000040, "Wrong size on UDatShuffleCupArcanaTable");
static_assert(offsetof(UDatShuffleCupArcanaTable, Data) == 0x000030, "Member 'UDatShuffleCupArcanaTable::Data' has a wrong offset!");

// Class xrd777.DatShuffleLoversArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleLoversArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleLoversArcanaRecord>  Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleLoversArcanaTable">();
	}
	static class UDatShuffleLoversArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleLoversArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleLoversArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleLoversArcanaTable");
static_assert(sizeof(UDatShuffleLoversArcanaTable) == 0x000040, "Wrong size on UDatShuffleLoversArcanaTable");
static_assert(offsetof(UDatShuffleLoversArcanaTable, Data) == 0x000030, "Member 'UDatShuffleLoversArcanaTable::Data' has a wrong offset!");

// Class xrd777.MovieSceneEvtDialogueOptionsSection
// 0x0100 (0x01E8 - 0x00E8)
class UMovieSceneEvtDialogueOptionsSection final : public UMovieSceneSection
{
public:
	struct FNameCurve                             Events;                                            // 0x00E8(0x0078)(Deprecated, NativeAccessSpecifierPrivate)
	struct FMovieSceneEvtDialogueOptionsSectionData EventData;                                         // 0x0160(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtDialogueOptionsSection">();
	}
	static class UMovieSceneEvtDialogueOptionsSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtDialogueOptionsSection>();
	}
};
static_assert(alignof(UMovieSceneEvtDialogueOptionsSection) == 0x000008, "Wrong alignment on UMovieSceneEvtDialogueOptionsSection");
static_assert(sizeof(UMovieSceneEvtDialogueOptionsSection) == 0x0001E8, "Wrong size on UMovieSceneEvtDialogueOptionsSection");
static_assert(offsetof(UMovieSceneEvtDialogueOptionsSection, Events) == 0x0000E8, "Member 'UMovieSceneEvtDialogueOptionsSection::Events' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtDialogueOptionsSection, EventData) == 0x000160, "Member 'UMovieSceneEvtDialogueOptionsSection::EventData' has a wrong offset!");

// Class xrd777.BtlTableTypes
// 0x0000 (0x0028 - 0x0028)
class UBtlTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTableTypes">();
	}
	static class UBtlTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTableTypes>();
	}
};
static_assert(alignof(UBtlTableTypes) == 0x000008, "Wrong alignment on UBtlTableTypes");
static_assert(sizeof(UBtlTableTypes) == 0x000028, "Wrong size on UBtlTableTypes");

// Class xrd777.DatShuffleArcanaNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleArcanaNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleArcanaNameRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleArcanaNameTable">();
	}
	static class UDatShuffleArcanaNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleArcanaNameTable>();
	}
};
static_assert(alignof(UDatShuffleArcanaNameTable) == 0x000008, "Wrong alignment on UDatShuffleArcanaNameTable");
static_assert(sizeof(UDatShuffleArcanaNameTable) == 0x000040, "Wrong size on UDatShuffleArcanaNameTable");
static_assert(offsetof(UDatShuffleArcanaNameTable, Data) == 0x000030, "Member 'UDatShuffleArcanaNameTable::Data' has a wrong offset!");

// Class xrd777.DatShuffleCommonCoefficientArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleCommonCoefficientArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleCommonCoefficientArcanaRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleCommonCoefficientArcanaTable">();
	}
	static class UDatShuffleCommonCoefficientArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleCommonCoefficientArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleCommonCoefficientArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleCommonCoefficientArcanaTable");
static_assert(sizeof(UDatShuffleCommonCoefficientArcanaTable) == 0x000040, "Wrong size on UDatShuffleCommonCoefficientArcanaTable");
static_assert(offsetof(UDatShuffleCommonCoefficientArcanaTable, Data) == 0x000030, "Member 'UDatShuffleCommonCoefficientArcanaTable::Data' has a wrong offset!");

// Class xrd777.DatShuffleCommonItemdropArcanaTable
// 0x0010 (0x0040 - 0x0030)
class UDatShuffleCommonItemdropArcanaTable final : public UAppDataAsset
{
public:
	TArray<struct FDatShuffleCommonItemdropArcanaRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleCommonItemdropArcanaTable">();
	}
	static class UDatShuffleCommonItemdropArcanaTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleCommonItemdropArcanaTable>();
	}
};
static_assert(alignof(UDatShuffleCommonItemdropArcanaTable) == 0x000008, "Wrong alignment on UDatShuffleCommonItemdropArcanaTable");
static_assert(sizeof(UDatShuffleCommonItemdropArcanaTable) == 0x000040, "Wrong size on UDatShuffleCommonItemdropArcanaTable");
static_assert(offsetof(UDatShuffleCommonItemdropArcanaTable, Data) == 0x000030, "Member 'UDatShuffleCommonItemdropArcanaTable::Data' has a wrong offset!");

// Class xrd777.DatBtlCommonNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatBtlCommonNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatBtlCommonName>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatBtlCommonNameTable">();
	}
	static class UDatBtlCommonNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatBtlCommonNameTable>();
	}
};
static_assert(alignof(UDatBtlCommonNameTable) == 0x000008, "Wrong alignment on UDatBtlCommonNameTable");
static_assert(sizeof(UDatBtlCommonNameTable) == 0x000040, "Wrong size on UDatBtlCommonNameTable");
static_assert(offsetof(UDatBtlCommonNameTable, Data) == 0x000030, "Member 'UDatBtlCommonNameTable::Data' has a wrong offset!");

// Class xrd777.DatCalcPANICDropItemTable
// 0x0010 (0x0040 - 0x0030)
class UDatCalcPANICDropItemTable final : public UAppDataAsset
{
public:
	TArray<struct FDatCalcPANICDropItemRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatCalcPANICDropItemTable">();
	}
	static class UDatCalcPANICDropItemTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatCalcPANICDropItemTable>();
	}
};
static_assert(alignof(UDatCalcPANICDropItemTable) == 0x000008, "Wrong alignment on UDatCalcPANICDropItemTable");
static_assert(sizeof(UDatCalcPANICDropItemTable) == 0x000040, "Wrong size on UDatCalcPANICDropItemTable");
static_assert(offsetof(UDatCalcPANICDropItemTable, Data) == 0x000030, "Member 'UDatCalcPANICDropItemTable::Data' has a wrong offset!");

// Class xrd777.DatCalcPANICUseItemTable
// 0x0010 (0x0040 - 0x0030)
class UDatCalcPANICUseItemTable final : public UAppDataAsset
{
public:
	TArray<struct FDatCalcPANICUseItemRecord>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatCalcPANICUseItemTable">();
	}
	static class UDatCalcPANICUseItemTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatCalcPANICUseItemTable>();
	}
};
static_assert(alignof(UDatCalcPANICUseItemTable) == 0x000008, "Wrong alignment on UDatCalcPANICUseItemTable");
static_assert(sizeof(UDatCalcPANICUseItemTable) == 0x000040, "Wrong size on UDatCalcPANICUseItemTable");
static_assert(offsetof(UDatCalcPANICUseItemTable, Data) == 0x000030, "Member 'UDatCalcPANICUseItemTable::Data' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaPropAttachSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtCharaPropAttachSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtCharaPropAttachSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPropAttachSection">();
	}
	static class UMovieSceneEvtCharaPropAttachSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPropAttachSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPropAttachSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPropAttachSection");
static_assert(sizeof(UMovieSceneEvtCharaPropAttachSection) == 0x000170, "Wrong size on UMovieSceneEvtCharaPropAttachSection");
static_assert(offsetof(UMovieSceneEvtCharaPropAttachSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtCharaPropAttachSection::EventData' has a wrong offset!");

// Class xrd777.ConfigDungeonBGMSelectDialog
// 0x00C0 (0x00E8 - 0x0028)
class UConfigDungeonBGMSelectDialog final : public UObject
{
public:
	uint8                                         Pad_28[0xC0];                                      // 0x0028(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigDungeonBGMSelectDialog">();
	}
	static class UConfigDungeonBGMSelectDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigDungeonBGMSelectDialog>();
	}
};
static_assert(alignof(UConfigDungeonBGMSelectDialog) == 0x000008, "Wrong alignment on UConfigDungeonBGMSelectDialog");
static_assert(sizeof(UConfigDungeonBGMSelectDialog) == 0x0000E8, "Wrong size on UConfigDungeonBGMSelectDialog");

// Class xrd777.DatEncountEnemyBadPercentTable
// 0x0010 (0x0040 - 0x0030)
class UDatEncountEnemyBadPercentTable final : public UAppDataAsset
{
public:
	TArray<struct FDatEncountEnemyBadPercentRecord> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEncountEnemyBadPercentTable">();
	}
	static class UDatEncountEnemyBadPercentTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEncountEnemyBadPercentTable>();
	}
};
static_assert(alignof(UDatEncountEnemyBadPercentTable) == 0x000008, "Wrong alignment on UDatEncountEnemyBadPercentTable");
static_assert(sizeof(UDatEncountEnemyBadPercentTable) == 0x000040, "Wrong size on UDatEncountEnemyBadPercentTable");
static_assert(offsetof(UDatEncountEnemyBadPercentTable, Data) == 0x000030, "Member 'UDatEncountEnemyBadPercentTable::Data' has a wrong offset!");

// Class xrd777.DatBtlTheurgiaBoostTable
// 0x0010 (0x0040 - 0x0030)
class UDatBtlTheurgiaBoostTable final : public UAppDataAsset
{
public:
	TArray<struct FDatBtlTheurgiaBoostRecord>     Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatBtlTheurgiaBoostTable">();
	}
	static class UDatBtlTheurgiaBoostTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatBtlTheurgiaBoostTable>();
	}
};
static_assert(alignof(UDatBtlTheurgiaBoostTable) == 0x000008, "Wrong alignment on UDatBtlTheurgiaBoostTable");
static_assert(sizeof(UDatBtlTheurgiaBoostTable) == 0x000040, "Wrong size on UDatBtlTheurgiaBoostTable");
static_assert(offsetof(UDatBtlTheurgiaBoostTable, Data) == 0x000030, "Member 'UDatBtlTheurgiaBoostTable::Data' has a wrong offset!");

// Class xrd777.MovieSceneEvtMessageSubtitleSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtMessageSubtitleSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtMessageSubtitleSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtMessageSubtitleSection">();
	}
	static class UMovieSceneEvtMessageSubtitleSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtMessageSubtitleSection>();
	}
};
static_assert(alignof(UMovieSceneEvtMessageSubtitleSection) == 0x000008, "Wrong alignment on UMovieSceneEvtMessageSubtitleSection");
static_assert(sizeof(UMovieSceneEvtMessageSubtitleSection) == 0x000170, "Wrong size on UMovieSceneEvtMessageSubtitleSection");
static_assert(offsetof(UMovieSceneEvtMessageSubtitleSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtMessageSubtitleSection::EventData' has a wrong offset!");

// Class xrd777.BtlVoicePlayWatcher
// 0x0028 (0x0050 - 0x0028)
class UBtlVoicePlayWatcher final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlVoicePlayWatcher">();
	}
	static class UBtlVoicePlayWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlVoicePlayWatcher>();
	}
};
static_assert(alignof(UBtlVoicePlayWatcher) == 0x000008, "Wrong alignment on UBtlVoicePlayWatcher");
static_assert(sizeof(UBtlVoicePlayWatcher) == 0x000050, "Wrong size on UBtlVoicePlayWatcher");

// Class xrd777.DatBtlMixraidReleaseTable
// 0x0010 (0x0040 - 0x0030)
class UDatBtlMixraidReleaseTable final : public UAppDataAsset
{
public:
	TArray<struct FDatBtlMixraidReleaseRecord>    Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatBtlMixraidReleaseTable">();
	}
	static class UDatBtlMixraidReleaseTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatBtlMixraidReleaseTable>();
	}
};
static_assert(alignof(UDatBtlMixraidReleaseTable) == 0x000008, "Wrong alignment on UDatBtlMixraidReleaseTable");
static_assert(sizeof(UDatBtlMixraidReleaseTable) == 0x000040, "Wrong size on UDatBtlMixraidReleaseTable");
static_assert(offsetof(UDatBtlMixraidReleaseTable, Data) == 0x000030, "Member 'UDatBtlMixraidReleaseTable::Data' has a wrong offset!");

// Class xrd777.TheurgiaAnimActor
// 0x0018 (0x0290 - 0x0278)
class ATheurgiaAnimActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheurgiaAnimActor">();
	}
	static class ATheurgiaAnimActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATheurgiaAnimActor>();
	}
};
static_assert(alignof(ATheurgiaAnimActor) == 0x000008, "Wrong alignment on ATheurgiaAnimActor");
static_assert(sizeof(ATheurgiaAnimActor) == 0x000290, "Wrong size on ATheurgiaAnimActor");

// Class xrd777.BtlDataBaseComponent
// 0x0000 (0x00C8 - 0x00C8)
class UBtlDataBaseComponent : public UAppActorComponent
{
public:
	bool CallCheckAlreadyRequestEscape(class UBtlCoreComponent* BtlCore);
	bool CallCheckEncountEscape(class UBtlCoreComponent* BtlCore);
	void CallRequestEscape(class UBtlCoreComponent* BtlCore);
	void CallSupportInfoDisableShift(class UBtlCoreComponent* BtlCore);
	bool CheckExistTarget(class UBtlCoreComponent* BtlCore, int32 SkillId);
	bool CheckExistTutorial(class UBtlCoreComponent* BtlCore);
	bool CheckNyxCoreBattle(class UBtlCoreComponent* BtlCore);
	bool CheckSupport(class ABtlActor* Actor, int32 Type);
	bool CheckSupportDownUp(class ABtlActor* Actor, EBtlDataSupportTable Support);
	bool CheckTacticsIconLLSize(class ABtlActor* Target);
	bool ChkAllCostOff(class UBtlCoreComponent* BtlCore);
	bool ChkAutoSkill(int32 SkillId);
	bool ChkEnemySideWeak(class ABtlActor* Action, const TArray<class ABtlActor*>& EnemyList, EBtlDataAttr Attr);
	bool ChkEnemySideWeakAll(class ABtlActor* Action, const TArray<class ABtlActor*>& EnemyList);
	int32 ChkExcessEfficary(class ABtlActor* PAction, const TArray<class ABtlActor*>& TargetList, int32 SkillId, bool IsItem);
	bool ChkLastActionLoop(class UBtlCoreComponent* BtlCore);
	bool ChkPlayerDamageOff(class UBtlCoreComponent* BtlCore);
	bool ChkPrevUseSkillIDFrag();
	bool ChkSelectAllPersona(class UBtlCoreComponent* BtlCore);
	bool ChkSelectAllSkill(class UBtlCoreComponent* BtlCore);
	bool ChkSkillIgnoreResistances(class ABtlActor* Action, int32 SkillId);
	bool ChkSpecialSkillID(int32 ID);
	bool ChkTPValid(class ABtlActor* Actor);
	bool ChkTurnOff(class UBtlCoreComponent* BtlCore);
	bool ChkTutorialSkillList(class UBtlCoreComponent* BtlCore);
	bool ChkUseAllSkillAgeing(class UBtlCoreComponent* BtlCore);
	void ClearBadStatus(class ABtlActor* Actor);
	void ClearSupport(class ABtlActor* Actor);
	void ClearTargetSupport(class ABtlActor* Actor, int32 Type);
	void CloseAllAttr(class ABtlActor* Actor);
	EBtlDataAnalyze GatAnalizeAttr(class ABtlActor* Actor, uint8 Attr);
	int32 GetAnalyzeAttrMaxNum();
	class FText GetAttackName(int32 Attr);
	bool GetBadStatus(class ABtlActor* Actor, int32 Type);
	class FText GetBtlCommonText(int32 Key);
	void GetCorrespondList(TArray<class ABtlActor*>* Out, class ABtlActor* SpEmployment, EBtlCommandType Command, int32 ID);
	int32 GetEnemyDropItem(class ABtlActor* Actor, int32 Index_0);
	int32 GetFukaTheurgiaSkill();
	bool GetInputDecideKeyCross();
	TArray<struct FBtlItemData> GetItemBagData();
	int32 GetItemIconSprNo(int32 ItemId);
	class FText GetItemName(int32 ItemId);
	int32 GetItemSkillID(int32 ItemId);
	EBtlDataItemUseType GetItemUseType(class UBtlCoreComponent* BtlCore, EBtlCommandType Type, int32 ID);
	TArray<bool> GetKeyControl(class UBtlCoreComponent* BtlCore);
	bool GetManualOperate(class ABtlActor* Action);
	int32 GetNormalSkillMaxNum();
	int32 GetOperation(class ABtlActor* Action);
	bool GetOrgiaMode(class ABtlActor* Actor);
	void GetPersonaBySpecialSkill(int32 SkillId, int32* PersonaID1, int32* PersonaID2, bool* TwoPersona);
	int32 GetPersonaEquipID(class ABtlActor* Actor);
	int32 GetPersonaEquipIndex(class ABtlActor* Actor);
	class FText GetPersonaEquipName(class ABtlActor* Actor);
	TArray<int32> GetPersonaEquipSkillList(class ABtlActor* Actor);
	int32 GetPersonaMaxNum();
	class FText GetPersonaName(int32 PersonaID);
	void GetPersonaNameList(class ABtlActor* Actor, TArray<class FText>* NameList, int32* Count, int32* Equip);
	TArray<int32> GetPersonaSkillList(class ABtlActor* Actor, int32 Index_0);
	TArray<int32> GetPersonaStockIndexList(class ABtlActor* Actor);
	TArray<int32> GetPersonaTableSkillList(int32 PersonaID);
	struct FColor GetPlatFormButtonColor(int32 ButtonType);
	int32 GetPrevUseItemID();
	int32 GetPrevUseSkillID(class ABtlActor* Action);
	EBtlDataAttr GetSkillAttr(int32 SkillId);
	int32 GetSkillCost(int32 SkillId, class ABtlActor* Action, bool* Sucsess, EBtlDataCostType* Cost);
	bool GetSkillCostCheckOff(int32 SkillId);
	EBtlDataEfficacyType GetSkillEfficacyType(int32 SkillId);
	int32 GetSkillIconSprNo(int32 SkillId);
	int32 GetSkillIconSprNoByAttr(EBtlDataAttr Attr);
	bool GetSkillIsBadStatus(int32 SkillId);
	bool GetSkillIsCharge(int32 SkillId);
	bool GetSkillIsDamage(int32 SkillId, EBtlDataCostType Type);
	bool GetSkillIsDamageBit(int32 SkillId);
	bool GetSkillIsHealSupport(int32 SkillId, EBtlDataSupportTable* Support);
	bool GetSkillIsNoPanel(int32 SkillId);
	bool GetSkillIsRecovery(int32 SkillId, EBtlDataCostType Type);
	bool GetSkillIsSupport(int32 SkillId);
	void GetSkillList(class ABtlActor* Actor, TArray<int32>* Output);
	int32 GetSkillMaxNum();
	class FText GetSkillName(int32 SkillId, bool* Sucsess);
	class FText GetSkillParamN(int32 SkillId, bool* Sucsess);
	EBtlDataTargetArea GetSkillTargetArea(int32 SkillId);
	struct FBtlDataTargetRule GetSkillTargetRule(int32 SkillId);
	EBtlDataTargetType GetSkillTargetType(int32 SkillId);
	int32 GetSpecialAutoSkill(class ABtlActor* Actor, bool* bPowerUp);
	TArray<int32> GetSpecialSkillList(class ABtlActor* Actor);
	int32 GetStatusEndurance(class ABtlActor* Actor);
	int32 GetStatusLuck(class ABtlActor* Actor);
	int32 GetStatusMagic(class ABtlActor* Actor);
	int32 GetStatusSpeed(class ABtlActor* Actor);
	int32 GetStatusStrength(class ABtlActor* Actor);
	int32 GetSupportPoint(class ABtlActor* Actor, int32 Type);
	int32 GetSupportTurn(class ABtlActor* Actor, int32 Type);
	int32 GetTargetEffectiveIndex(const TArray<class ABtlActor*>& Target, EBtlDataCostType Type);
	class UBmdAsset* GetTheurgiaFlavorBMD();
	class ABtlActor* GetUINextAction(class UBtlCoreComponent* BtlCore);
	int32 GetUnitArcana(class ABtlActor* Actor);
	int32 GetUnitHP(class ABtlActor* Actor);
	int32 GetUnitID(class ABtlActor* Actor);
	int32 GetUnitLevel(class ABtlActor* Actor);
	int32 GetUnitMaxHP(class ABtlActor* Actor);
	int32 GetUnitMaxSP(class ABtlActor* Actor);
	int32 GetUnitMaxTP(class ABtlActor* Actor);
	class FText GetUnitName(class ABtlActor* Actor, bool InsertSpace);
	int32 GetUnitSP(class ABtlActor* Actor);
	int32 GetUnitTP(class ABtlActor* Actor);
	class AActor* GetViewTargetActor(class APlayerCameraManager* CameraManager);
	class ABtlActor* MoveCursorTactics(int32 NowIdx, const TArray<class ABtlActor*>& List, const TArray<struct FVector2D>& PosCursor, EBtlDataMoveCursorTactics MoveCursor, bool IsBoss);
	class ABtlActor* MoveCursorTacticsSimple(int32 NowIdx, const TArray<class ABtlActor*>& List, const TArray<struct FVector2D>& PosCursor, EBtlDataMoveCursorTactics MoveCursor);
	void OpenAllAttr(class ABtlActor* Actor);
	void SavePrevUseItemID(int32 ID);
	void SavePrevUseSkillID(class ABtlActor* Action, int32 ID);
	void SaveReceiveSkillAttr(const TArray<class ABtlActor*>& Targets, EBtlDataAttr Attr);
	void SetBadStatus(class ABtlActor* Actor, int32 Type);
	void SetHighStreamingLocation(const struct FVector& Location);
	void SetManualOperate(class ABtlActor* Action, bool IsManual);
	void SetOperation(class ABtlActor* Action, int32 Operation);
	void SetPersonaDefaultStock(class ABtlActor* Actor, int32 PersonaID, int32* Index_0);
	void SetPersonaEquipID(class ABtlActor* Actor, int32 ID);
	void SetPersonaStockEquip(class ABtlActor* Actor, int32 Index_0);
	void SetSupport(class ABtlActor* Actor, int32 Type);
	void SetUnitHP(class ABtlActor* Actor, int32 Hp);
	void SetUnitSP(class ABtlActor* Actor, int32 Hp);
	void SetUnitTP(class ABtlActor* Actor, int32 Hp);
	TArray<class ABtlActor*> SortEnemyTacticsList(const TArray<class ABtlActor*>& InList);
	TArray<struct FBtlItemData> SortItemBagData(class UBtlCoreComponent* BtlCore, const TArray<struct FBtlItemData>& In);
	TArray<class ABtlActor*> SortPlayerTacticsList(const TArray<class ABtlActor*>& InList);
	void StartNavigation(class ABtlActor* Action, EBtlGuiState* State, int32* ID, TArray<class ABtlActor*>* Target, int32* PersonaID, bool* Physical);
	bool StartTheugiaWindow(class ABtlActor* PAction, const TArray<class ABtlActor*>& TargetList);
	bool SyncRewuestTutorial(class UBtlCoreComponent* BtlCore);
	class ABtlActor* SyncTheugiaWindowEnd(class UBtlCoreComponent* BtlCore, bool* IsEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlDataBaseComponent">();
	}
	static class UBtlDataBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlDataBaseComponent>();
	}
};
static_assert(alignof(UBtlDataBaseComponent) == 0x000008, "Wrong alignment on UBtlDataBaseComponent");
static_assert(sizeof(UBtlDataBaseComponent) == 0x0000C8, "Wrong size on UBtlDataBaseComponent");

// Class xrd777.BtlEnvironmentBase
// 0x0010 (0x00D8 - 0x00C8)
class UBtlEnvironmentBase : public UAppActorComponent
{
public:
	TArray<class AFldAnimObj*>                    BgObjList;                                         // 0x00C8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void DeleteLoversFogEffect();
	TArray<class ANiagaraActor*> GetLoversFogEffects();
	class AFldAnimObj* GetMonorailBGObj();
	TArray<class ANiagaraActor*> GetMonorailRushEffects();
	TArray<class AFldAnimObj*> GetMonorailStrapObj();
	TArray<class AFldAnimObj*> GetMonorailWallObj();
	TArray<class ANiagaraActor*> GetNyxAvatarFeatherEffects();
	void InvisibleHangedmanBGObj();
	void RequestLoversFogEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEnvironmentBase">();
	}
	static class UBtlEnvironmentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlEnvironmentBase>();
	}
};
static_assert(alignof(UBtlEnvironmentBase) == 0x000008, "Wrong alignment on UBtlEnvironmentBase");
static_assert(sizeof(UBtlEnvironmentBase) == 0x0000D8, "Wrong size on UBtlEnvironmentBase");
static_assert(offsetof(UBtlEnvironmentBase, BgObjList) == 0x0000C8, "Member 'UBtlEnvironmentBase::BgObjList' has a wrong offset!");

// Class xrd777.BtlEventActor
// 0x0028 (0x02A0 - 0x0278)
class ABtlEventActor final : public AAppActor
{
public:
	bool                                          bCompleteInit;                                     // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartScript;                                      // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlEventController*                    PController;                                       // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BtlEventProcNo;                                    // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCommonAsset;                                     // 0x028C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D[0x13];                                     // 0x028D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEventActor">();
	}
	static class ABtlEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlEventActor>();
	}
};
static_assert(alignof(ABtlEventActor) == 0x000008, "Wrong alignment on ABtlEventActor");
static_assert(sizeof(ABtlEventActor) == 0x0002A0, "Wrong size on ABtlEventActor");
static_assert(offsetof(ABtlEventActor, bCompleteInit) == 0x000278, "Member 'ABtlEventActor::bCompleteInit' has a wrong offset!");
static_assert(offsetof(ABtlEventActor, bStartScript) == 0x000279, "Member 'ABtlEventActor::bStartScript' has a wrong offset!");
static_assert(offsetof(ABtlEventActor, PController) == 0x000280, "Member 'ABtlEventActor::PController' has a wrong offset!");
static_assert(offsetof(ABtlEventActor, BtlEventProcNo) == 0x000288, "Member 'ABtlEventActor::BtlEventProcNo' has a wrong offset!");
static_assert(offsetof(ABtlEventActor, IsCommonAsset) == 0x00028C, "Member 'ABtlEventActor::IsCommonAsset' has a wrong offset!");

// Class xrd777.CldSceneChange
// 0x0000 (0x0028 - 0x0028)
class UCldSceneChange final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldSceneChange">();
	}
	static class UCldSceneChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldSceneChange>();
	}
};
static_assert(alignof(UCldSceneChange) == 0x000008, "Wrong alignment on UCldSceneChange");
static_assert(sizeof(UCldSceneChange) == 0x000028, "Wrong size on UCldSceneChange");

// Class xrd777.BtlEventAlloutShuffleMonitor
// 0x0050 (0x02C8 - 0x0278)
class ABtlEventAlloutShuffleMonitor final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnSyncStartCharaAnime;                             // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSyncShuffleEnd;                                  // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBtlCoreComponent*                      PCore;                                             // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlShuffleMainBase*                    PShuffle;                                          // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlShuffleMainBase>        ShuffleUIBp;                                       // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartShuffleTime(class UBtlCoreComponent* BtlCore);

	bool CheckReadyToDestroy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEventAlloutShuffleMonitor">();
	}
	static class ABtlEventAlloutShuffleMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlEventAlloutShuffleMonitor>();
	}
};
static_assert(alignof(ABtlEventAlloutShuffleMonitor) == 0x000008, "Wrong alignment on ABtlEventAlloutShuffleMonitor");
static_assert(sizeof(ABtlEventAlloutShuffleMonitor) == 0x0002C8, "Wrong size on ABtlEventAlloutShuffleMonitor");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, OnSyncStartCharaAnime) == 0x000278, "Member 'ABtlEventAlloutShuffleMonitor::OnSyncStartCharaAnime' has a wrong offset!");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, OnSyncShuffleEnd) == 0x000288, "Member 'ABtlEventAlloutShuffleMonitor::OnSyncShuffleEnd' has a wrong offset!");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, PCore) == 0x000298, "Member 'ABtlEventAlloutShuffleMonitor::PCore' has a wrong offset!");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, PShuffle) == 0x0002A0, "Member 'ABtlEventAlloutShuffleMonitor::PShuffle' has a wrong offset!");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, ShuffleUIBp) == 0x0002A8, "Member 'ABtlEventAlloutShuffleMonitor::ShuffleUIBp' has a wrong offset!");
static_assert(offsetof(ABtlEventAlloutShuffleMonitor, Loader) == 0x0002B0, "Member 'ABtlEventAlloutShuffleMonitor::Loader' has a wrong offset!");

// Class xrd777.MovieSceneEvtFieldAnimationSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtFieldAnimationSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtFieldAnimationSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtFieldAnimationSection">();
	}
	static class UMovieSceneEvtFieldAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtFieldAnimationSection>();
	}
};
static_assert(alignof(UMovieSceneEvtFieldAnimationSection) == 0x000008, "Wrong alignment on UMovieSceneEvtFieldAnimationSection");
static_assert(sizeof(UMovieSceneEvtFieldAnimationSection) == 0x000170, "Wrong size on UMovieSceneEvtFieldAnimationSection");
static_assert(offsetof(UMovieSceneEvtFieldAnimationSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtFieldAnimationSection::EventData' has a wrong offset!");

// Class xrd777.FadePgDarkHour
// 0x00C0 (0x0100 - 0x0040)
class UFadePgDarkHour final : public UFadeProgramBase
{
public:
	struct FDarkHourWork                          Work;                                              // 0x0040(0x00C0)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgDarkHour">();
	}
	static class UFadePgDarkHour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgDarkHour>();
	}
};
static_assert(alignof(UFadePgDarkHour) == 0x000008, "Wrong alignment on UFadePgDarkHour");
static_assert(sizeof(UFadePgDarkHour) == 0x000100, "Wrong size on UFadePgDarkHour");
static_assert(offsetof(UFadePgDarkHour, Work) == 0x000040, "Member 'UFadePgDarkHour::Work' has a wrong offset!");

// Class xrd777.BtlEventBfLoader
// 0x0040 (0x02B8 - 0x0278)
class ABtlEventBfLoader final : public AAppActor
{
public:
	bool                                          bCompleteInit;                                     // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               PBfAsset;                                          // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              PBmdAsset;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEventBfLoader">();
	}
	static class ABtlEventBfLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlEventBfLoader>();
	}
};
static_assert(alignof(ABtlEventBfLoader) == 0x000008, "Wrong alignment on ABtlEventBfLoader");
static_assert(sizeof(ABtlEventBfLoader) == 0x0002B8, "Wrong size on ABtlEventBfLoader");
static_assert(offsetof(ABtlEventBfLoader, bCompleteInit) == 0x000278, "Member 'ABtlEventBfLoader::bCompleteInit' has a wrong offset!");
static_assert(offsetof(ABtlEventBfLoader, PAssetLoader) == 0x000280, "Member 'ABtlEventBfLoader::PAssetLoader' has a wrong offset!");
static_assert(offsetof(ABtlEventBfLoader, PBfAsset) == 0x000288, "Member 'ABtlEventBfLoader::PBfAsset' has a wrong offset!");
static_assert(offsetof(ABtlEventBfLoader, PBmdAsset) == 0x000290, "Member 'ABtlEventBfLoader::PBmdAsset' has a wrong offset!");

// Class xrd777.FldDungeonLoader
// 0x00C8 (0x0340 - 0x0278)
class AFldDungeonLoader final : public AAppActor
{
public:
	uint8                                         Pad_278[0xC8];                                     // 0x0278(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLoader">();
	}
	static class AFldDungeonLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLoader>();
	}
};
static_assert(alignof(AFldDungeonLoader) == 0x000008, "Wrong alignment on AFldDungeonLoader");
static_assert(sizeof(AFldDungeonLoader) == 0x000340, "Wrong size on AFldDungeonLoader");

// Class xrd777.BtlEventController
// 0x0080 (0x0148 - 0x00C8)
class UBtlEventController : public UAppActorComponent
{
public:
	bool                                          bLoadCompleted;                                    // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonLoadCompleted;                              // 0x00C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBfAsset*                               PBfCommonAsset;                                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              PBmdCommonAsset;                                   // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBfAsset*                               PBfAsset;                                          // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              PBmdAsset;                                         // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlEventActor*                         PEventActor;                                       // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBtlEncountParam                       EncountParam;                                      // 0x00F8(0x0024)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlCoreComponent*                      BtlCore;                                           // 0x0120(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAppActor>                  SequencerObserveClass;                             // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEndScirpt;                                       // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CommonEventStart(EBtlCommonEventType EventType);
	void EventStart(EBtlEventType EventType);
	bool HasEventScriptForBP(const struct FBtlEncountParam& EncParam);
	bool IsPlayingEvent();
	void ResetAllPerformer();
	void SetPerformer(class ABtlActor* Actor, EBtlEventAreaType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEventController">();
	}
	static class UBtlEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlEventController>();
	}
};
static_assert(alignof(UBtlEventController) == 0x000008, "Wrong alignment on UBtlEventController");
static_assert(sizeof(UBtlEventController) == 0x000148, "Wrong size on UBtlEventController");
static_assert(offsetof(UBtlEventController, bLoadCompleted) == 0x0000C8, "Member 'UBtlEventController::bLoadCompleted' has a wrong offset!");
static_assert(offsetof(UBtlEventController, bCommonLoadCompleted) == 0x0000C9, "Member 'UBtlEventController::bCommonLoadCompleted' has a wrong offset!");
static_assert(offsetof(UBtlEventController, PBfCommonAsset) == 0x0000D0, "Member 'UBtlEventController::PBfCommonAsset' has a wrong offset!");
static_assert(offsetof(UBtlEventController, PBmdCommonAsset) == 0x0000D8, "Member 'UBtlEventController::PBmdCommonAsset' has a wrong offset!");
static_assert(offsetof(UBtlEventController, PBfAsset) == 0x0000E0, "Member 'UBtlEventController::PBfAsset' has a wrong offset!");
static_assert(offsetof(UBtlEventController, PBmdAsset) == 0x0000E8, "Member 'UBtlEventController::PBmdAsset' has a wrong offset!");
static_assert(offsetof(UBtlEventController, PEventActor) == 0x0000F0, "Member 'UBtlEventController::PEventActor' has a wrong offset!");
static_assert(offsetof(UBtlEventController, EncountParam) == 0x0000F8, "Member 'UBtlEventController::EncountParam' has a wrong offset!");
static_assert(offsetof(UBtlEventController, BtlCore) == 0x000120, "Member 'UBtlEventController::BtlCore' has a wrong offset!");
static_assert(offsetof(UBtlEventController, SequencerObserveClass) == 0x000128, "Member 'UBtlEventController::SequencerObserveClass' has a wrong offset!");
static_assert(offsetof(UBtlEventController, OnEndScirpt) == 0x000130, "Member 'UBtlEventController::OnEndScirpt' has a wrong offset!");

// Class xrd777.TestNishidaResource
// 0x0030 (0x0058 - 0x0028)
class UTestNishidaResource final : public UObject
{
public:
	class UTexture*                               M_pTexture;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                M_pSoftTexture;                                    // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestNishidaResource">();
	}
	static class UTestNishidaResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestNishidaResource>();
	}
};
static_assert(alignof(UTestNishidaResource) == 0x000008, "Wrong alignment on UTestNishidaResource");
static_assert(sizeof(UTestNishidaResource) == 0x000058, "Wrong size on UTestNishidaResource");
static_assert(offsetof(UTestNishidaResource, M_pTexture) == 0x000028, "Member 'UTestNishidaResource::M_pTexture' has a wrong offset!");
static_assert(offsetof(UTestNishidaResource, M_pSoftTexture) == 0x000030, "Member 'UTestNishidaResource::M_pSoftTexture' has a wrong offset!");

// Class xrd777.CmpSystemSystem
// 0x0030 (0x0058 - 0x0028)
class UCmpSystemSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PCmpMainActor;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUISaveLoad*                            PSaveMenu;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIRestore*                             PRestoreMenu;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSystemSystem">();
	}
	static class UCmpSystemSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSystemSystem>();
	}
};
static_assert(alignof(UCmpSystemSystem) == 0x000008, "Wrong alignment on UCmpSystemSystem");
static_assert(sizeof(UCmpSystemSystem) == 0x000058, "Wrong size on UCmpSystemSystem");
static_assert(offsetof(UCmpSystemSystem, PCmpMainActor) == 0x000040, "Member 'UCmpSystemSystem::PCmpMainActor' has a wrong offset!");
static_assert(offsetof(UCmpSystemSystem, PSaveMenu) == 0x000048, "Member 'UCmpSystemSystem::PSaveMenu' has a wrong offset!");
static_assert(offsetof(UCmpSystemSystem, PRestoreMenu) == 0x000050, "Member 'UCmpSystemSystem::PRestoreMenu' has a wrong offset!");

// Class xrd777.BtlEventCutsceneController
// 0x0988 (0x09B0 - 0x0028)
class UBtlEventCutsceneController final : public UObject
{
public:
	class UDataTable*                             SequenceTable;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBtlCutsceneHandleData                 LoadSequence[0x32];                                // 0x0030(0x0030)(NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0990(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           LoaderTable;                                       // 0x0998(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A0[0x8];                                      // 0x09A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AllLoader;                                         // 0x09A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEventCutsceneController">();
	}
	static class UBtlEventCutsceneController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlEventCutsceneController>();
	}
};
static_assert(alignof(UBtlEventCutsceneController) == 0x000008, "Wrong alignment on UBtlEventCutsceneController");
static_assert(sizeof(UBtlEventCutsceneController) == 0x0009B0, "Wrong size on UBtlEventCutsceneController");
static_assert(offsetof(UBtlEventCutsceneController, SequenceTable) == 0x000028, "Member 'UBtlEventCutsceneController::SequenceTable' has a wrong offset!");
static_assert(offsetof(UBtlEventCutsceneController, LoadSequence) == 0x000030, "Member 'UBtlEventCutsceneController::LoadSequence' has a wrong offset!");
static_assert(offsetof(UBtlEventCutsceneController, SequenceActor) == 0x000990, "Member 'UBtlEventCutsceneController::SequenceActor' has a wrong offset!");
static_assert(offsetof(UBtlEventCutsceneController, LoaderTable) == 0x000998, "Member 'UBtlEventCutsceneController::LoaderTable' has a wrong offset!");
static_assert(offsetof(UBtlEventCutsceneController, AllLoader) == 0x0009A8, "Member 'UBtlEventCutsceneController::AllLoader' has a wrong offset!");

// Class xrd777.TitleStateNetworkCheck
// 0x0018 (0x0050 - 0x0038)
class UTitleStateNetworkCheck final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AUISystemMsgActor*                      NetWaitDialog;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateNetworkCheck">();
	}
	static class UTitleStateNetworkCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateNetworkCheck>();
	}
};
static_assert(alignof(UTitleStateNetworkCheck) == 0x000008, "Wrong alignment on UTitleStateNetworkCheck");
static_assert(sizeof(UTitleStateNetworkCheck) == 0x000050, "Wrong size on UTitleStateNetworkCheck");
static_assert(offsetof(UTitleStateNetworkCheck, NetWaitDialog) == 0x000048, "Member 'UTitleStateNetworkCheck::NetWaitDialog' has a wrong offset!");

// Class xrd777.BtlFadeManager
// 0x0070 (0x02E8 - 0x0278)
class ABtlFadeManager final : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnFadeOut;                                         // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFadeIn;                                          // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsFadeing;                                         // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsScreenWrap;                                      // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnemyFlag;                                       // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAIActionFlag;                                    // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlFadeType                                  Type;                                              // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlFadeType                                  ReceaveType;                                       // 0x029D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossFade;                                        // 0x029E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F[0x1];                                      // 0x029F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrossfadeTime;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossFadeMaxTime;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastFadeOut;                                       // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBtlFadeParam>                  FadeParam;                                         // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABtlFadeManager>            LoadClass;                                         // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PLoader;                                           // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BtlCrossFadeIn(int32 Frame);
	static void BtlCrossFadeOut();
	static bool BtlFadeCheckScreenWrap();
	static void BtlFadeIn(EBtlFadeType Type_0, int32 Frame, bool IsEnemy, bool IsAIAction);
	static class ABtlFadeManager* BtlFadeManagerGetInstance();
	static void BtlFadeOut(EBtlFadeType Type_0, int32 Frame, bool IsEnemy, bool IsAIAction);
	static bool BtlFadeSync();

	void ClearDrawItem();
	void FadeInit(bool IsFadeOut);
	void FadeUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlFadeManager">();
	}
	static class ABtlFadeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlFadeManager>();
	}
};
static_assert(alignof(ABtlFadeManager) == 0x000008, "Wrong alignment on ABtlFadeManager");
static_assert(sizeof(ABtlFadeManager) == 0x0002E8, "Wrong size on ABtlFadeManager");
static_assert(offsetof(ABtlFadeManager, OnFadeOut) == 0x000278, "Member 'ABtlFadeManager::OnFadeOut' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, OnFadeIn) == 0x000288, "Member 'ABtlFadeManager::OnFadeIn' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, IsFadeing) == 0x000298, "Member 'ABtlFadeManager::IsFadeing' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, IsScreenWrap) == 0x000299, "Member 'ABtlFadeManager::IsScreenWrap' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, IsEnemyFlag) == 0x00029A, "Member 'ABtlFadeManager::IsEnemyFlag' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, IsAIActionFlag) == 0x00029B, "Member 'ABtlFadeManager::IsAIActionFlag' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, Type) == 0x00029C, "Member 'ABtlFadeManager::Type' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, ReceaveType) == 0x00029D, "Member 'ABtlFadeManager::ReceaveType' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, bCrossFade) == 0x00029E, "Member 'ABtlFadeManager::bCrossFade' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, CrossfadeTime) == 0x0002A0, "Member 'ABtlFadeManager::CrossfadeTime' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, CrossFadeMaxTime) == 0x0002A4, "Member 'ABtlFadeManager::CrossFadeMaxTime' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, LastFadeOut) == 0x0002A8, "Member 'ABtlFadeManager::LastFadeOut' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, FadeParam) == 0x0002B0, "Member 'ABtlFadeManager::FadeParam' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, LoadClass) == 0x0002D0, "Member 'ABtlFadeManager::LoadClass' has a wrong offset!");
static_assert(offsetof(ABtlFadeManager, PLoader) == 0x0002D8, "Member 'ABtlFadeManager::PLoader' has a wrong offset!");

// Class xrd777.DatSaveDataLocalization
// 0x0108 (0x0138 - 0x0030)
class UDatSaveDataLocalization final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x108];                                     // 0x0030(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSaveDataLocalization">();
	}
	static class UDatSaveDataLocalization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSaveDataLocalization>();
	}
};
static_assert(alignof(UDatSaveDataLocalization) == 0x000008, "Wrong alignment on UDatSaveDataLocalization");
static_assert(sizeof(UDatSaveDataLocalization) == 0x000138, "Wrong size on UDatSaveDataLocalization");

// Class xrd777.BtlFormationPoint
// 0x0008 (0x0228 - 0x0220)
class ABtlFormationPoint final : public AActor
{
public:
	bool                                          IsForEnemies;                                      // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlFormationSizeType                         SizeCategory;                                      // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlFormationPoint">();
	}
	static class ABtlFormationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlFormationPoint>();
	}
};
static_assert(alignof(ABtlFormationPoint) == 0x000008, "Wrong alignment on ABtlFormationPoint");
static_assert(sizeof(ABtlFormationPoint) == 0x000228, "Wrong size on ABtlFormationPoint");
static_assert(offsetof(ABtlFormationPoint, IsForEnemies) == 0x000220, "Member 'ABtlFormationPoint::IsForEnemies' has a wrong offset!");
static_assert(offsetof(ABtlFormationPoint, SizeCategory) == 0x000221, "Member 'ABtlFormationPoint::SizeCategory' has a wrong offset!");

// Class xrd777.TitleStateComeBackLoad
// 0x00A8 (0x00E0 - 0x0038)
class UTitleStateComeBackLoad final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateComeBackLoad">();
	}
	static class UTitleStateComeBackLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateComeBackLoad>();
	}
};
static_assert(alignof(UTitleStateComeBackLoad) == 0x000008, "Wrong alignment on UTitleStateComeBackLoad");
static_assert(sizeof(UTitleStateComeBackLoad) == 0x0000E0, "Wrong size on UTitleStateComeBackLoad");

// Class xrd777.BtlGuiAnalyzeComponent
// 0x0010 (0x00D8 - 0x00C8)
class UBtlGuiAnalyzeComponent final : public UAppActorComponent
{
public:
	class UBmdAsset*                              BmdAsset;                                          // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckAttrFullOpen(class ABtlActor* Actor);
	bool CheckEndLoader();
	bool CheckHighAnalyzeEnableSP();
	bool CheckPlayHighAnalzeSupport(class UBtlCoreComponent* BtlCore);
	bool CheckShowArcana(class ABtlActor* Actor);
	bool CheckShowAttackAttr(class ABtlActor* Actor);
	bool CheckShowFukaFukidashi(class UBtlCoreComponent* BtlCore);
	bool CheckShowItem(class ABtlActor* Actor);
	bool CheckShowSkill(class ABtlActor* Actor);
	bool CheckShowStatus(class ABtlActor* Actor);
	void CloseAnalyze();
	void CloseSelectWindow();
	int32 GetAnalyzeSupportInfo(class UBtlCoreComponent* BtlCore, EBtlAnalyzeSupportType Type);
	int32 GetCostHighAnalyze();
	bool GetDebugEnableFlag(class UBtlCoreComponent* BtlCore);
	class UBmdAsset* GetHighAnalyzeBMD(class UBtlCoreComponent* BtlCore);
	EBtlAnalyzeSupportType GetSupportTypeTargetEnemy(class UBtlCoreComponent* BtlCore, class ABtlActor* Actor);
	void HiddenFukaPartyPanel();
	void Init();
	void OpenSelectWindow();
	void PlayAnalyzeSupportInfo(class UBtlCoreComponent* BtlCore, int32 PlayID);
	void PlaySupportInfo(class UBtlCoreComponent* BtlCore, class ABtlActor* Actor);
	TArray<class ABtlActor*> RemoveSameEnemyID(const TArray<class ABtlActor*>& InList, class ABtlActor* PriorityActor);
	void SetSelectIndex(int32 Idx);
	void ShowFukaPartyPanel();
	void ShowMessage(int32 Index_0);
	void StartLoadResource();
	void UpdateAnalyze(class ABtlActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiAnalyzeComponent">();
	}
	static class UBtlGuiAnalyzeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiAnalyzeComponent>();
	}
};
static_assert(alignof(UBtlGuiAnalyzeComponent) == 0x000008, "Wrong alignment on UBtlGuiAnalyzeComponent");
static_assert(sizeof(UBtlGuiAnalyzeComponent) == 0x0000D8, "Wrong size on UBtlGuiAnalyzeComponent");
static_assert(offsetof(UBtlGuiAnalyzeComponent, BmdAsset) == 0x0000C8, "Member 'UBtlGuiAnalyzeComponent::BmdAsset' has a wrong offset!");
static_assert(offsetof(UBtlGuiAnalyzeComponent, Loader) == 0x0000D0, "Member 'UBtlGuiAnalyzeComponent::Loader' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectCore
// 0x0030 (0x0058 - 0x0028)
class UBtlGuiDrawObjectCore : public UObject
{
public:
	bool                                          Visible;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrpNo;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBtlGuiDrawObjectCore*>          ChildObject;                                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBtlGuiDrawFlag                        DrawFlag;                                          // 0x0050(0x0003)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAlpha();
	float GetAngle();
	struct FVector2D GetAngleAnchorPos();
	struct FColor GetColor();
	struct FVector2D GetPos();
	struct FVector2D GetScale();
	struct FVector2D GetScaleAnchorPos();
	void SetAlpha(float Alpha);
	void SetAnchorPos(const struct FVector2D& Anchor);
	void SetAngle(float Angle);
	void SetAngleAnchorPos(const struct FVector2D& Anchor);
	void SetChildObject(class UBtlGuiDrawObjectCore* Object, const struct FBtlGuiDrawFlag& Flag);
	void SetColor(const struct FColor& Color);
	void SetPos(const struct FVector2D& Pos);
	void SetScale(float Scale);
	void SetScaleAnchorPos(const struct FVector2D& Anchor);
	void SetScaleVec2(const struct FVector2D& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectCore">();
	}
	static class UBtlGuiDrawObjectCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectCore>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectCore) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectCore");
static_assert(sizeof(UBtlGuiDrawObjectCore) == 0x000058, "Wrong size on UBtlGuiDrawObjectCore");
static_assert(offsetof(UBtlGuiDrawObjectCore, Visible) == 0x000028, "Member 'UBtlGuiDrawObjectCore::Visible' has a wrong offset!");
static_assert(offsetof(UBtlGuiDrawObjectCore, GrpNo) == 0x00002C, "Member 'UBtlGuiDrawObjectCore::GrpNo' has a wrong offset!");
static_assert(offsetof(UBtlGuiDrawObjectCore, ChildObject) == 0x000040, "Member 'UBtlGuiDrawObjectCore::ChildObject' has a wrong offset!");
static_assert(offsetof(UBtlGuiDrawObjectCore, DrawFlag) == 0x000050, "Member 'UBtlGuiDrawObjectCore::DrawFlag' has a wrong offset!");

// Class xrd777.DatItemActor
// 0x0018 (0x0290 - 0x0278)
class ADatItemActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatItemActor">();
	}
	static class ADatItemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADatItemActor>();
	}
};
static_assert(alignof(ADatItemActor) == 0x000008, "Wrong alignment on ADatItemActor");
static_assert(sizeof(ADatItemActor) == 0x000290, "Wrong size on ADatItemActor");
static_assert(offsetof(ADatItemActor, MAssetLoader_) == 0x000280, "Member 'ADatItemActor::MAssetLoader_' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectClearScreen
// 0x0008 (0x0060 - 0x0058)
class UBtlGuiDrawObjectClearScreen final : public UBtlGuiDrawObjectCore
{
public:
	struct FColor                                 Color;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlGuiOT                                     OT;                                                // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectClearScreen">();
	}
	static class UBtlGuiDrawObjectClearScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectClearScreen>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectClearScreen) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectClearScreen");
static_assert(sizeof(UBtlGuiDrawObjectClearScreen) == 0x000060, "Wrong size on UBtlGuiDrawObjectClearScreen");
static_assert(offsetof(UBtlGuiDrawObjectClearScreen, Color) == 0x000058, "Member 'UBtlGuiDrawObjectClearScreen::Color' has a wrong offset!");
static_assert(offsetof(UBtlGuiDrawObjectClearScreen, OT) == 0x00005C, "Member 'UBtlGuiDrawObjectClearScreen::OT' has a wrong offset!");

// Class xrd777.FldDungeonLayoutBrokenActor
// 0x0008 (0x02A0 - 0x0298)
class AFldDungeonLayoutBrokenActor final : public AFldDungeonLayoutActor
{
public:
	bool                                          Empty;                                             // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Probability;                                       // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutBrokenActor">();
	}
	static class AFldDungeonLayoutBrokenActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutBrokenActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutBrokenActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutBrokenActor");
static_assert(sizeof(AFldDungeonLayoutBrokenActor) == 0x0002A0, "Wrong size on AFldDungeonLayoutBrokenActor");
static_assert(offsetof(AFldDungeonLayoutBrokenActor, Empty) == 0x000298, "Member 'AFldDungeonLayoutBrokenActor::Empty' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutBrokenActor, Probability) == 0x00029C, "Member 'AFldDungeonLayoutBrokenActor::Probability' has a wrong offset!");

// Class xrd777.TestMultiDraw
// 0x00B8 (0x02D8 - 0x0220)
class ATestMultiDraw final : public AActor
{
public:
	class UTexture*                               baseTex;                                           // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               baseMultiBaseTex;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               baseMultiTex;                                      // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               MaskTex;                                           // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              MpMultiplyTestSpr;                                 // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MAT;                                               // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              Mat2;                                              // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MTestMID2D;                                        // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              MTestMIC2D;                                        // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupEye_00;                                      // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupEye_01;                                      // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupMouth_00;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupMouth_01;                                    // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupSdw_00;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupSdw_01;                                      // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupEye_mask;                                    // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupMouth_mask;                                  // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DrawableMaterial;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               bustupBase;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestMultiDraw">();
	}
	static class ATestMultiDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestMultiDraw>();
	}
};
static_assert(alignof(ATestMultiDraw) == 0x000008, "Wrong alignment on ATestMultiDraw");
static_assert(sizeof(ATestMultiDraw) == 0x0002D8, "Wrong size on ATestMultiDraw");
static_assert(offsetof(ATestMultiDraw, baseTex) == 0x000220, "Member 'ATestMultiDraw::baseTex' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, baseMultiBaseTex) == 0x000228, "Member 'ATestMultiDraw::baseMultiBaseTex' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, baseMultiTex) == 0x000230, "Member 'ATestMultiDraw::baseMultiTex' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, MaskTex) == 0x000238, "Member 'ATestMultiDraw::MaskTex' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, MpMultiplyTestSpr) == 0x000240, "Member 'ATestMultiDraw::MpMultiplyTestSpr' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, MAT) == 0x000248, "Member 'ATestMultiDraw::MAT' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, Mat2) == 0x000250, "Member 'ATestMultiDraw::Mat2' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, MTestMID2D) == 0x000258, "Member 'ATestMultiDraw::MTestMID2D' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, MTestMIC2D) == 0x000268, "Member 'ATestMultiDraw::MTestMIC2D' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupEye_00) == 0x000270, "Member 'ATestMultiDraw::bustupEye_00' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupEye_01) == 0x000278, "Member 'ATestMultiDraw::bustupEye_01' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupMouth_00) == 0x000280, "Member 'ATestMultiDraw::bustupMouth_00' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupMouth_01) == 0x000288, "Member 'ATestMultiDraw::bustupMouth_01' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupSdw_00) == 0x000290, "Member 'ATestMultiDraw::bustupSdw_00' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupSdw_01) == 0x000298, "Member 'ATestMultiDraw::bustupSdw_01' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupEye_mask) == 0x0002A0, "Member 'ATestMultiDraw::bustupEye_mask' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupMouth_mask) == 0x0002A8, "Member 'ATestMultiDraw::bustupMouth_mask' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, DrawableMaterial) == 0x0002C8, "Member 'ATestMultiDraw::DrawableMaterial' has a wrong offset!");
static_assert(offsetof(ATestMultiDraw, bustupBase) == 0x0002D0, "Member 'ATestMultiDraw::bustupBase' has a wrong offset!");

// Class xrd777.FclAntiqueShop
// 0x0178 (0x0538 - 0x03C0)
class AFclAntiqueShop final : public AFclShopBase
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAntiqueShopLineUpListTable*            LineupTable_;                                      // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               BfAsset_;                                          // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset_;                                         // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _ComSpr00;                                         // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _ComSpr00_Astrea;                                  // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              _ComPlg00;                                         // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _Spr00;                                            // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              _Plg00;                                            // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataAntique;                           // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AFclAntiqueShopDrawActor>   _DrawActorClass;                                   // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFclAntiqueShopDrawActor*               _DrawActor;                                        // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x48];                                     // 0x0420(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TextColLayoutData;                                 // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextColLayoutDataTable;                            // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0xB0];                                     // 0x0488(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclAntiqueShop">();
	}
	static class AFclAntiqueShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclAntiqueShop>();
	}
};
static_assert(alignof(AFclAntiqueShop) == 0x000008, "Wrong alignment on AFclAntiqueShop");
static_assert(sizeof(AFclAntiqueShop) == 0x000538, "Wrong size on AFclAntiqueShop");
static_assert(offsetof(AFclAntiqueShop, Loader_) == 0x0003C0, "Member 'AFclAntiqueShop::Loader_' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, LineupTable_) == 0x0003C8, "Member 'AFclAntiqueShop::LineupTable_' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, BfAsset_) == 0x0003D0, "Member 'AFclAntiqueShop::BfAsset_' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, BmdAsset_) == 0x0003D8, "Member 'AFclAntiqueShop::BmdAsset_' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _ComSpr00) == 0x0003E0, "Member 'AFclAntiqueShop::_ComSpr00' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _ComSpr00_Astrea) == 0x0003E8, "Member 'AFclAntiqueShop::_ComSpr00_Astrea' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _ComPlg00) == 0x0003F0, "Member 'AFclAntiqueShop::_ComPlg00' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _Spr00) == 0x0003F8, "Member 'AFclAntiqueShop::_Spr00' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _Plg00) == 0x000400, "Member 'AFclAntiqueShop::_Plg00' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, PParamLayoutDataAntique) == 0x000408, "Member 'AFclAntiqueShop::PParamLayoutDataAntique' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _DrawActorClass) == 0x000410, "Member 'AFclAntiqueShop::_DrawActorClass' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, _DrawActor) == 0x000418, "Member 'AFclAntiqueShop::_DrawActor' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, LayoutData) == 0x000468, "Member 'AFclAntiqueShop::LayoutData' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, TextColLayoutData) == 0x000470, "Member 'AFclAntiqueShop::TextColLayoutData' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, LayoutDataTable) == 0x000478, "Member 'AFclAntiqueShop::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AFclAntiqueShop, TextColLayoutDataTable) == 0x000480, "Member 'AFclAntiqueShop::TextColLayoutDataTable' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectImage
// 0x0078 (0x00D0 - 0x0058)
class UBtlGuiDrawObjectImage final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawImage                       Data;                                              // 0x0060(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void GetWidthHeight(float* Width, float* Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectImage">();
	}
	static class UBtlGuiDrawObjectImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectImage>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectImage) == 0x000010, "Wrong alignment on UBtlGuiDrawObjectImage");
static_assert(sizeof(UBtlGuiDrawObjectImage) == 0x0000D0, "Wrong size on UBtlGuiDrawObjectImage");
static_assert(offsetof(UBtlGuiDrawObjectImage, Data) == 0x000060, "Member 'UBtlGuiDrawObjectImage::Data' has a wrong offset!");

// Class xrd777.FldDungeonPartActor
// 0x0150 (0x03C8 - 0x0278)
class AFldDungeonPartActor : public AAppActor
{
public:
	EPartType                                     PartType;                                          // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PartVariation;                                     // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPartDirType                                  PartDirType;                                       // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForbiddenDoor;                                     // 0x0281(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MonadPassage;                                      // 0x0282(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExclusivelyForEvent;                               // 0x0283(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x54];                                     // 0x0284(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldDungeonLayoutActor*>         M_LayoutActor;                                     // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutStartActor*>    M_pLayoutStart;                                    // 0x02E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_pLayoutEnemy;                                    // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_LayoutEnemyPath;                                 // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_LayoutTBox;                                      // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutRetDev;                                   // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonLayoutActor*                 M_pLayoutNPC;                                      // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutReaper;                                   // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutClock;                                    // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutSecretGate;                               // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldDungeonObjectInfoActor*>     M_ObjectInfoActor;                                 // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         M_pSKMeshComps;                                    // 0x0388(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                M_pLightComps;                                     // 0x0398(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x20];                                     // 0x03A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonPartActor">();
	}
	static class AFldDungeonPartActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonPartActor>();
	}
};
static_assert(alignof(AFldDungeonPartActor) == 0x000008, "Wrong alignment on AFldDungeonPartActor");
static_assert(sizeof(AFldDungeonPartActor) == 0x0003C8, "Wrong size on AFldDungeonPartActor");
static_assert(offsetof(AFldDungeonPartActor, PartType) == 0x000278, "Member 'AFldDungeonPartActor::PartType' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, PartVariation) == 0x00027C, "Member 'AFldDungeonPartActor::PartVariation' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, PartDirType) == 0x000280, "Member 'AFldDungeonPartActor::PartDirType' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, ForbiddenDoor) == 0x000281, "Member 'AFldDungeonPartActor::ForbiddenDoor' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, MonadPassage) == 0x000282, "Member 'AFldDungeonPartActor::MonadPassage' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, ExclusivelyForEvent) == 0x000283, "Member 'AFldDungeonPartActor::ExclusivelyForEvent' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_LayoutActor) == 0x0002D8, "Member 'AFldDungeonPartActor::M_LayoutActor' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutStart) == 0x0002E8, "Member 'AFldDungeonPartActor::M_pLayoutStart' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutEnemy) == 0x0002F8, "Member 'AFldDungeonPartActor::M_pLayoutEnemy' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_LayoutEnemyPath) == 0x000308, "Member 'AFldDungeonPartActor::M_LayoutEnemyPath' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_LayoutTBox) == 0x000318, "Member 'AFldDungeonPartActor::M_LayoutTBox' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutRetDev) == 0x000328, "Member 'AFldDungeonPartActor::M_pLayoutRetDev' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutNPC) == 0x000338, "Member 'AFldDungeonPartActor::M_pLayoutNPC' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutReaper) == 0x000340, "Member 'AFldDungeonPartActor::M_pLayoutReaper' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutClock) == 0x000348, "Member 'AFldDungeonPartActor::M_pLayoutClock' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLayoutSecretGate) == 0x000350, "Member 'AFldDungeonPartActor::M_pLayoutSecretGate' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_ObjectInfoActor) == 0x000370, "Member 'AFldDungeonPartActor::M_ObjectInfoActor' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pSKMeshComps) == 0x000388, "Member 'AFldDungeonPartActor::M_pSKMeshComps' has a wrong offset!");
static_assert(offsetof(AFldDungeonPartActor, M_pLightComps) == 0x000398, "Member 'AFldDungeonPartActor::M_pLightComps' has a wrong offset!");

// Class xrd777.FldDungeonFDoorPartActor
// 0x0008 (0x03D0 - 0x03C8)
class AFldDungeonFDoorPartActor final : public AFldDungeonPartActor
{
public:
	int32                                         FDoorGroupNum;                                     // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonFDoorPartActor">();
	}
	static class AFldDungeonFDoorPartActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonFDoorPartActor>();
	}
};
static_assert(alignof(AFldDungeonFDoorPartActor) == 0x000008, "Wrong alignment on AFldDungeonFDoorPartActor");
static_assert(sizeof(AFldDungeonFDoorPartActor) == 0x0003D0, "Wrong size on AFldDungeonFDoorPartActor");
static_assert(offsetof(AFldDungeonFDoorPartActor, FDoorGroupNum) == 0x0003C8, "Member 'AFldDungeonFDoorPartActor::FDoorGroupNum' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectPanel
// 0x0040 (0x0098 - 0x0058)
class UBtlGuiDrawObjectPanel final : public UBtlGuiDrawObjectCore
{
public:
	struct FBtlGuiDrawPanel                       Data;                                              // 0x0058(0x003C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectPanel">();
	}
	static class UBtlGuiDrawObjectPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectPanel>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectPanel) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectPanel");
static_assert(sizeof(UBtlGuiDrawObjectPanel) == 0x000098, "Wrong size on UBtlGuiDrawObjectPanel");
static_assert(offsetof(UBtlGuiDrawObjectPanel, Data) == 0x000058, "Member 'UBtlGuiDrawObjectPanel::Data' has a wrong offset!");

// Class xrd777.TitleCharaBase
// 0x0010 (0x0230 - 0x0220)
class ATitleCharaBase final : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 CharaMesh;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeAnimationEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleCharaBase">();
	}
	static class ATitleCharaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATitleCharaBase>();
	}
};
static_assert(alignof(ATitleCharaBase) == 0x000008, "Wrong alignment on ATitleCharaBase");
static_assert(sizeof(ATitleCharaBase) == 0x000230, "Wrong size on ATitleCharaBase");
static_assert(offsetof(ATitleCharaBase, Root) == 0x000220, "Member 'ATitleCharaBase::Root' has a wrong offset!");
static_assert(offsetof(ATitleCharaBase, CharaMesh) == 0x000228, "Member 'ATitleCharaBase::CharaMesh' has a wrong offset!");

// Class xrd777.HolidayEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class UHolidayEventDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FHolidayEventDataTable>         Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HolidayEventDataAsset">();
	}
	static class UHolidayEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHolidayEventDataAsset>();
	}
};
static_assert(alignof(UHolidayEventDataAsset) == 0x000008, "Wrong alignment on UHolidayEventDataAsset");
static_assert(sizeof(UHolidayEventDataAsset) == 0x000040, "Wrong size on UHolidayEventDataAsset");
static_assert(offsetof(UHolidayEventDataAsset, Tables) == 0x000030, "Member 'UHolidayEventDataAsset::Tables' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectText
// 0x0060 (0x00B8 - 0x0058)
class UBtlGuiDrawObjectText final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawText                        Data;                                              // 0x0060(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void ApplyFontStyleMakeOffset();
	void CalcAdjustedScale(const struct FBtlGuiDrawText& Item, const struct FVector2D& TextCollision, bool ScalingOnlyX, struct FVector2D* AdjustedScale);
	void GetTextWidthHeight(float* Width, float* Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectText">();
	}
	static class UBtlGuiDrawObjectText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectText>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectText) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectText");
static_assert(sizeof(UBtlGuiDrawObjectText) == 0x0000B8, "Wrong size on UBtlGuiDrawObjectText");
static_assert(offsetof(UBtlGuiDrawObjectText, Data) == 0x000060, "Member 'UBtlGuiDrawObjectText::Data' has a wrong offset!");

// Class xrd777.TitleStateSelect
// 0x0078 (0x00B0 - 0x0038)
class UTitleStateSelect final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIKeyHelpDraw*                         KeyHelpUI;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ALocalizeStaffRoll*                     StaffRoll;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAddContent*                            AddContentCheck;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateSelect">();
	}
	static class UTitleStateSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateSelect>();
	}
};
static_assert(alignof(UTitleStateSelect) == 0x000008, "Wrong alignment on UTitleStateSelect");
static_assert(sizeof(UTitleStateSelect) == 0x0000B0, "Wrong size on UTitleStateSelect");
static_assert(offsetof(UTitleStateSelect, KeyHelpUI) == 0x000050, "Member 'UTitleStateSelect::KeyHelpUI' has a wrong offset!");
static_assert(offsetof(UTitleStateSelect, StaffRoll) == 0x000068, "Member 'UTitleStateSelect::StaffRoll' has a wrong offset!");
static_assert(offsetof(UTitleStateSelect, AddContentCheck) == 0x000070, "Member 'UTitleStateSelect::AddContentCheck' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectMsg
// 0x0088 (0x00E0 - 0x0058)
class UBtlGuiDrawObjectMsg final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawMsg                         Data;                                              // 0x0060(0x0080)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void CalcAdjustedScale(const struct FBtlGuiDrawMsg& Item, const struct FVector2D& TextCollision, struct FVector2D* AdjustedScale, float* LineBreak, bool OnKeepScale);
	void CalcAdjustedScaleOnlyX(const struct FBtlGuiDrawMsg& Item, const struct FVector2D& TextCollision, struct FVector2D* AdjustedScale);
	void GetMsgWindowLength(float* Width, float* Height);
	void ReCreateMsgInfo();
	void ResetBmd();
	void SetItemHelpMsg(int32 ItemId);
	void SetSkillHelpMsg();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectMsg">();
	}
	static class UBtlGuiDrawObjectMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectMsg>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectMsg) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectMsg");
static_assert(sizeof(UBtlGuiDrawObjectMsg) == 0x0000E0, "Wrong size on UBtlGuiDrawObjectMsg");
static_assert(offsetof(UBtlGuiDrawObjectMsg, Data) == 0x000060, "Member 'UBtlGuiDrawObjectMsg::Data' has a wrong offset!");

// Class xrd777.CmpMainActor
// 0x2F68 (0x31E0 - 0x0278)
class ACmpMainActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x1050];                                   // 0x0278(0x1050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x12C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACampSceneCapture>          SceneCaptureClass;                                 // 0x12D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACampSceneCapture*                      PSceneCapture2D;                                   // 0x12D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      PCaptureMaterial;                                  // 0x12E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PCaptureInstanceDynamic;                           // 0x12E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      POutlineMaterial;                                  // 0x12F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               POutlineInstanceDynamic;                           // 0x12F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              PSimpleCopyMaterial;                               // 0x1300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PSimpleCopyMateDynamic;                            // 0x1308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              PHologramMaterial;                                 // 0x1310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PHologramMateDynamic;                              // 0x1318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HologMaskTexAAry;                                  // 0x1320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HologMaskTexBAry;                                  // 0x1328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HologMaskTexCAry;                                  // 0x1330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HologMaskTexDAry;                                  // 0x1338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1340[0x8];                                     // 0x1340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PGlassMateDynamic;                                 // 0x1348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 PCaptureRenderTarget;                              // 0x1350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HeroGaussMaskTexAry[0xB];                          // 0x1358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             POutAnimationTexture;                              // 0x13B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              PSprCommon;                                        // 0x13B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimBgAry[0x2];                                    // 0x13C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamHologTable;                                  // 0x13D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamTopTable;                                    // 0x13D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamSkillTable;                                  // 0x13E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamItemTable;                                   // 0x13E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamEquipTable;                                  // 0x13F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamPersonaTable;                                // 0x13F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamStatusTable;                                 // 0x1400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamRankUpTable;                                 // 0x1408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamCommuTable;                                  // 0x1410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamSystemTable;                                 // 0x1418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamCommonTable;                                 // 0x1420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PCameraTable;                                      // 0x1428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PHologramTable;                                    // 0x1430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PCharaLookAdjustTable;                             // 0x1438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           PCharaLookAdjustMPC;                               // 0x1440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              PMateWaveCaustics;                                 // 0x1448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGetUIParameter                        M_SlashColorParameter;                             // 0x1450(0x0078)(NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataRoot;                              // 0x14C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSystem;                            // 0x14D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamTriangularCursorDataRoot;                    // 0x14D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamTriangularCursorDataSystem;                  // 0x14E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuest;                             // 0x14E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuestDate;                         // 0x14F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutPersonaList;                           // 0x14F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataItem;                              // 0x1500(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSkill;                             // 0x1508(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSkill2;                            // 0x1510(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataOthers;                            // 0x1518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataOthersAstrea;                      // 0x1520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataHelpOthers;                        // 0x1528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataPartyPanel;                        // 0x1530(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataTutorialText;                      // 0x1538(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataDictionaryText;                    // 0x1540(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCalendarText;                      // 0x1548(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataEquipTextCol;                      // 0x1550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataItemTextCol;                       // 0x1558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuestTextCol;                      // 0x1560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuestTextPos;                      // 0x1568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuestTextPosAstrea;                // 0x1570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataQuestTextColAstrea;                // 0x1578(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCommuTextCol;                      // 0x1580(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataStatusTextCol;                     // 0x1588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataOkNext;                            // 0x1590(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataOkNextMask;                        // 0x1598(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataRootTouchColl;                     // 0x15A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSystemTouchColl;                   // 0x15A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiRootAAry[0x1E];                            // 0x15B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiRootBAry[0x1E];                            // 0x16A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiSkillAAry[0x1E];                           // 0x1790(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiSkillBAry[0x1E];                           // 0x1880(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiItemAAry[0x1E];                            // 0x1970(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiItemBAry[0x1E];                            // 0x1A60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiEquipAAry[0x1E];                           // 0x1B50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiEquipBAry[0x1E];                           // 0x1C40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiPersonaAAry[0x1E];                         // 0x1D30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiPersonaBAry[0x1E];                         // 0x1E20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiStatusAAry[0x1E];                          // 0x1F10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiStatusBAry[0x1E];                          // 0x2000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiQuestAAry[0x1E];                           // 0x20F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiQuestBAry[0x1E];                           // 0x21E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiCommuAAry[0x1E];                           // 0x22D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiCommuBAry[0x1E];                           // 0x23C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiCalendarAAry[0x1E];                        // 0x24B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiCalendarBAry[0x1E];                        // 0x25A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiSystemAAry[0x1E];                          // 0x2690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiSystemBAry[0x1E];                          // 0x2780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiTutorialAAry[0x1E];                        // 0x2870(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiTutorialBAry[0x1E];                        // 0x2960(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiConfigAAry[0x1E];                          // 0x2A50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimNamiConfigBAry[0x1E];                          // 0x2B40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             PCharaGlassAry[0xC];                               // 0x2C30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             PCharaDetailAry[0xC];                              // 0x2C90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             PCharaDetailShdAry[0xC];                           // 0x2CF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D50[0x20];                                    // 0x2D50(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCmpMenuBase*>                   MenuList;                                          // 0x2D70(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D80[0x8];                                     // 0x2D80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpMenuBase*                           PCurrentMenu;                                      // 0x2D88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpMenuBase*                           PNextMenu;                                         // 0x2D90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpMenuBase*                           PPrevMenu;                                         // 0x2D98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCampModelController*                   PModelController;                                  // 0x2DA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainLoadActor*                      PCmpMainLoadActor;                                 // 0x2DA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DB0[0x8];                                     // 0x2DB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacter>                 PHeroCharaClass;                                   // 0x2DB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppAnimCtrl*                           PHeroAnimCtrl;                                     // 0x2DC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             MateInterAry;                                      // 0x2DC8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsDisableForceTermination;                        // 0x2DD8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD9[0x1];                                     // 0x2DD9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEquipChange;                                      // 0x2DDA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReturnCommuToField;                               // 0x2DDB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DDC[0x4];                                     // 0x2DDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIRequest*                             PUIRequest;                                        // 0x2DE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMissingPerson*                       PUIMissingPerson;                                  // 0x2DE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITheurgia*                            PUITheurgia;                                       // 0x2DF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DF8[0x308];                                   // 0x2DF8(0x0308)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     RootLayoutDataTable;                               // 0x3100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SystemLayoutDataTable;                             // 0x3108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestLayoutDataTable;                              // 0x3110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestDateLayoutDataTable;                          // 0x3118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OthersLayoutDataTable;                             // 0x3120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OthersLayoutDataTableAstrea;                       // 0x3128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     HelpOthersLayoutDataTable;                         // 0x3130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PersonaListLayoutDataTable;                        // 0x3138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     ItemLayoutDataTable;                               // 0x3140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SkillLayoutDataTable;                              // 0x3148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SkillLayoutDataTable2;                             // 0x3150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PartyPanelLayoutDataTable;                         // 0x3158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TutorialTextLayoutDataTable;                       // 0x3160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     DictionaryTextLayoutDataTable;                     // 0x3168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CalendarTextLayoutDataTable;                       // 0x3170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     EquipTextColLayoutDataTable;                       // 0x3178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     ItemTextColLayoutDataTable;                        // 0x3180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestTextColLayoutDataTable;                       // 0x3188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestTextPosLayoutDataTable;                       // 0x3190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestTextPosLayoutDataTableAstrea;                 // 0x3198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     QuestTextColLayoutDataTableAstrea;                 // 0x31A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CommuTextColLayoutDataTable;                       // 0x31A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     StatusTextColLayoutDataTable;                      // 0x31B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x31B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x31C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     RootTouchCollLayoutDataTable;                      // 0x31C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SystemTouchCollLayoutDataTable;                    // 0x31D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D8[0x8];                                     // 0x31D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpMainActor">();
	}
	static class ACmpMainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACmpMainActor>();
	}
};
static_assert(alignof(ACmpMainActor) == 0x000008, "Wrong alignment on ACmpMainActor");
static_assert(sizeof(ACmpMainActor) == 0x0031E0, "Wrong size on ACmpMainActor");
static_assert(offsetof(ACmpMainActor, PAssetLoader) == 0x0012C8, "Member 'ACmpMainActor::PAssetLoader' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, SceneCaptureClass) == 0x0012D0, "Member 'ACmpMainActor::SceneCaptureClass' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PSceneCapture2D) == 0x0012D8, "Member 'ACmpMainActor::PSceneCapture2D' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCaptureMaterial) == 0x0012E0, "Member 'ACmpMainActor::PCaptureMaterial' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCaptureInstanceDynamic) == 0x0012E8, "Member 'ACmpMainActor::PCaptureInstanceDynamic' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, POutlineMaterial) == 0x0012F0, "Member 'ACmpMainActor::POutlineMaterial' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, POutlineInstanceDynamic) == 0x0012F8, "Member 'ACmpMainActor::POutlineInstanceDynamic' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PSimpleCopyMaterial) == 0x001300, "Member 'ACmpMainActor::PSimpleCopyMaterial' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PSimpleCopyMateDynamic) == 0x001308, "Member 'ACmpMainActor::PSimpleCopyMateDynamic' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PHologramMaterial) == 0x001310, "Member 'ACmpMainActor::PHologramMaterial' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PHologramMateDynamic) == 0x001318, "Member 'ACmpMainActor::PHologramMateDynamic' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HologMaskTexAAry) == 0x001320, "Member 'ACmpMainActor::HologMaskTexAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HologMaskTexBAry) == 0x001328, "Member 'ACmpMainActor::HologMaskTexBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HologMaskTexCAry) == 0x001330, "Member 'ACmpMainActor::HologMaskTexCAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HologMaskTexDAry) == 0x001338, "Member 'ACmpMainActor::HologMaskTexDAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PGlassMateDynamic) == 0x001348, "Member 'ACmpMainActor::PGlassMateDynamic' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCaptureRenderTarget) == 0x001350, "Member 'ACmpMainActor::PCaptureRenderTarget' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HeroGaussMaskTexAry) == 0x001358, "Member 'ACmpMainActor::HeroGaussMaskTexAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, POutAnimationTexture) == 0x0013B0, "Member 'ACmpMainActor::POutAnimationTexture' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PSprCommon) == 0x0013B8, "Member 'ACmpMainActor::PSprCommon' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimBgAry) == 0x0013C0, "Member 'ACmpMainActor::PUimBgAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamHologTable) == 0x0013D0, "Member 'ACmpMainActor::PParamHologTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamTopTable) == 0x0013D8, "Member 'ACmpMainActor::PParamTopTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamSkillTable) == 0x0013E0, "Member 'ACmpMainActor::PParamSkillTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamItemTable) == 0x0013E8, "Member 'ACmpMainActor::PParamItemTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamEquipTable) == 0x0013F0, "Member 'ACmpMainActor::PParamEquipTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamPersonaTable) == 0x0013F8, "Member 'ACmpMainActor::PParamPersonaTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamStatusTable) == 0x001400, "Member 'ACmpMainActor::PParamStatusTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamRankUpTable) == 0x001408, "Member 'ACmpMainActor::PParamRankUpTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamCommuTable) == 0x001410, "Member 'ACmpMainActor::PParamCommuTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamSystemTable) == 0x001418, "Member 'ACmpMainActor::PParamSystemTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamCommonTable) == 0x001420, "Member 'ACmpMainActor::PParamCommonTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCameraTable) == 0x001428, "Member 'ACmpMainActor::PCameraTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PHologramTable) == 0x001430, "Member 'ACmpMainActor::PHologramTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCharaLookAdjustTable) == 0x001438, "Member 'ACmpMainActor::PCharaLookAdjustTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCharaLookAdjustMPC) == 0x001440, "Member 'ACmpMainActor::PCharaLookAdjustMPC' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PMateWaveCaustics) == 0x001448, "Member 'ACmpMainActor::PMateWaveCaustics' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, M_SlashColorParameter) == 0x001450, "Member 'ACmpMainActor::M_SlashColorParameter' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataRoot) == 0x0014C8, "Member 'ACmpMainActor::PParamLayoutDataRoot' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataSystem) == 0x0014D0, "Member 'ACmpMainActor::PParamLayoutDataSystem' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamTriangularCursorDataRoot) == 0x0014D8, "Member 'ACmpMainActor::PParamTriangularCursorDataRoot' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamTriangularCursorDataSystem) == 0x0014E0, "Member 'ACmpMainActor::PParamTriangularCursorDataSystem' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuest) == 0x0014E8, "Member 'ACmpMainActor::PParamLayoutDataQuest' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuestDate) == 0x0014F0, "Member 'ACmpMainActor::PParamLayoutDataQuestDate' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutPersonaList) == 0x0014F8, "Member 'ACmpMainActor::PParamLayoutPersonaList' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataItem) == 0x001500, "Member 'ACmpMainActor::PParamLayoutDataItem' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataSkill) == 0x001508, "Member 'ACmpMainActor::PParamLayoutDataSkill' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataSkill2) == 0x001510, "Member 'ACmpMainActor::PParamLayoutDataSkill2' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataOthers) == 0x001518, "Member 'ACmpMainActor::PParamLayoutDataOthers' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataOthersAstrea) == 0x001520, "Member 'ACmpMainActor::PParamLayoutDataOthersAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataHelpOthers) == 0x001528, "Member 'ACmpMainActor::PParamLayoutDataHelpOthers' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataPartyPanel) == 0x001530, "Member 'ACmpMainActor::PParamLayoutDataPartyPanel' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataTutorialText) == 0x001538, "Member 'ACmpMainActor::PParamLayoutDataTutorialText' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataDictionaryText) == 0x001540, "Member 'ACmpMainActor::PParamLayoutDataDictionaryText' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataCalendarText) == 0x001548, "Member 'ACmpMainActor::PParamLayoutDataCalendarText' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataEquipTextCol) == 0x001550, "Member 'ACmpMainActor::PParamLayoutDataEquipTextCol' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataItemTextCol) == 0x001558, "Member 'ACmpMainActor::PParamLayoutDataItemTextCol' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuestTextCol) == 0x001560, "Member 'ACmpMainActor::PParamLayoutDataQuestTextCol' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuestTextPos) == 0x001568, "Member 'ACmpMainActor::PParamLayoutDataQuestTextPos' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuestTextPosAstrea) == 0x001570, "Member 'ACmpMainActor::PParamLayoutDataQuestTextPosAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataQuestTextColAstrea) == 0x001578, "Member 'ACmpMainActor::PParamLayoutDataQuestTextColAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataCommuTextCol) == 0x001580, "Member 'ACmpMainActor::PParamLayoutDataCommuTextCol' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataStatusTextCol) == 0x001588, "Member 'ACmpMainActor::PParamLayoutDataStatusTextCol' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataOkNext) == 0x001590, "Member 'ACmpMainActor::PParamLayoutDataOkNext' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataOkNextMask) == 0x001598, "Member 'ACmpMainActor::PParamLayoutDataOkNextMask' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataRootTouchColl) == 0x0015A0, "Member 'ACmpMainActor::PParamLayoutDataRootTouchColl' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PParamLayoutDataSystemTouchColl) == 0x0015A8, "Member 'ACmpMainActor::PParamLayoutDataSystemTouchColl' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiRootAAry) == 0x0015B0, "Member 'ACmpMainActor::PUimNamiRootAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiRootBAry) == 0x0016A0, "Member 'ACmpMainActor::PUimNamiRootBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiSkillAAry) == 0x001790, "Member 'ACmpMainActor::PUimNamiSkillAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiSkillBAry) == 0x001880, "Member 'ACmpMainActor::PUimNamiSkillBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiItemAAry) == 0x001970, "Member 'ACmpMainActor::PUimNamiItemAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiItemBAry) == 0x001A60, "Member 'ACmpMainActor::PUimNamiItemBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiEquipAAry) == 0x001B50, "Member 'ACmpMainActor::PUimNamiEquipAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiEquipBAry) == 0x001C40, "Member 'ACmpMainActor::PUimNamiEquipBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiPersonaAAry) == 0x001D30, "Member 'ACmpMainActor::PUimNamiPersonaAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiPersonaBAry) == 0x001E20, "Member 'ACmpMainActor::PUimNamiPersonaBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiStatusAAry) == 0x001F10, "Member 'ACmpMainActor::PUimNamiStatusAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiStatusBAry) == 0x002000, "Member 'ACmpMainActor::PUimNamiStatusBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiQuestAAry) == 0x0020F0, "Member 'ACmpMainActor::PUimNamiQuestAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiQuestBAry) == 0x0021E0, "Member 'ACmpMainActor::PUimNamiQuestBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiCommuAAry) == 0x0022D0, "Member 'ACmpMainActor::PUimNamiCommuAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiCommuBAry) == 0x0023C0, "Member 'ACmpMainActor::PUimNamiCommuBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiCalendarAAry) == 0x0024B0, "Member 'ACmpMainActor::PUimNamiCalendarAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiCalendarBAry) == 0x0025A0, "Member 'ACmpMainActor::PUimNamiCalendarBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiSystemAAry) == 0x002690, "Member 'ACmpMainActor::PUimNamiSystemAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiSystemBAry) == 0x002780, "Member 'ACmpMainActor::PUimNamiSystemBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiTutorialAAry) == 0x002870, "Member 'ACmpMainActor::PUimNamiTutorialAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiTutorialBAry) == 0x002960, "Member 'ACmpMainActor::PUimNamiTutorialBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiConfigAAry) == 0x002A50, "Member 'ACmpMainActor::PUimNamiConfigAAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUimNamiConfigBAry) == 0x002B40, "Member 'ACmpMainActor::PUimNamiConfigBAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCharaGlassAry) == 0x002C30, "Member 'ACmpMainActor::PCharaGlassAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCharaDetailAry) == 0x002C90, "Member 'ACmpMainActor::PCharaDetailAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCharaDetailShdAry) == 0x002CF0, "Member 'ACmpMainActor::PCharaDetailShdAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, MenuList) == 0x002D70, "Member 'ACmpMainActor::MenuList' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCurrentMenu) == 0x002D88, "Member 'ACmpMainActor::PCurrentMenu' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PNextMenu) == 0x002D90, "Member 'ACmpMainActor::PNextMenu' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PPrevMenu) == 0x002D98, "Member 'ACmpMainActor::PPrevMenu' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PModelController) == 0x002DA0, "Member 'ACmpMainActor::PModelController' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PCmpMainLoadActor) == 0x002DA8, "Member 'ACmpMainActor::PCmpMainLoadActor' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PHeroCharaClass) == 0x002DB8, "Member 'ACmpMainActor::PHeroCharaClass' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PHeroAnimCtrl) == 0x002DC0, "Member 'ACmpMainActor::PHeroAnimCtrl' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, MateInterAry) == 0x002DC8, "Member 'ACmpMainActor::MateInterAry' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, bIsDisableForceTermination) == 0x002DD8, "Member 'ACmpMainActor::bIsDisableForceTermination' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, bEquipChange) == 0x002DDA, "Member 'ACmpMainActor::bEquipChange' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, bReturnCommuToField) == 0x002DDB, "Member 'ACmpMainActor::bReturnCommuToField' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUIRequest) == 0x002DE0, "Member 'ACmpMainActor::PUIRequest' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUIMissingPerson) == 0x002DE8, "Member 'ACmpMainActor::PUIMissingPerson' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PUITheurgia) == 0x002DF0, "Member 'ACmpMainActor::PUITheurgia' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, RootLayoutDataTable) == 0x003100, "Member 'ACmpMainActor::RootLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, SystemLayoutDataTable) == 0x003108, "Member 'ACmpMainActor::SystemLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestLayoutDataTable) == 0x003110, "Member 'ACmpMainActor::QuestLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestDateLayoutDataTable) == 0x003118, "Member 'ACmpMainActor::QuestDateLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, OthersLayoutDataTable) == 0x003120, "Member 'ACmpMainActor::OthersLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, OthersLayoutDataTableAstrea) == 0x003128, "Member 'ACmpMainActor::OthersLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, HelpOthersLayoutDataTable) == 0x003130, "Member 'ACmpMainActor::HelpOthersLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PersonaListLayoutDataTable) == 0x003138, "Member 'ACmpMainActor::PersonaListLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, ItemLayoutDataTable) == 0x003140, "Member 'ACmpMainActor::ItemLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, SkillLayoutDataTable) == 0x003148, "Member 'ACmpMainActor::SkillLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, SkillLayoutDataTable2) == 0x003150, "Member 'ACmpMainActor::SkillLayoutDataTable2' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, PartyPanelLayoutDataTable) == 0x003158, "Member 'ACmpMainActor::PartyPanelLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, TutorialTextLayoutDataTable) == 0x003160, "Member 'ACmpMainActor::TutorialTextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, DictionaryTextLayoutDataTable) == 0x003168, "Member 'ACmpMainActor::DictionaryTextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, CalendarTextLayoutDataTable) == 0x003170, "Member 'ACmpMainActor::CalendarTextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, EquipTextColLayoutDataTable) == 0x003178, "Member 'ACmpMainActor::EquipTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, ItemTextColLayoutDataTable) == 0x003180, "Member 'ACmpMainActor::ItemTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestTextColLayoutDataTable) == 0x003188, "Member 'ACmpMainActor::QuestTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestTextPosLayoutDataTable) == 0x003190, "Member 'ACmpMainActor::QuestTextPosLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestTextPosLayoutDataTableAstrea) == 0x003198, "Member 'ACmpMainActor::QuestTextPosLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, QuestTextColLayoutDataTableAstrea) == 0x0031A0, "Member 'ACmpMainActor::QuestTextColLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, CommuTextColLayoutDataTable) == 0x0031A8, "Member 'ACmpMainActor::CommuTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, StatusTextColLayoutDataTable) == 0x0031B0, "Member 'ACmpMainActor::StatusTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, OkNextLayoutDataTable) == 0x0031B8, "Member 'ACmpMainActor::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, OkNextMaskLayoutDataTable) == 0x0031C0, "Member 'ACmpMainActor::OkNextMaskLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, RootTouchCollLayoutDataTable) == 0x0031C8, "Member 'ACmpMainActor::RootTouchCollLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ACmpMainActor, SystemTouchCollLayoutDataTable) == 0x0031D0, "Member 'ACmpMainActor::SystemTouchCollLayoutDataTable' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectRect
// 0x0078 (0x00D0 - 0x0058)
class UBtlGuiDrawObjectRect final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawRect                        Data;                                              // 0x0080(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnEnableTouchCollision(bool OnEnable);
	void SetListTouchCollision(EBtlTouchScreenID ScreenID, int32 Idx, float AdjustX, float AdjustY, float AdjustAngle, float AdjustW, float AdjustH, int32 AddLayer);
	void SetScrollBarTouchCollision(EBtlTouchScreenID ScreenID, float AdjustX, float AdjustY, float AdjustAngle, float AdjustW, float AdjustH, bool OnSlider);
	void SetTouchCollision(EBtlTouchCallbackValue CallbackValue, float AdjustX, float AdjustY, float AdjustAngle, float AdjustW, float AdjustH, int32 AddLayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectRect">();
	}
	static class UBtlGuiDrawObjectRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectRect>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectRect) == 0x000010, "Wrong alignment on UBtlGuiDrawObjectRect");
static_assert(sizeof(UBtlGuiDrawObjectRect) == 0x0000D0, "Wrong size on UBtlGuiDrawObjectRect");
static_assert(offsetof(UBtlGuiDrawObjectRect, Data) == 0x000080, "Member 'UBtlGuiDrawObjectRect::Data' has a wrong offset!");

// Class xrd777.TitleStateOP
// 0x0018 (0x0050 - 0x0038)
class UTitleStateOP final : public UTitleStateBase
{
public:
	class AMoviePlayActor*                        MovieActor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateOP">();
	}
	static class UTitleStateOP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateOP>();
	}
};
static_assert(alignof(UTitleStateOP) == 0x000008, "Wrong alignment on UTitleStateOP");
static_assert(sizeof(UTitleStateOP) == 0x000050, "Wrong size on UTitleStateOP");
static_assert(offsetof(UTitleStateOP, MovieActor) == 0x000038, "Member 'UTitleStateOP::MovieActor' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectSprite
// 0x0080 (0x00D8 - 0x0058)
class UBtlGuiDrawObjectSprite final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x30];                                      // 0x0058(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawSprite                      Data;                                              // 0x0088(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void GetWidthHeight(float* Width, float* Height);
	void OnEnableTouchCollision(bool OnEnable);
	void SetListTouchCollision(EBtlTouchScreenID ScreenID, int32 Idx, float AdjustX, float AdjustY, float AdjustAngle, float AdjustW, float AdjustH, int32 AddLayer);
	void SetTouchCollision(EBtlTouchCallbackValue CallbackValue, float AdjustX, float AdjustY, float AdjustAngle, float AdjustW, float AdjustH, int32 AddLayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectSprite">();
	}
	static class UBtlGuiDrawObjectSprite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectSprite>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectSprite) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectSprite");
static_assert(sizeof(UBtlGuiDrawObjectSprite) == 0x0000D8, "Wrong size on UBtlGuiDrawObjectSprite");
static_assert(offsetof(UBtlGuiDrawObjectSprite, Data) == 0x000088, "Member 'UBtlGuiDrawObjectSprite::Data' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectMaterial
// 0x0068 (0x00C0 - 0x0058)
class UBtlGuiDrawObjectMaterial final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawMaterial                    Data;                                              // 0x0060(0x0060)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectMaterial">();
	}
	static class UBtlGuiDrawObjectMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectMaterial>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectMaterial) == 0x000010, "Wrong alignment on UBtlGuiDrawObjectMaterial");
static_assert(sizeof(UBtlGuiDrawObjectMaterial) == 0x0000C0, "Wrong size on UBtlGuiDrawObjectMaterial");
static_assert(offsetof(UBtlGuiDrawObjectMaterial, Data) == 0x000060, "Member 'UBtlGuiDrawObjectMaterial::Data' has a wrong offset!");

// Class xrd777.DatPlayerLastNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatPlayerLastNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPlayerNameOne>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerLastNameTable">();
	}
	static class UDatPlayerLastNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerLastNameTable>();
	}
};
static_assert(alignof(UDatPlayerLastNameTable) == 0x000008, "Wrong alignment on UDatPlayerLastNameTable");
static_assert(sizeof(UDatPlayerLastNameTable) == 0x000040, "Wrong size on UDatPlayerLastNameTable");
static_assert(offsetof(UDatPlayerLastNameTable, Data) == 0x000030, "Member 'UDatPlayerLastNameTable::Data' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectPlg
// 0x0048 (0x00A0 - 0x0058)
class UBtlGuiDrawObjectPlg final : public UBtlGuiDrawObjectCore
{
public:
	struct FBtlGuiDrawPlg                         Data;                                              // 0x0058(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	struct FVector2D GetSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectPlg">();
	}
	static class UBtlGuiDrawObjectPlg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectPlg>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectPlg) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectPlg");
static_assert(sizeof(UBtlGuiDrawObjectPlg) == 0x0000A0, "Wrong size on UBtlGuiDrawObjectPlg");
static_assert(offsetof(UBtlGuiDrawObjectPlg, Data) == 0x000058, "Member 'UBtlGuiDrawObjectPlg::Data' has a wrong offset!");

// Class xrd777.TheurgiaDraw
// 0x0020 (0x02D8 - 0x02B8)
class ATheurgiaDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseSkillHelp();
	void DrawCharacteristicHelp(float X, float Y);
	void DrawCharacteristicName(float X, float Y);
	void DrawCharaName(float X, float Y);
	void DrawRiseTrend(float X, float Y);
	void DrawTheurgiaHelp(float X, float Y, int32 Index_0);
	void DrawTheurgiaName(float X, float Y, int32 Index_0);
	void OpenSkillHelp();
	void SetCurrsorIndex(int32 No);
	void UpdateTimes(const float DeltaTime);

	int32 GetTheurgiaCursorIndex() const;
	int32 GetTheurgiaListMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheurgiaDraw">();
	}
	static class ATheurgiaDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATheurgiaDraw>();
	}
};
static_assert(alignof(ATheurgiaDraw) == 0x000008, "Wrong alignment on ATheurgiaDraw");
static_assert(sizeof(ATheurgiaDraw) == 0x0002D8, "Wrong size on ATheurgiaDraw");

// Class xrd777.FclWeaponShopDrawActor
// 0x0820 (0x0AC0 - 0x02A0)
class AFclWeaponShopDrawActor final : public AFclWeaponShopDrawActorBase
{
public:
	uint8                                         Pad_2A0[0x38];                                     // 0x02A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponShopDrawCommon*                  _CommonData;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _BgColor;                                          // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 _InfoWindowInnerColor;                             // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuAnim;                                      // 0x02E8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CatIconAnim;                                      // 0x0330(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TapeAnim;                                         // 0x0378(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TapeChangeAnim;                                   // 0x03C0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _EquipCompareTapeAnim;                             // 0x0408(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListCursorBaseInAnim;                             // 0x0450(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListCursorInAnim;                                 // 0x0498(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListTriangleCursorInAnim;                         // 0x04E0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListTriangleCursorLoopAnim;                       // 0x0528(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _LRCursorLoopAnim;                                 // 0x0570(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _LRCursorInputAnim;                                // 0x05B8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _UDCursorLoopAnim;                                 // 0x0600(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _UDCursorInputAnim;                                // 0x0648(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _RevolverAnim;                                     // 0x0690(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponShopAnimParam>           _DecideConfirmPanelAnimArray;                      // 0x06D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponShopAnimParam>           _NumConfirmPanelAnimArray;                         // 0x06E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponShopAnimParam>           _MoneyWindowAnimArray;                             // 0x06F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _EquipCompareInAnim;                               // 0x0708(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _EquipCompareOutAnim;                              // 0x0750(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ParamUpDownAnim;                                  // 0x0798(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponShopAnimParam>           _PicUpAnimArray;                                   // 0x07E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _SellListCursorBaseInAnim;                         // 0x07F0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _SellListCursorInAnim;                             // 0x0838(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ParamUpDownLoopAnim;                              // 0x0880(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _ListInAnim;                                       // 0x08C8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CharaEquipListInAnim;                             // 0x0910(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TopMenuOutAnim;                                   // 0x0958(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CatIconOutAnim;                                   // 0x09A0(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _TapeOutAnim;                                      // 0x09E8(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _CharaListCursorInAnim;                            // 0x0A30(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponShopAnimParam                   _SellInfoInAnim;                                   // 0x0A78(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	void EventMcaCameraInit(int32 Tag);
	void EventMcaCameraMemberSelect(int32 Tag);
	void EventMcaCameraSell(int32 Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclWeaponShopDrawActor">();
	}
	static class AFclWeaponShopDrawActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclWeaponShopDrawActor>();
	}
};
static_assert(alignof(AFclWeaponShopDrawActor) == 0x000008, "Wrong alignment on AFclWeaponShopDrawActor");
static_assert(sizeof(AFclWeaponShopDrawActor) == 0x000AC0, "Wrong size on AFclWeaponShopDrawActor");
static_assert(offsetof(AFclWeaponShopDrawActor, _CommonData) == 0x0002D8, "Member 'AFclWeaponShopDrawActor::_CommonData' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _BgColor) == 0x0002E0, "Member 'AFclWeaponShopDrawActor::_BgColor' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _InfoWindowInnerColor) == 0x0002E4, "Member 'AFclWeaponShopDrawActor::_InfoWindowInnerColor' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _TopMenuAnim) == 0x0002E8, "Member 'AFclWeaponShopDrawActor::_TopMenuAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _CatIconAnim) == 0x000330, "Member 'AFclWeaponShopDrawActor::_CatIconAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _TapeAnim) == 0x000378, "Member 'AFclWeaponShopDrawActor::_TapeAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _TapeChangeAnim) == 0x0003C0, "Member 'AFclWeaponShopDrawActor::_TapeChangeAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _EquipCompareTapeAnim) == 0x000408, "Member 'AFclWeaponShopDrawActor::_EquipCompareTapeAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ListCursorBaseInAnim) == 0x000450, "Member 'AFclWeaponShopDrawActor::_ListCursorBaseInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ListCursorInAnim) == 0x000498, "Member 'AFclWeaponShopDrawActor::_ListCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ListTriangleCursorInAnim) == 0x0004E0, "Member 'AFclWeaponShopDrawActor::_ListTriangleCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ListTriangleCursorLoopAnim) == 0x000528, "Member 'AFclWeaponShopDrawActor::_ListTriangleCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _LRCursorLoopAnim) == 0x000570, "Member 'AFclWeaponShopDrawActor::_LRCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _LRCursorInputAnim) == 0x0005B8, "Member 'AFclWeaponShopDrawActor::_LRCursorInputAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _UDCursorLoopAnim) == 0x000600, "Member 'AFclWeaponShopDrawActor::_UDCursorLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _UDCursorInputAnim) == 0x000648, "Member 'AFclWeaponShopDrawActor::_UDCursorInputAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _RevolverAnim) == 0x000690, "Member 'AFclWeaponShopDrawActor::_RevolverAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _DecideConfirmPanelAnimArray) == 0x0006D8, "Member 'AFclWeaponShopDrawActor::_DecideConfirmPanelAnimArray' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _NumConfirmPanelAnimArray) == 0x0006E8, "Member 'AFclWeaponShopDrawActor::_NumConfirmPanelAnimArray' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _MoneyWindowAnimArray) == 0x0006F8, "Member 'AFclWeaponShopDrawActor::_MoneyWindowAnimArray' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _EquipCompareInAnim) == 0x000708, "Member 'AFclWeaponShopDrawActor::_EquipCompareInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _EquipCompareOutAnim) == 0x000750, "Member 'AFclWeaponShopDrawActor::_EquipCompareOutAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ParamUpDownAnim) == 0x000798, "Member 'AFclWeaponShopDrawActor::_ParamUpDownAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _PicUpAnimArray) == 0x0007E0, "Member 'AFclWeaponShopDrawActor::_PicUpAnimArray' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _SellListCursorBaseInAnim) == 0x0007F0, "Member 'AFclWeaponShopDrawActor::_SellListCursorBaseInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _SellListCursorInAnim) == 0x000838, "Member 'AFclWeaponShopDrawActor::_SellListCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ParamUpDownLoopAnim) == 0x000880, "Member 'AFclWeaponShopDrawActor::_ParamUpDownLoopAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _ListInAnim) == 0x0008C8, "Member 'AFclWeaponShopDrawActor::_ListInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _CharaEquipListInAnim) == 0x000910, "Member 'AFclWeaponShopDrawActor::_CharaEquipListInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _TopMenuOutAnim) == 0x000958, "Member 'AFclWeaponShopDrawActor::_TopMenuOutAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _CatIconOutAnim) == 0x0009A0, "Member 'AFclWeaponShopDrawActor::_CatIconOutAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _TapeOutAnim) == 0x0009E8, "Member 'AFclWeaponShopDrawActor::_TapeOutAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _CharaListCursorInAnim) == 0x000A30, "Member 'AFclWeaponShopDrawActor::_CharaListCursorInAnim' has a wrong offset!");
static_assert(offsetof(AFclWeaponShopDrawActor, _SellInfoInAnim) == 0x000A78, "Member 'AFclWeaponShopDrawActor::_SellInfoInAnim' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectPrimitive
// 0x0060 (0x00B8 - 0x0058)
class UBtlGuiDrawObjectPrimitive final : public UBtlGuiDrawObjectCore
{
public:
	struct FBtlGuiDrawPrimitive                   Data;                                              // 0x0058(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void MakeCircle(float Radius, const struct FColor& Color, const struct FVector2D& Scale);
	void MakeRhombus(const struct FVector2D& Size, const struct FColor& Color);
	void SetAntiLength(float Anti);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectPrimitive">();
	}
	static class UBtlGuiDrawObjectPrimitive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectPrimitive>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectPrimitive) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectPrimitive");
static_assert(sizeof(UBtlGuiDrawObjectPrimitive) == 0x0000B8, "Wrong size on UBtlGuiDrawObjectPrimitive");
static_assert(offsetof(UBtlGuiDrawObjectPrimitive, Data) == 0x000058, "Member 'UBtlGuiDrawObjectPrimitive::Data' has a wrong offset!");

// Class xrd777.FldDungeonComponentBase
// 0x0080 (0x0148 - 0x00C8)
class UFldDungeonComponentBase : public UAppActorComponent
{
public:
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldDungeonScriptActor*>         M_ScrHandleList01;                                 // 0x0118(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFldDungeonScriptActor*>         M_ScrHandleList02;                                 // 0x0128(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x4];                                      // 0x0138(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_Name;                                            // 0x013C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonComponentBase">();
	}
	static class UFldDungeonComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonComponentBase>();
	}
};
static_assert(alignof(UFldDungeonComponentBase) == 0x000008, "Wrong alignment on UFldDungeonComponentBase");
static_assert(sizeof(UFldDungeonComponentBase) == 0x000148, "Wrong size on UFldDungeonComponentBase");
static_assert(offsetof(UFldDungeonComponentBase, M_ScrHandleList01) == 0x000118, "Member 'UFldDungeonComponentBase::M_ScrHandleList01' has a wrong offset!");
static_assert(offsetof(UFldDungeonComponentBase, M_ScrHandleList02) == 0x000128, "Member 'UFldDungeonComponentBase::M_ScrHandleList02' has a wrong offset!");
static_assert(offsetof(UFldDungeonComponentBase, M_Name) == 0x00013C, "Member 'UFldDungeonComponentBase::M_Name' has a wrong offset!");

// Class xrd777.FldDungeonSeparatelyController
// 0x0058 (0x01A0 - 0x0148)
class UFldDungeonSeparatelyController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x58];                                     // 0x0148(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSeparatelyController">();
	}
	static class UFldDungeonSeparatelyController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonSeparatelyController>();
	}
};
static_assert(alignof(UFldDungeonSeparatelyController) == 0x000008, "Wrong alignment on UFldDungeonSeparatelyController");
static_assert(sizeof(UFldDungeonSeparatelyController) == 0x0001A0, "Wrong size on UFldDungeonSeparatelyController");

// Class xrd777.BtlGuiDrawObjectLineFrame
// 0x0058 (0x00B0 - 0x0058)
class UBtlGuiDrawObjectLineFrame final : public UBtlGuiDrawObjectCore
{
public:
	struct FBtlGuiDrawLineFrame                   Data;                                              // 0x0058(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void MakeCircle(float Radius, const struct FColor& Color);
	void MakeRhombus(const struct FVector2D& Size, const struct FColor& Color);
	void SetAntiLength(float Anti);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectLineFrame">();
	}
	static class UBtlGuiDrawObjectLineFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectLineFrame>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectLineFrame) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectLineFrame");
static_assert(sizeof(UBtlGuiDrawObjectLineFrame) == 0x0000B0, "Wrong size on UBtlGuiDrawObjectLineFrame");
static_assert(offsetof(UBtlGuiDrawObjectLineFrame, Data) == 0x000058, "Member 'UBtlGuiDrawObjectLineFrame::Data' has a wrong offset!");

// Class xrd777.TownMapRestrictionsDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTownMapRestrictionsDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTownMapRestrictionsTable>      Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownMapRestrictionsDataAsset">();
	}
	static class UTownMapRestrictionsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownMapRestrictionsDataAsset>();
	}
};
static_assert(alignof(UTownMapRestrictionsDataAsset) == 0x000008, "Wrong alignment on UTownMapRestrictionsDataAsset");
static_assert(sizeof(UTownMapRestrictionsDataAsset) == 0x000040, "Wrong size on UTownMapRestrictionsDataAsset");
static_assert(offsetof(UTownMapRestrictionsDataAsset, Data) == 0x000030, "Member 'UTownMapRestrictionsDataAsset::Data' has a wrong offset!");

// Class xrd777.EvtTableTypes
// 0x0000 (0x0028 - 0x0028)
class UEvtTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtTableTypes">();
	}
	static class UEvtTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtTableTypes>();
	}
};
static_assert(alignof(UEvtTableTypes) == 0x000008, "Wrong alignment on UEvtTableTypes");
static_assert(sizeof(UEvtTableTypes) == 0x000028, "Wrong size on UEvtTableTypes");

// Class xrd777.BtlGuiDrawObjectRoundRect
// 0x0040 (0x0098 - 0x0058)
class UBtlGuiDrawObjectRoundRect final : public UBtlGuiDrawObjectCore
{
public:
	struct FBtlGuiDrawRoundRect                   Data;                                              // 0x0058(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectRoundRect">();
	}
	static class UBtlGuiDrawObjectRoundRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectRoundRect>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectRoundRect) == 0x000008, "Wrong alignment on UBtlGuiDrawObjectRoundRect");
static_assert(sizeof(UBtlGuiDrawObjectRoundRect) == 0x000098, "Wrong size on UBtlGuiDrawObjectRoundRect");
static_assert(offsetof(UBtlGuiDrawObjectRoundRect, Data) == 0x000058, "Member 'UBtlGuiDrawObjectRoundRect::Data' has a wrong offset!");

// Class xrd777.UIArcanaCardCapture
// 0x0128 (0x03E0 - 0x02B8)
class alignas(0x10) AUIArcanaCardCapture final : public AUIDrawBaseActor
{
public:
	class UTexture*                               PModelCaptureTex;                                  // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAppPropsCardContainer*                 CardContainer;                                     // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAppPropsCore*                          CardBp;                                            // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x68];                                     // 0x02D0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimSequence[0x9];                                 // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AUISceneCapture*                        PUISceneCapture2D;                                 // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUISceneCapture>            UISceneCaptureClass;                               // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         CardEffect;                                        // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      EffectComponent;                                   // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkeltalComponent;                                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInEffect();
	void FadeOutEffect();
	void StartAnimeRecoveryIn();
	void StartAnimeRecoveryOutv();
	void StartAnimeRecoveryTurn();
	void StartAnimeReverse();
	void StartPoemOutAnime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArcanaCardCapture">();
	}
	static class AUIArcanaCardCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIArcanaCardCapture>();
	}
};
static_assert(alignof(AUIArcanaCardCapture) == 0x000010, "Wrong alignment on AUIArcanaCardCapture");
static_assert(sizeof(AUIArcanaCardCapture) == 0x0003E0, "Wrong size on AUIArcanaCardCapture");
static_assert(offsetof(AUIArcanaCardCapture, PModelCaptureTex) == 0x0002B8, "Member 'AUIArcanaCardCapture::PModelCaptureTex' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, CardContainer) == 0x0002C0, "Member 'AUIArcanaCardCapture::CardContainer' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, CardBp) == 0x0002C8, "Member 'AUIArcanaCardCapture::CardBp' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, AnimSequence) == 0x000338, "Member 'AUIArcanaCardCapture::AnimSequence' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, PUISceneCapture2D) == 0x0003A8, "Member 'AUIArcanaCardCapture::PUISceneCapture2D' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, UISceneCaptureClass) == 0x0003B0, "Member 'AUIArcanaCardCapture::UISceneCaptureClass' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, AnimManager) == 0x0003B8, "Member 'AUIArcanaCardCapture::AnimManager' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, CardEffect) == 0x0003C0, "Member 'AUIArcanaCardCapture::CardEffect' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, EffectComponent) == 0x0003C8, "Member 'AUIArcanaCardCapture::EffectComponent' has a wrong offset!");
static_assert(offsetof(AUIArcanaCardCapture, SkeltalComponent) == 0x0003D0, "Member 'AUIArcanaCardCapture::SkeltalComponent' has a wrong offset!");

// Class xrd777.BtlGuiDrawObjectSilhouette
// 0x0078 (0x00D0 - 0x0058)
class UBtlGuiDrawObjectSilhouette final : public UBtlGuiDrawObjectCore
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlGuiDrawSilhouette                  Data;                                              // 0x0060(0x0070)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawObjectSilhouette">();
	}
	static class UBtlGuiDrawObjectSilhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawObjectSilhouette>();
	}
};
static_assert(alignof(UBtlGuiDrawObjectSilhouette) == 0x000010, "Wrong alignment on UBtlGuiDrawObjectSilhouette");
static_assert(sizeof(UBtlGuiDrawObjectSilhouette) == 0x0000D0, "Wrong size on UBtlGuiDrawObjectSilhouette");
static_assert(offsetof(UBtlGuiDrawObjectSilhouette, Data) == 0x000060, "Member 'UBtlGuiDrawObjectSilhouette::Data' has a wrong offset!");

// Class xrd777.CmpRoot
// 0x0088 (0x00C0 - 0x0038)
class UCmpRoot final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpRootDraw*                           PRootDraw;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpRoot">();
	}
	static class UCmpRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpRoot>();
	}
};
static_assert(alignof(UCmpRoot) == 0x000008, "Wrong alignment on UCmpRoot");
static_assert(sizeof(UCmpRoot) == 0x0000C0, "Wrong size on UCmpRoot");
static_assert(offsetof(UCmpRoot, PRootDraw) == 0x000088, "Member 'UCmpRoot::PRootDraw' has a wrong offset!");

// Class xrd777.BtlGuiDrawComponent
// 0x0020 (0x00E8 - 0x00C8)
class UBtlGuiDrawComponent final : public UAppActorComponent
{
public:
	EBtlGuiCanvas                                 CanvasType;                                        // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBtlGuiDrawObjectCore*>          ItemAry;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BtlGuiCheckDrawEnable(bool* Enable);
	static void BtlGuiSetDrawEnable(bool IsEnable);
	static struct FVector2D BtlGuiWorldToScreen(const struct FVector& WorldPos, class APlayerController* PlayerController);
	static bool BtlGuiWorldToScreen2(const struct FVector& WorldPos, class APlayerCameraManager* CameraManager, struct FVector2D* OutPos, float* FZ, class ACameraActor* CameraActor);
	static struct FVector2D GetViewportSize();

	void ClearCanvas(EBtlGuiCanvas Canvas, float Alpha, const struct FBtlBlendState& Bs);
	void ClearDrawItem();
	void ClearScreen(int32 GrpNo, int32* OutID, class UBtlGuiDrawObjectClearScreen** OutItem, const struct FColor& Color, EBtlGuiOT OT);
	void CreateDrawImage(int32 GrpNo, class UTexture* Texture, const struct FVector2D& Pos, int32* OutID, class UBtlGuiDrawObjectImage** OutItem);
	void CreateDrawImageByStruct(int32 GrpNo, const struct FBtlGuiDrawImage& Item, int32* OutID, class UBtlGuiDrawObjectImage** OutItem);
	void CreateDrawLineFrame(int32 GrpNo, const struct FBtlGuiDrawLineFrame& Item, int32* OutID, class UBtlGuiDrawObjectLineFrame** OutItem);
	void CreateDrawMaterial(int32 GrpNo, const struct FBtlGuiDrawMaterial& Item, int32* OutID, class UBtlGuiDrawObjectMaterial** OutItem);
	void CreateDrawMsg(int32 GrpNo, const struct FBtlGuiDrawMsg& Item, int32* OutID, class UBtlGuiDrawObjectMsg** OutItem);
	void CreateDrawPanel(int32 GrpNo, const struct FBtlGuiDrawPanel& Item, int32* OutID, class UBtlGuiDrawObjectPanel** OutItem);
	void CreateDrawPlg(int32 GrpNo, const struct FBtlGuiDrawPlg& Item, int32* OutID, class UBtlGuiDrawObjectPlg** OutItem);
	void CreateDrawPrimitive(int32 GrpNo, const struct FBtlGuiDrawPrimitive& Item, int32* OutID, class UBtlGuiDrawObjectPrimitive** OutItem);
	void CreateDrawRect(int32 GrpNo, const struct FBtlGuiDrawRect& Item, int32* OutID, class UBtlGuiDrawObjectRect** OutItem);
	void CreateDrawRoundRect(int32 GrpNo, const struct FBtlGuiDrawRoundRect& Item, int32* OutID, class UBtlGuiDrawObjectRoundRect** OutItem);
	void CreateDrawSilhouette(int32 GrpNo, const struct FBtlGuiDrawSilhouette& Item, int32* OutID, class UBtlGuiDrawObjectSilhouette** OutItem);
	void CreateDrawSprite(int32 GrpNo, const struct FBtlGuiDrawSprite& Item, int32* OutID, class UBtlGuiDrawObjectSprite** OutItem, bool OnChangeByPlatform);
	void CreateDrawText(int32 GrpNo, const struct FBtlGuiDrawText& Item, int32* OutID, class UBtlGuiDrawObjectText** OutItem);
	void Draw();
	void DrawAtCanvas(EBtlGuiCanvas UseCanvas);
	class UTexture* FrameBufferCapture(bool Is2DCapture);
	void GetAllDrawItem(TArray<int32>* IdAry, TArray<class UBtlGuiDrawObjectCore*>* ObjAry);
	void GetDrawItem(int32 ID, class UBtlGuiDrawObjectCore** Obj);
	void GetGroupDrawItem(int32 GrpNo, TArray<int32>* IdAry, TArray<class UBtlGuiDrawObjectCore*>* ObjAry, bool Reverse);
	class UTextureRenderTarget2D* GetRenderTarget(EBtlGuiCanvas Canvas);
	bool GetVisible();
	bool IsNotUsingPS4PS5GuardYesNoKey(class UBtlGuiDrawObjectSprite* Item);
	bool IsWindowsPlatform();
	void SetAryVisible(bool IsVisible);
	void SetCanvas(EBtlGuiCanvas Canvas);
	void SetComponentBoolOff(bool IsOff);
	void SetItemVisible(int32 Idx, bool IsVisible);
	void SetVisible(bool IsVisible);
	void TranslateObjectToAsset(class UObject* Obj, TSubclassOf<class UObject> TranslateClass, class UObject** OutAsset);
	class UPlgAsset* TranslateObjectToPlgAsset(class UObject* Obj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiDrawComponent">();
	}
	static class UBtlGuiDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiDrawComponent>();
	}
};
static_assert(alignof(UBtlGuiDrawComponent) == 0x000008, "Wrong alignment on UBtlGuiDrawComponent");
static_assert(sizeof(UBtlGuiDrawComponent) == 0x0000E8, "Wrong size on UBtlGuiDrawComponent");
static_assert(offsetof(UBtlGuiDrawComponent, CanvasType) == 0x0000C8, "Member 'UBtlGuiDrawComponent::CanvasType' has a wrong offset!");
static_assert(offsetof(UBtlGuiDrawComponent, ItemAry) == 0x0000D0, "Member 'UBtlGuiDrawComponent::ItemAry' has a wrong offset!");

// Class xrd777.TitleStateWaitGamerTag
// 0x0010 (0x0048 - 0x0038)
class UTitleStateWaitGamerTag final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateWaitGamerTag">();
	}
	static class UTitleStateWaitGamerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateWaitGamerTag>();
	}
};
static_assert(alignof(UTitleStateWaitGamerTag) == 0x000008, "Wrong alignment on UTitleStateWaitGamerTag");
static_assert(sizeof(UTitleStateWaitGamerTag) == 0x000048, "Wrong size on UTitleStateWaitGamerTag");

// Class xrd777.BtlEncountWipeLoader
// 0x0060 (0x0088 - 0x0028)
class UBtlEncountWipeLoader final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PLoader;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharacter*                             Chara;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABtlEncountWipeCore>        EncountBp;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlEncountWipeCore>        EventEncountBp;                                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlEncountWipeCore>        PinthEncountBp;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEncountWipeLoader">();
	}
	static class UBtlEncountWipeLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlEncountWipeLoader>();
	}
};
static_assert(alignof(UBtlEncountWipeLoader) == 0x000008, "Wrong alignment on UBtlEncountWipeLoader");
static_assert(sizeof(UBtlEncountWipeLoader) == 0x000088, "Wrong size on UBtlEncountWipeLoader");
static_assert(offsetof(UBtlEncountWipeLoader, PLoader) == 0x000048, "Member 'UBtlEncountWipeLoader::PLoader' has a wrong offset!");
static_assert(offsetof(UBtlEncountWipeLoader, Chara) == 0x000050, "Member 'UBtlEncountWipeLoader::Chara' has a wrong offset!");
static_assert(offsetof(UBtlEncountWipeLoader, EncountBp) == 0x000070, "Member 'UBtlEncountWipeLoader::EncountBp' has a wrong offset!");
static_assert(offsetof(UBtlEncountWipeLoader, EventEncountBp) == 0x000078, "Member 'UBtlEncountWipeLoader::EventEncountBp' has a wrong offset!");
static_assert(offsetof(UBtlEncountWipeLoader, PinthEncountBp) == 0x000080, "Member 'UBtlEncountWipeLoader::PinthEncountBp' has a wrong offset!");

// Class xrd777.BtlEncountWipeCore
// 0x0028 (0x02A0 - 0x0278)
class ABtlEncountWipeCore : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             OnCalledBattle;                                    // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          RequestWipeOut;                                    // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWraped;                                          // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSequenceEnable;                                  // 0x028A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlEncountWipeType                           WipeType;                                          // 0x028B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlCoreComponent*                      Core;                                              // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BtlEncountWipeCheckWraped();
	static void BtlEncountWipeDeleteInstance();
	static class ABtlEncountWipeCore* BtlEncountWipeGetInstance();
	static void ClearResources();
	static void LoadResources();

	bool CheckFadeInEnd();
	void ForceFadeIn();
	EBtlEncountWipeType GetWipeType();
	void RequestEndWipe(class UBtlCoreComponent* Core_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlEncountWipeCore">();
	}
	static class ABtlEncountWipeCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlEncountWipeCore>();
	}
};
static_assert(alignof(ABtlEncountWipeCore) == 0x000008, "Wrong alignment on ABtlEncountWipeCore");
static_assert(sizeof(ABtlEncountWipeCore) == 0x0002A0, "Wrong size on ABtlEncountWipeCore");
static_assert(offsetof(ABtlEncountWipeCore, OnCalledBattle) == 0x000278, "Member 'ABtlEncountWipeCore::OnCalledBattle' has a wrong offset!");
static_assert(offsetof(ABtlEncountWipeCore, RequestWipeOut) == 0x000288, "Member 'ABtlEncountWipeCore::RequestWipeOut' has a wrong offset!");
static_assert(offsetof(ABtlEncountWipeCore, IsWraped) == 0x000289, "Member 'ABtlEncountWipeCore::IsWraped' has a wrong offset!");
static_assert(offsetof(ABtlEncountWipeCore, IsSequenceEnable) == 0x00028A, "Member 'ABtlEncountWipeCore::IsSequenceEnable' has a wrong offset!");
static_assert(offsetof(ABtlEncountWipeCore, WipeType) == 0x00028B, "Member 'ABtlEncountWipeCore::WipeType' has a wrong offset!");
static_assert(offsetof(ABtlEncountWipeCore, Core) == 0x000290, "Member 'ABtlEncountWipeCore::Core' has a wrong offset!");

// Class xrd777.DatTableTypes
// 0x0000 (0x0028 - 0x0028)
class UDatTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatTableTypes">();
	}
	static class UDatTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatTableTypes>();
	}
};
static_assert(alignof(UDatTableTypes) == 0x000008, "Wrong alignment on UDatTableTypes");
static_assert(sizeof(UDatTableTypes) == 0x000028, "Wrong size on UDatTableTypes");

// Class xrd777.BtlGuiEncountWipe
// 0x0028 (0x02C8 - 0x02A0)
class ABtlGuiEncountWipe final : public ABtlEncountWipeCore
{
public:
	class ACharacter*                             Chara;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnd;                                             // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLine;                                         // 0x02AC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLine;                                           // 0x02B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWipe();
	float GetCharacterAnimTime();
	class UAppCharacterComp* GetCharacterComp();
	void SetCharacterAttackAnim();
	void SetCharacterVisible(bool Visible);
	void SetTransform(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiEncountWipe">();
	}
	static class ABtlGuiEncountWipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiEncountWipe>();
	}
};
static_assert(alignof(ABtlGuiEncountWipe) == 0x000008, "Wrong alignment on ABtlGuiEncountWipe");
static_assert(sizeof(ABtlGuiEncountWipe) == 0x0002C8, "Wrong size on ABtlGuiEncountWipe");
static_assert(offsetof(ABtlGuiEncountWipe, Chara) == 0x0002A0, "Member 'ABtlGuiEncountWipe::Chara' has a wrong offset!");
static_assert(offsetof(ABtlGuiEncountWipe, IsEnd) == 0x0002A8, "Member 'ABtlGuiEncountWipe::IsEnd' has a wrong offset!");
static_assert(offsetof(ABtlGuiEncountWipe, StartLine) == 0x0002AC, "Member 'ABtlGuiEncountWipe::StartLine' has a wrong offset!");
static_assert(offsetof(ABtlGuiEncountWipe, EndLine) == 0x0002B8, "Member 'ABtlGuiEncountWipe::EndLine' has a wrong offset!");

// Class xrd777.FldDungeonSecretGateController
// 0x0010 (0x0158 - 0x0148)
class UFldDungeonSecretGateController final : public UFldDungeonComponentBase
{
public:
	class AFldDungeonObjectActor*                 M_SecretGateActor;                                 // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutSecretGate;                               // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSecretGateController">();
	}
	static class UFldDungeonSecretGateController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonSecretGateController>();
	}
};
static_assert(alignof(UFldDungeonSecretGateController) == 0x000008, "Wrong alignment on UFldDungeonSecretGateController");
static_assert(sizeof(UFldDungeonSecretGateController) == 0x000158, "Wrong size on UFldDungeonSecretGateController");
static_assert(offsetof(UFldDungeonSecretGateController, M_SecretGateActor) == 0x000148, "Member 'UFldDungeonSecretGateController::M_SecretGateActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonSecretGateController, M_pLayoutSecretGate) == 0x000150, "Member 'UFldDungeonSecretGateController::M_pLayoutSecretGate' has a wrong offset!");

// Class xrd777.SuggestionTextListTable
// 0x0010 (0x0040 - 0x0030)
class USuggestionTextListTable final : public UAppDataAsset
{
public:
	TArray<struct FSuggestionTextList>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuggestionTextListTable">();
	}
	static class USuggestionTextListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuggestionTextListTable>();
	}
};
static_assert(alignof(USuggestionTextListTable) == 0x000008, "Wrong alignment on USuggestionTextListTable");
static_assert(sizeof(USuggestionTextListTable) == 0x000040, "Wrong size on USuggestionTextListTable");
static_assert(offsetof(USuggestionTextListTable, Data) == 0x000030, "Member 'USuggestionTextListTable::Data' has a wrong offset!");

// Class xrd777.DatUIText
// 0x0028 (0x0058 - 0x0030)
class UDatUIText final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatUIText">();
	}
	static class UDatUIText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatUIText>();
	}
};
static_assert(alignof(UDatUIText) == 0x000008, "Wrong alignment on UDatUIText");
static_assert(sizeof(UDatUIText) == 0x000058, "Wrong size on UDatUIText");

// Class xrd777.BtlGuiPinchEncountWipe
// 0x0008 (0x02A8 - 0x02A0)
class ABtlGuiPinchEncountWipe final : public ABtlEncountWipeCore
{
public:
	bool                                          IsEnd;                                             // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimation;                                       // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTexDraw;                                         // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWipe();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiPinchEncountWipe">();
	}
	static class ABtlGuiPinchEncountWipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiPinchEncountWipe>();
	}
};
static_assert(alignof(ABtlGuiPinchEncountWipe) == 0x000008, "Wrong alignment on ABtlGuiPinchEncountWipe");
static_assert(sizeof(ABtlGuiPinchEncountWipe) == 0x0002A8, "Wrong size on ABtlGuiPinchEncountWipe");
static_assert(offsetof(ABtlGuiPinchEncountWipe, IsEnd) == 0x0002A0, "Member 'ABtlGuiPinchEncountWipe::IsEnd' has a wrong offset!");
static_assert(offsetof(ABtlGuiPinchEncountWipe, IsAnimation) == 0x0002A1, "Member 'ABtlGuiPinchEncountWipe::IsAnimation' has a wrong offset!");
static_assert(offsetof(ABtlGuiPinchEncountWipe, IsTexDraw) == 0x0002A2, "Member 'ABtlGuiPinchEncountWipe::IsTexDraw' has a wrong offset!");

// Class xrd777.FldDungeonTBoxController
// 0x00C8 (0x0210 - 0x0148)
class UFldDungeonTBoxController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonObjectActor*>         M_TBoxActor;                                       // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonSoundBaseActor*>      M_TBoxSE;                                          // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonObjectActor*                 M_HitTBox;                                         // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x98];                                     // 0x0178(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoFloorAdvanceProcess();
	void DesignFloorAdvanceProcess();
	void FixedFloorAdvanceProcess();
	void ForbiddenDoorHitEvent(EDungeonObjHitEvent EventType, int32 ID, class AFldDungeonObjectActor* PObject);
	void HitEvent(EDungeonObjHitEvent EventType, int32 ID, class AFldDungeonObjectActor* PObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonTBoxController">();
	}
	static class UFldDungeonTBoxController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonTBoxController>();
	}
};
static_assert(alignof(UFldDungeonTBoxController) == 0x000008, "Wrong alignment on UFldDungeonTBoxController");
static_assert(sizeof(UFldDungeonTBoxController) == 0x000210, "Wrong size on UFldDungeonTBoxController");
static_assert(offsetof(UFldDungeonTBoxController, M_TBoxActor) == 0x000148, "Member 'UFldDungeonTBoxController::M_TBoxActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonTBoxController, M_TBoxSE) == 0x000158, "Member 'UFldDungeonTBoxController::M_TBoxSE' has a wrong offset!");
static_assert(offsetof(UFldDungeonTBoxController, M_HitTBox) == 0x000170, "Member 'UFldDungeonTBoxController::M_HitTBox' has a wrong offset!");

// Class xrd777.BtlGuiEventEncountWipe
// 0x0008 (0x02A8 - 0x02A0)
class ABtlGuiEventEncountWipe final : public ABtlEncountWipeCore
{
public:
	bool                                          IsEnd;                                             // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimation;                                       // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTexDraw;                                         // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWipe();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiEventEncountWipe">();
	}
	static class ABtlGuiEventEncountWipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiEventEncountWipe>();
	}
};
static_assert(alignof(ABtlGuiEventEncountWipe) == 0x000008, "Wrong alignment on ABtlGuiEventEncountWipe");
static_assert(sizeof(ABtlGuiEventEncountWipe) == 0x0002A8, "Wrong size on ABtlGuiEventEncountWipe");
static_assert(offsetof(ABtlGuiEventEncountWipe, IsEnd) == 0x0002A0, "Member 'ABtlGuiEventEncountWipe::IsEnd' has a wrong offset!");
static_assert(offsetof(ABtlGuiEventEncountWipe, IsAnimation) == 0x0002A1, "Member 'ABtlGuiEventEncountWipe::IsAnimation' has a wrong offset!");
static_assert(offsetof(ABtlGuiEventEncountWipe, IsTexDraw) == 0x0002A2, "Member 'ABtlGuiEventEncountWipe::IsTexDraw' has a wrong offset!");

// Class xrd777.BustupAnimDataAsset
// 0x0020 (0x0050 - 0x0030)
class UBustupAnimDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FBustupAnim>                    EyeAnim;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBustupMouthAnim>               MouthAnim;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupAnimDataAsset">();
	}
	static class UBustupAnimDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupAnimDataAsset>();
	}
};
static_assert(alignof(UBustupAnimDataAsset) == 0x000008, "Wrong alignment on UBustupAnimDataAsset");
static_assert(sizeof(UBustupAnimDataAsset) == 0x000050, "Wrong size on UBustupAnimDataAsset");
static_assert(offsetof(UBustupAnimDataAsset, EyeAnim) == 0x000030, "Member 'UBustupAnimDataAsset::EyeAnim' has a wrong offset!");
static_assert(offsetof(UBustupAnimDataAsset, MouthAnim) == 0x000040, "Member 'UBustupAnimDataAsset::MouthAnim' has a wrong offset!");

// Class xrd777.FadePgColorOut
// 0x0000 (0x0040 - 0x0040)
class UFadePgColorOut final : public UFadeProgramBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgColorOut">();
	}
	static class UFadePgColorOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgColorOut>();
	}
};
static_assert(alignof(UFadePgColorOut) == 0x000008, "Wrong alignment on UFadePgColorOut");
static_assert(sizeof(UFadePgColorOut) == 0x000040, "Wrong size on UFadePgColorOut");

// Class xrd777.BtlGuiFBufferCapture
// 0x0028 (0x02A0 - 0x0278)
class ABtlGuiFBufferCapture final : public AAppActor
{
public:
	TSubclassOf<class ABtlGuiFBufferCapture>      LoadClass;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PLoader;                                           // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSetupCompleted;                                  // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDraw;                                            // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is2DCapture;                                       // 0x028A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B[0x1];                                      // 0x028B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationTime;                                     // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAnimationTime;                                  // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndGtayScale;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndWhiteOut;                                       // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BtlFBufferCaptureCreate(float GrayScale, float WhiteOut, float AnimTime);
	static void BtlFBufferCaptureCreate2D(float GrayScale, float WhiteOut, float AnimTime);
	static void BtlFBufferCaptureDelete();
	static void BtlFBufferCaptureDrawEnd();
	static class ABtlGuiFBufferCapture* BtlFBufferCaptureGetInstance();
	static void BtlFBufferCaptureStart(bool Is2DCapture_0, bool IsGrayScale, float AnimTime);

	void SetCapture();
	void SetGrayScale(float GrayScale);
	void SetupBP();
	void SetWhiteOut(float WhiteOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiFBufferCapture">();
	}
	static class ABtlGuiFBufferCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiFBufferCapture>();
	}
};
static_assert(alignof(ABtlGuiFBufferCapture) == 0x000008, "Wrong alignment on ABtlGuiFBufferCapture");
static_assert(sizeof(ABtlGuiFBufferCapture) == 0x0002A0, "Wrong size on ABtlGuiFBufferCapture");
static_assert(offsetof(ABtlGuiFBufferCapture, LoadClass) == 0x000278, "Member 'ABtlGuiFBufferCapture::LoadClass' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, PLoader) == 0x000280, "Member 'ABtlGuiFBufferCapture::PLoader' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, IsSetupCompleted) == 0x000288, "Member 'ABtlGuiFBufferCapture::IsSetupCompleted' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, IsDraw) == 0x000289, "Member 'ABtlGuiFBufferCapture::IsDraw' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, Is2DCapture) == 0x00028A, "Member 'ABtlGuiFBufferCapture::Is2DCapture' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, AnimationTime) == 0x00028C, "Member 'ABtlGuiFBufferCapture::AnimationTime' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, EndAnimationTime) == 0x000290, "Member 'ABtlGuiFBufferCapture::EndAnimationTime' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, EndGtayScale) == 0x000294, "Member 'ABtlGuiFBufferCapture::EndGtayScale' has a wrong offset!");
static_assert(offsetof(ABtlGuiFBufferCapture, EndWhiteOut) == 0x000298, "Member 'ABtlGuiFBufferCapture::EndWhiteOut' has a wrong offset!");

// Class xrd777.SoundDataAssets
// 0x0010 (0x0038 - 0x0028)
class USoundDataAssets final : public UObject
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PDlcBgm;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundDataAssets">();
	}
	static class USoundDataAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundDataAssets>();
	}
};
static_assert(alignof(USoundDataAssets) == 0x000008, "Wrong alignment on USoundDataAssets");
static_assert(sizeof(USoundDataAssets) == 0x000038, "Wrong size on USoundDataAssets");
static_assert(offsetof(USoundDataAssets, PAssetLoader) == 0x000028, "Member 'USoundDataAssets::PAssetLoader' has a wrong offset!");
static_assert(offsetof(USoundDataAssets, PDlcBgm) == 0x000030, "Member 'USoundDataAssets::PDlcBgm' has a wrong offset!");

// Class xrd777.BtlGuiIconComponent
// 0x0038 (0x0100 - 0x00C8)
class UBtlGuiIconComponent : public UAppActorComponent
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnVisibleEvent;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHiddenEvent;                                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJyokyoHelpEndEvent;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallJyokyoHelpBroadcast();
	void CancelJyokyoHelpForBP();
	bool CheckPartyPanelVisible();
	void ClearDamagePanelForBP();
	void ClearKeyHelpOffset();
	void ClearSkillNamePanelForBP();
	void CreateActionSuggestion();
	void CreateDamagePanelForBP(const struct FBtlGuiIconDamage& Data);
	void CreatePartyPanel(float Scale, float X, float Y);
	void CreateSkillNamePanelForBP(EBtlCommandType Cmd, int32 ID, bool IsEnemy, float Time);
	void CreateTotalDamagePanelForBP(int32 Damage);
	void DamagePartyPanel(int32 PlayerId, bool IsWeak);
	void DestroyActionSuggestion();
	void DestroyPartyPanel();
	void DisableCharacterPartyPanel();
	class UTexture* GetRenderTargets(int32 Num);
	bool LoadSyncPartyPanel();
	void RecoverPartyPanel_BadStatus(int32 PlayerId);
	void RecoverPartyPanel_HP(int32 PlayerId);
	void RecoverPartyPanel_SP(int32 PlayerId);
	void RequestJyokyoHelpForBP(int32 Genus, int32 ID, int32 MsgNo, int32 Var1, int32 Var2, float RenderTime, float DelayTime, bool ForceOverride, int32 Flags_0);
	void SetCharacterPartyPanel(class ABtlActor* ActiveActor, bool IsSkipAnim);
	void SetKeyHelpOffset(EBtlGuiIconKeyHelp Help, class UBtlCoreComponent* BtlCore, bool NoChange, bool DisableParam);
	void SetKeyHelpVisible(bool Visible, class UBtlCoreComponent* BtlCore);
	void SetPartyPanelVisible(bool Vidible, bool ResetAnimFlag);
	void SetVariableJyokyoHelp(class UBtlGuiDrawObjectMsg* PMsg, int32 Genus, int32 ID, int32 Var1, int32 Var2, int32 Flags_0);
	void ShowFukaPartyPanel();
	void Start1MoreEffectForBP(bool IsEnemy, float Time);
	void StartEncountEffectForBP(bool IsPlayerAdvantage, float Time);
	void UpdateParamPartyPanel_HP(int32 PlayerId, int32 Hp);
	void UpdateParamPartyPanel_SP(int32 PlayerId, int32 Sp);
	void VisibleActionSuggestion(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiIconComponent">();
	}
	static class UBtlGuiIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiIconComponent>();
	}
};
static_assert(alignof(UBtlGuiIconComponent) == 0x000008, "Wrong alignment on UBtlGuiIconComponent");
static_assert(sizeof(UBtlGuiIconComponent) == 0x000100, "Wrong size on UBtlGuiIconComponent");
static_assert(offsetof(UBtlGuiIconComponent, OnVisibleEvent) == 0x0000D0, "Member 'UBtlGuiIconComponent::OnVisibleEvent' has a wrong offset!");
static_assert(offsetof(UBtlGuiIconComponent, OnHiddenEvent) == 0x0000E0, "Member 'UBtlGuiIconComponent::OnHiddenEvent' has a wrong offset!");
static_assert(offsetof(UBtlGuiIconComponent, OnJyokyoHelpEndEvent) == 0x0000F0, "Member 'UBtlGuiIconComponent::OnJyokyoHelpEndEvent' has a wrong offset!");

// Class xrd777.CmpSystem
// 0x00E0 (0x0118 - 0x0038)
class UCmpSystem final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpSystemDraw*                         PSystemDraw;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpSystemSystem*                       PSystemSystem;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUISaveLoad*                            PSaveMenu;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUITutorial*                            PTutorial;                                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIDictionary*                          PDictionary;                                       // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUITutorialDraw>            PTutorialDrawClass;                                // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIConfiguration*                       PConfig;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x38];                                      // 0x00E0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndPlaySubProcess(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSystem">();
	}
	static class UCmpSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSystem>();
	}
};
static_assert(alignof(UCmpSystem) == 0x000008, "Wrong alignment on UCmpSystem");
static_assert(sizeof(UCmpSystem) == 0x000118, "Wrong size on UCmpSystem");
static_assert(offsetof(UCmpSystem, PSystemDraw) == 0x0000A8, "Member 'UCmpSystem::PSystemDraw' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PSystemSystem) == 0x0000B0, "Member 'UCmpSystem::PSystemSystem' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PSaveMenu) == 0x0000B8, "Member 'UCmpSystem::PSaveMenu' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PTutorial) == 0x0000C0, "Member 'UCmpSystem::PTutorial' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PDictionary) == 0x0000C8, "Member 'UCmpSystem::PDictionary' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PTutorialDrawClass) == 0x0000D0, "Member 'UCmpSystem::PTutorialDrawClass' has a wrong offset!");
static_assert(offsetof(UCmpSystem, PConfig) == 0x0000D8, "Member 'UCmpSystem::PConfig' has a wrong offset!");

// Class xrd777.BtlGuiListComponent
// 0x00B8 (0x0180 - 0x00C8)
class UBtlGuiListComponent final : public UAppActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCurcorUpdate;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurcorUpdated;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x98];                                      // 0x00E8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetCursor(int32* CursorIndex, int32* TopIndex, int32* CurrentIndex);
	void Init(int32 ItemDtarMin, int32 ItemDtarMax, int32 ItemNum, EBtlListScreenID ScreenID, int32 CursorIdx, int32 ListTopIdx, int32 MoveType);
	void SetCursor(int32 CurrentIndex);
	void SetScrollBarData(float PosY, float ScrollRange, float CenterPosY);
	void Update(int32* CursorIndex, int32* TopIndex, int32* CurrentIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiListComponent">();
	}
	static class UBtlGuiListComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiListComponent>();
	}
};
static_assert(alignof(UBtlGuiListComponent) == 0x000008, "Wrong alignment on UBtlGuiListComponent");
static_assert(sizeof(UBtlGuiListComponent) == 0x000180, "Wrong size on UBtlGuiListComponent");
static_assert(offsetof(UBtlGuiListComponent, OnCurcorUpdate) == 0x0000C8, "Member 'UBtlGuiListComponent::OnCurcorUpdate' has a wrong offset!");
static_assert(offsetof(UBtlGuiListComponent, OnCurcorUpdated) == 0x0000D8, "Member 'UBtlGuiListComponent::OnCurcorUpdated' has a wrong offset!");

// Class xrd777.UIBackLog
// 0x0120 (0x0398 - 0x0278)
class AUIBackLog final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishedDelegate;                                // 0x0290(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUIBackLogDraw>             BackLoadDrawClass;                                 // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIBackLogDraw*                         PBackLoadDraw;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Tex;                                               // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    CaptureBackGround;                                 // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PParamLayoutData;                                  // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataAstrea;                            // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableAstrea;                            // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x78];                                     // 0x0320(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackLog">();
	}
	static class AUIBackLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackLog>();
	}
};
static_assert(alignof(AUIBackLog) == 0x000008, "Wrong alignment on AUIBackLog");
static_assert(sizeof(AUIBackLog) == 0x000398, "Wrong size on AUIBackLog");
static_assert(offsetof(AUIBackLog, M_pLoader) == 0x000288, "Member 'AUIBackLog::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIBackLog, OnFinishedDelegate) == 0x000290, "Member 'AUIBackLog::OnFinishedDelegate' has a wrong offset!");
static_assert(offsetof(AUIBackLog, BackLoadDrawClass) == 0x0002C0, "Member 'AUIBackLog::BackLoadDrawClass' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PAssetLoader) == 0x0002C8, "Member 'AUIBackLog::PAssetLoader' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PBackLoadDraw) == 0x0002D0, "Member 'AUIBackLog::PBackLoadDraw' has a wrong offset!");
static_assert(offsetof(AUIBackLog, Tex) == 0x0002E0, "Member 'AUIBackLog::Tex' has a wrong offset!");
static_assert(offsetof(AUIBackLog, CaptureBackGround) == 0x0002E8, "Member 'AUIBackLog::CaptureBackGround' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PParamLayoutData) == 0x000300, "Member 'AUIBackLog::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PParamLayoutDataAstrea) == 0x000308, "Member 'AUIBackLog::PParamLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PLayoutDataTable) == 0x000310, "Member 'AUIBackLog::PLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIBackLog, PLayoutDataTableAstrea) == 0x000318, "Member 'AUIBackLog::PLayoutDataTableAstrea' has a wrong offset!");

// Class xrd777.BtlGuiPersonaStatusComponent
// 0x0088 (0x0150 - 0x00C8)
class UBtlGuiPersonaStatusComponent final : public UAppActorComponent
{
public:
	class APersonaStatus*                         PActor;                                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlActor*                              PFirstCharacter;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeL1;                                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeR1;                                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x58];                                      // 0x00F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangePersonaStatusLeft();
	void ChangePersonaStatusLeftActor();
	bool ChangePersonaStatusRight();
	void ChangePersonaStatusRightActor();
	bool CheckPersonaChange();
	bool CheckPersonaCommentary();
	bool CheckPersonaSkillHelp();
	void ClosePersonaStatus(class UBtlCoreComponent* PCore);
	void CreateInstance();
	void CreatePersonaStatus(class ABtlActor* Actor, class UBtlCoreComponent* PCore, int32 CurrentNum, bool AlwaysChange);
	void CreatePersonaStatusTargetSelect(class ABtlActor* Actor, class UBtlCoreComponent* PCore, const TArray<class ABtlActor*>& PlayerList);
	void DeleteInstance();
	class ABtlActor* GetDispActor(class UBtlCoreComponent* PCore);
	int32 GetPersonaStockCount(class ABtlActor* Actor);
	bool IsEndPersonaStatus();
	void SetEquipPersona();
	void StartPersonaCommentary();
	void StartPersonaSkillHelp();
	void UpdatePersonaStatus(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiPersonaStatusComponent">();
	}
	static class UBtlGuiPersonaStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiPersonaStatusComponent>();
	}
};
static_assert(alignof(UBtlGuiPersonaStatusComponent) == 0x000008, "Wrong alignment on UBtlGuiPersonaStatusComponent");
static_assert(sizeof(UBtlGuiPersonaStatusComponent) == 0x000150, "Wrong size on UBtlGuiPersonaStatusComponent");
static_assert(offsetof(UBtlGuiPersonaStatusComponent, PActor) == 0x0000C8, "Member 'UBtlGuiPersonaStatusComponent::PActor' has a wrong offset!");
static_assert(offsetof(UBtlGuiPersonaStatusComponent, PFirstCharacter) == 0x0000D0, "Member 'UBtlGuiPersonaStatusComponent::PFirstCharacter' has a wrong offset!");
static_assert(offsetof(UBtlGuiPersonaStatusComponent, OnChangeL1) == 0x0000D8, "Member 'UBtlGuiPersonaStatusComponent::OnChangeL1' has a wrong offset!");
static_assert(offsetof(UBtlGuiPersonaStatusComponent, OnChangeR1) == 0x0000E8, "Member 'UBtlGuiPersonaStatusComponent::OnChangeR1' has a wrong offset!");

// Class xrd777.BtlGuiPromiseComponent
// 0x0000 (0x00C8 - 0x00C8)
class UBtlGuiPromiseComponent final : public UAppActorComponent
{
public:
	bool CheckMsgStart();
	void StartSupportInfo(class UBtlCoreComponent* BtlCore, bool IsGeneral, int32 MsgNo);
	void StopSupportInfo(class UBtlCoreComponent* BtlCore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiPromiseComponent">();
	}
	static class UBtlGuiPromiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiPromiseComponent>();
	}
};
static_assert(alignof(UBtlGuiPromiseComponent) == 0x000008, "Wrong alignment on UBtlGuiPromiseComponent");
static_assert(sizeof(UBtlGuiPromiseComponent) == 0x0000C8, "Wrong size on UBtlGuiPromiseComponent");

// Class xrd777.CmpPersonaList
// 0x0098 (0x00D8 - 0x0040)
class UCmpPersonaList final : public UUIScene
{
public:
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpPersona*                          Context_;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PSStatusActor_;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x40];                                      // 0x0098(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpPersonaList">();
	}
	static class UCmpPersonaList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpPersonaList>();
	}
};
static_assert(alignof(UCmpPersonaList) == 0x000008, "Wrong alignment on UCmpPersonaList");
static_assert(sizeof(UCmpPersonaList) == 0x0000D8, "Wrong size on UCmpPersonaList");
static_assert(offsetof(UCmpPersonaList, Context_) == 0x000088, "Member 'UCmpPersonaList::Context_' has a wrong offset!");
static_assert(offsetof(UCmpPersonaList, PSStatusActor_) == 0x000090, "Member 'UCmpPersonaList::PSStatusActor_' has a wrong offset!");

// Class xrd777.BtlGuiResourcesBase
// 0x0008 (0x0280 - 0x0278)
class ABtlGuiResourcesBase : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiResourcesBase">();
	}
	static class ABtlGuiResourcesBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiResourcesBase>();
	}
};
static_assert(alignof(ABtlGuiResourcesBase) == 0x000008, "Wrong alignment on ABtlGuiResourcesBase");
static_assert(sizeof(ABtlGuiResourcesBase) == 0x000280, "Wrong size on ABtlGuiResourcesBase");

// Class xrd777.FldDungeonTalkController
// 0x0038 (0x0180 - 0x0148)
class UFldDungeonTalkController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x38];                                     // 0x0148(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonTalkController">();
	}
	static class UFldDungeonTalkController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonTalkController>();
	}
};
static_assert(alignof(UFldDungeonTalkController) == 0x000008, "Wrong alignment on UFldDungeonTalkController");
static_assert(sizeof(UFldDungeonTalkController) == 0x000180, "Wrong size on UFldDungeonTalkController");

// Class xrd777.MiniMapInfoDataAsset
// 0x0010 (0x0040 - 0x0030)
class UMiniMapInfoDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FMiniMapInfoTable>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapInfoDataAsset">();
	}
	static class UMiniMapInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapInfoDataAsset>();
	}
};
static_assert(alignof(UMiniMapInfoDataAsset) == 0x000008, "Wrong alignment on UMiniMapInfoDataAsset");
static_assert(sizeof(UMiniMapInfoDataAsset) == 0x000040, "Wrong size on UMiniMapInfoDataAsset");
static_assert(offsetof(UMiniMapInfoDataAsset, Data) == 0x000030, "Member 'UMiniMapInfoDataAsset::Data' has a wrong offset!");

// Class xrd777.CmpSkillSystem
// 0x0030 (0x0058 - 0x0028)
class UCmpSkillSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSkillSystem">();
	}
	static class UCmpSkillSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSkillSystem>();
	}
};
static_assert(alignof(UCmpSkillSystem) == 0x000008, "Wrong alignment on UCmpSkillSystem");
static_assert(sizeof(UCmpSkillSystem) == 0x000058, "Wrong size on UCmpSkillSystem");

// Class xrd777.BtlGuiResourcesActor
// 0x00D0 (0x0350 - 0x0280)
class ABtlGuiResourcesActor : public ABtlGuiResourcesBase
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PLoadAsset;                                        // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           PLoader;                                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StackLoadPath;                                     // 0x02B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     PItemSkillListTextDataTable;                       // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTargetInfoTextDataTable;                          // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTacticsListTextDataTable;                         // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTheurgiaDataTable;                                // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTacticsDataTable;                                 // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTopDataTable;                                     // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PGuardDataTable;                                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTheurgiaTextDataTable;                            // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTheurgiaTextRowDataTable;                         // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTheurgiaTextPosDataTable;                         // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTacticsCheckDataTable;                            // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PPromiseDataTable;                                 // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PAnalyzeDataTable;                                 // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PAnalyzeTextDataTable;                             // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PDamageIconDataTable;                              // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PRushDataTable;                                    // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     POthersDataTable;                                  // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PTouchCollDataTable;                               // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallDelegate();
	class UObject* GetAddResources();
	class UObject* GetResources(class FName Name_0);
	void InitializeAnalyzeLayoutData(class UDataTable* Data);
	void InitializeAnalyzeTextLayoutData(class UDataTable* Data);
	void InitializeBattleTouchCollLayoutData(class UDataTable* Data);
	void InitializeDamageIconLayoutData(class UDataTable* Data);
	void InitializeGuardLayoutData(class UDataTable* Data);
	void InitializeItemSkillListTextLayoutData(class UDataTable* Data);
	void InitializeOthersLayoutData(class UDataTable* Data);
	void InitializePromiseLayoutData(class UDataTable* Data);
	void InitializeRushLayoutData(class UDataTable* Data);
	void InitializeTacticsLayoutData(class UDataTable* Data);
	void InitializeTacticsListTextLayoutData(class UDataTable* Data);
	void InitializeTargetInfoLayoutData(class UDataTable* Data);
	void InitializeTargetInfoTextLayoutData(class UDataTable* Data);
	void InitializeTheurgiaLayoutData(class UDataTable* Data);
	void InitializeTheurgiaTextLayoutData(class UDataTable* TextData, class UDataTable* TextRowData, class UDataTable* TextPosData);
	void InitializeTopLayoutData(class UDataTable* Data);
	void RequestAddResources(const class FString& ResourcesPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiResourcesActor">();
	}
	static class ABtlGuiResourcesActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiResourcesActor>();
	}
};
static_assert(alignof(ABtlGuiResourcesActor) == 0x000008, "Wrong alignment on ABtlGuiResourcesActor");
static_assert(sizeof(ABtlGuiResourcesActor) == 0x000350, "Wrong size on ABtlGuiResourcesActor");
static_assert(offsetof(ABtlGuiResourcesActor, PLoadAsset) == 0x0002A0, "Member 'ABtlGuiResourcesActor::PLoadAsset' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PLoader) == 0x0002A8, "Member 'ABtlGuiResourcesActor::PLoader' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, StackLoadPath) == 0x0002B0, "Member 'ABtlGuiResourcesActor::StackLoadPath' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PItemSkillListTextDataTable) == 0x0002C0, "Member 'ABtlGuiResourcesActor::PItemSkillListTextDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTargetInfoTextDataTable) == 0x0002C8, "Member 'ABtlGuiResourcesActor::PTargetInfoTextDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTacticsListTextDataTable) == 0x0002D0, "Member 'ABtlGuiResourcesActor::PTacticsListTextDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTheurgiaDataTable) == 0x0002D8, "Member 'ABtlGuiResourcesActor::PTheurgiaDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTacticsDataTable) == 0x0002E0, "Member 'ABtlGuiResourcesActor::PTacticsDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTopDataTable) == 0x0002E8, "Member 'ABtlGuiResourcesActor::PTopDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PGuardDataTable) == 0x0002F0, "Member 'ABtlGuiResourcesActor::PGuardDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTheurgiaTextDataTable) == 0x0002F8, "Member 'ABtlGuiResourcesActor::PTheurgiaTextDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTheurgiaTextRowDataTable) == 0x000300, "Member 'ABtlGuiResourcesActor::PTheurgiaTextRowDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTheurgiaTextPosDataTable) == 0x000308, "Member 'ABtlGuiResourcesActor::PTheurgiaTextPosDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTacticsCheckDataTable) == 0x000310, "Member 'ABtlGuiResourcesActor::PTacticsCheckDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PPromiseDataTable) == 0x000318, "Member 'ABtlGuiResourcesActor::PPromiseDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PAnalyzeDataTable) == 0x000320, "Member 'ABtlGuiResourcesActor::PAnalyzeDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PAnalyzeTextDataTable) == 0x000328, "Member 'ABtlGuiResourcesActor::PAnalyzeTextDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PDamageIconDataTable) == 0x000330, "Member 'ABtlGuiResourcesActor::PDamageIconDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PRushDataTable) == 0x000338, "Member 'ABtlGuiResourcesActor::PRushDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, POthersDataTable) == 0x000340, "Member 'ABtlGuiResourcesActor::POthersDataTable' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesActor, PTouchCollDataTable) == 0x000348, "Member 'ABtlGuiResourcesActor::PTouchCollDataTable' has a wrong offset!");

// Class xrd777.BtlGuiResourcesLoadWatcher
// 0x0020 (0x02A0 - 0x0280)
class ABtlGuiResourcesLoadWatcher final : public ABtlGuiResourcesBase
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABtlGuiResourcesActor>      LoadClass;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           PLoader;                                           // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void LoadStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiResourcesLoadWatcher">();
	}
	static class ABtlGuiResourcesLoadWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiResourcesLoadWatcher>();
	}
};
static_assert(alignof(ABtlGuiResourcesLoadWatcher) == 0x000008, "Wrong alignment on ABtlGuiResourcesLoadWatcher");
static_assert(sizeof(ABtlGuiResourcesLoadWatcher) == 0x0002A0, "Wrong size on ABtlGuiResourcesLoadWatcher");
static_assert(offsetof(ABtlGuiResourcesLoadWatcher, LoadClass) == 0x000290, "Member 'ABtlGuiResourcesLoadWatcher::LoadClass' has a wrong offset!");
static_assert(offsetof(ABtlGuiResourcesLoadWatcher, PLoader) == 0x000298, "Member 'ABtlGuiResourcesLoadWatcher::PLoader' has a wrong offset!");

// Class xrd777.UIAccessInfoDraw
// 0x0E70 (0x1110 - 0x02A0)
class alignas(0x10) AUIAccessInfoDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x50];                                     // 0x02A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pMiniMapSpr;                                     // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pMiniMapSprAstrea;                               // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pPlaceSpr;                                       // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pPlaceSprAstrea;                                 // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMiniMapDraw*                         M_pMiniMap;                                        // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           M_pLoader;                                         // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScrActor*                              M_pScrActor;                                       // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBfAsset*                               M_pBfAsset;                                        // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              M_pBmdAsset;                                       // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILocationSelect*                      M_pLocationSelect;                                 // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlacePlg;                                       // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pPlacePlgAstrea;                                 // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0xB38];                                    // 0x0350(0x0B38)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_tagUip;                                          // 0x0E88(0x0078)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_tagFadeInCurve;                                  // 0x0F00(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_tagFadeOutCurve;                                 // 0x0F30(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_F60[0x58];                                     // 0x0F60(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0FB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0FC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LayoutParamData;                                   // 0x0FC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlaceNameLayoutData;                               // 0x0FD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     PlaceNameLayoutDataTable;                          // 0x0FD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlaceNameLayoutDataAstrea;                         // 0x0FE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     PlaceNameLayoutDataTableAstrea;                    // 0x0FE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MapNameLayoutData;                                 // 0x0FF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     MapNameLayoutDataTable;                            // 0x0FF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             IwatodaiFloorNoLayoutData;                         // 0x1000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     IwatodaiFloorNoLayoutDataTable;                    // 0x1008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MallFloorNoLayoutData;                             // 0x1010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     MallFloorNoLayoutDataTable;                        // 0x1018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SchoolFloorNoLayoutData;                           // 0x1020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     SchoolFloorNoLayoutDataTable;                      // 0x1028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DormitoryFloorNoLayoutData;                        // 0x1030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     DormitoryFloorNoLayoutDataTable;                   // 0x1038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RyokanFloorNoLayoutData;                           // 0x1040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     RyokanFloorNoLayoutDataTable;                      // 0x1048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HotelFloorNoLayoutData;                            // 0x1050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     HotelFloorNoLayoutDataTable;                       // 0x1058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ThebelFloorNoLayoutData;                           // 0x1060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     ThebelFloorNoLayoutDataTable;                      // 0x1068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ArqaFloorNoLayoutData;                             // 0x1070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     ArqaFloorNoLayoutDataTable;                        // 0x1078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             YabbashahFloorNoLayoutData;                        // 0x1080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     YabbashahFloorNoLayoutDataTable;                   // 0x1088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TziahFloorNoLayoutData;                            // 0x1090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TziahFloorNoLayoutDataTable;                       // 0x1098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HarabahFloorNoLayoutData;                          // 0x10A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     HarabahFloorNoLayoutDataTable;                     // 0x10A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AdamahFloorNoLayoutData;                           // 0x10B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     AdamahFloorNoLayoutDataTable;                      // 0x10B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     DungeonFloorNoLayoutDataAstrea;                    // 0x10C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UUILayoutDataTable*>             DungeonFloorNoLayoutDataTableAstrea;               // 0x10D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E0[0x30];                                    // 0x10E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAccessInfoDraw">();
	}
	static class AUIAccessInfoDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIAccessInfoDraw>();
	}
};
static_assert(alignof(AUIAccessInfoDraw) == 0x000010, "Wrong alignment on AUIAccessInfoDraw");
static_assert(sizeof(AUIAccessInfoDraw) == 0x001110, "Wrong size on AUIAccessInfoDraw");
static_assert(offsetof(AUIAccessInfoDraw, M_pMiniMapSpr) == 0x0002F0, "Member 'AUIAccessInfoDraw::M_pMiniMapSpr' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pMiniMapSprAstrea) == 0x0002F8, "Member 'AUIAccessInfoDraw::M_pMiniMapSprAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pPlaceSpr) == 0x000300, "Member 'AUIAccessInfoDraw::M_pPlaceSpr' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pPlaceSprAstrea) == 0x000308, "Member 'AUIAccessInfoDraw::M_pPlaceSprAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pMiniMap) == 0x000310, "Member 'AUIAccessInfoDraw::M_pMiniMap' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pLoader) == 0x000318, "Member 'AUIAccessInfoDraw::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pScrActor) == 0x000320, "Member 'AUIAccessInfoDraw::M_pScrActor' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pBfAsset) == 0x000328, "Member 'AUIAccessInfoDraw::M_pBfAsset' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pBmdAsset) == 0x000330, "Member 'AUIAccessInfoDraw::M_pBmdAsset' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pLocationSelect) == 0x000338, "Member 'AUIAccessInfoDraw::M_pLocationSelect' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pPlacePlg) == 0x000340, "Member 'AUIAccessInfoDraw::M_pPlacePlg' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_pPlacePlgAstrea) == 0x000348, "Member 'AUIAccessInfoDraw::M_pPlacePlgAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_tagUip) == 0x000E88, "Member 'AUIAccessInfoDraw::M_tagUip' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_tagFadeInCurve) == 0x000F00, "Member 'AUIAccessInfoDraw::M_tagFadeInCurve' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, M_tagFadeOutCurve) == 0x000F30, "Member 'AUIAccessInfoDraw::M_tagFadeOutCurve' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, LayoutData) == 0x000FB8, "Member 'AUIAccessInfoDraw::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, LayoutDataTable) == 0x000FC0, "Member 'AUIAccessInfoDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, LayoutParamData) == 0x000FC8, "Member 'AUIAccessInfoDraw::LayoutParamData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, PlaceNameLayoutData) == 0x000FD0, "Member 'AUIAccessInfoDraw::PlaceNameLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, PlaceNameLayoutDataTable) == 0x000FD8, "Member 'AUIAccessInfoDraw::PlaceNameLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, PlaceNameLayoutDataAstrea) == 0x000FE0, "Member 'AUIAccessInfoDraw::PlaceNameLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, PlaceNameLayoutDataTableAstrea) == 0x000FE8, "Member 'AUIAccessInfoDraw::PlaceNameLayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, MapNameLayoutData) == 0x000FF0, "Member 'AUIAccessInfoDraw::MapNameLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, MapNameLayoutDataTable) == 0x000FF8, "Member 'AUIAccessInfoDraw::MapNameLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, IwatodaiFloorNoLayoutData) == 0x001000, "Member 'AUIAccessInfoDraw::IwatodaiFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, IwatodaiFloorNoLayoutDataTable) == 0x001008, "Member 'AUIAccessInfoDraw::IwatodaiFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, MallFloorNoLayoutData) == 0x001010, "Member 'AUIAccessInfoDraw::MallFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, MallFloorNoLayoutDataTable) == 0x001018, "Member 'AUIAccessInfoDraw::MallFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, SchoolFloorNoLayoutData) == 0x001020, "Member 'AUIAccessInfoDraw::SchoolFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, SchoolFloorNoLayoutDataTable) == 0x001028, "Member 'AUIAccessInfoDraw::SchoolFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, DormitoryFloorNoLayoutData) == 0x001030, "Member 'AUIAccessInfoDraw::DormitoryFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, DormitoryFloorNoLayoutDataTable) == 0x001038, "Member 'AUIAccessInfoDraw::DormitoryFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, RyokanFloorNoLayoutData) == 0x001040, "Member 'AUIAccessInfoDraw::RyokanFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, RyokanFloorNoLayoutDataTable) == 0x001048, "Member 'AUIAccessInfoDraw::RyokanFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, HotelFloorNoLayoutData) == 0x001050, "Member 'AUIAccessInfoDraw::HotelFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, HotelFloorNoLayoutDataTable) == 0x001058, "Member 'AUIAccessInfoDraw::HotelFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, ThebelFloorNoLayoutData) == 0x001060, "Member 'AUIAccessInfoDraw::ThebelFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, ThebelFloorNoLayoutDataTable) == 0x001068, "Member 'AUIAccessInfoDraw::ThebelFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, ArqaFloorNoLayoutData) == 0x001070, "Member 'AUIAccessInfoDraw::ArqaFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, ArqaFloorNoLayoutDataTable) == 0x001078, "Member 'AUIAccessInfoDraw::ArqaFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, YabbashahFloorNoLayoutData) == 0x001080, "Member 'AUIAccessInfoDraw::YabbashahFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, YabbashahFloorNoLayoutDataTable) == 0x001088, "Member 'AUIAccessInfoDraw::YabbashahFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, TziahFloorNoLayoutData) == 0x001090, "Member 'AUIAccessInfoDraw::TziahFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, TziahFloorNoLayoutDataTable) == 0x001098, "Member 'AUIAccessInfoDraw::TziahFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, HarabahFloorNoLayoutData) == 0x0010A0, "Member 'AUIAccessInfoDraw::HarabahFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, HarabahFloorNoLayoutDataTable) == 0x0010A8, "Member 'AUIAccessInfoDraw::HarabahFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, AdamahFloorNoLayoutData) == 0x0010B0, "Member 'AUIAccessInfoDraw::AdamahFloorNoLayoutData' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, AdamahFloorNoLayoutDataTable) == 0x0010B8, "Member 'AUIAccessInfoDraw::AdamahFloorNoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, DungeonFloorNoLayoutDataAstrea) == 0x0010C0, "Member 'AUIAccessInfoDraw::DungeonFloorNoLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUIAccessInfoDraw, DungeonFloorNoLayoutDataTableAstrea) == 0x0010D0, "Member 'AUIAccessInfoDraw::DungeonFloorNoLayoutDataTableAstrea' has a wrong offset!");

// Class xrd777.DatPersona
// 0x0038 (0x0060 - 0x0028)
class UDatPersona final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TablePersona;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableAttr;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableName;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableGrowth;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableAllyGrowth;                                   // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TableAstreaPersonaBook;                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPersona">();
	}
	static class UDatPersona* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPersona>();
	}
};
static_assert(alignof(UDatPersona) == 0x000008, "Wrong alignment on UDatPersona");
static_assert(sizeof(UDatPersona) == 0x000060, "Wrong size on UDatPersona");
static_assert(offsetof(UDatPersona, Loader) == 0x000028, "Member 'UDatPersona::Loader' has a wrong offset!");
static_assert(offsetof(UDatPersona, TablePersona) == 0x000030, "Member 'UDatPersona::TablePersona' has a wrong offset!");
static_assert(offsetof(UDatPersona, TableAttr) == 0x000038, "Member 'UDatPersona::TableAttr' has a wrong offset!");
static_assert(offsetof(UDatPersona, TableName) == 0x000040, "Member 'UDatPersona::TableName' has a wrong offset!");
static_assert(offsetof(UDatPersona, TableGrowth) == 0x000048, "Member 'UDatPersona::TableGrowth' has a wrong offset!");
static_assert(offsetof(UDatPersona, TableAllyGrowth) == 0x000050, "Member 'UDatPersona::TableAllyGrowth' has a wrong offset!");
static_assert(offsetof(UDatPersona, TableAstreaPersonaBook) == 0x000058, "Member 'UDatPersona::TableAstreaPersonaBook' has a wrong offset!");

// Class xrd777.BtlGuiResources
// 0x0018 (0x00E0 - 0x00C8)
class UBtlGuiResources final : public UAppActorComponent
{
public:
	FMulticastInlineDelegateProperty_             AddResourcesDelegate;                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABtlGuiResourcesBase* BtlGuiResourcesCreate();
	static void BtlGuiResourcesDestroy();
	static bool CheckBtlResourcesCompleted();
	static void SetAsyncLoadCompleted();
	static void SetResourcesActor(class ABtlGuiResourcesActor* Actor);

	void GetAddResources(TSubclassOf<class UObject> ResourcesClass, class UObject** OutResources);
	void GetAddResourcesPure(TSubclassOf<class UObject> ResourcesClass, class UObject** OutResources);
	struct FVector2D GetAnalyzeAdjustedPosition(EBtlAnalyzeLayout LayoutId);
	struct FVector2D GetAnalyzeTextTextCollition(EBtlAnalyzeTextLayout LayoutId);
	class UTextureRenderTarget2D* GetAppRenderTarget(int32 Type);
	class USprAsset* GetCampSpr();
	struct FVector2D GetDamageIconAdjustedPosition(EBtlDamageIconLayout LayoutId);
	struct FVector2D GetGuardAdjustedPosition(EBtlGuardLayout LayoutId);
	class USprAsset* GetItemIconSpr();
	struct FVector GetItemSkillListTextCollision(EBtlItemSkillListTextLayout LayoutId);
	class USprAsset* GetKeyHelpSpr();
	struct FVector2D GetOthersAdjustedPosition(EBtlOthersLayout LayoutId);
	struct FVector2D GetPromiseAdjustedPosition(EBtlPromiseLayout LayoutId);
	void GetResources(class FName ResourcesName, TSubclassOf<class UObject> ResourcesClass, class UObject** OutResources);
	void GetResourcesPure(class FName ResourcesName, TSubclassOf<class UObject> ResourcesClass, class UObject** OutResources);
	struct FVector2D GetRushAdjustedPosition(EBtlRushLayout LayoutId);
	struct FVector2D GetTacticsAdjustedPosition(EBtlTacticsLayout LayoutId);
	struct FVector2D GetTacticsCheckAdjustedPosition(EBtlTacticsCheckLayout LayoutId);
	struct FVector2D GetTacticsTextCollision(EBtlTacticsListTextLayout LayoutId);
	struct FVector2D GetTargetInfoTextCollision(EBtlTargetInfoTextLayout LayoutId);
	struct FVector2D GetTheurgiaAdjustedPosition(EBtlTheurgiaLayout LayoutId);
	struct FVector2D GetTheurgiaTextPos(EUITheurgiaTextPosLayout LayoutId);
	int32 GetTheurgiaTextRow(EUITheurgiaTextRowLayout LayoutId);
	struct FVector2D GetTheurgiaTextTextCollition(EUITheurgiaTextLayout LayoutId);
	struct FVector2D GetTopAdjustedPosition(EBtlTopLayout LayoutId);
	void GetTouchCollData(EBtlTouchCollisionLayout LayoutId, float* PosX, float* PosY, float* Angle, float* Width, float* Height);
	void InitializeLayoutDebugMenu(class ABtlGuiStateManager* StateManager);
	void LoadEndAction();
	void RequestAddResources(const class FString& ResourcesPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiResources">();
	}
	static class UBtlGuiResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlGuiResources>();
	}
};
static_assert(alignof(UBtlGuiResources) == 0x000008, "Wrong alignment on UBtlGuiResources");
static_assert(sizeof(UBtlGuiResources) == 0x0000E0, "Wrong size on UBtlGuiResources");
static_assert(offsetof(UBtlGuiResources, AddResourcesDelegate) == 0x0000C8, "Member 'UBtlGuiResources::AddResourcesDelegate' has a wrong offset!");

// Class xrd777.MovieSceneEvtDialogueSection
// 0x0100 (0x01E8 - 0x00E8)
class UMovieSceneEvtDialogueSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtDialogueSectionData      EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)
	struct FNameCurve                             Events;                                            // 0x0170(0x0078)(Deprecated, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtDialogueSection">();
	}
	static class UMovieSceneEvtDialogueSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtDialogueSection>();
	}
};
static_assert(alignof(UMovieSceneEvtDialogueSection) == 0x000008, "Wrong alignment on UMovieSceneEvtDialogueSection");
static_assert(sizeof(UMovieSceneEvtDialogueSection) == 0x0001E8, "Wrong size on UMovieSceneEvtDialogueSection");
static_assert(offsetof(UMovieSceneEvtDialogueSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtDialogueSection::EventData' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtDialogueSection, Events) == 0x000170, "Member 'UMovieSceneEvtDialogueSection::Events' has a wrong offset!");

// Class xrd777.BtlGuiRushEffect
// 0x0058 (0x02D0 - 0x0278)
class ABtlGuiRushEffect : public AAppActor
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC;                                               // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x4];                                      // 0x0290(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SwitchState;                                       // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaterialOt;                                        // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RenderOt;                                          // 0x029C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetLoader*                           PLoader;                                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEffectEnable;                                     // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnimationPause;                                   // 0x02A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadComlpeted;                                    // 0x02AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBtlFlag;                                          // 0x02AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBtlGuiRushEffectParam                 DefaultEffectParam;                                // 0x02AC(0x001C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaskWidth;                                         // 0x02C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimationPause(bool Pause);
	void SetAppCanvas(int32 AppCanvas);
	void SetBtlFlag(bool Flag);
	void SetEffect(bool Enable);
	void SetOT(int32 OT);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiRushEffect">();
	}
	static class ABtlGuiRushEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiRushEffect>();
	}
};
static_assert(alignof(ABtlGuiRushEffect) == 0x000008, "Wrong alignment on ABtlGuiRushEffect");
static_assert(sizeof(ABtlGuiRushEffect) == 0x0002D0, "Wrong size on ABtlGuiRushEffect");
static_assert(offsetof(ABtlGuiRushEffect, Material) == 0x000278, "Member 'ABtlGuiRushEffect::Material' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, DynamicMaterial) == 0x000280, "Member 'ABtlGuiRushEffect::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, MPC) == 0x000288, "Member 'ABtlGuiRushEffect::MPC' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, SwitchState) == 0x000294, "Member 'ABtlGuiRushEffect::SwitchState' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, MaterialOt) == 0x000298, "Member 'ABtlGuiRushEffect::MaterialOt' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, RenderOt) == 0x00029C, "Member 'ABtlGuiRushEffect::RenderOt' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, PLoader) == 0x0002A0, "Member 'ABtlGuiRushEffect::PLoader' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, bEffectEnable) == 0x0002A8, "Member 'ABtlGuiRushEffect::bEffectEnable' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, bAnimationPause) == 0x0002A9, "Member 'ABtlGuiRushEffect::bAnimationPause' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, bLoadComlpeted) == 0x0002AA, "Member 'ABtlGuiRushEffect::bLoadComlpeted' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, bBtlFlag) == 0x0002AB, "Member 'ABtlGuiRushEffect::bBtlFlag' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, DefaultEffectParam) == 0x0002AC, "Member 'ABtlGuiRushEffect::DefaultEffectParam' has a wrong offset!");
static_assert(offsetof(ABtlGuiRushEffect, MaskWidth) == 0x0002C8, "Member 'ABtlGuiRushEffect::MaskWidth' has a wrong offset!");

// Class xrd777.CampModelControllerItem
// 0x0018 (0x0040 - 0x0028)
class UCampModelControllerItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCampModelControllerMotionItem> AnimItems;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampModelControllerItem">();
	}
	static class UCampModelControllerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampModelControllerItem>();
	}
};
static_assert(alignof(UCampModelControllerItem) == 0x000008, "Wrong alignment on UCampModelControllerItem");
static_assert(sizeof(UCampModelControllerItem) == 0x000040, "Wrong size on UCampModelControllerItem");
static_assert(offsetof(UCampModelControllerItem, AnimItems) == 0x000030, "Member 'UCampModelControllerItem::AnimItems' has a wrong offset!");

// Class xrd777.CampPlayerModelControllerItem
// 0x0020 (0x0060 - 0x0040)
class UCampPlayerModelControllerItem final : public UCampModelControllerItem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacter>                 PCharacterClass;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             PCharacter;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PDefaultMontage;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampPlayerModelControllerItem">();
	}
	static class UCampPlayerModelControllerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampPlayerModelControllerItem>();
	}
};
static_assert(alignof(UCampPlayerModelControllerItem) == 0x000008, "Wrong alignment on UCampPlayerModelControllerItem");
static_assert(sizeof(UCampPlayerModelControllerItem) == 0x000060, "Wrong size on UCampPlayerModelControllerItem");
static_assert(offsetof(UCampPlayerModelControllerItem, PCharacterClass) == 0x000048, "Member 'UCampPlayerModelControllerItem::PCharacterClass' has a wrong offset!");
static_assert(offsetof(UCampPlayerModelControllerItem, PCharacter) == 0x000050, "Member 'UCampPlayerModelControllerItem::PCharacter' has a wrong offset!");
static_assert(offsetof(UCampPlayerModelControllerItem, PDefaultMontage) == 0x000058, "Member 'UCampPlayerModelControllerItem::PDefaultMontage' has a wrong offset!");

// Class xrd777.EventSkipEffect
// 0x0000 (0x02D0 - 0x02D0)
class AEventSkipEffect final : public ABtlGuiRushEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSkipEffect">();
	}
	static class AEventSkipEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSkipEffect>();
	}
};
static_assert(alignof(AEventSkipEffect) == 0x000008, "Wrong alignment on AEventSkipEffect");
static_assert(sizeof(AEventSkipEffect) == 0x0002D0, "Wrong size on AEventSkipEffect");

// Class xrd777.MovieSceneEvtCharaPackFaceAnimationSection
// 0x0100 (0x01E8 - 0x00E8)
class UMovieSceneEvtCharaPackFaceAnimationSection final : public UMovieSceneSection
{
public:
	struct FNameCurve                             Events;                                            // 0x00E8(0x0078)(Deprecated, NativeAccessSpecifierPrivate)
	struct FMovieSceneEvtCharaPackFaceAnimationSectionData EventData;                                         // 0x0160(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPackFaceAnimationSection">();
	}
	static class UMovieSceneEvtCharaPackFaceAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPackFaceAnimationSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPackFaceAnimationSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPackFaceAnimationSection");
static_assert(sizeof(UMovieSceneEvtCharaPackFaceAnimationSection) == 0x0001E8, "Wrong size on UMovieSceneEvtCharaPackFaceAnimationSection");
static_assert(offsetof(UMovieSceneEvtCharaPackFaceAnimationSection, Events) == 0x0000E8, "Member 'UMovieSceneEvtCharaPackFaceAnimationSection::Events' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaPackFaceAnimationSection, EventData) == 0x000160, "Member 'UMovieSceneEvtCharaPackFaceAnimationSection::EventData' has a wrong offset!");

// Class xrd777.BtlGuiStateManager
// 0x0038 (0x02B0 - 0x0278)
class ABtlGuiStateManager final : public AAppActor
{
public:
	EBtlGuiState                                  NowState;                                          // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBtlGuiState                                  PrevState;                                         // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBtlGuiState>                          StateList;                                         // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             GuiStateChange;                                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GuiStateChangeParam;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ChangePrevState(bool SendFlag, int32 SendNumber);
	void ClearState();
	int32 GetDebugDamageTextIdx();
	int32 GetDebugJyokyoHelpID();
	int32 GetDebugSkillNamePanelID();
	EBtlGuiState GetPrevState();
	EBtlGuiState GetState();
	bool IsLayoutDebugMenuOpen();
	bool OnDebugRushDraw();
	bool OnDebugRushStopMaskAnimPause();
	bool OnDebugRushStopMaskVisible();
	void ResetPrevState();
	void SetPrevState(EBtlGuiState State);
	void SetState(EBtlGuiState State, bool SendFlag, int32 SendNumber);
	void UpdateLayoutDebugMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlGuiStateManager">();
	}
	static class ABtlGuiStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlGuiStateManager>();
	}
};
static_assert(alignof(ABtlGuiStateManager) == 0x000008, "Wrong alignment on ABtlGuiStateManager");
static_assert(sizeof(ABtlGuiStateManager) == 0x0002B0, "Wrong size on ABtlGuiStateManager");
static_assert(offsetof(ABtlGuiStateManager, NowState) == 0x000278, "Member 'ABtlGuiStateManager::NowState' has a wrong offset!");
static_assert(offsetof(ABtlGuiStateManager, PrevState) == 0x000279, "Member 'ABtlGuiStateManager::PrevState' has a wrong offset!");
static_assert(offsetof(ABtlGuiStateManager, StateList) == 0x000280, "Member 'ABtlGuiStateManager::StateList' has a wrong offset!");
static_assert(offsetof(ABtlGuiStateManager, GuiStateChange) == 0x000290, "Member 'ABtlGuiStateManager::GuiStateChange' has a wrong offset!");
static_assert(offsetof(ABtlGuiStateManager, GuiStateChangeParam) == 0x0002A0, "Member 'ABtlGuiStateManager::GuiStateChangeParam' has a wrong offset!");

// Class xrd777.BtlInputComponent
// 0x0198 (0x0260 - 0x00C8)
class UBtlInputComponent final : public UAppActorComponent
{
public:
	uint8                                         Pad_C8[0x23];                                      // 0x00C8(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlInputKey                           InputKey;                                          // 0x00EB(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B[0x5];                                      // 0x011B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             InputDelegate;                                     // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigRU;                                            // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigOK;                                            // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigRL;                                            // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigCANCEL;                                        // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigLU;                                            // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigLR;                                            // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigLL;                                            // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigLD;                                            // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigR1;                                            // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigL1;                                            // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigR2;                                            // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigL2;                                            // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigR3;                                            // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigL3;                                            // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigOPTION;                                        // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrigTOUCH;                                         // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x30];                                     // 0x0230(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BtlInputCheckComponentEnable(bool* Enable);
	static void BtlInputSetComponentEnable(bool IsEnable);

	void AddTouchCollCallback();
	void BtlInputAlwaysEnable(bool IsEnable);
	void BtlInputCheckCtrlEnable(bool* Enable);
	void BtlInputKeyLock(const TArray<EBtlInputKeyboardEnum>& LockKey);
	void BtlInputKeyLockClear();
	void BtlInputSetCtrlEnable(bool IsEnable);
	void CallInputTrigKeyboard(EBtlInputKeyboardEnum Key);
	void RemoveTouchCollCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlInputComponent">();
	}
	static class UBtlInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlInputComponent>();
	}
};
static_assert(alignof(UBtlInputComponent) == 0x000008, "Wrong alignment on UBtlInputComponent");
static_assert(sizeof(UBtlInputComponent) == 0x000260, "Wrong size on UBtlInputComponent");
static_assert(offsetof(UBtlInputComponent, InputKey) == 0x0000EB, "Member 'UBtlInputComponent::InputKey' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, InputDelegate) == 0x000120, "Member 'UBtlInputComponent::InputDelegate' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigRU) == 0x000130, "Member 'UBtlInputComponent::TrigRU' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigOK) == 0x000140, "Member 'UBtlInputComponent::TrigOK' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigRL) == 0x000150, "Member 'UBtlInputComponent::TrigRL' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigCANCEL) == 0x000160, "Member 'UBtlInputComponent::TrigCANCEL' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigLU) == 0x000170, "Member 'UBtlInputComponent::TrigLU' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigLR) == 0x000180, "Member 'UBtlInputComponent::TrigLR' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigLL) == 0x000190, "Member 'UBtlInputComponent::TrigLL' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigLD) == 0x0001A0, "Member 'UBtlInputComponent::TrigLD' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigR1) == 0x0001B0, "Member 'UBtlInputComponent::TrigR1' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigL1) == 0x0001C0, "Member 'UBtlInputComponent::TrigL1' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigR2) == 0x0001D0, "Member 'UBtlInputComponent::TrigR2' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigL2) == 0x0001E0, "Member 'UBtlInputComponent::TrigL2' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigR3) == 0x0001F0, "Member 'UBtlInputComponent::TrigR3' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigL3) == 0x000200, "Member 'UBtlInputComponent::TrigL3' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigOPTION) == 0x000210, "Member 'UBtlInputComponent::TrigOPTION' has a wrong offset!");
static_assert(offsetof(UBtlInputComponent, TrigTOUCH) == 0x000220, "Member 'UBtlInputComponent::TrigTOUCH' has a wrong offset!");

// Class xrd777.BtlBossVoice
// 0x0000 (0x0070 - 0x0070)
class UBtlBossVoice : public UBtlVoice
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossVoice">();
	}
	static class UBtlBossVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossVoice>();
	}
};
static_assert(alignof(UBtlBossVoice) == 0x000008, "Wrong alignment on UBtlBossVoice");
static_assert(sizeof(UBtlBossVoice) == 0x000070, "Wrong size on UBtlBossVoice");

// Class xrd777.BtlBossStregaVoice
// 0x0000 (0x0070 - 0x0070)
class UBtlBossStregaVoice final : public UBtlBossVoice
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossStregaVoice">();
	}
	static class UBtlBossStregaVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossStregaVoice>();
	}
};
static_assert(alignof(UBtlBossStregaVoice) == 0x000008, "Wrong alignment on UBtlBossStregaVoice");
static_assert(sizeof(UBtlBossStregaVoice) == 0x000070, "Wrong size on UBtlBossStregaVoice");

// Class xrd777.BtlManager
// 0x0050 (0x02C8 - 0x0278)
class ABtlManager final : public AAppActor
{
public:
	class ABtlControlBase*                        Control;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABtlControlBase>            ControlAsset;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBtlEncountParam                       Param;                                             // 0x0298(0x0024)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0xC];                                      // 0x02BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlManager">();
	}
	static class ABtlManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlManager>();
	}
};
static_assert(alignof(ABtlManager) == 0x000008, "Wrong alignment on ABtlManager");
static_assert(sizeof(ABtlManager) == 0x0002C8, "Wrong size on ABtlManager");
static_assert(offsetof(ABtlManager, Control) == 0x000278, "Member 'ABtlManager::Control' has a wrong offset!");
static_assert(offsetof(ABtlManager, Loader) == 0x000280, "Member 'ABtlManager::Loader' has a wrong offset!");
static_assert(offsetof(ABtlManager, ControlAsset) == 0x000290, "Member 'ABtlManager::ControlAsset' has a wrong offset!");
static_assert(offsetof(ABtlManager, Param) == 0x000298, "Member 'ABtlManager::Param' has a wrong offset!");

// Class xrd777.TutorialTableDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTutorialTableDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FTutorialTables>                Table;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialTableDataAsset">();
	}
	static class UTutorialTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialTableDataAsset>();
	}
};
static_assert(alignof(UTutorialTableDataAsset) == 0x000008, "Wrong alignment on UTutorialTableDataAsset");
static_assert(sizeof(UTutorialTableDataAsset) == 0x000040, "Wrong size on UTutorialTableDataAsset");
static_assert(offsetof(UTutorialTableDataAsset, Table) == 0x000030, "Member 'UTutorialTableDataAsset::Table' has a wrong offset!");

// Class xrd777.CommunityEventManager
// 0x0018 (0x0290 - 0x0278)
class ACommunityEventManager final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCommunityCallEventData>        CallEventList;                                     // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityEventManager">();
	}
	static class ACommunityEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommunityEventManager>();
	}
};
static_assert(alignof(ACommunityEventManager) == 0x000008, "Wrong alignment on ACommunityEventManager");
static_assert(sizeof(ACommunityEventManager) == 0x000290, "Wrong size on ACommunityEventManager");
static_assert(offsetof(ACommunityEventManager, CallEventList) == 0x000280, "Member 'ACommunityEventManager::CallEventList' has a wrong offset!");

// Class xrd777.BtlControlBase
// 0x0008 (0x0280 - 0x0278)
class ABtlControlBase final : public AAppActor
{
public:
	class UBtlCoreComponent*                      BtlCore;                                           // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckBattleInProgress();
	void DestroyLoadedData();
	void Encount(const struct FBtlEncountParam& EncountParam);
	bool PreLoad(const struct FBtlEncountParam& EncountParam);
	void SetGamePaused(int32 IsPause);
	bool SyncBattleFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlControlBase">();
	}
	static class ABtlControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlControlBase>();
	}
};
static_assert(alignof(ABtlControlBase) == 0x000008, "Wrong alignment on ABtlControlBase");
static_assert(sizeof(ABtlControlBase) == 0x000280, "Wrong size on ABtlControlBase");
static_assert(offsetof(ABtlControlBase, BtlCore) == 0x000278, "Member 'ABtlControlBase::BtlCore' has a wrong offset!");

// Class xrd777.BtlOrder
// 0x0020 (0x0048 - 0x0028)
class UBtlOrder final : public UObject
{
public:
	TArray<class ABtlActor*>                      InterruptList;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ABtlActor*>                      StandbyList;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlOrder">();
	}
	static class UBtlOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlOrder>();
	}
};
static_assert(alignof(UBtlOrder) == 0x000008, "Wrong alignment on UBtlOrder");
static_assert(sizeof(UBtlOrder) == 0x000048, "Wrong size on UBtlOrder");
static_assert(offsetof(UBtlOrder, InterruptList) == 0x000028, "Member 'UBtlOrder::InterruptList' has a wrong offset!");
static_assert(offsetof(UBtlOrder, StandbyList) == 0x000038, "Member 'UBtlOrder::StandbyList' has a wrong offset!");

// Class xrd777.UICampPartyPanel
// 0x0068 (0x0320 - 0x02B8)
class AUICampPartyPanel final : public ABasePartyPanel
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSprAstrea;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCampHeadPanel>                 M_aHeadPanelList;                                  // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveInAnim;                                     // 0x02E8(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICampPartyPanel">();
	}
	static class AUICampPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICampPartyPanel>();
	}
};
static_assert(alignof(AUICampPartyPanel) == 0x000008, "Wrong alignment on AUICampPartyPanel");
static_assert(sizeof(AUICampPartyPanel) == 0x000320, "Wrong size on AUICampPartyPanel");
static_assert(offsetof(AUICampPartyPanel, M_pLoader) == 0x0002C0, "Member 'AUICampPartyPanel::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUICampPartyPanel, M_pSpr) == 0x0002C8, "Member 'AUICampPartyPanel::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUICampPartyPanel, M_pSprAstrea) == 0x0002D0, "Member 'AUICampPartyPanel::M_pSprAstrea' has a wrong offset!");
static_assert(offsetof(AUICampPartyPanel, M_aHeadPanelList) == 0x0002D8, "Member 'AUICampPartyPanel::M_aHeadPanelList' has a wrong offset!");
static_assert(offsetof(AUICampPartyPanel, M_curveInAnim) == 0x0002E8, "Member 'AUICampPartyPanel::M_curveInAnim' has a wrong offset!");

// Class xrd777.DatSkill
// 0x0028 (0x0050 - 0x0028)
class UDatSkill final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableName;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableSkill;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableNormal;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableAttrName;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSkill">();
	}
	static class UDatSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSkill>();
	}
};
static_assert(alignof(UDatSkill) == 0x000008, "Wrong alignment on UDatSkill");
static_assert(sizeof(UDatSkill) == 0x000050, "Wrong size on UDatSkill");
static_assert(offsetof(UDatSkill, Loader) == 0x000028, "Member 'UDatSkill::Loader' has a wrong offset!");
static_assert(offsetof(UDatSkill, TableName) == 0x000030, "Member 'UDatSkill::TableName' has a wrong offset!");
static_assert(offsetof(UDatSkill, TableSkill) == 0x000038, "Member 'UDatSkill::TableSkill' has a wrong offset!");
static_assert(offsetof(UDatSkill, TableNormal) == 0x000040, "Member 'UDatSkill::TableNormal' has a wrong offset!");
static_assert(offsetof(UDatSkill, TableAttrName) == 0x000048, "Member 'UDatSkill::TableAttrName' has a wrong offset!");

// Class xrd777.BtlPerformanceMonitor
// 0x0000 (0x0278 - 0x0278)
class ABtlPerformanceMonitor final : public AAppActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPerformanceMonitor">();
	}
	static class ABtlPerformanceMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlPerformanceMonitor>();
	}
};
static_assert(alignof(ABtlPerformanceMonitor) == 0x000008, "Wrong alignment on ABtlPerformanceMonitor");
static_assert(sizeof(ABtlPerformanceMonitor) == 0x000278, "Wrong size on ABtlPerformanceMonitor");

// Class xrd777.MovieSceneEvtMovieSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtMovieSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtMovieSectionData         EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtMovieSection">();
	}
	static class UMovieSceneEvtMovieSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtMovieSection>();
	}
};
static_assert(alignof(UMovieSceneEvtMovieSection) == 0x000008, "Wrong alignment on UMovieSceneEvtMovieSection");
static_assert(sizeof(UMovieSceneEvtMovieSection) == 0x000170, "Wrong size on UMovieSceneEvtMovieSection");
static_assert(offsetof(UMovieSceneEvtMovieSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtMovieSection::EventData' has a wrong offset!");

// Class xrd777.BtlPhase
// 0x0008 (0x0280 - 0x0278)
class ABtlPhase : public AAppActor
{
public:
	EBtlPhaseType                                 Type;                                              // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImplementInBP;                                     // 0x0279(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABtlPhase* CreateNextPhase(EBtlPhaseType Phase);
	void FinalizePhase();
	void FinalizePhaseInBP();
	class ABtlPhase* GetNextPhase();
	class ABtlPhase* GetNextPhaseInBP();
	void SetNowBattlePhaseName(EBattlePhaseName NewPhaseName);
	void StartPhase();
	void StartPhaseInBP();
	bool SyncProgressTimingInBP();

	bool CheckProgressNextPhaseInBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPhase">();
	}
	static class ABtlPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlPhase>();
	}
};
static_assert(alignof(ABtlPhase) == 0x000008, "Wrong alignment on ABtlPhase");
static_assert(sizeof(ABtlPhase) == 0x000280, "Wrong size on ABtlPhase");
static_assert(offsetof(ABtlPhase, Type) == 0x000278, "Member 'ABtlPhase::Type' has a wrong offset!");
static_assert(offsetof(ABtlPhase, ImplementInBP) == 0x000279, "Member 'ABtlPhase::ImplementInBP' has a wrong offset!");

// Class xrd777.ChristmasEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class UChristmasEventDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FChristmasEventData>            Table;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChristmasEventDataAsset">();
	}
	static class UChristmasEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChristmasEventDataAsset>();
	}
};
static_assert(alignof(UChristmasEventDataAsset) == 0x000008, "Wrong alignment on UChristmasEventDataAsset");
static_assert(sizeof(UChristmasEventDataAsset) == 0x000040, "Wrong size on UChristmasEventDataAsset");
static_assert(offsetof(UChristmasEventDataAsset, Table) == 0x000030, "Member 'UChristmasEventDataAsset::Table' has a wrong offset!");

// Class xrd777.BtlPhaseVictory
// 0x0020 (0x02A0 - 0x0280)
class ABtlPhaseVictory : public ABtlPhase
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlCompensation*                       CompensationData;                                  // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlCoreComponent*                      BtlCore;                                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetResultType(EBtlResultType Resulttype);

	EBtlResultType GetResultType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPhaseVictory">();
	}
	static class ABtlPhaseVictory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlPhaseVictory>();
	}
};
static_assert(alignof(ABtlPhaseVictory) == 0x000008, "Wrong alignment on ABtlPhaseVictory");
static_assert(sizeof(ABtlPhaseVictory) == 0x0002A0, "Wrong size on ABtlPhaseVictory");
static_assert(offsetof(ABtlPhaseVictory, CompensationData) == 0x000288, "Member 'ABtlPhaseVictory::CompensationData' has a wrong offset!");
static_assert(offsetof(ABtlPhaseVictory, BtlCore) == 0x000290, "Member 'ABtlPhaseVictory::BtlCore' has a wrong offset!");

// Class xrd777.MovieSceneEvtFadeScreenSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtFadeScreenSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtFadeScreenSectionData    EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtFadeScreenSection">();
	}
	static class UMovieSceneEvtFadeScreenSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtFadeScreenSection>();
	}
};
static_assert(alignof(UMovieSceneEvtFadeScreenSection) == 0x000008, "Wrong alignment on UMovieSceneEvtFadeScreenSection");
static_assert(sizeof(UMovieSceneEvtFadeScreenSection) == 0x000170, "Wrong size on UMovieSceneEvtFadeScreenSection");
static_assert(offsetof(UMovieSceneEvtFadeScreenSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtFadeScreenSection::EventData' has a wrong offset!");

// Class xrd777.BtlPhaseResult
// 0x02E0 (0x0580 - 0x02A0)
class ABtlPhaseResult : public ABtlPhaseVictory
{
public:
	uint8                                         Pad_2A0[0xD0];                                     // 0x02A0(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlResultSceneBase*                    _sceneBase;                                        // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlResultUIBase*                       _uiBase;                                           // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlResultViewData*                     _ViewData;                                         // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlShuffleMainBase*                    _ShuffleMain;                                      // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlGuiDrawObjectRect*                  ReactBackGround;                                   // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlResultUIBase>           ResutlUIBp;                                        // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlShuffleMainBase>        ShuffleUIBp;                                       // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlPhase*                              PhaseVictory;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasVictoryPhase;                                   // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStartResultInVictory;                            // 0x03C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReadyForExitByVictoryPhase;                        // 0x03C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C3[0x1A5];                                    // 0x03C3(0x01A5)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FoundActors;                                       // 0x0568(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAlreadyStartResult();
	void CreatePhaseVictory();
	void PlayResultUI();
	void ReleaseResource();
	void SetHaveVictorySequence(bool Flag);
	void SetStartResultInVictory(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlPhaseResult">();
	}
	static class ABtlPhaseResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlPhaseResult>();
	}
};
static_assert(alignof(ABtlPhaseResult) == 0x000008, "Wrong alignment on ABtlPhaseResult");
static_assert(sizeof(ABtlPhaseResult) == 0x000580, "Wrong size on ABtlPhaseResult");
static_assert(offsetof(ABtlPhaseResult, _sceneBase) == 0x000370, "Member 'ABtlPhaseResult::_sceneBase' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, _uiBase) == 0x000378, "Member 'ABtlPhaseResult::_uiBase' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, _ViewData) == 0x000380, "Member 'ABtlPhaseResult::_ViewData' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, _ShuffleMain) == 0x000388, "Member 'ABtlPhaseResult::_ShuffleMain' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, ReactBackGround) == 0x000390, "Member 'ABtlPhaseResult::ReactBackGround' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, ResutlUIBp) == 0x000398, "Member 'ABtlPhaseResult::ResutlUIBp' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, ShuffleUIBp) == 0x0003A0, "Member 'ABtlPhaseResult::ShuffleUIBp' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, Loader) == 0x0003A8, "Member 'ABtlPhaseResult::Loader' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, PhaseVictory) == 0x0003B8, "Member 'ABtlPhaseResult::PhaseVictory' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, HasVictoryPhase) == 0x0003C0, "Member 'ABtlPhaseResult::HasVictoryPhase' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, IsStartResultInVictory) == 0x0003C1, "Member 'ABtlPhaseResult::IsStartResultInVictory' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, ReadyForExitByVictoryPhase) == 0x0003C2, "Member 'ABtlPhaseResult::ReadyForExitByVictoryPhase' has a wrong offset!");
static_assert(offsetof(ABtlPhaseResult, FoundActors) == 0x000568, "Member 'ABtlPhaseResult::FoundActors' has a wrong offset!");

// Class xrd777.BtlResidentDataBase
// 0x0078 (0x0140 - 0x00C8)
class UBtlResidentDataBase : public UAppActorComponent
{
public:
	class UNiagaraSystem*                         SummonVFX;                                         // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SummonShellVFX;                                    // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HitSlashVFX;                                       // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HitPierceVFX;                                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HitStrikeVFX;                                      // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ReflectionVFX;                                     // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         AbsorptionVFX;                                     // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PersonaAuraVFX;                                    // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PersonaAuraShineVFX;                               // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShadowSummonVFX;                                   // 0x0110(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShadowDeadVFX;                                     // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ShadowDeadSplashVFX;                               // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HitPierceVFX_YukariCritical;                       // 0x0128(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetLoader*                           Loader;                                            // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadedResidentData;                                // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckLoaded(EBtlResidentResource Type);
	class UNiagaraSystem* GetEffect(EBtlResidentResource Type);
	void LoadAsync();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlResidentDataBase">();
	}
	static class UBtlResidentDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlResidentDataBase>();
	}
};
static_assert(alignof(UBtlResidentDataBase) == 0x000008, "Wrong alignment on UBtlResidentDataBase");
static_assert(sizeof(UBtlResidentDataBase) == 0x000140, "Wrong size on UBtlResidentDataBase");
static_assert(offsetof(UBtlResidentDataBase, SummonVFX) == 0x0000C8, "Member 'UBtlResidentDataBase::SummonVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, SummonShellVFX) == 0x0000D0, "Member 'UBtlResidentDataBase::SummonShellVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, HitSlashVFX) == 0x0000D8, "Member 'UBtlResidentDataBase::HitSlashVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, HitPierceVFX) == 0x0000E0, "Member 'UBtlResidentDataBase::HitPierceVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, HitStrikeVFX) == 0x0000E8, "Member 'UBtlResidentDataBase::HitStrikeVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, ReflectionVFX) == 0x0000F0, "Member 'UBtlResidentDataBase::ReflectionVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, AbsorptionVFX) == 0x0000F8, "Member 'UBtlResidentDataBase::AbsorptionVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, PersonaAuraVFX) == 0x000100, "Member 'UBtlResidentDataBase::PersonaAuraVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, PersonaAuraShineVFX) == 0x000108, "Member 'UBtlResidentDataBase::PersonaAuraShineVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, ShadowSummonVFX) == 0x000110, "Member 'UBtlResidentDataBase::ShadowSummonVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, ShadowDeadVFX) == 0x000118, "Member 'UBtlResidentDataBase::ShadowDeadVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, ShadowDeadSplashVFX) == 0x000120, "Member 'UBtlResidentDataBase::ShadowDeadSplashVFX' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, HitPierceVFX_YukariCritical) == 0x000128, "Member 'UBtlResidentDataBase::HitPierceVFX_YukariCritical' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, Loader) == 0x000130, "Member 'UBtlResidentDataBase::Loader' has a wrong offset!");
static_assert(offsetof(UBtlResidentDataBase, LoadedResidentData) == 0x000138, "Member 'UBtlResidentDataBase::LoadedResidentData' has a wrong offset!");

// Class xrd777.CalendarActor
// 0x0020 (0x0298 - 0x0278)
class ACalendarActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalendarActor">();
	}
	static class ACalendarActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACalendarActor>();
	}
};
static_assert(alignof(ACalendarActor) == 0x000008, "Wrong alignment on ACalendarActor");
static_assert(sizeof(ACalendarActor) == 0x000298, "Wrong size on ACalendarActor");

// Class xrd777.BtlResultResourceManager
// 0x0190 (0x0408 - 0x0278)
class ABtlResultResourceManager final : public AAppActor
{
public:
	TSubclassOf<class ABtlResultUIBase>           ResutlUIBp;                                        // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABtlShuffleMainBase>        ShuffleUIBp;                                       // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              MessageBmd;                                        // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              SprShuffle;                                        // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              PlgShuffle;                                        // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimCardInSequence[0x8];                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimCardIn[0x5];                                   // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CardSelectEffect;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CardBonusEffect;                                   // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlShuffleArcanaManager*               ArcanaManager;                                     // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x90];                                     // 0x0320(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               AllGetDownTexture[0x4];                            // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              SprResult;                                         // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              SprResultAstrea;                                   // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              BmdResult;                                         // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAppPropsCardContainer*                 CardContainer;                                     // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlResultResourceManager">();
	}
	static class ABtlResultResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlResultResourceManager>();
	}
};
static_assert(alignof(ABtlResultResourceManager) == 0x000008, "Wrong alignment on ABtlResultResourceManager");
static_assert(sizeof(ABtlResultResourceManager) == 0x000408, "Wrong size on ABtlResultResourceManager");
static_assert(offsetof(ABtlResultResourceManager, ResutlUIBp) == 0x000278, "Member 'ABtlResultResourceManager::ResutlUIBp' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, ShuffleUIBp) == 0x000280, "Member 'ABtlResultResourceManager::ShuffleUIBp' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, MessageBmd) == 0x000288, "Member 'ABtlResultResourceManager::MessageBmd' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, SprShuffle) == 0x000290, "Member 'ABtlResultResourceManager::SprShuffle' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, PlgShuffle) == 0x000298, "Member 'ABtlResultResourceManager::PlgShuffle' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, AnimCardInSequence) == 0x0002A0, "Member 'ABtlResultResourceManager::AnimCardInSequence' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, AnimCardIn) == 0x0002E0, "Member 'ABtlResultResourceManager::AnimCardIn' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, CardSelectEffect) == 0x000308, "Member 'ABtlResultResourceManager::CardSelectEffect' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, CardBonusEffect) == 0x000310, "Member 'ABtlResultResourceManager::CardBonusEffect' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, ArcanaManager) == 0x000318, "Member 'ABtlResultResourceManager::ArcanaManager' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, AllGetDownTexture) == 0x0003B0, "Member 'ABtlResultResourceManager::AllGetDownTexture' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, SprResult) == 0x0003D0, "Member 'ABtlResultResourceManager::SprResult' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, SprResultAstrea) == 0x0003D8, "Member 'ABtlResultResourceManager::SprResultAstrea' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, BmdResult) == 0x0003E0, "Member 'ABtlResultResourceManager::BmdResult' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, CardContainer) == 0x0003E8, "Member 'ABtlResultResourceManager::CardContainer' has a wrong offset!");
static_assert(offsetof(ABtlResultResourceManager, Loader) == 0x0003F8, "Member 'ABtlResultResourceManager::Loader' has a wrong offset!");

// Class xrd777.UIBattlePartyPanel
// 0x0838 (0x0AF0 - 0x02B8)
class AUIBattlePartyPanel final : public ABasePartyPanel
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSprAstrea;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_UIParameter;                                     // 0x02D8(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0xE0];                                     // 0x0350(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBattleHeadPanel>               M_aHeadPanelList;                                  // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_uip;                                             // 0x0450(0x0078)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveDamageShake[0x4];                           // 0x04C8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveIceYScale[0x4];                             // 0x0588(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveIceAlpha[0x4];                              // 0x0648(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveThunderWave[0x4];                           // 0x0708(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveThunderWaveBone[0x4];                       // 0x07C8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveThunderWaveCharaLight[0x4];                 // 0x0888(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveThunderWaveIcons[0x4];                      // 0x0948(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveOrgiaEffect[0x4];                           // 0x0A08(0x0030)(NativeAccessSpecifierPublic)
	class UMaterialInterface*                     M_pSmokeMat;                                       // 0x0AC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               M_pSmokeMatInst;                                   // 0x0AD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     M_pSmokeMatGrey;                                   // 0x0AD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               M_pSmokeMatInstGrey;                               // 0x0AE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPartyPanelRecoveryEffect*              M_pRecoveryEffect;                                 // 0x0AE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBattlePartyPanel">();
	}
	static class AUIBattlePartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBattlePartyPanel>();
	}
};
static_assert(alignof(AUIBattlePartyPanel) == 0x000008, "Wrong alignment on AUIBattlePartyPanel");
static_assert(sizeof(AUIBattlePartyPanel) == 0x000AF0, "Wrong size on AUIBattlePartyPanel");
static_assert(offsetof(AUIBattlePartyPanel, M_pLoader) == 0x0002C0, "Member 'AUIBattlePartyPanel::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSpr) == 0x0002C8, "Member 'AUIBattlePartyPanel::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSprAstrea) == 0x0002D0, "Member 'AUIBattlePartyPanel::M_pSprAstrea' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_UIParameter) == 0x0002D8, "Member 'AUIBattlePartyPanel::M_UIParameter' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_aHeadPanelList) == 0x000430, "Member 'AUIBattlePartyPanel::M_aHeadPanelList' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_uip) == 0x000450, "Member 'AUIBattlePartyPanel::M_uip' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveDamageShake) == 0x0004C8, "Member 'AUIBattlePartyPanel::M_curveDamageShake' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveIceYScale) == 0x000588, "Member 'AUIBattlePartyPanel::M_curveIceYScale' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveIceAlpha) == 0x000648, "Member 'AUIBattlePartyPanel::M_curveIceAlpha' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveThunderWave) == 0x000708, "Member 'AUIBattlePartyPanel::M_curveThunderWave' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveThunderWaveBone) == 0x0007C8, "Member 'AUIBattlePartyPanel::M_curveThunderWaveBone' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveThunderWaveCharaLight) == 0x000888, "Member 'AUIBattlePartyPanel::M_curveThunderWaveCharaLight' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveThunderWaveIcons) == 0x000948, "Member 'AUIBattlePartyPanel::M_curveThunderWaveIcons' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_curveOrgiaEffect) == 0x000A08, "Member 'AUIBattlePartyPanel::M_curveOrgiaEffect' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSmokeMat) == 0x000AC8, "Member 'AUIBattlePartyPanel::M_pSmokeMat' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSmokeMatInst) == 0x000AD0, "Member 'AUIBattlePartyPanel::M_pSmokeMatInst' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSmokeMatGrey) == 0x000AD8, "Member 'AUIBattlePartyPanel::M_pSmokeMatGrey' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pSmokeMatInstGrey) == 0x000AE0, "Member 'AUIBattlePartyPanel::M_pSmokeMatInstGrey' has a wrong offset!");
static_assert(offsetof(AUIBattlePartyPanel, M_pRecoveryEffect) == 0x000AE8, "Member 'AUIBattlePartyPanel::M_pRecoveryEffect' has a wrong offset!");

// Class xrd777.CoefficientDataAsset
// 0x0020 (0x0050 - 0x0030)
class UCoefficientDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FCoefficientInfo>               GeneralTable;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniqCoefficient>               UniqTables;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoefficientDataAsset">();
	}
	static class UCoefficientDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoefficientDataAsset>();
	}
};
static_assert(alignof(UCoefficientDataAsset) == 0x000008, "Wrong alignment on UCoefficientDataAsset");
static_assert(sizeof(UCoefficientDataAsset) == 0x000050, "Wrong size on UCoefficientDataAsset");
static_assert(offsetof(UCoefficientDataAsset, GeneralTable) == 0x000030, "Member 'UCoefficientDataAsset::GeneralTable' has a wrong offset!");
static_assert(offsetof(UCoefficientDataAsset, UniqTables) == 0x000040, "Member 'UCoefficientDataAsset::UniqTables' has a wrong offset!");

// Class xrd777.BtlResultSceneBase
// 0x0000 (0x0278 - 0x0278)
class ABtlResultSceneBase final : public AAppActor
{
public:
	bool CheckCompleteLoadResource();
	bool CheckEndEntryScene();
	void LoadResource();
	void ReleaseResource();
	void StartEntryScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlResultSceneBase">();
	}
	static class ABtlResultSceneBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlResultSceneBase>();
	}
};
static_assert(alignof(ABtlResultSceneBase) == 0x000008, "Wrong alignment on ABtlResultSceneBase");
static_assert(sizeof(ABtlResultSceneBase) == 0x000278, "Wrong size on ABtlResultSceneBase");

// Class xrd777.BtlResultUIBase
// 0x0158 (0x03D0 - 0x0278)
class ABtlResultUIBase final : public AAppActor
{
public:
	class UBtlResultViewData*                     _ViewData;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowPlusWindos;                                  // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsCreateMsgWindow;                                 // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FoundActors;                                       // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ShowingPersonaNum;                                 // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ShowingPlayerNum;                                  // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEndPersonaStatus;                                // 0x02BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEndHeroPersona;                                  // 0x02BB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEndAllyPersona;                                  // 0x02BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APersonaStatus*                         _PersonaStatusActor;                               // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              SprResult;                                         // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              SprResultAstrea;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdResult;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               EquipPersonaTexture;                               // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlResultResourceManager*              ResultResource;                                    // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUpdateTutorial;                                 // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x1];                                      // 0x02F9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUpdateMajorArcanaGetMsg;                        // 0x02FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FB[0x15];                                     // 0x02FB(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_ArcanaGetMsgAndTutorialParameter;                // 0x0310(0x0078)(NativeAccessSpecifierPrivate)
	bool                                          IsEndPrepare;                                      // 0x0388(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutDataAstrea;                                  // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTableAstrea;                             // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TextLayoutData;                                    // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextLayoutDataTable;                               // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextLayoutData;                                  // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginMajorArcanaGetMessage();
	void BeginMajorArcanaTutorial();
	bool CalcOpenMajorArcanaMsgInfo();
	int32 CalcResultSprIdMetis(int32 PlayerId, bool IsLevelUp, int32 DefaultSprId);
	EBtlResultHeroPersonaUpEvent CalcStockUp();
	bool CheckCompleteLoadResource();
	bool CheckEndResultUI();
	bool CheckHeroStatus();
	bool CheckPersonaStatus();
	bool CheckShowMsg(int32 ID);
	bool CheckSKillGetPersona();
	void CloseHeroStatus();
	void CloseMsg();
	int32 ConvertItemSprID(int32 ItemId);
	void CreateMsg();
	void DrawMsg(int32 ID);
	void EndMajorArcanaGetMessage();
	void EndTutorialMsg();
	struct FVector2D GetAdjustedLayoutPosition(EBtlResultLayout InLayoutId, const struct FVector2D& InDefaultPos);
	struct FVector2D GetAdjustedLayoutPositionAstrea(EBtlResultLayoutAstrea InLayoutId, const struct FVector2D& InDefaultPos);
	TArray<struct FBtlResultAllyLvupParam> GetAllyLevelupParam();
	int32 GetDebugPersonaTexutreID();
	class UTexture* GetEquipPersonaTexture();
	void GetHeroHumanLvupParam(bool* IsLvup, int32* Level);
	struct FBtlResultHeroInfo GetHeroInfo();
	int32 GetItemMsgID();
	TArray<struct FBtlResultItemParam> GetItemParams();
	struct FVector2D GetOkNextLayoutPosition(EOkNextLayout InLayoutId, const struct FVector2D& InDefaultPos);
	TArray<struct FBtlResultPersonaParam> GetPersonaLevelupParam();
	class UBmdAsset* GetResultBmd();
	class USprAsset* GetSprAsset();
	class USprAsset* GetSprAssetAstrea();
	struct FVector2D GetTextCollision(EBtlResultTextLayout InLayoutId);
	float GetUipParamOfMajorArcanaAndGetMsg(const class FString& ParamKey);
	bool InputDebugButton();
	bool InputDebugButtonL();
	bool InputDebugButtonR();
	bool InputRepRUButton();
	bool InputTrigDecideButton();
	bool IsDrawComma(int32 DigCount);
	bool IsLayoutDebugMenuOpen();
	bool IsMatchMetisOfPlayerId(int32 PlayerId);
	void LoadResource();
	void NextDebugPersonaTexutreID();
	void ObtainItems();
	bool OpenMajorArcanaTutorialAstrea();
	void PrevDebugPersonaTexutreID();
	void ReleaseResource();
	void StartHeroStatus();
	void StartPersona();
	void StartResultUI(class UBtlResultViewData* InViewData);
	bool UpdateMajorArcanaGetMessage();
	void UpdatePersonaStatus();

	bool IsOpenableMajorArcanaMsgAstrea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlResultUIBase">();
	}
	static class ABtlResultUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlResultUIBase>();
	}
};
static_assert(alignof(ABtlResultUIBase) == 0x000008, "Wrong alignment on ABtlResultUIBase");
static_assert(sizeof(ABtlResultUIBase) == 0x0003D0, "Wrong size on ABtlResultUIBase");
static_assert(offsetof(ABtlResultUIBase, _ViewData) == 0x000278, "Member 'ABtlResultUIBase::_ViewData' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsShowPlusWindos) == 0x000280, "Member 'ABtlResultUIBase::IsShowPlusWindos' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsCreateMsgWindow) == 0x000288, "Member 'ABtlResultUIBase::IsCreateMsgWindow' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, FoundActors) == 0x000290, "Member 'ABtlResultUIBase::FoundActors' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, ShowingPersonaNum) == 0x0002B8, "Member 'ABtlResultUIBase::ShowingPersonaNum' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, ShowingPlayerNum) == 0x0002B9, "Member 'ABtlResultUIBase::ShowingPlayerNum' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsEndPersonaStatus) == 0x0002BA, "Member 'ABtlResultUIBase::IsEndPersonaStatus' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsEndHeroPersona) == 0x0002BB, "Member 'ABtlResultUIBase::IsEndHeroPersona' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsEndAllyPersona) == 0x0002BC, "Member 'ABtlResultUIBase::IsEndAllyPersona' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, _PersonaStatusActor) == 0x0002C0, "Member 'ABtlResultUIBase::_PersonaStatusActor' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, Loader) == 0x0002C8, "Member 'ABtlResultUIBase::Loader' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, SprResult) == 0x0002D0, "Member 'ABtlResultUIBase::SprResult' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, SprResultAstrea) == 0x0002D8, "Member 'ABtlResultUIBase::SprResultAstrea' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, BmdResult) == 0x0002E0, "Member 'ABtlResultUIBase::BmdResult' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, EquipPersonaTexture) == 0x0002E8, "Member 'ABtlResultUIBase::EquipPersonaTexture' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, ResultResource) == 0x0002F0, "Member 'ABtlResultUIBase::ResultResource' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, bIsUpdateTutorial) == 0x0002F8, "Member 'ABtlResultUIBase::bIsUpdateTutorial' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, bIsUpdateMajorArcanaGetMsg) == 0x0002FA, "Member 'ABtlResultUIBase::bIsUpdateMajorArcanaGetMsg' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, M_ArcanaGetMsgAndTutorialParameter) == 0x000310, "Member 'ABtlResultUIBase::M_ArcanaGetMsgAndTutorialParameter' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, IsEndPrepare) == 0x000388, "Member 'ABtlResultUIBase::IsEndPrepare' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, LayoutData) == 0x000390, "Member 'ABtlResultUIBase::LayoutData' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, LayoutDataAstrea) == 0x000398, "Member 'ABtlResultUIBase::LayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, LayoutDataTable) == 0x0003A0, "Member 'ABtlResultUIBase::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, LayoutDataTableAstrea) == 0x0003A8, "Member 'ABtlResultUIBase::LayoutDataTableAstrea' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, TextLayoutData) == 0x0003B0, "Member 'ABtlResultUIBase::TextLayoutData' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, TextLayoutDataTable) == 0x0003B8, "Member 'ABtlResultUIBase::TextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, OkNextLayoutData) == 0x0003C0, "Member 'ABtlResultUIBase::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(ABtlResultUIBase, OkNextLayoutDataTable) == 0x0003C8, "Member 'ABtlResultUIBase::OkNextLayoutDataTable' has a wrong offset!");

// Class xrd777.DatDlcBgmTable
// 0x0010 (0x0040 - 0x0030)
class UDatDlcBgmTable final : public UAppDataAsset
{
public:
	TArray<struct FDatDlcBgmTableData>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatDlcBgmTable">();
	}
	static class UDatDlcBgmTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatDlcBgmTable>();
	}
};
static_assert(alignof(UDatDlcBgmTable) == 0x000008, "Wrong alignment on UDatDlcBgmTable");
static_assert(sizeof(UDatDlcBgmTable) == 0x000040, "Wrong size on UDatDlcBgmTable");
static_assert(offsetof(UDatDlcBgmTable, Data) == 0x000030, "Member 'UDatDlcBgmTable::Data' has a wrong offset!");

// Class xrd777.CampLoadSequenceBase
// 0x0008 (0x0030 - 0x0028)
class UCampLoadSequenceBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampLoadSequenceBase">();
	}
	static class UCampLoadSequenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampLoadSequenceBase>();
	}
};
static_assert(alignof(UCampLoadSequenceBase) == 0x000008, "Wrong alignment on UCampLoadSequenceBase");
static_assert(sizeof(UCampLoadSequenceBase) == 0x000030, "Wrong size on UCampLoadSequenceBase");

// Class xrd777.CallFieldSequence
// 0x0000 (0x0030 - 0x0030)
class UCallFieldSequence final : public UCampLoadSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallFieldSequence">();
	}
	static class UCallFieldSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallFieldSequence>();
	}
};
static_assert(alignof(UCallFieldSequence) == 0x000008, "Wrong alignment on UCallFieldSequence");
static_assert(sizeof(UCallFieldSequence) == 0x000030, "Wrong size on UCallFieldSequence");

// Class xrd777.BtlResultViewData
// 0x0068 (0x0090 - 0x0028)
class UBtlResultViewData final : public UObject
{
public:
	int64                                         Exp;                                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Money;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 PartyAfterLevel;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HeroStatusShowFlag;                                // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x27];                                      // 0x0061(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsBonusExpArcana;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBonusExpTheurgia;                                // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlResultViewData">();
	}
	static class UBtlResultViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlResultViewData>();
	}
};
static_assert(alignof(UBtlResultViewData) == 0x000008, "Wrong alignment on UBtlResultViewData");
static_assert(sizeof(UBtlResultViewData) == 0x000090, "Wrong size on UBtlResultViewData");
static_assert(offsetof(UBtlResultViewData, Exp) == 0x000028, "Member 'UBtlResultViewData::Exp' has a wrong offset!");
static_assert(offsetof(UBtlResultViewData, Money) == 0x000030, "Member 'UBtlResultViewData::Money' has a wrong offset!");
static_assert(offsetof(UBtlResultViewData, PartyAfterLevel) == 0x000050, "Member 'UBtlResultViewData::PartyAfterLevel' has a wrong offset!");
static_assert(offsetof(UBtlResultViewData, HeroStatusShowFlag) == 0x000060, "Member 'UBtlResultViewData::HeroStatusShowFlag' has a wrong offset!");
static_assert(offsetof(UBtlResultViewData, IsBonusExpArcana) == 0x000088, "Member 'UBtlResultViewData::IsBonusExpArcana' has a wrong offset!");
static_assert(offsetof(UBtlResultViewData, IsBonusExpTheurgia) == 0x000089, "Member 'UBtlResultViewData::IsBonusExpTheurgia' has a wrong offset!");

// Class xrd777.MsgTest
// 0x0018 (0x0238 - 0x0220)
class AMsgTest final : public AActor
{
public:
	class UBmdAsset*                              MpBmdAsset;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgTest">();
	}
	static class AMsgTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMsgTest>();
	}
};
static_assert(alignof(AMsgTest) == 0x000008, "Wrong alignment on AMsgTest");
static_assert(sizeof(AMsgTest) == 0x000238, "Wrong size on AMsgTest");
static_assert(offsetof(AMsgTest, MpBmdAsset) == 0x000220, "Member 'AMsgTest::MpBmdAsset' has a wrong offset!");

// Class xrd777.BtlScriptCommandEventBattle
// 0x0048 (0x02C0 - 0x0278)
class ABtlScriptCommandEventBattle final : public AAppActor
{
public:
	uint8                                         Pad_278[0x48];                                     // 0x0278(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventBattleEnd();
	void EventBattleEventInit();
	void EventBattleEventWait();
	void EventBattleInit();
	void EventBattleLoad();
	void EventBattlePlay();
	void EventBattleSetup();
	void EventBattleWait();
	void FieldBattleEnd();
	void FieldBattleInit();
	void FieldBattleLoad();
	void FieldBattlePlay();
	void FieldBattleSetup();
	void FieldBattleWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlScriptCommandEventBattle">();
	}
	static class ABtlScriptCommandEventBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlScriptCommandEventBattle>();
	}
};
static_assert(alignof(ABtlScriptCommandEventBattle) == 0x000008, "Wrong alignment on ABtlScriptCommandEventBattle");
static_assert(sizeof(ABtlScriptCommandEventBattle) == 0x0002C0, "Wrong size on ABtlScriptCommandEventBattle");

// Class xrd777.UIDebugReceiveVoiceAction
// 0x0008 (0x02B8 - 0x02B0)
class AUIDebugReceiveVoiceAction final : public AUIVoiceBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDebugReceiveVoiceAction">();
	}
	static class AUIDebugReceiveVoiceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDebugReceiveVoiceAction>();
	}
};
static_assert(alignof(AUIDebugReceiveVoiceAction) == 0x000008, "Wrong alignment on AUIDebugReceiveVoiceAction");
static_assert(sizeof(AUIDebugReceiveVoiceAction) == 0x0002B8, "Wrong size on AUIDebugReceiveVoiceAction");

// Class xrd777.BtlSequencerObserve
// 0x0000 (0x0278 - 0x0278)
class ABtlSequencerObserve : public AAppActor
{
public:
	void SetParam(class ALevelSequenceActor* InSequenceActor, bool InStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSequencerObserve">();
	}
	static class ABtlSequencerObserve* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlSequencerObserve>();
	}
};
static_assert(alignof(ABtlSequencerObserve) == 0x000008, "Wrong alignment on ABtlSequencerObserve");
static_assert(sizeof(ABtlSequencerObserve) == 0x000278, "Wrong size on ABtlSequencerObserve");

// Class xrd777.MovieSceneEvtScriptSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtScriptSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtScriptSectionData        EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtScriptSection">();
	}
	static class UMovieSceneEvtScriptSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtScriptSection>();
	}
};
static_assert(alignof(UMovieSceneEvtScriptSection) == 0x000008, "Wrong alignment on UMovieSceneEvtScriptSection");
static_assert(sizeof(UMovieSceneEvtScriptSection) == 0x000170, "Wrong size on UMovieSceneEvtScriptSection");
static_assert(offsetof(UMovieSceneEvtScriptSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtScriptSection::EventData' has a wrong offset!");

// Class xrd777.BtlShakeManager
// 0x0030 (0x02A8 - 0x0278)
class ABtlShakeManager final : public AAppActor
{
public:
	TArray<TSubclassOf<class UMatineeCameraShake>> PresetShakeClass;                                  // 0x0278(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAssetLoader*                           Loader;                                            // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABtlShakeManager*                       ChildActor;                                        // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlShakeManager>           ShakeAsset;                                        // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABtlShakeManager* BtlShakeManagerGetInstance();
	static void BtlShakePlay(EBtlShakeType Type, float PlayTime, class APlayerController* Controller);
	static void BtlShakeStop(class APlayerController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlShakeManager">();
	}
	static class ABtlShakeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlShakeManager>();
	}
};
static_assert(alignof(ABtlShakeManager) == 0x000008, "Wrong alignment on ABtlShakeManager");
static_assert(sizeof(ABtlShakeManager) == 0x0002A8, "Wrong size on ABtlShakeManager");
static_assert(offsetof(ABtlShakeManager, PresetShakeClass) == 0x000278, "Member 'ABtlShakeManager::PresetShakeClass' has a wrong offset!");
static_assert(offsetof(ABtlShakeManager, Loader) == 0x000288, "Member 'ABtlShakeManager::Loader' has a wrong offset!");
static_assert(offsetof(ABtlShakeManager, ChildActor) == 0x000290, "Member 'ABtlShakeManager::ChildActor' has a wrong offset!");
static_assert(offsetof(ABtlShakeManager, ShakeAsset) == 0x000298, "Member 'ABtlShakeManager::ShakeAsset' has a wrong offset!");

// Class xrd777.BtlShuffleArcanaManager
// 0x0048 (0x02C0 - 0x0278)
class ABtlShuffleArcanaManager final : public AAppActor
{
public:
	TArray<int32>                                 RemainMajorArcana;                                 // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 RemainMinorArcana;                                 // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         FoundActors;                                       // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlShuffleArcanaManager">();
	}
	static class ABtlShuffleArcanaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlShuffleArcanaManager>();
	}
};
static_assert(alignof(ABtlShuffleArcanaManager) == 0x000008, "Wrong alignment on ABtlShuffleArcanaManager");
static_assert(sizeof(ABtlShuffleArcanaManager) == 0x0002C0, "Wrong size on ABtlShuffleArcanaManager");
static_assert(offsetof(ABtlShuffleArcanaManager, RemainMajorArcana) == 0x000278, "Member 'ABtlShuffleArcanaManager::RemainMajorArcana' has a wrong offset!");
static_assert(offsetof(ABtlShuffleArcanaManager, RemainMinorArcana) == 0x000288, "Member 'ABtlShuffleArcanaManager::RemainMinorArcana' has a wrong offset!");
static_assert(offsetof(ABtlShuffleArcanaManager, FoundActors) == 0x0002A8, "Member 'ABtlShuffleArcanaManager::FoundActors' has a wrong offset!");

// Class xrd777.CharacterSimpleLipsAnimAppComponent
// 0x0110 (0x01D8 - 0x00C8)
class UCharacterSimpleLipsAnimAppComponent final : public UAppActorComponent
{
public:
	class UCurveFloat*                            LipACurveDefault;                                  // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTotalLipDeltaTime;                          // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTotalTime;                                  // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequestedTotalEndTime;                             // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipsPlayRate;                                      // 0x00DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartLipsDelaySec;                                 // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LipACustomCurve;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerMajorID;                                     // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerMinorID;                                     // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterSimpleLipsAnimAppListener    CurrentLipsyncParam;                               // 0x00F8(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharBaseComp*                       AppCharacterComponent;                             // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipA_PropPath;                                     // 0x0138(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipI_PropPath;                                     // 0x0158(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipU_PropPath;                                     // 0x0178(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipE_PropPath;                                     // 0x0198(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipO_PropPath;                                     // 0x01B8(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindPropsPtr();
	void OnChangeLipsState(ECharacterSimpleLipsAnimAppStateType LipSyncAppStateType, const struct FCharacterSimpleLipsAnimAppListener& LipsyncParam);

	class UCharacterSimpleLipsAnimAppSubsystem* GetLipsSubsystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSimpleLipsAnimAppComponent">();
	}
	static class UCharacterSimpleLipsAnimAppComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSimpleLipsAnimAppComponent>();
	}
};
static_assert(alignof(UCharacterSimpleLipsAnimAppComponent) == 0x000008, "Wrong alignment on UCharacterSimpleLipsAnimAppComponent");
static_assert(sizeof(UCharacterSimpleLipsAnimAppComponent) == 0x0001D8, "Wrong size on UCharacterSimpleLipsAnimAppComponent");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipACurveDefault) == 0x0000C8, "Member 'UCharacterSimpleLipsAnimAppComponent::LipACurveDefault' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, CurrentTotalLipDeltaTime) == 0x0000D0, "Member 'UCharacterSimpleLipsAnimAppComponent::CurrentTotalLipDeltaTime' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, CurrentTotalTime) == 0x0000D4, "Member 'UCharacterSimpleLipsAnimAppComponent::CurrentTotalTime' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, RequestedTotalEndTime) == 0x0000D8, "Member 'UCharacterSimpleLipsAnimAppComponent::RequestedTotalEndTime' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipsPlayRate) == 0x0000DC, "Member 'UCharacterSimpleLipsAnimAppComponent::LipsPlayRate' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, StartLipsDelaySec) == 0x0000E0, "Member 'UCharacterSimpleLipsAnimAppComponent::StartLipsDelaySec' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipACustomCurve) == 0x0000E8, "Member 'UCharacterSimpleLipsAnimAppComponent::LipACustomCurve' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, PlayerMajorID) == 0x0000F0, "Member 'UCharacterSimpleLipsAnimAppComponent::PlayerMajorID' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, PlayerMinorID) == 0x0000F4, "Member 'UCharacterSimpleLipsAnimAppComponent::PlayerMinorID' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, CurrentLipsyncParam) == 0x0000F8, "Member 'UCharacterSimpleLipsAnimAppComponent::CurrentLipsyncParam' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, OwnerMesh) == 0x000128, "Member 'UCharacterSimpleLipsAnimAppComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, AppCharacterComponent) == 0x000130, "Member 'UCharacterSimpleLipsAnimAppComponent::AppCharacterComponent' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipA_PropPath) == 0x000138, "Member 'UCharacterSimpleLipsAnimAppComponent::LipA_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipI_PropPath) == 0x000158, "Member 'UCharacterSimpleLipsAnimAppComponent::LipI_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipU_PropPath) == 0x000178, "Member 'UCharacterSimpleLipsAnimAppComponent::LipU_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipE_PropPath) == 0x000198, "Member 'UCharacterSimpleLipsAnimAppComponent::LipE_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppComponent, LipO_PropPath) == 0x0001B8, "Member 'UCharacterSimpleLipsAnimAppComponent::LipO_PropPath' has a wrong offset!");

// Class xrd777.BtlShuffleMainBase
// 0x0D60 (0x0FD8 - 0x0278)
class ABtlShuffleMainBase final : public AAppActor
{
public:
	uint8                                         Pad_278[0x94];                                     // 0x0278(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectCoursorIndex;                                // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowCardsMax;                                      // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableSelectNum;                                   // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstSelect;                                     // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStopButton;                                      // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A[0x26];                                     // 0x031A(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedCardNum;                                   // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionCardIndex;                                   // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartMajorArcanaEffect;                          // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlShuffleCardState                          EffectMessagePage;                                 // 0x0349(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x2];                                      // 0x034A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PersonaSelectCoursorIndex;                         // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersonaSelectState;                                // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x2];                                      // 0x0354(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsStartCharaAnime;                                 // 0x0356(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357[0x5];                                      // 0x0357(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllGetBonousMessageIndex;                          // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBtlShuffleCardState                          AllGetBonousEffectMessageIndex;                    // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndCardInAnime;                                  // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndPersonaListInFlag;                            // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndArcanaBurstInFlag;                            // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 AppearMajors;                                      // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x18];                                     // 0x0380(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              SprShuffle;                                        // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PlgShuffle;                                        // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTutorialManager*                       PTutorialManager;                                  // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBmdAsset*                              MessageBmd;                                        // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               AllGetDownTexture[0x4];                            // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlGuiDrawObjectMsg*                   MsgShuffle;                                        // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBtlCompensation*                       CompensationData;                                  // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABtlShuffleArcanaManager*               ArcanaManager;                                     // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBtlShufflePersonaList*                 PersonaList;                                       // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x9C0];                                    // 0x0408(0x09C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimCardInSequence[0x8];                           // 0x0DC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      AnimCardIn[0x5];                                   // 0x0E08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         CardSelectEffect;                                  // 0x0E30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         CardBonusEffect;                                   // 0x0E38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAppPropsCardContainer*                 CardContainer;                                     // 0x0E40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FShuffleCardInfo>               CardInfos;                                         // 0x0E48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E58[0x38];                                     // 0x0E58(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class APersonaStatus*                         _PersonaStatusActor;                               // 0x0E90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E98[0x40];                                     // 0x0E98(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ABtlResultResourceManager*              ResultResource;                                    // 0x0ED8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EE0[0x8];                                      // 0x0EE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_EffectCardPosInfo;                               // 0x0EE8(0x0078)(NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0F60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextLayoutDataTable;                               // 0x0F68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F70[0x68];                                     // 0x0F70(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionCancel(int32 Idx);
	void ActionCardInStateEffect(int32 Idx);
	void ActionOnemore();
	void ActionSelectCard(int32 Idx);
	void CardFallDraw();
	void CardFallInit();
	void CardFallUpdate(float DeltaTime);
	void ChangeCardRotationSpeed(int32 Idx);
	void ChangePersonaStatusLeft(int32 Cursor);
	void ChangePersonaStatusRight(int32 Cursor);
	void ChangeStateAllGetBonus();
	void ChangeStateEffectAllGetBonus();
	void ChangeStateEffectCard();
	void ChangeStateEnter();
	void ChangeStateExit();
	void ChangeStateSelectCard();
	void ChangeStateSelectCardAllGetBonus();
	void ChangeStateSelectPersona();
	void ChangeTextureEffectCard();
	bool CheckAllGetBonusMode();
	bool CheckAlloutMode();
	bool CheckChangeCard();
	bool CheckCompleteLoadResource();
	bool CheckCursorSlectedArcana(int32 Idx);
	bool CheckDoubleDraw();
	bool CheckEnableShuffletime();
	bool CheckLoadCardResource();
	bool CheckNewCard(int32 Idx);
	bool CheckShowMsg(int32 ID);
	bool CheckShowPersonaStatus();
	void CloseMsg();
	void ClosePersonaStatus();
	void CreateMsg();
	void CreatePersonaStatus();
	void EndStateAllGetBonus();
	void EndStateEffectAllGetBonus();
	void EndStateEffectCard();
	void EndStateEnter();
	void EndStateExit();
	void EndStateSelectCard();
	void EndStateSelectCardAllGetBonus();
	void EndStateSelectPersona();
	struct FVector2D GetAdjustedPosition(EBtlShuffleLayout InLayoutId);
	class UTexture* GetAllGetTexture(int32 Idx);
	void GetAppearCard(int32 Idx, struct FAppPropsCardParam* Output, bool IsBonusCard);
	void GetAppearCardInfoDetail(int32 Idx, int32* Type, int32* Rank, int32* Value, int32* Value2, bool IsBonusCard);
	void GetAxisR(float* X, float* Y);
	class UBmdAsset* GetBmdAsset();
	float GetEffectCardPosX(int32 TargetCardIndex);
	int32 GetHaveItemNumBySelectCard(int32 Idx, bool IsBonusCard);
	TArray<int32> GetHaveMajorArcana();
	class UAnimSequenceBase* GetInAnime(int32 Idx);
	int32 GetItemNumSelectCard(int32 Idx, bool IsBonusCard);
	int32 GetMaxNumMajorArcana();
	int32 GetMegNoDetailArcanaSelectCard(int32 Idx, int32 MinorId, bool IsBonusCard);
	class FString GetNameMajorArcana(int32 ID);
	class FString GetNamePersona(int32 ID);
	class UPlgAsset* GetPlgAsset();
	int32 GetRemainNumMajorArcana();
	int32 GetSelectedCardIndex(int32 SelectIdx);
	class USprAsset* GetSprAsset();
	struct FVector GetTextCollision(EBtlShuffleTextLayout InLayoutId);
	void InitLayoutDataTable(class UDataTable* PLayoutData, class UDataTable* PTextLayoutData);
	void LoadResource();
	void LoadTimeCardEnd();
	void LoadTimeCardStart();
	void PlayOnemore();
	void PrepareStateAllGetBonus();
	void PrepareStateEffectAllGetBonus();
	void PrepareStateEffectCard();
	void PrepareStateEnter();
	void PrepareStateExit();
	void PrepareStateSelectCard();
	void PrepareStateSelectCardAllGetBonus();
	void PrepareStateSelectPersona();
	void ReleaseResource();
	void ReleaseTutorialStopper();
	void RunStateAllGetBonus(float DeltaTime);
	void RunStateEffectAllGetBonus(float DeltaTime);
	void RunStateEffectCard(float DeltaTime);
	void RunStateEnter(float DeltaTime);
	void RunStateExit(float DeltaTime);
	void RunStateSelectCard(float DeltaTime);
	void RunStateSelectCardAllGetBonus(float DeltaTime);
	void RunStateSelectPersona(float DeltaTime);
	void SecondTextCardInStateEffect(int32 Idx);
	void SetAlphaPersonaList(float Alpha);
	void SetBmdValue(class UBtlGuiDrawObjectMsg* PMsg, const class FString& Value1, const class FString& Value2, const class FString& Value3, const class FString& Value4);
	void SetEndArcanaBurstInFlag(bool Value);
	void SetEndCardInAnime(bool Input);
	void SetEndPersonaListInFlag(bool Value);
	void SetKeyHelp(EBtlShuffleKeyHelpState State);
	void SetMsgVariableSelectCard(class UBtlGuiDrawObjectMsg* PMsg, int32 Idx, int32 PersonaID, bool IsBonusCard);
	void SetPersonaSkillHelp(bool Use);
	void SetPosPersonaList(const struct FVector2D& InPos);
	void SetTouchCollision(int32 Index_0, float X, float Y, float Width, float Height, EUI_DRAW_POINT DrawPoint);
	void StartingCardSelect();
	void StartLoadCardResource();
	void StartMsg(int32 ID);
	void UpdateCardRotation(float DeltaTime, int32 Idx);

	bool IsInMonadDoorAndNormalOrMore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlShuffleMainBase">();
	}
	static class ABtlShuffleMainBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlShuffleMainBase>();
	}
};
static_assert(alignof(ABtlShuffleMainBase) == 0x000008, "Wrong alignment on ABtlShuffleMainBase");
static_assert(sizeof(ABtlShuffleMainBase) == 0x000FD8, "Wrong size on ABtlShuffleMainBase");
static_assert(offsetof(ABtlShuffleMainBase, SelectCoursorIndex) == 0x00030C, "Member 'ABtlShuffleMainBase::SelectCoursorIndex' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, ShowCardsMax) == 0x000310, "Member 'ABtlShuffleMainBase::ShowCardsMax' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, EnableSelectNum) == 0x000314, "Member 'ABtlShuffleMainBase::EnableSelectNum' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsFirstSelect) == 0x000318, "Member 'ABtlShuffleMainBase::IsFirstSelect' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsStopButton) == 0x000319, "Member 'ABtlShuffleMainBase::IsStopButton' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, SelectedCardNum) == 0x000340, "Member 'ABtlShuffleMainBase::SelectedCardNum' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, ActionCardIndex) == 0x000344, "Member 'ABtlShuffleMainBase::ActionCardIndex' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsStartMajorArcanaEffect) == 0x000348, "Member 'ABtlShuffleMainBase::IsStartMajorArcanaEffect' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, EffectMessagePage) == 0x000349, "Member 'ABtlShuffleMainBase::EffectMessagePage' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, PersonaSelectCoursorIndex) == 0x00034C, "Member 'ABtlShuffleMainBase::PersonaSelectCoursorIndex' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, PersonaSelectState) == 0x000350, "Member 'ABtlShuffleMainBase::PersonaSelectState' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsStartCharaAnime) == 0x000356, "Member 'ABtlShuffleMainBase::IsStartCharaAnime' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AllGetBonousMessageIndex) == 0x00035C, "Member 'ABtlShuffleMainBase::AllGetBonousMessageIndex' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AllGetBonousEffectMessageIndex) == 0x000360, "Member 'ABtlShuffleMainBase::AllGetBonousEffectMessageIndex' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsEndCardInAnime) == 0x000361, "Member 'ABtlShuffleMainBase::IsEndCardInAnime' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsEndPersonaListInFlag) == 0x000362, "Member 'ABtlShuffleMainBase::IsEndPersonaListInFlag' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, IsEndArcanaBurstInFlag) == 0x000363, "Member 'ABtlShuffleMainBase::IsEndArcanaBurstInFlag' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AppearMajors) == 0x000370, "Member 'ABtlShuffleMainBase::AppearMajors' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, Loader) == 0x000398, "Member 'ABtlShuffleMainBase::Loader' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, SprShuffle) == 0x0003A0, "Member 'ABtlShuffleMainBase::SprShuffle' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, PlgShuffle) == 0x0003A8, "Member 'ABtlShuffleMainBase::PlgShuffle' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, PTutorialManager) == 0x0003B0, "Member 'ABtlShuffleMainBase::PTutorialManager' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, MessageBmd) == 0x0003B8, "Member 'ABtlShuffleMainBase::MessageBmd' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AllGetDownTexture) == 0x0003C0, "Member 'ABtlShuffleMainBase::AllGetDownTexture' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, MsgShuffle) == 0x0003E0, "Member 'ABtlShuffleMainBase::MsgShuffle' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, CompensationData) == 0x0003E8, "Member 'ABtlShuffleMainBase::CompensationData' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, ArcanaManager) == 0x0003F0, "Member 'ABtlShuffleMainBase::ArcanaManager' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, PersonaList) == 0x000400, "Member 'ABtlShuffleMainBase::PersonaList' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AnimCardInSequence) == 0x000DC8, "Member 'ABtlShuffleMainBase::AnimCardInSequence' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, AnimCardIn) == 0x000E08, "Member 'ABtlShuffleMainBase::AnimCardIn' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, CardSelectEffect) == 0x000E30, "Member 'ABtlShuffleMainBase::CardSelectEffect' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, CardBonusEffect) == 0x000E38, "Member 'ABtlShuffleMainBase::CardBonusEffect' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, CardContainer) == 0x000E40, "Member 'ABtlShuffleMainBase::CardContainer' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, CardInfos) == 0x000E48, "Member 'ABtlShuffleMainBase::CardInfos' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, _PersonaStatusActor) == 0x000E90, "Member 'ABtlShuffleMainBase::_PersonaStatusActor' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, ResultResource) == 0x000ED8, "Member 'ABtlShuffleMainBase::ResultResource' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, M_EffectCardPosInfo) == 0x000EE8, "Member 'ABtlShuffleMainBase::M_EffectCardPosInfo' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, LayoutDataTable) == 0x000F60, "Member 'ABtlShuffleMainBase::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(ABtlShuffleMainBase, TextLayoutDataTable) == 0x000F68, "Member 'ABtlShuffleMainBase::TextLayoutDataTable' has a wrong offset!");

// Class xrd777.SoundPlayerActor
// 0x0008 (0x0280 - 0x0278)
class ASoundPlayerActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPlayerActor">();
	}
	static class ASoundPlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundPlayerActor>();
	}
};
static_assert(alignof(ASoundPlayerActor) == 0x000008, "Wrong alignment on ASoundPlayerActor");
static_assert(sizeof(ASoundPlayerActor) == 0x000280, "Wrong size on ASoundPlayerActor");

// Class xrd777.BtlShufflePersonaList
// 0x0A38 (0x0A60 - 0x0028)
class UBtlShufflePersonaList final : public UObject
{
public:
	uint8                                         Pad_28[0xA38];                                     // 0x0028(0x0A38)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlShufflePersonaList">();
	}
	static class UBtlShufflePersonaList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlShufflePersonaList>();
	}
};
static_assert(alignof(UBtlShufflePersonaList) == 0x000008, "Wrong alignment on UBtlShufflePersonaList");
static_assert(sizeof(UBtlShufflePersonaList) == 0x000A60, "Wrong size on UBtlShufflePersonaList");

// Class xrd777.BtlSkill
// 0x0060 (0x02D8 - 0x0278)
class ABtlSkill : public AAppActor
{
public:
	TArray<struct FBtlSkillParam>                 EffectList;                                        // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DestroyTime;                                       // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTime;                                        // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitUntilDestroy;                                  // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBtlSkillCameraEffectParam             CameraEffect;                                      // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          QuickAbsorptionEffectWhenAbsorptionOnly;           // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnvAnimTime;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLightEnvParam;                                  // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightIntensityRatio;                               // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFogEnvParam;                                    // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FogPower;                                          // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDistance;                                       // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogGradationRange;                                 // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBGBlack;                                        // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BGBlackPower;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnlyAbsorptionMode;                              // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcOnlyAbsorptionTime(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSkill">();
	}
	static class ABtlSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtlSkill>();
	}
};
static_assert(alignof(ABtlSkill) == 0x000008, "Wrong alignment on ABtlSkill");
static_assert(sizeof(ABtlSkill) == 0x0002D8, "Wrong size on ABtlSkill");
static_assert(offsetof(ABtlSkill, EffectList) == 0x000278, "Member 'ABtlSkill::EffectList' has a wrong offset!");
static_assert(offsetof(ABtlSkill, DestroyTime) == 0x000288, "Member 'ABtlSkill::DestroyTime' has a wrong offset!");
static_assert(offsetof(ABtlSkill, DamageTime) == 0x00028C, "Member 'ABtlSkill::DamageTime' has a wrong offset!");
static_assert(offsetof(ABtlSkill, WaitUntilDestroy) == 0x000290, "Member 'ABtlSkill::WaitUntilDestroy' has a wrong offset!");
static_assert(offsetof(ABtlSkill, CameraEffect) == 0x000298, "Member 'ABtlSkill::CameraEffect' has a wrong offset!");
static_assert(offsetof(ABtlSkill, QuickAbsorptionEffectWhenAbsorptionOnly) == 0x0002A8, "Member 'ABtlSkill::QuickAbsorptionEffectWhenAbsorptionOnly' has a wrong offset!");
static_assert(offsetof(ABtlSkill, EnvAnimTime) == 0x0002AC, "Member 'ABtlSkill::EnvAnimTime' has a wrong offset!");
static_assert(offsetof(ABtlSkill, UseLightEnvParam) == 0x0002B0, "Member 'ABtlSkill::UseLightEnvParam' has a wrong offset!");
static_assert(offsetof(ABtlSkill, LightIntensityRatio) == 0x0002B4, "Member 'ABtlSkill::LightIntensityRatio' has a wrong offset!");
static_assert(offsetof(ABtlSkill, UseFogEnvParam) == 0x0002B8, "Member 'ABtlSkill::UseFogEnvParam' has a wrong offset!");
static_assert(offsetof(ABtlSkill, FogPower) == 0x0002BC, "Member 'ABtlSkill::FogPower' has a wrong offset!");
static_assert(offsetof(ABtlSkill, FogDistance) == 0x0002C0, "Member 'ABtlSkill::FogDistance' has a wrong offset!");
static_assert(offsetof(ABtlSkill, FogGradationRange) == 0x0002C4, "Member 'ABtlSkill::FogGradationRange' has a wrong offset!");
static_assert(offsetof(ABtlSkill, UseBGBlack) == 0x0002C8, "Member 'ABtlSkill::UseBGBlack' has a wrong offset!");
static_assert(offsetof(ABtlSkill, BGBlackPower) == 0x0002CC, "Member 'ABtlSkill::BGBlackPower' has a wrong offset!");
static_assert(offsetof(ABtlSkill, IsOnlyAbsorptionMode) == 0x0002D0, "Member 'ABtlSkill::IsOnlyAbsorptionMode' has a wrong offset!");

// Class xrd777.SuzukiDrawTestDraw
// 0x0070 (0x0328 - 0x02B8)
class ASuzukiDrawTestDraw final : public AUIDrawBaseActor
{
public:
	class UMaterialInstance*                      PMaterial;                                         // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PParamMateDynamic;                                 // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PPlgAsset;                                         // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              PCaptureMaterial;                                  // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PBackgroundMaterial;                               // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               PCaptureTexture;                                   // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               PModelCaptureTex;                                  // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APreviewWorldUpdater*                   PWorldUpdater_;                                    // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         State;                                             // 0x02F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFrameBufferCapture*                    CaptureBackGround;                                 // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FromBPDraw(float X, float Y, float Angle);
	bool SyncModelCapture(const struct FTransform& ModelTransform, const struct FVector& NewGazeOffset);
	void Update(const float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuzukiDrawTestDraw">();
	}
	static class ASuzukiDrawTestDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuzukiDrawTestDraw>();
	}
};
static_assert(alignof(ASuzukiDrawTestDraw) == 0x000008, "Wrong alignment on ASuzukiDrawTestDraw");
static_assert(sizeof(ASuzukiDrawTestDraw) == 0x000328, "Wrong size on ASuzukiDrawTestDraw");
static_assert(offsetof(ASuzukiDrawTestDraw, PMaterial) == 0x0002B8, "Member 'ASuzukiDrawTestDraw::PMaterial' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PParamMateDynamic) == 0x0002C0, "Member 'ASuzukiDrawTestDraw::PParamMateDynamic' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PPlgAsset) == 0x0002C8, "Member 'ASuzukiDrawTestDraw::PPlgAsset' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PCaptureMaterial) == 0x0002D0, "Member 'ASuzukiDrawTestDraw::PCaptureMaterial' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PBackgroundMaterial) == 0x0002D8, "Member 'ASuzukiDrawTestDraw::PBackgroundMaterial' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PCaptureTexture) == 0x0002E0, "Member 'ASuzukiDrawTestDraw::PCaptureTexture' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PModelCaptureTex) == 0x0002E8, "Member 'ASuzukiDrawTestDraw::PModelCaptureTex' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, PWorldUpdater_) == 0x0002F0, "Member 'ASuzukiDrawTestDraw::PWorldUpdater_' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, State) == 0x0002F8, "Member 'ASuzukiDrawTestDraw::State' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTestDraw, CaptureBackGround) == 0x000300, "Member 'ASuzukiDrawTestDraw::CaptureBackGround' has a wrong offset!");

// Class xrd777.CmpSkill
// 0x0128 (0x0160 - 0x0038)
class UCmpSkill final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0xC8];                                      // 0x0038(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpSkillDraw*                          PSkillDraw;                                        // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpSkillSystem*                        PSkillSystem;                                      // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSkill">();
	}
	static class UCmpSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSkill>();
	}
};
static_assert(alignof(UCmpSkill) == 0x000008, "Wrong alignment on UCmpSkill");
static_assert(sizeof(UCmpSkill) == 0x000160, "Wrong size on UCmpSkill");
static_assert(offsetof(UCmpSkill, PSkillDraw) == 0x000100, "Member 'UCmpSkill::PSkillDraw' has a wrong offset!");
static_assert(offsetof(UCmpSkill, PSkillSystem) == 0x000108, "Member 'UCmpSkill::PSkillSystem' has a wrong offset!");

// Class xrd777.BtlSkillGeneratorComponent
// 0x0030 (0x00E0 - 0x00B0)
class UBtlSkillGeneratorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             HasFinishedSkillLoad;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABtlSkill*                              PSkill;                                            // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABtlSkill>                  SkillAsset;                                        // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LoadRequested;                                     // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABtlSkill* GetSkill();
	bool RequestCreateSkill(int32 SkillId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSkillGeneratorComponent">();
	}
	static class UBtlSkillGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSkillGeneratorComponent>();
	}
};
static_assert(alignof(UBtlSkillGeneratorComponent) == 0x000008, "Wrong alignment on UBtlSkillGeneratorComponent");
static_assert(sizeof(UBtlSkillGeneratorComponent) == 0x0000E0, "Wrong size on UBtlSkillGeneratorComponent");
static_assert(offsetof(UBtlSkillGeneratorComponent, HasFinishedSkillLoad) == 0x0000B0, "Member 'UBtlSkillGeneratorComponent::HasFinishedSkillLoad' has a wrong offset!");
static_assert(offsetof(UBtlSkillGeneratorComponent, PSkill) == 0x0000C0, "Member 'UBtlSkillGeneratorComponent::PSkill' has a wrong offset!");
static_assert(offsetof(UBtlSkillGeneratorComponent, SkillAsset) == 0x0000C8, "Member 'UBtlSkillGeneratorComponent::SkillAsset' has a wrong offset!");
static_assert(offsetof(UBtlSkillGeneratorComponent, Loader) == 0x0000D0, "Member 'UBtlSkillGeneratorComponent::Loader' has a wrong offset!");
static_assert(offsetof(UBtlSkillGeneratorComponent, LoadRequested) == 0x0000D8, "Member 'UBtlSkillGeneratorComponent::LoadRequested' has a wrong offset!");

// Class xrd777.BtlSoundBPFuncLib
// 0x0000 (0x0028 - 0x0028)
class UBtlSoundBPFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void BtlPCVoicePlay(class ABtlActor* Actor, int32 CueId);
	static void BtlPCVoicePlay_Command(class ABtlActor* Actor);
	static void BtlPCVoicePlay_HeroUI(class ABtlActor* Actor, int32 Type);
	static void BtlPCVoicePlay_ShiftSelect(class ABtlActor* Actor);
	static void BtlPCVoicePlayNotLipsync(class ABtlActor* Actor, int32 CueId);
	static void BtlSEPlay(int32 CueId);
	static void BtlSEPlayCANCEL();
	static void BtlSEPlayCRITICAL();
	static void BtlSEPlayCURSOR();
	static void BtlSEPlayDECIDE();
	static void BtlSEPlayDOWN();
	static void BtlSEPlayERROR();
	static void BtlSEPlayPAGE();
	static void BtlSEPlayPANELOPEN();
	static void BtlSEPlaySHIFT();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSoundBPFuncLib">();
	}
	static class UBtlSoundBPFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSoundBPFuncLib>();
	}
};
static_assert(alignof(UBtlSoundBPFuncLib) == 0x000008, "Wrong alignment on UBtlSoundBPFuncLib");
static_assert(sizeof(UBtlSoundBPFuncLib) == 0x000028, "Wrong size on UBtlSoundBPFuncLib");

// Class xrd777.DatMiniMapInfo
// 0x0028 (0x0058 - 0x0030)
class UDatMiniMapInfo final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMiniMapInfoTable>              M_aInfoList;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatMiniMapInfo">();
	}
	static class UDatMiniMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatMiniMapInfo>();
	}
};
static_assert(alignof(UDatMiniMapInfo) == 0x000008, "Wrong alignment on UDatMiniMapInfo");
static_assert(sizeof(UDatMiniMapInfo) == 0x000058, "Wrong size on UDatMiniMapInfo");
static_assert(offsetof(UDatMiniMapInfo, M_aInfoList) == 0x000048, "Member 'UDatMiniMapInfo::M_aInfoList' has a wrong offset!");

// Class xrd777.BtlSpecificEventBattle
// 0x0000 (0x0030 - 0x0030)
class UBtlSpecificEventBattle final : public UBtlBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSpecificEventBattle">();
	}
	static class UBtlSpecificEventBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSpecificEventBattle>();
	}
};
static_assert(alignof(UBtlSpecificEventBattle) == 0x000008, "Wrong alignment on UBtlSpecificEventBattle");
static_assert(sizeof(UBtlSpecificEventBattle) == 0x000030, "Wrong size on UBtlSpecificEventBattle");

// Class xrd777.MyBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMyBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyBlueprintFunctionLibrary">();
	}
	static class UMyBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMyBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMyBlueprintFunctionLibrary");
static_assert(sizeof(UMyBlueprintFunctionLibrary) == 0x000028, "Wrong size on UMyBlueprintFunctionLibrary");

// Class xrd777.BtlSupportInfoCommonOnly
// 0x0000 (0x0070 - 0x0070)
class UBtlSupportInfoCommonOnly final : public UBtlSupportInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportInfoCommonOnly">();
	}
	static class UBtlSupportInfoCommonOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportInfoCommonOnly>();
	}
};
static_assert(alignof(UBtlSupportInfoCommonOnly) == 0x000008, "Wrong alignment on UBtlSupportInfoCommonOnly");
static_assert(sizeof(UBtlSupportInfoCommonOnly) == 0x000070, "Wrong size on UBtlSupportInfoCommonOnly");

// Class xrd777.DailyChangeVoiceActionViewer
// 0x0038 (0x02C8 - 0x0290)
class ADailyChangeVoiceActionViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x28];                                     // 0x0290(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIDebugReceiveVoiceAction*             MVoiceConnect_;                                    // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyChangeVoiceActionViewer">();
	}
	static class ADailyChangeVoiceActionViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADailyChangeVoiceActionViewer>();
	}
};
static_assert(alignof(ADailyChangeVoiceActionViewer) == 0x000008, "Wrong alignment on ADailyChangeVoiceActionViewer");
static_assert(sizeof(ADailyChangeVoiceActionViewer) == 0x0002C8, "Wrong size on ADailyChangeVoiceActionViewer");
static_assert(offsetof(ADailyChangeVoiceActionViewer, MVoiceConnect_) == 0x0002B8, "Member 'ADailyChangeVoiceActionViewer::MVoiceConnect_' has a wrong offset!");

// Class xrd777.BtlSupportInfoFuka
// 0x0000 (0x0070 - 0x0070)
class UBtlSupportInfoFuka final : public UBtlSupportInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportInfoFuka">();
	}
	static class UBtlSupportInfoFuka* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportInfoFuka>();
	}
};
static_assert(alignof(UBtlSupportInfoFuka) == 0x000008, "Wrong alignment on UBtlSupportInfoFuka");
static_assert(sizeof(UBtlSupportInfoFuka) == 0x000070, "Wrong size on UBtlSupportInfoFuka");

// Class xrd777.SteamInputLibrary
// 0x0000 (0x0028 - 0x0028)
class USteamInputLibrary final : public UBlueprintFunctionLibrary
{
public:
	static ESteamControllerType GetInputTypeName(int32 NIndex);
	static void SteamInitializeLanguage();
	static bool SteamInputInitialize();
	static bool SteamInputPadPress_L1();
	static bool SteamInputPadPress_L2();
	static bool SteamInputPadPress_L3();
	static bool SteamInputPadPress_LeftDown();
	static bool SteamInputPadPress_LeftLeft();
	static bool SteamInputPadPress_LeftRight();
	static bool SteamInputPadPress_LeftUp();
	static bool SteamInputPadPress_R1();
	static bool SteamInputPadPress_R2();
	static bool SteamInputPadPress_R3();
	static bool SteamInputPadPress_RightDown();
	static bool SteamInputPadPress_RightLeft();
	static bool SteamInputPadPress_RightRight();
	static bool SteamInputPadPress_RightUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamInputLibrary">();
	}
	static class USteamInputLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamInputLibrary>();
	}
};
static_assert(alignof(USteamInputLibrary) == 0x000008, "Wrong alignment on USteamInputLibrary");
static_assert(sizeof(USteamInputLibrary) == 0x000028, "Wrong size on USteamInputLibrary");

// Class xrd777.BtlSupportInfoMessage
// 0x00A0 (0x00C8 - 0x0028)
class UBtlSupportInfoMessage final : public UObject
{
public:
	class UBmdAsset*                              CommonBmdAsset;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              CurrentNaviBmdAsset;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDatSupportInfo*                        CommonDataAsset;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDatSupportInfo*                        CurrentNaviDataAsset;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           Loader;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommonBmdpath;                                     // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CommonTablepath;                                   // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentNaviBmdpath;                                // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentNaviTablepath;                              // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportInfoMessage">();
	}
	static class UBtlSupportInfoMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportInfoMessage>();
	}
};
static_assert(alignof(UBtlSupportInfoMessage) == 0x000008, "Wrong alignment on UBtlSupportInfoMessage");
static_assert(sizeof(UBtlSupportInfoMessage) == 0x0000C8, "Wrong size on UBtlSupportInfoMessage");
static_assert(offsetof(UBtlSupportInfoMessage, CommonBmdAsset) == 0x000028, "Member 'UBtlSupportInfoMessage::CommonBmdAsset' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CurrentNaviBmdAsset) == 0x000030, "Member 'UBtlSupportInfoMessage::CurrentNaviBmdAsset' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CommonDataAsset) == 0x000038, "Member 'UBtlSupportInfoMessage::CommonDataAsset' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CurrentNaviDataAsset) == 0x000040, "Member 'UBtlSupportInfoMessage::CurrentNaviDataAsset' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, Loader) == 0x000048, "Member 'UBtlSupportInfoMessage::Loader' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CommonBmdpath) == 0x000070, "Member 'UBtlSupportInfoMessage::CommonBmdpath' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CommonTablepath) == 0x000080, "Member 'UBtlSupportInfoMessage::CommonTablepath' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CurrentNaviBmdpath) == 0x000090, "Member 'UBtlSupportInfoMessage::CurrentNaviBmdpath' has a wrong offset!");
static_assert(offsetof(UBtlSupportInfoMessage, CurrentNaviTablepath) == 0x0000A0, "Member 'UBtlSupportInfoMessage::CurrentNaviTablepath' has a wrong offset!");

// Class xrd777.BtlSupportSound
// 0x0000 (0x0028 - 0x0028)
class UBtlSupportSound final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlSupportSound">();
	}
	static class UBtlSupportSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlSupportSound>();
	}
};
static_assert(alignof(UBtlSupportSound) == 0x000008, "Wrong alignment on UBtlSupportSound");
static_assert(sizeof(UBtlSupportSound) == 0x000028, "Wrong size on UBtlSupportSound");

// Class xrd777.BtlTargetsManagerComponent
// 0x0038 (0x0100 - 0x00C8)
class UBtlTargetsManagerComponent : public UAppActorComponent
{
public:
	TArray<class ABtlActor*>                      Targets;                                           // 0x00C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABtlActor*>                      EffectTargets;                                     // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABtlActor*>                      CursorTargets;                                     // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABtlActor*                              MainCharacter;                                     // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Clear();
	void ClearForBP();
	TArray<class ABtlActor*> GetCursorTargets();
	TArray<class ABtlActor*> GetEffectTargets();
	class ABtlActor* GetMainCharacter();
	TArray<class ABtlActor*> GetTargets();
	void SetCursorTargets(const TArray<class ABtlActor*>& List);
	void SetMainCharacter(class ABtlActor* Character);
	void SetTargets(const TArray<class ABtlActor*>& List);

	bool CheckTargetIsLatestActionCharacter(class UBtlCoreComponent* PCore) const;
	bool CheckTargetIsNextActionCharacter(class UBtlCoreComponent* PCore) const;
	const TArray<class ABtlActor*> GetConstTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTargetsManagerComponent">();
	}
	static class UBtlTargetsManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTargetsManagerComponent>();
	}
};
static_assert(alignof(UBtlTargetsManagerComponent) == 0x000008, "Wrong alignment on UBtlTargetsManagerComponent");
static_assert(sizeof(UBtlTargetsManagerComponent) == 0x000100, "Wrong size on UBtlTargetsManagerComponent");
static_assert(offsetof(UBtlTargetsManagerComponent, Targets) == 0x0000C8, "Member 'UBtlTargetsManagerComponent::Targets' has a wrong offset!");
static_assert(offsetof(UBtlTargetsManagerComponent, EffectTargets) == 0x0000D8, "Member 'UBtlTargetsManagerComponent::EffectTargets' has a wrong offset!");
static_assert(offsetof(UBtlTargetsManagerComponent, CursorTargets) == 0x0000E8, "Member 'UBtlTargetsManagerComponent::CursorTargets' has a wrong offset!");
static_assert(offsetof(UBtlTargetsManagerComponent, MainCharacter) == 0x0000F8, "Member 'UBtlTargetsManagerComponent::MainCharacter' has a wrong offset!");

// Class xrd777.BtlTutorial2nd
// 0x0008 (0x0038 - 0x0030)
class UBtlTutorial2nd final : public UBtlTutorialBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorial2nd">();
	}
	static class UBtlTutorial2nd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorial2nd>();
	}
};
static_assert(alignof(UBtlTutorial2nd) == 0x000008, "Wrong alignment on UBtlTutorial2nd");
static_assert(sizeof(UBtlTutorial2nd) == 0x000038, "Wrong size on UBtlTutorial2nd");

// Class xrd777.BtlTutorialTheurgia
// 0x0008 (0x0038 - 0x0030)
class UBtlTutorialTheurgia final : public UBtlBoss
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlTutorialTheurgia">();
	}
	static class UBtlTutorialTheurgia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlTutorialTheurgia>();
	}
};
static_assert(alignof(UBtlTutorialTheurgia) == 0x000008, "Wrong alignment on UBtlTutorialTheurgia");
static_assert(sizeof(UBtlTutorialTheurgia) == 0x000038, "Wrong size on UBtlTutorialTheurgia");

// Class xrd777.BtlBossNyxAvatarVoice
// 0x0000 (0x0070 - 0x0070)
class UBtlBossNyxAvatarVoice final : public UBtlBossVoice
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtlBossNyxAvatarVoice">();
	}
	static class UBtlBossNyxAvatarVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBtlBossNyxAvatarVoice>();
	}
};
static_assert(alignof(UBtlBossNyxAvatarVoice) == 0x000008, "Wrong alignment on UBtlBossNyxAvatarVoice");
static_assert(sizeof(UBtlBossNyxAvatarVoice) == 0x000070, "Wrong size on UBtlBossNyxAvatarVoice");

// Class xrd777.BustupObject
// 0x0100 (0x0128 - 0x0028)
class UBustupObject final : public UObject
{
public:
	class UMaterialInterface*                     BaseMaterial_;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DrawableMaterial_[0x2];                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               BaseTex_;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               ShadowMask_;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               RimLightMask_;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               EyeTex_[0x3];                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               MouthTex_[0x3];                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               BlushTex_;                                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               SweatTex_;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               BaseMask_;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               DropMask_;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader_;                                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupAnimDataAsset*                   BustupAnim_;                                       // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USupportBustupDataAsset*                SupportBustupOffset_;                              // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupObject">();
	}
	static class UBustupObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupObject>();
	}
};
static_assert(alignof(UBustupObject) == 0x000008, "Wrong alignment on UBustupObject");
static_assert(sizeof(UBustupObject) == 0x000128, "Wrong size on UBustupObject");
static_assert(offsetof(UBustupObject, BaseMaterial_) == 0x000028, "Member 'UBustupObject::BaseMaterial_' has a wrong offset!");
static_assert(offsetof(UBustupObject, DrawableMaterial_) == 0x000030, "Member 'UBustupObject::DrawableMaterial_' has a wrong offset!");
static_assert(offsetof(UBustupObject, BaseTex_) == 0x000040, "Member 'UBustupObject::BaseTex_' has a wrong offset!");
static_assert(offsetof(UBustupObject, ShadowMask_) == 0x000048, "Member 'UBustupObject::ShadowMask_' has a wrong offset!");
static_assert(offsetof(UBustupObject, RimLightMask_) == 0x000050, "Member 'UBustupObject::RimLightMask_' has a wrong offset!");
static_assert(offsetof(UBustupObject, EyeTex_) == 0x000058, "Member 'UBustupObject::EyeTex_' has a wrong offset!");
static_assert(offsetof(UBustupObject, MouthTex_) == 0x000070, "Member 'UBustupObject::MouthTex_' has a wrong offset!");
static_assert(offsetof(UBustupObject, BlushTex_) == 0x000088, "Member 'UBustupObject::BlushTex_' has a wrong offset!");
static_assert(offsetof(UBustupObject, SweatTex_) == 0x000090, "Member 'UBustupObject::SweatTex_' has a wrong offset!");
static_assert(offsetof(UBustupObject, BaseMask_) == 0x000098, "Member 'UBustupObject::BaseMask_' has a wrong offset!");
static_assert(offsetof(UBustupObject, DropMask_) == 0x0000A0, "Member 'UBustupObject::DropMask_' has a wrong offset!");
static_assert(offsetof(UBustupObject, Loader_) == 0x0000A8, "Member 'UBustupObject::Loader_' has a wrong offset!");
static_assert(offsetof(UBustupObject, BustupAnim_) == 0x000118, "Member 'UBustupObject::BustupAnim_' has a wrong offset!");
static_assert(offsetof(UBustupObject, SupportBustupOffset_) == 0x000120, "Member 'UBustupObject::SupportBustupOffset_' has a wrong offset!");

// Class xrd777.BustupModel
// 0x0020 (0x0048 - 0x0028)
class UBustupModel final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupDraw*                            PBustupDraw;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupModel">();
	}
	static class UBustupModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupModel>();
	}
};
static_assert(alignof(UBustupModel) == 0x000008, "Wrong alignment on UBustupModel");
static_assert(sizeof(UBustupModel) == 0x000048, "Wrong size on UBustupModel");
static_assert(offsetof(UBustupModel, PBustupDraw) == 0x000040, "Member 'UBustupModel::PBustupDraw' has a wrong offset!");

// Class xrd777.Calendar
// 0x00A0 (0x00C8 - 0x0028)
class UCalendar final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class ACldBindingEventActor*                  MEventActor_;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MChangeFlag_;                                      // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldSceneChangeType                           MChangeType_;                                      // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldSceneChangeType                           MChangeSetted_;                                    // 0x00AD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MChangePrevDay_;                                   // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldTimeZone                                  MChangePrevTimeZone_;                              // 0x00B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MChangeNextDay_;                                   // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECldTimeZone                                  MChangeNextTimeZone_;                              // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CursorDay;                                         // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Calendar">();
	}
	static class UCalendar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalendar>();
	}
};
static_assert(alignof(UCalendar) == 0x000008, "Wrong alignment on UCalendar");
static_assert(sizeof(UCalendar) == 0x0000C8, "Wrong size on UCalendar");
static_assert(offsetof(UCalendar, MEventActor_) == 0x0000A0, "Member 'UCalendar::MEventActor_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangeFlag_) == 0x0000A8, "Member 'UCalendar::MChangeFlag_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangeType_) == 0x0000AC, "Member 'UCalendar::MChangeType_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangeSetted_) == 0x0000AD, "Member 'UCalendar::MChangeSetted_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangePrevDay_) == 0x0000B0, "Member 'UCalendar::MChangePrevDay_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangePrevTimeZone_) == 0x0000B4, "Member 'UCalendar::MChangePrevTimeZone_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangeNextDay_) == 0x0000B8, "Member 'UCalendar::MChangeNextDay_' has a wrong offset!");
static_assert(offsetof(UCalendar, MChangeNextTimeZone_) == 0x0000BC, "Member 'UCalendar::MChangeNextTimeZone_' has a wrong offset!");
static_assert(offsetof(UCalendar, CursorDay) == 0x0000C0, "Member 'UCalendar::CursorDay' has a wrong offset!");

// Class xrd777.CampModelController
// 0x0020 (0x0048 - 0x0028)
class UCampModelController final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCampModelControllerItem*>       Items;                                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampModelController">();
	}
	static class UCampModelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampModelController>();
	}
};
static_assert(alignof(UCampModelController) == 0x000008, "Wrong alignment on UCampModelController");
static_assert(sizeof(UCampModelController) == 0x000048, "Wrong size on UCampModelController");
static_assert(offsetof(UCampModelController, PAssetLoader) == 0x000030, "Member 'UCampModelController::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UCampModelController, Items) == 0x000038, "Member 'UCampModelController::Items' has a wrong offset!");

// Class xrd777.CharacterLipsyncAppComponent
// 0x00D8 (0x01A0 - 0x00C8)
class UCharacterLipsyncAppComponent final : public UAppActorComponent
{
public:
	struct FLipsyncAppListener                    CurrentLipsyncParam;                               // 0x00C8(0x0014)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharBaseComp*                       AppCharacterComponent;                             // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipA_PropPath;                                     // 0x00F0(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipI_PropPath;                                     // 0x0110(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipU_PropPath;                                     // 0x0130(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipE_PropPath;                                     // 0x0150(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TFieldPath<struct FFloatProperty>             LipO_PropPath;                                     // 0x0170(0x0020)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MCurrentTotalTime;                                 // 0x0190(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MLipACurveDefault;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindLipPropsPtr();
	void OnChangeLipsyncState(ELipSyncAppStateType LipSyncAppStateType, const struct FLipsyncAppListener& LipsyncParam);

	class ULipsyncAppObserverSubsystem* GetLipsyncSubsystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterLipsyncAppComponent">();
	}
	static class UCharacterLipsyncAppComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterLipsyncAppComponent>();
	}
};
static_assert(alignof(UCharacterLipsyncAppComponent) == 0x000008, "Wrong alignment on UCharacterLipsyncAppComponent");
static_assert(sizeof(UCharacterLipsyncAppComponent) == 0x0001A0, "Wrong size on UCharacterLipsyncAppComponent");
static_assert(offsetof(UCharacterLipsyncAppComponent, CurrentLipsyncParam) == 0x0000C8, "Member 'UCharacterLipsyncAppComponent::CurrentLipsyncParam' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, OwnerMesh) == 0x0000E0, "Member 'UCharacterLipsyncAppComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, AppCharacterComponent) == 0x0000E8, "Member 'UCharacterLipsyncAppComponent::AppCharacterComponent' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, LipA_PropPath) == 0x0000F0, "Member 'UCharacterLipsyncAppComponent::LipA_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, LipI_PropPath) == 0x000110, "Member 'UCharacterLipsyncAppComponent::LipI_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, LipU_PropPath) == 0x000130, "Member 'UCharacterLipsyncAppComponent::LipU_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, LipE_PropPath) == 0x000150, "Member 'UCharacterLipsyncAppComponent::LipE_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, LipO_PropPath) == 0x000170, "Member 'UCharacterLipsyncAppComponent::LipO_PropPath' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, MCurrentTotalTime) == 0x000190, "Member 'UCharacterLipsyncAppComponent::MCurrentTotalTime' has a wrong offset!");
static_assert(offsetof(UCharacterLipsyncAppComponent, MLipACurveDefault) == 0x000198, "Member 'UCharacterLipsyncAppComponent::MLipACurveDefault' has a wrong offset!");

// Class xrd777.CharacterSimpleLipsAnimAppSubsystem
// 0x0060 (0x0090 - 0x0030)
class UCharacterSimpleLipsAnimAppSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             LipsAppDelegate;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, struct FCharacterSimpleLipsAnimAppListener> SpeakCharacterMap;                                 // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void FinishSpeakCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID);
	void FinishSpeakCharacterPtr(class AActor* ActorPtr);
	void StartSpeakCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID, float RequestedSpeakTotalTime, bool bOverride);
	void StartSpeakCharacterPtr(class AActor* ActorPtr, float RequestedSpeakTotalTime, int32 MajorPlayerID, int32 MinorPlayerID, bool bOverride);
	void StartSpeakCharacterWithCustomParam(const struct FCharacterSimpleLipsAnimAppParam& SimpleLipsParam, bool bOverride);
	void StopAllSpeakCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSimpleLipsAnimAppSubsystem">();
	}
	static class UCharacterSimpleLipsAnimAppSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSimpleLipsAnimAppSubsystem>();
	}
};
static_assert(alignof(UCharacterSimpleLipsAnimAppSubsystem) == 0x000008, "Wrong alignment on UCharacterSimpleLipsAnimAppSubsystem");
static_assert(sizeof(UCharacterSimpleLipsAnimAppSubsystem) == 0x000090, "Wrong size on UCharacterSimpleLipsAnimAppSubsystem");
static_assert(offsetof(UCharacterSimpleLipsAnimAppSubsystem, LipsAppDelegate) == 0x000030, "Member 'UCharacterSimpleLipsAnimAppSubsystem::LipsAppDelegate' has a wrong offset!");
static_assert(offsetof(UCharacterSimpleLipsAnimAppSubsystem, SpeakCharacterMap) == 0x000040, "Member 'UCharacterSimpleLipsAnimAppSubsystem::SpeakCharacterMap' has a wrong offset!");

// Class xrd777.CldBpFuncLib
// 0x0000 (0x0028 - 0x0028)
class UCldBpFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckWinterCloth();
	static bool CldCheckDayDispInOut();
	static ECldDayDispState CldGetDayDispState();
	static void CldSetDrawDayDisp(ECldDayDispState Flag);
	static void CldSetDrawDayDispIm(ECldDayDispState Flag);
	static int32 GetNowMoonAge();
	static ECldSeason GetNowSeason();
	static int32 GetNowTime();
	static ECldTimeZone GetNowTimeZone();
	static int32 GetNowTotalDay();
	static void GetNowTotalToDayMon(int32* Month, int32* Day);
	static bool GetNowYasumi();
	static int32 GetNowYoubi();
	static int32 GetTotalDayFromSeason(ECldSeason Season);
	static void SetNowTimeZone(ECldTimeZone TimeZone);
	static void SetNowTotalDay(int32 TotalDay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldBpFuncLib">();
	}
	static class UCldBpFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldBpFuncLib>();
	}
};
static_assert(alignof(UCldBpFuncLib) == 0x000008, "Wrong alignment on UCldBpFuncLib");
static_assert(sizeof(UCldBpFuncLib) == 0x000028, "Wrong size on UCldBpFuncLib");

// Class xrd777.CldCommonData
// 0x0038 (0x0060 - 0x0028)
class UCldCommonData final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACldCmnDataActor*                       MActor_;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCldDateDataAsset*                      MDatesData_;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 MBpClass_[0x2];                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldCommonData">();
	}
	static class UCldCommonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldCommonData>();
	}
};
static_assert(alignof(UCldCommonData) == 0x000008, "Wrong alignment on UCldCommonData");
static_assert(sizeof(UCldCommonData) == 0x000060, "Wrong size on UCldCommonData");
static_assert(offsetof(UCldCommonData, MActor_) == 0x000030, "Member 'UCldCommonData::MActor_' has a wrong offset!");
static_assert(offsetof(UCldCommonData, MDatesData_) == 0x000048, "Member 'UCldCommonData::MDatesData_' has a wrong offset!");
static_assert(offsetof(UCldCommonData, MBpClass_) == 0x000050, "Member 'UCldCommonData::MBpClass_' has a wrong offset!");

// Class xrd777.CldDateMessageDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCldDateMessageDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FCldDateMessageMonth>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldDateMessageDataAsset">();
	}
	static class UCldDateMessageDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldDateMessageDataAsset>();
	}
};
static_assert(alignof(UCldDateMessageDataAsset) == 0x000008, "Wrong alignment on UCldDateMessageDataAsset");
static_assert(sizeof(UCldDateMessageDataAsset) == 0x000040, "Wrong size on UCldDateMessageDataAsset");
static_assert(offsetof(UCldDateMessageDataAsset, Data) == 0x000030, "Member 'UCldDateMessageDataAsset::Data' has a wrong offset!");

// Class xrd777.CldSchedulerActor
// 0x0050 (0x02C8 - 0x0278)
class ACldSchedulerActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIVoiceConnect*                        MVoiceConnect_;                                    // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 MBpClass_;                                         // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUtlProcActor*                          MProcActor_;                                       // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetBpObjEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldSchedulerActor">();
	}
	static class ACldSchedulerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACldSchedulerActor>();
	}
};
static_assert(alignof(ACldSchedulerActor) == 0x000008, "Wrong alignment on ACldSchedulerActor");
static_assert(sizeof(ACldSchedulerActor) == 0x0002C8, "Wrong size on ACldSchedulerActor");
static_assert(offsetof(ACldSchedulerActor, MVoiceConnect_) == 0x000288, "Member 'ACldSchedulerActor::MVoiceConnect_' has a wrong offset!");
static_assert(offsetof(ACldSchedulerActor, MAssetLoader_) == 0x0002B0, "Member 'ACldSchedulerActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(ACldSchedulerActor, MBpClass_) == 0x0002B8, "Member 'ACldSchedulerActor::MBpClass_' has a wrong offset!");
static_assert(offsetof(ACldSchedulerActor, MProcActor_) == 0x0002C0, "Member 'ACldSchedulerActor::MProcActor_' has a wrong offset!");

// Class xrd777.UtlProcActor
// 0x0038 (0x02B0 - 0x0278)
class AUtlProcActor : public AAppActor
{
public:
	FMulticastInlineDelegateProperty_             MEndDelegate_;                                     // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x28];                                     // 0x0288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestBfSettedFile(const class UObject* WorldContextObject, int32 ProcNo, const struct FLatentActionInfo& LatentInfo, int32* Result);
	void Return();
	void ReturnField();
	void StartProc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtlProcActor">();
	}
	static class AUtlProcActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUtlProcActor>();
	}
};
static_assert(alignof(AUtlProcActor) == 0x000008, "Wrong alignment on AUtlProcActor");
static_assert(sizeof(AUtlProcActor) == 0x0002B0, "Wrong size on AUtlProcActor");
static_assert(offsetof(AUtlProcActor, MEndDelegate_) == 0x000278, "Member 'AUtlProcActor::MEndDelegate_' has a wrong offset!");

// Class xrd777.CldSchedulerProcActor
// 0x0000 (0x02B0 - 0x02B0)
class ACldSchedulerProcActor final : public AUtlProcActor
{
public:
	void AfterSchool();
	void AM();
	void CallNextTime();
	void EarlyMorning();
	void Midnight();
	void Morning();
	void Night();
	void Noon();
	void PM();
	void ShadowTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldSchedulerProcActor">();
	}
	static class ACldSchedulerProcActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACldSchedulerProcActor>();
	}
};
static_assert(alignof(ACldSchedulerProcActor) == 0x000008, "Wrong alignment on ACldSchedulerProcActor");
static_assert(sizeof(ACldSchedulerProcActor) == 0x0002B0, "Wrong size on ACldSchedulerProcActor");

// Class xrd777.CldTableTypes
// 0x0000 (0x0028 - 0x0028)
class UCldTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CldTableTypes">();
	}
	static class UCldTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCldTableTypes>();
	}
};
static_assert(alignof(UCldTableTypes) == 0x000008, "Wrong alignment on UCldTableTypes");
static_assert(sizeof(UCldTableTypes) == 0x000028, "Wrong size on UCldTableTypes");

// Class xrd777.CmpCalendar
// 0x0018 (0x0050 - 0x0038)
class UCmpCalendar final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader_;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmpCalendar*                         Actor_;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCalendar">();
	}
	static class UCmpCalendar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCalendar>();
	}
};
static_assert(alignof(UCmpCalendar) == 0x000008, "Wrong alignment on UCmpCalendar");
static_assert(sizeof(UCmpCalendar) == 0x000050, "Wrong size on UCmpCalendar");
static_assert(offsetof(UCmpCalendar, AssetLoader_) == 0x000040, "Member 'UCmpCalendar::AssetLoader_' has a wrong offset!");
static_assert(offsetof(UCmpCalendar, Actor_) == 0x000048, "Member 'UCmpCalendar::Actor_' has a wrong offset!");

// Class xrd777.CmpCharacterStatus
// 0x0058 (0x0098 - 0x0040)
class UCmpCharacterStatus final : public UUIScene
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpHeroHumanStatus*                    HeroStatus_;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICmpStatus*                           Owner_;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCharacterStatus">();
	}
	static class UCmpCharacterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCharacterStatus>();
	}
};
static_assert(alignof(UCmpCharacterStatus) == 0x000008, "Wrong alignment on UCmpCharacterStatus");
static_assert(sizeof(UCmpCharacterStatus) == 0x000098, "Wrong size on UCmpCharacterStatus");
static_assert(offsetof(UCmpCharacterStatus, HeroStatus_) == 0x000058, "Member 'UCmpCharacterStatus::HeroStatus_' has a wrong offset!");
static_assert(offsetof(UCmpCharacterStatus, Owner_) == 0x000060, "Member 'UCmpCharacterStatus::Owner_' has a wrong offset!");

// Class xrd777.CmpCommu
// 0x0C28 (0x0C60 - 0x0038)
class UCmpCommu final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             PCommuBustupAry[0x1C];                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0xB08];                                    // 0x0140(0x0B08)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader_;                                      // 0x0C48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmpCommu*                            Actor_;                                            // 0x0C50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpCommuModelController*               PModelController;                                  // 0x0C58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCommu">();
	}
	static class UCmpCommu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCommu>();
	}
};
static_assert(alignof(UCmpCommu) == 0x000008, "Wrong alignment on UCmpCommu");
static_assert(sizeof(UCmpCommu) == 0x000C60, "Wrong size on UCmpCommu");
static_assert(offsetof(UCmpCommu, PCommuBustupAry) == 0x000060, "Member 'UCmpCommu::PCommuBustupAry' has a wrong offset!");
static_assert(offsetof(UCmpCommu, AssetLoader_) == 0x000C48, "Member 'UCmpCommu::AssetLoader_' has a wrong offset!");
static_assert(offsetof(UCmpCommu, Actor_) == 0x000C50, "Member 'UCmpCommu::Actor_' has a wrong offset!");
static_assert(offsetof(UCmpCommu, PModelController) == 0x000C58, "Member 'UCmpCommu::PModelController' has a wrong offset!");

// Class xrd777.CmpCommuList
// 0x0510 (0x0550 - 0x0040)
class UCmpCommuList final : public UUIScene
{
public:
	uint8                                         Pad_40[0x480];                                     // 0x0040(0x0480)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpCommu*                            Context_;                                          // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmpCommu*                            PParent;                                           // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x78];                                     // 0x04D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCommuList">();
	}
	static class UCmpCommuList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCommuList>();
	}
};
static_assert(alignof(UCmpCommuList) == 0x000008, "Wrong alignment on UCmpCommuList");
static_assert(sizeof(UCmpCommuList) == 0x000550, "Wrong size on UCmpCommuList");
static_assert(offsetof(UCmpCommuList, Context_) == 0x0004C0, "Member 'UCmpCommuList::Context_' has a wrong offset!");
static_assert(offsetof(UCmpCommuList, PParent) == 0x0004C8, "Member 'UCmpCommuList::PParent' has a wrong offset!");
static_assert(offsetof(UCmpCommuList, PMainActor) == 0x0004D0, "Member 'UCmpCommuList::PMainActor' has a wrong offset!");

// Class xrd777.CmpCommuModelController
// 0x0070 (0x02E8 - 0x0278)
class ACmpCommuModelController final : public AAppActor
{
public:
	uint8                                         Pad_278[0x38];                                     // 0x0278(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppPropsCardContainer*                 PCardContainer;                                    // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppPropsCore*                          PCardBp;                                           // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     PTextures;                                         // 0x02C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAnimSequence*>                  PMotions;                                          // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCommuModelController">();
	}
	static class ACmpCommuModelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACmpCommuModelController>();
	}
};
static_assert(alignof(ACmpCommuModelController) == 0x000008, "Wrong alignment on ACmpCommuModelController");
static_assert(sizeof(ACmpCommuModelController) == 0x0002E8, "Wrong size on ACmpCommuModelController");
static_assert(offsetof(ACmpCommuModelController, PMainActor) == 0x0002B0, "Member 'ACmpCommuModelController::PMainActor' has a wrong offset!");
static_assert(offsetof(ACmpCommuModelController, PCardContainer) == 0x0002B8, "Member 'ACmpCommuModelController::PCardContainer' has a wrong offset!");
static_assert(offsetof(ACmpCommuModelController, PCardBp) == 0x0002C0, "Member 'ACmpCommuModelController::PCardBp' has a wrong offset!");
static_assert(offsetof(ACmpCommuModelController, PTextures) == 0x0002C8, "Member 'ACmpCommuModelController::PTextures' has a wrong offset!");
static_assert(offsetof(ACmpCommuModelController, PMotions) == 0x0002D8, "Member 'ACmpCommuModelController::PMotions' has a wrong offset!");

// Class xrd777.CmpEquipDraw
// 0x3500 (0x3528 - 0x0028)
class UCmpEquipDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x3498];                                    // 0x0028(0x3498)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x34C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpEquip*                              PParent;                                           // 0x34C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34D0[0x58];                                    // 0x34D0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpEquipDraw">();
	}
	static class UCmpEquipDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpEquipDraw>();
	}
};
static_assert(alignof(UCmpEquipDraw) == 0x000008, "Wrong alignment on UCmpEquipDraw");
static_assert(sizeof(UCmpEquipDraw) == 0x003528, "Wrong size on UCmpEquipDraw");
static_assert(offsetof(UCmpEquipDraw, PMainActor) == 0x0034C0, "Member 'UCmpEquipDraw::PMainActor' has a wrong offset!");
static_assert(offsetof(UCmpEquipDraw, PParent) == 0x0034C8, "Member 'UCmpEquipDraw::PParent' has a wrong offset!");

// Class xrd777.CmpHeroHumanStatus
// 0x0020 (0x0060 - 0x0040)
class UCmpHeroHumanStatus final : public UUIScene
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpHeroHumanStatusDraw*                POffHumanParamDraw_;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICmpStatus*                           PParent;                                           // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpHeroHumanStatus">();
	}
	static class UCmpHeroHumanStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpHeroHumanStatus>();
	}
};
static_assert(alignof(UCmpHeroHumanStatus) == 0x000008, "Wrong alignment on UCmpHeroHumanStatus");
static_assert(sizeof(UCmpHeroHumanStatus) == 0x000060, "Wrong size on UCmpHeroHumanStatus");
static_assert(offsetof(UCmpHeroHumanStatus, POffHumanParamDraw_) == 0x000050, "Member 'UCmpHeroHumanStatus::POffHumanParamDraw_' has a wrong offset!");
static_assert(offsetof(UCmpHeroHumanStatus, PParent) == 0x000058, "Member 'UCmpHeroHumanStatus::PParent' has a wrong offset!");

// Class xrd777.CmpItem
// 0x0208 (0x0240 - 0x0038)
class UCmpItem final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x150];                                     // 0x0038(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpItemSystem*                         PSystem;                                           // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpItemDraw*                           PDraw;                                             // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PPersonaStatus;                                    // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0xA0];                                     // 0x01A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpItem">();
	}
	static class UCmpItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpItem>();
	}
};
static_assert(alignof(UCmpItem) == 0x000008, "Wrong alignment on UCmpItem");
static_assert(sizeof(UCmpItem) == 0x000240, "Wrong size on UCmpItem");
static_assert(offsetof(UCmpItem, PSystem) == 0x000188, "Member 'UCmpItem::PSystem' has a wrong offset!");
static_assert(offsetof(UCmpItem, PDraw) == 0x000190, "Member 'UCmpItem::PDraw' has a wrong offset!");
static_assert(offsetof(UCmpItem, PPersonaStatus) == 0x000198, "Member 'UCmpItem::PPersonaStatus' has a wrong offset!");

// Class xrd777.CallTitleSequence
// 0x0000 (0x0030 - 0x0030)
class UCallTitleSequence final : public UCampLoadSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallTitleSequence">();
	}
	static class UCallTitleSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallTitleSequence>();
	}
};
static_assert(alignof(UCallTitleSequence) == 0x000008, "Wrong alignment on UCallTitleSequence");
static_assert(sizeof(UCallTitleSequence) == 0x000030, "Wrong size on UCallTitleSequence");

// Class xrd777.CmpPersona
// 0x0428 (0x0460 - 0x0038)
class UCmpPersona final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader_;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PDynaMateWaveCausticsAry[0x18];                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             PTexArcanaWordAry[0x18];                           // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmpPersona*                          Actor_;                                            // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x288];                                    // 0x01D8(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpPersona">();
	}
	static class UCmpPersona* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpPersona>();
	}
};
static_assert(alignof(UCmpPersona) == 0x000008, "Wrong alignment on UCmpPersona");
static_assert(sizeof(UCmpPersona) == 0x000460, "Wrong size on UCmpPersona");
static_assert(offsetof(UCmpPersona, AssetLoader_) == 0x000048, "Member 'UCmpPersona::AssetLoader_' has a wrong offset!");
static_assert(offsetof(UCmpPersona, PDynaMateWaveCausticsAry) == 0x000050, "Member 'UCmpPersona::PDynaMateWaveCausticsAry' has a wrong offset!");
static_assert(offsetof(UCmpPersona, PTexArcanaWordAry) == 0x000110, "Member 'UCmpPersona::PTexArcanaWordAry' has a wrong offset!");
static_assert(offsetof(UCmpPersona, Actor_) == 0x0001D0, "Member 'UCmpPersona::Actor_' has a wrong offset!");

// Class xrd777.CmpRootDraw
// 0x0850 (0x0878 - 0x0028)
class UCmpRootDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x800];                                     // 0x0028(0x0800)(Fixing Size After Last Property [ Dumper-7 ])
	class UUimAsset*                              PUimTextCursorOn;                                  // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimCursorLoop;                                    // 0x0830(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              PUimCursorInBounce;                                // 0x0838(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       PMenuItemInstanceDynamics;                         // 0x0840(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterial*                              PMetaricMaterial;                                  // 0x0850(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              PWriteMetaricMaterial;                             // 0x0858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PWriteMetaricInstanceDynamics;                     // 0x0860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x0868(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_870[0x8];                                      // 0x0870(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpRootDraw">();
	}
	static class UCmpRootDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpRootDraw>();
	}
};
static_assert(alignof(UCmpRootDraw) == 0x000008, "Wrong alignment on UCmpRootDraw");
static_assert(sizeof(UCmpRootDraw) == 0x000878, "Wrong size on UCmpRootDraw");
static_assert(offsetof(UCmpRootDraw, PUimTextCursorOn) == 0x000828, "Member 'UCmpRootDraw::PUimTextCursorOn' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PUimCursorLoop) == 0x000830, "Member 'UCmpRootDraw::PUimCursorLoop' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PUimCursorInBounce) == 0x000838, "Member 'UCmpRootDraw::PUimCursorInBounce' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PMenuItemInstanceDynamics) == 0x000840, "Member 'UCmpRootDraw::PMenuItemInstanceDynamics' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PMetaricMaterial) == 0x000850, "Member 'UCmpRootDraw::PMetaricMaterial' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PWriteMetaricMaterial) == 0x000858, "Member 'UCmpRootDraw::PWriteMetaricMaterial' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PWriteMetaricInstanceDynamics) == 0x000860, "Member 'UCmpRootDraw::PWriteMetaricInstanceDynamics' has a wrong offset!");
static_assert(offsetof(UCmpRootDraw, PMainActor) == 0x000868, "Member 'UCmpRootDraw::PMainActor' has a wrong offset!");

// Class xrd777.CmpSkillDraw
// 0x0520 (0x0548 - 0x0028)
class UCmpSkillDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x508];                                     // 0x0040(0x0508)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpSkillDraw">();
	}
	static class UCmpSkillDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpSkillDraw>();
	}
};
static_assert(alignof(UCmpSkillDraw) == 0x000008, "Wrong alignment on UCmpSkillDraw");
static_assert(sizeof(UCmpSkillDraw) == 0x000548, "Wrong size on UCmpSkillDraw");
static_assert(offsetof(UCmpSkillDraw, PMainActor) == 0x000038, "Member 'UCmpSkillDraw::PMainActor' has a wrong offset!");

// Class xrd777.CmpStatus
// 0x0210 (0x0248 - 0x0038)
class UCmpStatus final : public UCmpMenuBase
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICmpStatus*                           Actor_;                                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x1E8];                                     // 0x0060(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpStatus">();
	}
	static class UCmpStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpStatus>();
	}
};
static_assert(alignof(UCmpStatus) == 0x000008, "Wrong alignment on UCmpStatus");
static_assert(sizeof(UCmpStatus) == 0x000248, "Wrong size on UCmpStatus");
static_assert(offsetof(UCmpStatus, Actor_) == 0x000058, "Member 'UCmpStatus::Actor_' has a wrong offset!");

// Class xrd777.CmpStatusCharacterList
// 0x00D8 (0x0118 - 0x0040)
class UCmpStatusCharacterList final : public UUIScene
{
public:
	uint8                                         Pad_40[0x78];                                      // 0x0040(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICmpStatus*                           Owner_;                                            // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x58];                                      // 0x00C0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpStatusCharacterList">();
	}
	static class UCmpStatusCharacterList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpStatusCharacterList>();
	}
};
static_assert(alignof(UCmpStatusCharacterList) == 0x000008, "Wrong alignment on UCmpStatusCharacterList");
static_assert(sizeof(UCmpStatusCharacterList) == 0x000118, "Wrong size on UCmpStatusCharacterList");
static_assert(offsetof(UCmpStatusCharacterList, Owner_) == 0x0000B8, "Member 'UCmpStatusCharacterList::Owner_' has a wrong offset!");

// Class xrd777.UITheurgia
// 0x0F30 (0x0F58 - 0x0028)
class UUITheurgia final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 M_pRefWorld;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pTheurgiaSpr;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pTheurgiaSpr_Astrea;                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              M_pTheurgiaPlg;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     M_pBGMat;                                          // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pBGMatInst;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pCampSpr;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              M_pCampPlg;                                        // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pTheurgiaUIDT;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMiscSpecialKeyhelp*                  M_pMiscSpecialKeyhelp;                             // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x100];                                     // 0x00C8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveFloatAnimation                   M_curveCurrentCursorAlways_Light;                  // 0x01C8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCurrentCursorAlways_Persona;                // 0x01F8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCurrentCursorAlways_ChangeTiming;           // 0x0228(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_CursorRate;                           // 0x0258(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveEnd_CursorRate;                             // 0x0288(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCtrlCursorIn_Rate;                          // 0x02B8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCtrlCursorOut_Rate;                         // 0x02E8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_CursorListRate;                       // 0x0318(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_LRCursorListRate;                     // 0x0348(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_LRCursorListAlpha;                    // 0x0378(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveEnd_LRCursorListRate;                       // 0x03A8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveEnd_LRCursorListAlpha;                      // 0x03D8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curve_LRCursorListWaveRate;                      // 0x0408(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveEnd_SkillRate;                              // 0x0438(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_DetailTextIn;                         // 0x0468(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_TheurgiaText;                         // 0x0498(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveStart_SkillHelpText;                        // 0x04C8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveStart_StatusTab;                            // 0x04F8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveEnd_StatusTab;                              // 0x0528(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_CirclePos;                      // 0x0558(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_CircleScale;                    // 0x0588(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailEnd_CirclePos;                        // 0x05B8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailEnd_CircleScale;                      // 0x05E8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_DetailAddText;                  // 0x0618(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailEnd_DetailAddText;                    // 0x0648(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_PersonalityRate;                // 0x0678(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_NormalPersonalityRate;          // 0x06A8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailEnd_NormalPersonalityRate;            // 0x06D8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailStart_MovementRate;                   // 0x0708(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveDetailEnd_MovementRate;                     // 0x0738(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveDetailStart_Kira;                           // 0x0768(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCurrentCursorLineFirst_Rate;                // 0x0798(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveCurrentCursorLineLoop_Rate;                 // 0x07C8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_YellowKira;                            // 0x07F8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveMove_YellowKira;                            // 0x0828(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveMove_YellowKiraPowerUp;                     // 0x0858(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAndScale_YellowKira;                  // 0x0888(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAndScale_YellowKira_PowerUp;          // 0x08B8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_YellowPersonality;                     // 0x08E8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_BlackBG_In;                            // 0x0918(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveMove_YellowPersonality;                     // 0x0948(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFlickering_AfterYellowKira1;                // 0x0978(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFlickering_AfterYellowKira2;                // 0x09A8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFlickering_Text;                            // 0x09D8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveRotate_AfterYellowKira1;                    // 0x0A08(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveRotate_AfterYellowKira2;                    // 0x0A38(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveMove_MovePassiveTextRatio;                  // 0x0A68(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_YellowPersonalityPlate;                // 0x0A98(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_BlackBG_Out;                           // 0x0AC8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_BlackBG_In_Obtain;                     // 0x0AF8(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_BlackBG_Out_Obtain;                    // 0x0B28(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_YellowPersonalityPlate_Obtain;         // 0x0B58(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveMove_YellowPersonality_Obtain;              // 0x0B88(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFade_YellowPersonality_Obtain;              // 0x0BB8(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_BE8[0x180];                                    // 0x0BE8(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveVectorAnimation                  M_curveRipple_ObtainCursor;                        // 0x0D68(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveFlickering_ObtainSkillText;                 // 0x0D98(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curveMove_ObtainSkillTextRatio;                  // 0x0DC8(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_DF8[0xD0];                                     // 0x0DF8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0EC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0ED0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextLayoutData;                                    // 0x0ED8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextLayoutDataTable;                               // 0x0EE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextPosLayoutData;                                 // 0x0EE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextPosLayoutDataTable;                            // 0x0EF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextRowLayoutData;                                 // 0x0EF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TexRowLayoutDataTable;                             // 0x0F00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F08[0x50];                                     // 0x0F08(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITheurgia">();
	}
	static class UUITheurgia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITheurgia>();
	}
};
static_assert(alignof(UUITheurgia) == 0x000008, "Wrong alignment on UUITheurgia");
static_assert(sizeof(UUITheurgia) == 0x000F58, "Wrong size on UUITheurgia");
static_assert(offsetof(UUITheurgia, M_pLoader) == 0x000070, "Member 'UUITheurgia::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pRefWorld) == 0x000078, "Member 'UUITheurgia::M_pRefWorld' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pTheurgiaSpr) == 0x000080, "Member 'UUITheurgia::M_pTheurgiaSpr' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pTheurgiaSpr_Astrea) == 0x000088, "Member 'UUITheurgia::M_pTheurgiaSpr_Astrea' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pTheurgiaPlg) == 0x000090, "Member 'UUITheurgia::M_pTheurgiaPlg' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pBGMat) == 0x000098, "Member 'UUITheurgia::M_pBGMat' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pBGMatInst) == 0x0000A0, "Member 'UUITheurgia::M_pBGMatInst' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pCampSpr) == 0x0000A8, "Member 'UUITheurgia::M_pCampSpr' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pCampPlg) == 0x0000B0, "Member 'UUITheurgia::M_pCampPlg' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pTheurgiaUIDT) == 0x0000B8, "Member 'UUITheurgia::M_pTheurgiaUIDT' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_pMiscSpecialKeyhelp) == 0x0000C0, "Member 'UUITheurgia::M_pMiscSpecialKeyhelp' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCurrentCursorAlways_Light) == 0x0001C8, "Member 'UUITheurgia::M_curveCurrentCursorAlways_Light' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCurrentCursorAlways_Persona) == 0x0001F8, "Member 'UUITheurgia::M_curveCurrentCursorAlways_Persona' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCurrentCursorAlways_ChangeTiming) == 0x000228, "Member 'UUITheurgia::M_curveCurrentCursorAlways_ChangeTiming' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_CursorRate) == 0x000258, "Member 'UUITheurgia::M_curveStart_CursorRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveEnd_CursorRate) == 0x000288, "Member 'UUITheurgia::M_curveEnd_CursorRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCtrlCursorIn_Rate) == 0x0002B8, "Member 'UUITheurgia::M_curveCtrlCursorIn_Rate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCtrlCursorOut_Rate) == 0x0002E8, "Member 'UUITheurgia::M_curveCtrlCursorOut_Rate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_CursorListRate) == 0x000318, "Member 'UUITheurgia::M_curveStart_CursorListRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_LRCursorListRate) == 0x000348, "Member 'UUITheurgia::M_curveStart_LRCursorListRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_LRCursorListAlpha) == 0x000378, "Member 'UUITheurgia::M_curveStart_LRCursorListAlpha' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveEnd_LRCursorListRate) == 0x0003A8, "Member 'UUITheurgia::M_curveEnd_LRCursorListRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveEnd_LRCursorListAlpha) == 0x0003D8, "Member 'UUITheurgia::M_curveEnd_LRCursorListAlpha' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curve_LRCursorListWaveRate) == 0x000408, "Member 'UUITheurgia::M_curve_LRCursorListWaveRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveEnd_SkillRate) == 0x000438, "Member 'UUITheurgia::M_curveEnd_SkillRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_DetailTextIn) == 0x000468, "Member 'UUITheurgia::M_curveStart_DetailTextIn' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_TheurgiaText) == 0x000498, "Member 'UUITheurgia::M_curveStart_TheurgiaText' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_SkillHelpText) == 0x0004C8, "Member 'UUITheurgia::M_curveStart_SkillHelpText' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveStart_StatusTab) == 0x0004F8, "Member 'UUITheurgia::M_curveStart_StatusTab' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveEnd_StatusTab) == 0x000528, "Member 'UUITheurgia::M_curveEnd_StatusTab' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_CirclePos) == 0x000558, "Member 'UUITheurgia::M_curveDetailStart_CirclePos' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_CircleScale) == 0x000588, "Member 'UUITheurgia::M_curveDetailStart_CircleScale' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailEnd_CirclePos) == 0x0005B8, "Member 'UUITheurgia::M_curveDetailEnd_CirclePos' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailEnd_CircleScale) == 0x0005E8, "Member 'UUITheurgia::M_curveDetailEnd_CircleScale' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_DetailAddText) == 0x000618, "Member 'UUITheurgia::M_curveDetailStart_DetailAddText' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailEnd_DetailAddText) == 0x000648, "Member 'UUITheurgia::M_curveDetailEnd_DetailAddText' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_PersonalityRate) == 0x000678, "Member 'UUITheurgia::M_curveDetailStart_PersonalityRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_NormalPersonalityRate) == 0x0006A8, "Member 'UUITheurgia::M_curveDetailStart_NormalPersonalityRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailEnd_NormalPersonalityRate) == 0x0006D8, "Member 'UUITheurgia::M_curveDetailEnd_NormalPersonalityRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_MovementRate) == 0x000708, "Member 'UUITheurgia::M_curveDetailStart_MovementRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailEnd_MovementRate) == 0x000738, "Member 'UUITheurgia::M_curveDetailEnd_MovementRate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveDetailStart_Kira) == 0x000768, "Member 'UUITheurgia::M_curveDetailStart_Kira' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCurrentCursorLineFirst_Rate) == 0x000798, "Member 'UUITheurgia::M_curveCurrentCursorLineFirst_Rate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveCurrentCursorLineLoop_Rate) == 0x0007C8, "Member 'UUITheurgia::M_curveCurrentCursorLineLoop_Rate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_YellowKira) == 0x0007F8, "Member 'UUITheurgia::M_curveFade_YellowKira' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_YellowKira) == 0x000828, "Member 'UUITheurgia::M_curveMove_YellowKira' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_YellowKiraPowerUp) == 0x000858, "Member 'UUITheurgia::M_curveMove_YellowKiraPowerUp' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveRotateAndScale_YellowKira) == 0x000888, "Member 'UUITheurgia::M_curveRotateAndScale_YellowKira' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveRotateAndScale_YellowKira_PowerUp) == 0x0008B8, "Member 'UUITheurgia::M_curveRotateAndScale_YellowKira_PowerUp' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_YellowPersonality) == 0x0008E8, "Member 'UUITheurgia::M_curveFade_YellowPersonality' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_BlackBG_In) == 0x000918, "Member 'UUITheurgia::M_curveFade_BlackBG_In' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_YellowPersonality) == 0x000948, "Member 'UUITheurgia::M_curveMove_YellowPersonality' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFlickering_AfterYellowKira1) == 0x000978, "Member 'UUITheurgia::M_curveFlickering_AfterYellowKira1' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFlickering_AfterYellowKira2) == 0x0009A8, "Member 'UUITheurgia::M_curveFlickering_AfterYellowKira2' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFlickering_Text) == 0x0009D8, "Member 'UUITheurgia::M_curveFlickering_Text' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveRotate_AfterYellowKira1) == 0x000A08, "Member 'UUITheurgia::M_curveRotate_AfterYellowKira1' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveRotate_AfterYellowKira2) == 0x000A38, "Member 'UUITheurgia::M_curveRotate_AfterYellowKira2' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_MovePassiveTextRatio) == 0x000A68, "Member 'UUITheurgia::M_curveMove_MovePassiveTextRatio' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_YellowPersonalityPlate) == 0x000A98, "Member 'UUITheurgia::M_curveFade_YellowPersonalityPlate' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_BlackBG_Out) == 0x000AC8, "Member 'UUITheurgia::M_curveFade_BlackBG_Out' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_BlackBG_In_Obtain) == 0x000AF8, "Member 'UUITheurgia::M_curveFade_BlackBG_In_Obtain' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_BlackBG_Out_Obtain) == 0x000B28, "Member 'UUITheurgia::M_curveFade_BlackBG_Out_Obtain' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_YellowPersonalityPlate_Obtain) == 0x000B58, "Member 'UUITheurgia::M_curveFade_YellowPersonalityPlate_Obtain' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_YellowPersonality_Obtain) == 0x000B88, "Member 'UUITheurgia::M_curveMove_YellowPersonality_Obtain' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFade_YellowPersonality_Obtain) == 0x000BB8, "Member 'UUITheurgia::M_curveFade_YellowPersonality_Obtain' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveRipple_ObtainCursor) == 0x000D68, "Member 'UUITheurgia::M_curveRipple_ObtainCursor' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveFlickering_ObtainSkillText) == 0x000D98, "Member 'UUITheurgia::M_curveFlickering_ObtainSkillText' has a wrong offset!");
static_assert(offsetof(UUITheurgia, M_curveMove_ObtainSkillTextRatio) == 0x000DC8, "Member 'UUITheurgia::M_curveMove_ObtainSkillTextRatio' has a wrong offset!");
static_assert(offsetof(UUITheurgia, LayoutData) == 0x000EC8, "Member 'UUITheurgia::LayoutData' has a wrong offset!");
static_assert(offsetof(UUITheurgia, LayoutDataTable) == 0x000ED0, "Member 'UUITheurgia::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TextLayoutData) == 0x000ED8, "Member 'UUITheurgia::TextLayoutData' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TextLayoutDataTable) == 0x000EE0, "Member 'UUITheurgia::TextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TextPosLayoutData) == 0x000EE8, "Member 'UUITheurgia::TextPosLayoutData' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TextPosLayoutDataTable) == 0x000EF0, "Member 'UUITheurgia::TextPosLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TextRowLayoutData) == 0x000EF8, "Member 'UUITheurgia::TextRowLayoutData' has a wrong offset!");
static_assert(offsetof(UUITheurgia, TexRowLayoutDataTable) == 0x000F00, "Member 'UUITheurgia::TexRowLayoutDataTable' has a wrong offset!");

// Class xrd777.CombineTest
// 0x0008 (0x0280 - 0x0278)
class ACombineTest final : public AAppActor
{
public:
	class UUICombineCalc*                         CombineCalc_;                                      // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombineTest">();
	}
	static class ACombineTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACombineTest>();
	}
};
static_assert(alignof(ACombineTest) == 0x000008, "Wrong alignment on ACombineTest");
static_assert(sizeof(ACombineTest) == 0x000280, "Wrong size on ACombineTest");
static_assert(offsetof(ACombineTest, CombineCalc_) == 0x000278, "Member 'ACombineTest::CombineCalc_' has a wrong offset!");

// Class xrd777.CommunityHandler
// 0x0120 (0x0148 - 0x0028)
class UCommunityHandler final : public UObject
{
public:
	uint8                                         Pad_28[0xC8];                                      // 0x0028(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommunityEventDataAsset*               PEventDataAsset;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHolidayEventDataAsset*                 PHolidayEventDataAsset;                            // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHolidayScheduleDataAsset*              PHolidayScheduleDataAsset;                         // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PMemberFormatTable;                                // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PNameFormatTable;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoefficientDataAsset*                  PCoefficientDataAsset;                             // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommunityPresentDataAsset*             PPresentDataAsset;                                 // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoviesEventDataAsset*                  PMoviesEventDataAsset;                             // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USummerFestivalEventDataAsset*          PSummerFestivalEventDataAsset;                     // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChristmasEventDataAsset*               PChristmasEventDataAsset;                          // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACommunityEventManager*                 PEventManager;                                     // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityHandler">();
	}
	static class UCommunityHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunityHandler>();
	}
};
static_assert(alignof(UCommunityHandler) == 0x000008, "Wrong alignment on UCommunityHandler");
static_assert(sizeof(UCommunityHandler) == 0x000148, "Wrong size on UCommunityHandler");
static_assert(offsetof(UCommunityHandler, PEventDataAsset) == 0x0000F0, "Member 'UCommunityHandler::PEventDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PHolidayEventDataAsset) == 0x0000F8, "Member 'UCommunityHandler::PHolidayEventDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PHolidayScheduleDataAsset) == 0x000100, "Member 'UCommunityHandler::PHolidayScheduleDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PMemberFormatTable) == 0x000108, "Member 'UCommunityHandler::PMemberFormatTable' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PNameFormatTable) == 0x000110, "Member 'UCommunityHandler::PNameFormatTable' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PCoefficientDataAsset) == 0x000118, "Member 'UCommunityHandler::PCoefficientDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PPresentDataAsset) == 0x000120, "Member 'UCommunityHandler::PPresentDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PMoviesEventDataAsset) == 0x000128, "Member 'UCommunityHandler::PMoviesEventDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PSummerFestivalEventDataAsset) == 0x000130, "Member 'UCommunityHandler::PSummerFestivalEventDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PChristmasEventDataAsset) == 0x000138, "Member 'UCommunityHandler::PChristmasEventDataAsset' has a wrong offset!");
static_assert(offsetof(UCommunityHandler, PEventManager) == 0x000140, "Member 'UCommunityHandler::PEventManager' has a wrong offset!");

// Class xrd777.CommunityEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCommunityEventDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FCommunityEventTable>           Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityEventDataAsset">();
	}
	static class UCommunityEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunityEventDataAsset>();
	}
};
static_assert(alignof(UCommunityEventDataAsset) == 0x000008, "Wrong alignment on UCommunityEventDataAsset");
static_assert(sizeof(UCommunityEventDataAsset) == 0x000040, "Wrong size on UCommunityEventDataAsset");
static_assert(offsetof(UCommunityEventDataAsset, Tables) == 0x000030, "Member 'UCommunityEventDataAsset::Tables' has a wrong offset!");

// Class xrd777.UIVelvetRoomDraw
// 0x03D0 (0x0688 - 0x02B8)
class AUIVelvetRoomDraw final : public AUIDrawBaseActor
{
public:
	int32                                         Edit_Panel_InAnimation_Frame;                      // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Panel_OutAnimation_Frame;                     // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Panel_Loop_Wait_Time;                         // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Panel_Loop_Fade_In_Time;                      // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Panel_Loop_Fade_Out_Time;                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Cursor_InAnimation_Frame;                     // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Dollar_Icon_Animation_Time;                   // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Equipe_Icon_Animation_Time;                   // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Equipe_Icon_Wait_Time;                        // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Equipe_Icon_FadeOut_Frame;                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_HelpMessage_Line_Height;                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Sort_Tab_Animation_Frame;                     // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIVelvetRoomDrawScene                        Scene;                                             // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIDataAsset*                           AstreaResourceDataAsset;                           // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x90];                                     // 0x02F8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIVelvetRoomPanel*                     PPanel;                                            // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           PCamera;                                           // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PPersonaStatus;                                    // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Edit_PanelNoneColorRate;                           // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_InAnimationFrame_Lattice;                     // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Hero_FadeOut_Frame;                           // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_HelpMessageInAnimationFrame;                  // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_HelpMessageOutAnimationFrame;                 // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_HelpMessageChangeAnimationFrame;              // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Edit_CardOffsetPosition;                           // 0x03B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Edit_CardOffsetRotation;                           // 0x03C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Edit_CardSadowOffsetPosition;                      // 0x03D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Edit_CardSadowOffsetRotation;                      // 0x03DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_CardSadowScale;                               // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenLow_FadeIn_Frame;                  // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenLow_FadeIn_Delay;                  // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenMiddle_FadeIn_Frame;               // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenMiddle_FadeIn_Delay;               // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenHigh_FadeIn_Frame;                 // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_BlackScreenHigh_FadeIn_Delay;                 // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_FadeOut_Frame;                  // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_CardIn_Delay;                   // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_KeyHelpIn_Delay;                // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_VelvetRoomTop_Capture_OffsetUV;               // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_Hero_Wave1_Fade_Delay;          // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_Hero_Wave1_Fade_Frame;          // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_Hero_Wave2_Fade_Delay;          // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_VelvetRoomTop_Hero_Wave2_Fade_Frame;          // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCardSelectEvent;                                 // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnUniqeMotionEvent;                                // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTopInAnimationEvent;                             // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTopOutAnimationEvent;                            // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         CombineType;                                       // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHeroPlayMotion;                                  // 0x046C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      PHeroWaveMaterial1;                                // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      PHeroWaveMaterial2;                                // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PHeroWaveDynamicMaterial1;                         // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PHeroWaveDynamicMaterial2;                         // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIVelvetRoomUimCard*                   PCard;                                             // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIVelvetRoomMca*                       PMca;                                              // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Edit_2Combine_InAnimation_Frame;                   // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_Igor_InAnimation_Frame;              // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_Heading_InAnimation_Frame;           // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_List_SelectedAnimation_Frame;        // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_List_Cursor_Animation_Frame;         // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_1Icon_Animation_Frame;               // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_2Combine_Igor_Selected_Animation_Frame;       // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_2Combine_Capture_OffsetUV;                    // 0x04D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x18];                                     // 0x04DC(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SearchCombine_Heading_InAnimation_Frame;      // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_Igor_Panel_InAnimation_Frame;   // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_Sort_Panel_InAnimation_Frame;   // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_Name_Panel_InAnimation_Frame;   // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_Help_Message_InAnimation_Frame; // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_InAnimation_Frame;         // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_SearchCombine_Capture_OffsetUV;               // 0x050C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Fade_Out_Delay;            // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Fade_Out_Frame;            // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Fade_In_Delay;             // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Fade_In_Frame;             // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Slide_In_Delay;            // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SearchCombine_List_Slide_In_Frame;            // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52C[0xC];                                      // 0x052C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SpecialCombine_Heading_InAnimation_Frame;     // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SpecialCombine_Igor_Panel_InAnimation_Frame;  // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SpecialCombine_Name_Panel_InAnimation_Frame;  // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SpecialCombine_Help_Message_InAnimation_Frame; // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SpecialCombine_List_InAnimation_Frame;        // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_SpecialCombine_Capture_OffsetUV;              // 0x054C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x8];                                      // 0x0554(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Drawer_Heading_InAnimation_Frame;             // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Elizabeth_Panel_InAnimation_Frame;     // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Name_Panel_InAnimation_Frame;          // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Money_InAnimation_Delay;               // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Money_InAnimation_Frame;               // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Money_OutAnimation_Delay;              // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Money_OutAnimation_Frame;              // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Help_Message_InAnimation_Frame;        // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_InAnimation_Frame;                // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_Sort_Panel_InAnimation_Frame;          // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Angle_Animation_Frame;     // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_FadeIn_Delay;            // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_FadeIn_Frame;            // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_Animation_Delay;         // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_Animation_Frame1;        // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_Animation_Frame2;        // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_LockIcon_Animation_Frame3;        // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Scale1;                  // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Scale2;                  // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Scale3;                  // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Scale4;                  // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Angle1;                  // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Angle2;                  // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Angle3;                  // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Drawer_List_LockIcon_Angle4;                  // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_FadeOut_Delay;     // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_FadeOut_Frame;     // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_FadeIn_Delay;      // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_FadeIn_Frame;      // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_SlideIn_Delay;     // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Switch_Heading_SlideIn_Frame;     // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_Drawer_Capture_OffsetUV;                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Fade_Out_Delay;   // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Fade_Out_Frame;   // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Fade_In_Delay;    // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Fade_In_Frame;    // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Slide_In_Delay;   // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Drawer_List_Change_Category_Slide_In_Frame;   // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x34];                                     // 0x05F8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Registry_Heading_InAnimation_Frame;           // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Elizabeth_Panel_InAnimation_Frame;   // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Name_Panel_InAnimation_Frame;        // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Help_Message_InAnimation_Frame;      // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_List_InAnimation_Frame;              // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_List_CheckMark_Slide_Delay;          // 0x0640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_List_CheckMark_Slide_Frame;          // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_List_CheckMark_FadeIn_Delay;         // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_List_CheckMark_FadeIn_Frame;         // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Edit_Registry_Capture_OffsetUV;                    // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x30];                                     // 0x0658(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAstreaLoadAsset(const TSoftObjectPtr<class UObject> SoftAsset);
	void ApplyMcaForSceneCaptureComponent2D(class USceneCaptureComponent2D* SceneCaptureComponent2D, const class UObject* McaResourceData);
	void ApplyMcaToSceneCaptureComponent(class USceneCaptureComponent2D* PCaptureComponent, class UObject* PResource, EUIVELVET_ROOM_MCA_CAPTURE Type, const struct FVector& OffsetPoint, const struct FRotator& OffsetRotation, float OffsetFov);
	void Draw2CombineHeading(float X, float Y, const class UObject* UniqueResource);
	void Draw2CombineIgor(const class USceneCaptureComponent2D* PSceneCapture);
	void Draw2CombineList(const class UObject* UniqueResource, const class UObject* CommonResource);
	void Draw2CombinePlayerNameBoard(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawBackgroundPanelLattices(const class UObject* Resource);
	void DrawBackgroundPanels(const TArray<struct FColor>& Colors, const TArray<int32>& BlackPanelIndex);
	void DrawBlackScreenFadeOut();
	void DrawBlackScreenHigh();
	void DrawBlackScreenLow();
	void DrawBlackScreenMiddle();
	void DrawDrawerElizabeth(float X, float Y, float Angle, const class USceneCaptureComponent2D* PSceneCapture, const class UObject* Elizabeth);
	void DrawDrawerHeading(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawDrawerHelpMessage(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawDrawerList(float X, float Y, float Angle, const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawDrawerListSortPanel(float X, float Y, float Angle, const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawDrawerPlayerNameBoard(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawDrawerRegistryRate(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawHelpMessage2Combine(const class UObject* CommonResource);
	void DrawHelpMessageSearchCombine(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawHelpMessageSpecialCombine(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawMessageWaitScene();
	void DrawRegistryElizabeth(float X, float Y, float Angle, const class USceneCaptureComponent2D* PSceneCapture, const class UObject* Elizabeth);
	void DrawRegistryHeading(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawRegistryHelpMessage(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawRegistryList(float X, float Y, float Angle, const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawRegistryPlayerNameBoard(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawSearchCombineHeading(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawSearchCombineIgor(float X, float Y, float Angle, const class USceneCaptureComponent2D* PSceneCapture);
	void DrawSearchCombineList(const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawSearchCombinePlayerNameBoard(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawSearchCombineSortPanel(float X, float Y, float Angle, const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawSpecialCombineHeading(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawSpecialCombineIgor(float X, float Y, float Angle, const class USceneCaptureComponent2D* PSceneCapture);
	void DrawSpecialCombineList(const class UObject* UniqueResource, const class UObject* CommonResource);
	void DrawSpecialCombinePlayerNameBoard(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawTopBlackDesign(const class UObject* UniqueResource);
	void DrawTopCard(const struct FTransform& Transform, const class UObject* CardDataAsset);
	void DrawTopHelpMessage(float X, float Y, float Angle, const class UObject* CommonResource);
	void DrawTopHero(float X, float Y, float Width, float Height, const class USceneCaptureComponent2D* PSceneCapture);
	class UObject* GetAstreaResourceData(const int32 Index_0);
	int32 GetHeroCostumeID(int32 ForceID);
	void UpdateCardTimes(const float DeltaTime, const class UObject* ResourceData);
	void UpdateMcaTimes(const float DeltaTime, const class UObject* ResourceData);
	void UpdateTimes(const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomDraw">();
	}
	static class AUIVelvetRoomDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVelvetRoomDraw>();
	}
};
static_assert(alignof(AUIVelvetRoomDraw) == 0x000008, "Wrong alignment on AUIVelvetRoomDraw");
static_assert(sizeof(AUIVelvetRoomDraw) == 0x000688, "Wrong size on AUIVelvetRoomDraw");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Panel_InAnimation_Frame) == 0x0002B8, "Member 'AUIVelvetRoomDraw::Edit_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Panel_OutAnimation_Frame) == 0x0002BC, "Member 'AUIVelvetRoomDraw::Edit_Panel_OutAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Panel_Loop_Wait_Time) == 0x0002C0, "Member 'AUIVelvetRoomDraw::Edit_Panel_Loop_Wait_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Panel_Loop_Fade_In_Time) == 0x0002C4, "Member 'AUIVelvetRoomDraw::Edit_Panel_Loop_Fade_In_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Panel_Loop_Fade_Out_Time) == 0x0002C8, "Member 'AUIVelvetRoomDraw::Edit_Panel_Loop_Fade_Out_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Cursor_InAnimation_Frame) == 0x0002CC, "Member 'AUIVelvetRoomDraw::Edit_Cursor_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Dollar_Icon_Animation_Time) == 0x0002D0, "Member 'AUIVelvetRoomDraw::Edit_Dollar_Icon_Animation_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Equipe_Icon_Animation_Time) == 0x0002D4, "Member 'AUIVelvetRoomDraw::Edit_Equipe_Icon_Animation_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Equipe_Icon_Wait_Time) == 0x0002D8, "Member 'AUIVelvetRoomDraw::Edit_Equipe_Icon_Wait_Time' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Equipe_Icon_FadeOut_Frame) == 0x0002DC, "Member 'AUIVelvetRoomDraw::Edit_Equipe_Icon_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_HelpMessage_Line_Height) == 0x0002E0, "Member 'AUIVelvetRoomDraw::Edit_HelpMessage_Line_Height' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Sort_Tab_Animation_Frame) == 0x0002E4, "Member 'AUIVelvetRoomDraw::Edit_Sort_Tab_Animation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Scene) == 0x0002E8, "Member 'AUIVelvetRoomDraw::Scene' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, AstreaResourceDataAsset) == 0x0002F0, "Member 'AUIVelvetRoomDraw::AstreaResourceDataAsset' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PPanel) == 0x000388, "Member 'AUIVelvetRoomDraw::PPanel' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PCamera) == 0x000390, "Member 'AUIVelvetRoomDraw::PCamera' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PPersonaStatus) == 0x000398, "Member 'AUIVelvetRoomDraw::PPersonaStatus' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_PanelNoneColorRate) == 0x0003A0, "Member 'AUIVelvetRoomDraw::Edit_PanelNoneColorRate' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_InAnimationFrame_Lattice) == 0x0003A4, "Member 'AUIVelvetRoomDraw::Edit_InAnimationFrame_Lattice' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Hero_FadeOut_Frame) == 0x0003A8, "Member 'AUIVelvetRoomDraw::Edit_Hero_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_HelpMessageInAnimationFrame) == 0x0003AC, "Member 'AUIVelvetRoomDraw::Edit_HelpMessageInAnimationFrame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_HelpMessageOutAnimationFrame) == 0x0003B0, "Member 'AUIVelvetRoomDraw::Edit_HelpMessageOutAnimationFrame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_HelpMessageChangeAnimationFrame) == 0x0003B4, "Member 'AUIVelvetRoomDraw::Edit_HelpMessageChangeAnimationFrame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_CardOffsetPosition) == 0x0003B8, "Member 'AUIVelvetRoomDraw::Edit_CardOffsetPosition' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_CardOffsetRotation) == 0x0003C4, "Member 'AUIVelvetRoomDraw::Edit_CardOffsetRotation' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_CardSadowOffsetPosition) == 0x0003D0, "Member 'AUIVelvetRoomDraw::Edit_CardSadowOffsetPosition' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_CardSadowOffsetRotation) == 0x0003DC, "Member 'AUIVelvetRoomDraw::Edit_CardSadowOffsetRotation' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_CardSadowScale) == 0x0003E8, "Member 'AUIVelvetRoomDraw::Edit_CardSadowScale' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenLow_FadeIn_Frame) == 0x0003EC, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenLow_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenLow_FadeIn_Delay) == 0x0003F0, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenLow_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenMiddle_FadeIn_Frame) == 0x0003F4, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenMiddle_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenMiddle_FadeIn_Delay) == 0x0003F8, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenMiddle_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenHigh_FadeIn_Frame) == 0x0003FC, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenHigh_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_BlackScreenHigh_FadeIn_Delay) == 0x000400, "Member 'AUIVelvetRoomDraw::Edit_BlackScreenHigh_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_FadeOut_Frame) == 0x000404, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_CardIn_Delay) == 0x000408, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_CardIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_KeyHelpIn_Delay) == 0x00040C, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_KeyHelpIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_Capture_OffsetUV) == 0x000410, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_Capture_OffsetUV' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_Hero_Wave1_Fade_Delay) == 0x000418, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_Hero_Wave1_Fade_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_Hero_Wave1_Fade_Frame) == 0x00041C, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_Hero_Wave1_Fade_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_Hero_Wave2_Fade_Delay) == 0x000420, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_Hero_Wave2_Fade_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_VelvetRoomTop_Hero_Wave2_Fade_Frame) == 0x000424, "Member 'AUIVelvetRoomDraw::Edit_VelvetRoomTop_Hero_Wave2_Fade_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, OnCardSelectEvent) == 0x000428, "Member 'AUIVelvetRoomDraw::OnCardSelectEvent' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, OnUniqeMotionEvent) == 0x000438, "Member 'AUIVelvetRoomDraw::OnUniqeMotionEvent' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, OnTopInAnimationEvent) == 0x000448, "Member 'AUIVelvetRoomDraw::OnTopInAnimationEvent' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, OnTopOutAnimationEvent) == 0x000458, "Member 'AUIVelvetRoomDraw::OnTopOutAnimationEvent' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, CombineType) == 0x000468, "Member 'AUIVelvetRoomDraw::CombineType' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, IsHeroPlayMotion) == 0x00046C, "Member 'AUIVelvetRoomDraw::IsHeroPlayMotion' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PHeroWaveMaterial1) == 0x000470, "Member 'AUIVelvetRoomDraw::PHeroWaveMaterial1' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PHeroWaveMaterial2) == 0x000478, "Member 'AUIVelvetRoomDraw::PHeroWaveMaterial2' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PHeroWaveDynamicMaterial1) == 0x000480, "Member 'AUIVelvetRoomDraw::PHeroWaveDynamicMaterial1' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PHeroWaveDynamicMaterial2) == 0x000488, "Member 'AUIVelvetRoomDraw::PHeroWaveDynamicMaterial2' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PCard) == 0x0004A8, "Member 'AUIVelvetRoomDraw::PCard' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, PMca) == 0x0004B0, "Member 'AUIVelvetRoomDraw::PMca' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_InAnimation_Frame) == 0x0004B8, "Member 'AUIVelvetRoomDraw::Edit_2Combine_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_Igor_InAnimation_Frame) == 0x0004BC, "Member 'AUIVelvetRoomDraw::Edit_2Combine_Igor_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_Heading_InAnimation_Frame) == 0x0004C0, "Member 'AUIVelvetRoomDraw::Edit_2Combine_Heading_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_List_SelectedAnimation_Frame) == 0x0004C4, "Member 'AUIVelvetRoomDraw::Edit_2Combine_List_SelectedAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_List_Cursor_Animation_Frame) == 0x0004C8, "Member 'AUIVelvetRoomDraw::Edit_2Combine_List_Cursor_Animation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_1Icon_Animation_Frame) == 0x0004CC, "Member 'AUIVelvetRoomDraw::Edit_2Combine_1Icon_Animation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_Igor_Selected_Animation_Frame) == 0x0004D0, "Member 'AUIVelvetRoomDraw::Edit_2Combine_Igor_Selected_Animation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_2Combine_Capture_OffsetUV) == 0x0004D4, "Member 'AUIVelvetRoomDraw::Edit_2Combine_Capture_OffsetUV' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Heading_InAnimation_Frame) == 0x0004F4, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Heading_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Igor_Panel_InAnimation_Frame) == 0x0004F8, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Igor_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Sort_Panel_InAnimation_Frame) == 0x0004FC, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Sort_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Name_Panel_InAnimation_Frame) == 0x000500, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Name_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Help_Message_InAnimation_Frame) == 0x000504, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Help_Message_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_InAnimation_Frame) == 0x000508, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_Capture_OffsetUV) == 0x00050C, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_Capture_OffsetUV' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Fade_Out_Delay) == 0x000514, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Fade_Out_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Fade_Out_Frame) == 0x000518, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Fade_Out_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Fade_In_Delay) == 0x00051C, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Fade_In_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Fade_In_Frame) == 0x000520, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Slide_In_Delay) == 0x000524, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SearchCombine_List_Slide_In_Frame) == 0x000528, "Member 'AUIVelvetRoomDraw::Edit_SearchCombine_List_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_Heading_InAnimation_Frame) == 0x000538, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_Heading_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_Igor_Panel_InAnimation_Frame) == 0x00053C, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_Igor_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_Name_Panel_InAnimation_Frame) == 0x000540, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_Name_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_Help_Message_InAnimation_Frame) == 0x000544, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_Help_Message_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_List_InAnimation_Frame) == 0x000548, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_List_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_SpecialCombine_Capture_OffsetUV) == 0x00054C, "Member 'AUIVelvetRoomDraw::Edit_SpecialCombine_Capture_OffsetUV' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Heading_InAnimation_Frame) == 0x00055C, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Heading_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Elizabeth_Panel_InAnimation_Frame) == 0x000560, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Elizabeth_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Name_Panel_InAnimation_Frame) == 0x000564, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Name_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Money_InAnimation_Delay) == 0x000568, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Money_InAnimation_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Money_InAnimation_Frame) == 0x00056C, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Money_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Money_OutAnimation_Delay) == 0x000570, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Money_OutAnimation_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Money_OutAnimation_Frame) == 0x000574, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Money_OutAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Help_Message_InAnimation_Frame) == 0x000578, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Help_Message_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_InAnimation_Frame) == 0x00057C, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Sort_Panel_InAnimation_Frame) == 0x000580, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Sort_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Angle_Animation_Frame) == 0x000584, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Angle_Animation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_FadeIn_Delay) == 0x000588, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_FadeIn_Frame) == 0x00058C, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Animation_Delay) == 0x000590, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Animation_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Animation_Frame1) == 0x000594, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Animation_Frame1' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Animation_Frame2) == 0x000598, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Animation_Frame2' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Animation_Frame3) == 0x00059C, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Animation_Frame3' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Scale1) == 0x0005A0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Scale1' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Scale2) == 0x0005A4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Scale2' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Scale3) == 0x0005A8, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Scale3' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Scale4) == 0x0005AC, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Scale4' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Angle1) == 0x0005B0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Angle1' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Angle2) == 0x0005B4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Angle2' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Angle3) == 0x0005B8, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Angle3' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_LockIcon_Angle4) == 0x0005BC, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_LockIcon_Angle4' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_FadeOut_Delay) == 0x0005C0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_FadeOut_Frame) == 0x0005C4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_FadeIn_Delay) == 0x0005C8, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_FadeIn_Frame) == 0x0005CC, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_SlideIn_Delay) == 0x0005D0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Switch_Heading_SlideIn_Frame) == 0x0005D4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Switch_Heading_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_Capture_OffsetUV) == 0x0005D8, "Member 'AUIVelvetRoomDraw::Edit_Drawer_Capture_OffsetUV' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Fade_Out_Delay) == 0x0005E0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Fade_Out_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Fade_Out_Frame) == 0x0005E4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Fade_Out_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Fade_In_Delay) == 0x0005E8, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Fade_In_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Fade_In_Frame) == 0x0005EC, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Slide_In_Delay) == 0x0005F0, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Drawer_List_Change_Category_Slide_In_Frame) == 0x0005F4, "Member 'AUIVelvetRoomDraw::Edit_Drawer_List_Change_Category_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_Heading_InAnimation_Frame) == 0x00062C, "Member 'AUIVelvetRoomDraw::Edit_Registry_Heading_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_Elizabeth_Panel_InAnimation_Frame) == 0x000630, "Member 'AUIVelvetRoomDraw::Edit_Registry_Elizabeth_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_Name_Panel_InAnimation_Frame) == 0x000634, "Member 'AUIVelvetRoomDraw::Edit_Registry_Name_Panel_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_Help_Message_InAnimation_Frame) == 0x000638, "Member 'AUIVelvetRoomDraw::Edit_Registry_Help_Message_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_List_InAnimation_Frame) == 0x00063C, "Member 'AUIVelvetRoomDraw::Edit_Registry_List_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_List_CheckMark_Slide_Delay) == 0x000640, "Member 'AUIVelvetRoomDraw::Edit_Registry_List_CheckMark_Slide_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_List_CheckMark_Slide_Frame) == 0x000644, "Member 'AUIVelvetRoomDraw::Edit_Registry_List_CheckMark_Slide_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_List_CheckMark_FadeIn_Delay) == 0x000648, "Member 'AUIVelvetRoomDraw::Edit_Registry_List_CheckMark_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_List_CheckMark_FadeIn_Frame) == 0x00064C, "Member 'AUIVelvetRoomDraw::Edit_Registry_List_CheckMark_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoomDraw, Edit_Registry_Capture_OffsetUV) == 0x000650, "Member 'AUIVelvetRoomDraw::Edit_Registry_Capture_OffsetUV' has a wrong offset!");

// Class xrd777.HolidayScheduleDataAsset
// 0x0010 (0x0040 - 0x0030)
class UHolidayScheduleDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FHolidayScheduleData>           Table;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HolidayScheduleDataAsset">();
	}
	static class UHolidayScheduleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHolidayScheduleDataAsset>();
	}
};
static_assert(alignof(UHolidayScheduleDataAsset) == 0x000008, "Wrong alignment on UHolidayScheduleDataAsset");
static_assert(sizeof(UHolidayScheduleDataAsset) == 0x000040, "Wrong size on UHolidayScheduleDataAsset");
static_assert(offsetof(UHolidayScheduleDataAsset, Table) == 0x000030, "Member 'UHolidayScheduleDataAsset::Table' has a wrong offset!");

// Class xrd777.CommunityPresentDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCommunityPresentDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FCommunityPresentTable>         Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityPresentDataAsset">();
	}
	static class UCommunityPresentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunityPresentDataAsset>();
	}
};
static_assert(alignof(UCommunityPresentDataAsset) == 0x000008, "Wrong alignment on UCommunityPresentDataAsset");
static_assert(sizeof(UCommunityPresentDataAsset) == 0x000040, "Wrong size on UCommunityPresentDataAsset");
static_assert(offsetof(UCommunityPresentDataAsset, Tables) == 0x000030, "Member 'UCommunityPresentDataAsset::Tables' has a wrong offset!");

// Class xrd777.MoviesEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class UMoviesEventDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FMoviesEventData>               Table;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviesEventDataAsset">();
	}
	static class UMoviesEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoviesEventDataAsset>();
	}
};
static_assert(alignof(UMoviesEventDataAsset) == 0x000008, "Wrong alignment on UMoviesEventDataAsset");
static_assert(sizeof(UMoviesEventDataAsset) == 0x000040, "Wrong size on UMoviesEventDataAsset");
static_assert(offsetof(UMoviesEventDataAsset, Table) == 0x000030, "Member 'UMoviesEventDataAsset::Table' has a wrong offset!");

// Class xrd777.SummerFestivalEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class USummerFestivalEventDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSummerFestivalEventData>       Table;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummerFestivalEventDataAsset">();
	}
	static class USummerFestivalEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummerFestivalEventDataAsset>();
	}
};
static_assert(alignof(USummerFestivalEventDataAsset) == 0x000008, "Wrong alignment on USummerFestivalEventDataAsset");
static_assert(sizeof(USummerFestivalEventDataAsset) == 0x000040, "Wrong size on USummerFestivalEventDataAsset");
static_assert(offsetof(USummerFestivalEventDataAsset, Table) == 0x000030, "Member 'USummerFestivalEventDataAsset::Table' has a wrong offset!");

// Class xrd777.CommunityWork
// 0x0020 (0x0048 - 0x0028)
class UCommunityWork final : public UObject
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommunityHandler*                      PCommunityHandle;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVeveWork*                              PVeveWork;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHeroParameterHandle*                   PHeroParameterHandle;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunityWork">();
	}
	static class UCommunityWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunityWork>();
	}
};
static_assert(alignof(UCommunityWork) == 0x000008, "Wrong alignment on UCommunityWork");
static_assert(sizeof(UCommunityWork) == 0x000048, "Wrong size on UCommunityWork");
static_assert(offsetof(UCommunityWork, PAssetLoader) == 0x000028, "Member 'UCommunityWork::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UCommunityWork, PCommunityHandle) == 0x000030, "Member 'UCommunityWork::PCommunityHandle' has a wrong offset!");
static_assert(offsetof(UCommunityWork, PVeveWork) == 0x000038, "Member 'UCommunityWork::PVeveWork' has a wrong offset!");
static_assert(offsetof(UCommunityWork, PHeroParameterHandle) == 0x000040, "Member 'UCommunityWork::PHeroParameterHandle' has a wrong offset!");

// Class xrd777.ConfigDialog
// 0x0028 (0x0050 - 0x0028)
class UConfigDialog final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnConfirm;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigDialog">();
	}
	static class UConfigDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigDialog>();
	}
};
static_assert(alignof(UConfigDialog) == 0x000008, "Wrong alignment on UConfigDialog");
static_assert(sizeof(UConfigDialog) == 0x000050, "Wrong size on UConfigDialog");
static_assert(offsetof(UConfigDialog, OnConfirm) == 0x000028, "Member 'UConfigDialog::OnConfirm' has a wrong offset!");

// Class xrd777.CutInDraw
// 0x0828 (0x0AC8 - 0x02A0)
class ACutInDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x638];                                    // 0x02A0(0x0638)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader_;                                      // 0x08D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              EmotionIconPlg_;                                   // 0x08E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               BustUpTexture_;                                    // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               BustUpDummyTexture_;                               // 0x08F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGetUIParameter                        UIP_;                                              // 0x08F8(0x0078)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve1_;                                           // 0x0970(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve2_;                                           // 0x09A0(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve3_;                                           // 0x09D0(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve4_;                                           // 0x0A00(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve5_;                                           // 0x0A30(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve6_;                                           // 0x0A60(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  Curve7_;                                           // 0x0A90(0x0030)(NativeAccessSpecifierPrivate)
	class USprAsset*                              Spr_;                                              // 0x0AC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutInDraw">();
	}
	static class ACutInDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACutInDraw>();
	}
};
static_assert(alignof(ACutInDraw) == 0x000008, "Wrong alignment on ACutInDraw");
static_assert(sizeof(ACutInDraw) == 0x000AC8, "Wrong size on ACutInDraw");
static_assert(offsetof(ACutInDraw, AssetLoader_) == 0x0008D8, "Member 'ACutInDraw::AssetLoader_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, EmotionIconPlg_) == 0x0008E0, "Member 'ACutInDraw::EmotionIconPlg_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, BustUpTexture_) == 0x0008E8, "Member 'ACutInDraw::BustUpTexture_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, BustUpDummyTexture_) == 0x0008F0, "Member 'ACutInDraw::BustUpDummyTexture_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, UIP_) == 0x0008F8, "Member 'ACutInDraw::UIP_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve1_) == 0x000970, "Member 'ACutInDraw::Curve1_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve2_) == 0x0009A0, "Member 'ACutInDraw::Curve2_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve3_) == 0x0009D0, "Member 'ACutInDraw::Curve3_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve4_) == 0x000A00, "Member 'ACutInDraw::Curve4_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve5_) == 0x000A30, "Member 'ACutInDraw::Curve5_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve6_) == 0x000A60, "Member 'ACutInDraw::Curve6_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Curve7_) == 0x000A90, "Member 'ACutInDraw::Curve7_' has a wrong offset!");
static_assert(offsetof(ACutInDraw, Spr_) == 0x000AC0, "Member 'ACutInDraw::Spr_' has a wrong offset!");

// Class xrd777.DatAnalyze
// 0x0010 (0x0038 - 0x0028)
class UDatAnalyze final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableAnalyzeSync;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAnalyze">();
	}
	static class UDatAnalyze* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAnalyze>();
	}
};
static_assert(alignof(UDatAnalyze) == 0x000008, "Wrong alignment on UDatAnalyze");
static_assert(sizeof(UDatAnalyze) == 0x000038, "Wrong size on UDatAnalyze");
static_assert(offsetof(UDatAnalyze, Loader) == 0x000028, "Member 'UDatAnalyze::Loader' has a wrong offset!");
static_assert(offsetof(UDatAnalyze, TableAnalyzeSync) == 0x000030, "Member 'UDatAnalyze::TableAnalyzeSync' has a wrong offset!");

// Class xrd777.DatEncount
// 0x0010 (0x0038 - 0x0028)
class UDatEncount final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableEncount;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatEncount">();
	}
	static class UDatEncount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatEncount>();
	}
};
static_assert(alignof(UDatEncount) == 0x000008, "Wrong alignment on UDatEncount");
static_assert(sizeof(UDatEncount) == 0x000038, "Wrong size on UDatEncount");
static_assert(offsetof(UDatEncount, Loader) == 0x000028, "Member 'UDatEncount::Loader' has a wrong offset!");
static_assert(offsetof(UDatEncount, TableEncount) == 0x000030, "Member 'UDatEncount::TableEncount' has a wrong offset!");

// Class xrd777.DatFontAdjustment
// 0x0010 (0x0038 - 0x0028)
class UDatFontAdjustment final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFontAdjustmentListTable*               TableFontAdjustment;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatFontAdjustment">();
	}
	static class UDatFontAdjustment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatFontAdjustment>();
	}
};
static_assert(alignof(UDatFontAdjustment) == 0x000008, "Wrong alignment on UDatFontAdjustment");
static_assert(sizeof(UDatFontAdjustment) == 0x000038, "Wrong size on UDatFontAdjustment");
static_assert(offsetof(UDatFontAdjustment, Loader) == 0x000028, "Member 'UDatFontAdjustment::Loader' has a wrong offset!");
static_assert(offsetof(UDatFontAdjustment, TableFontAdjustment) == 0x000030, "Member 'UDatFontAdjustment::TableFontAdjustment' has a wrong offset!");

// Class xrd777.DatItem
// 0x00A8 (0x00D0 - 0x0028)
class UDatItem final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableAccs;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableArmor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableCommon;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableCostume;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableEvitem;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableMaterial;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableShoes;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableSkillcard;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableWeapon;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableAccsName;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableArmorName;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableCommonName;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableCostumeName;                                  // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableEvitemName;                                   // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableMaterialName;                                 // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableShoesName;                                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableSkillcardName;                                // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             TableWeaponName;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADatItemActor*                          MActor_;                                           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatItem">();
	}
	static class UDatItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatItem>();
	}
};
static_assert(alignof(UDatItem) == 0x000008, "Wrong alignment on UDatItem");
static_assert(sizeof(UDatItem) == 0x0000D0, "Wrong size on UDatItem");
static_assert(offsetof(UDatItem, Loader) == 0x000028, "Member 'UDatItem::Loader' has a wrong offset!");
static_assert(offsetof(UDatItem, TableAccs) == 0x000030, "Member 'UDatItem::TableAccs' has a wrong offset!");
static_assert(offsetof(UDatItem, TableArmor) == 0x000038, "Member 'UDatItem::TableArmor' has a wrong offset!");
static_assert(offsetof(UDatItem, TableCommon) == 0x000040, "Member 'UDatItem::TableCommon' has a wrong offset!");
static_assert(offsetof(UDatItem, TableCostume) == 0x000048, "Member 'UDatItem::TableCostume' has a wrong offset!");
static_assert(offsetof(UDatItem, TableEvitem) == 0x000050, "Member 'UDatItem::TableEvitem' has a wrong offset!");
static_assert(offsetof(UDatItem, TableMaterial) == 0x000058, "Member 'UDatItem::TableMaterial' has a wrong offset!");
static_assert(offsetof(UDatItem, TableShoes) == 0x000060, "Member 'UDatItem::TableShoes' has a wrong offset!");
static_assert(offsetof(UDatItem, TableSkillcard) == 0x000068, "Member 'UDatItem::TableSkillcard' has a wrong offset!");
static_assert(offsetof(UDatItem, TableWeapon) == 0x000070, "Member 'UDatItem::TableWeapon' has a wrong offset!");
static_assert(offsetof(UDatItem, TableAccsName) == 0x000078, "Member 'UDatItem::TableAccsName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableArmorName) == 0x000080, "Member 'UDatItem::TableArmorName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableCommonName) == 0x000088, "Member 'UDatItem::TableCommonName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableCostumeName) == 0x000090, "Member 'UDatItem::TableCostumeName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableEvitemName) == 0x000098, "Member 'UDatItem::TableEvitemName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableMaterialName) == 0x0000A0, "Member 'UDatItem::TableMaterialName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableShoesName) == 0x0000A8, "Member 'UDatItem::TableShoesName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableSkillcardName) == 0x0000B0, "Member 'UDatItem::TableSkillcardName' has a wrong offset!");
static_assert(offsetof(UDatItem, TableWeaponName) == 0x0000B8, "Member 'UDatItem::TableWeaponName' has a wrong offset!");
static_assert(offsetof(UDatItem, MActor_) == 0x0000C8, "Member 'UDatItem::MActor_' has a wrong offset!");

// Class xrd777.DatMiniMapOffset
// 0x0028 (0x0058 - 0x0030)
class UDatMiniMapOffset final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMiniMapOffsetTable>            M_aOffsetList;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatMiniMapOffset">();
	}
	static class UDatMiniMapOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatMiniMapOffset>();
	}
};
static_assert(alignof(UDatMiniMapOffset) == 0x000008, "Wrong alignment on UDatMiniMapOffset");
static_assert(sizeof(UDatMiniMapOffset) == 0x000058, "Wrong size on UDatMiniMapOffset");
static_assert(offsetof(UDatMiniMapOffset, M_aOffsetList) == 0x000048, "Member 'UDatMiniMapOffset::M_aOffsetList' has a wrong offset!");

// Class xrd777.DatPlayer
// 0x0038 (0x0060 - 0x0028)
class UDatPlayer final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableLevelup;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableMaxHPSP;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatPlayerMaxHPSPTable*                 MaxHPSPDataCache;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableName;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableFitstName;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableLastName;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayer">();
	}
	static class UDatPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayer>();
	}
};
static_assert(alignof(UDatPlayer) == 0x000008, "Wrong alignment on UDatPlayer");
static_assert(sizeof(UDatPlayer) == 0x000060, "Wrong size on UDatPlayer");
static_assert(offsetof(UDatPlayer, Loader) == 0x000028, "Member 'UDatPlayer::Loader' has a wrong offset!");
static_assert(offsetof(UDatPlayer, TableLevelup) == 0x000030, "Member 'UDatPlayer::TableLevelup' has a wrong offset!");
static_assert(offsetof(UDatPlayer, TableMaxHPSP) == 0x000038, "Member 'UDatPlayer::TableMaxHPSP' has a wrong offset!");
static_assert(offsetof(UDatPlayer, MaxHPSPDataCache) == 0x000040, "Member 'UDatPlayer::MaxHPSPDataCache' has a wrong offset!");
static_assert(offsetof(UDatPlayer, TableName) == 0x000048, "Member 'UDatPlayer::TableName' has a wrong offset!");
static_assert(offsetof(UDatPlayer, TableFitstName) == 0x000050, "Member 'UDatPlayer::TableFitstName' has a wrong offset!");
static_assert(offsetof(UDatPlayer, TableLastName) == 0x000058, "Member 'UDatPlayer::TableLastName' has a wrong offset!");

// Class xrd777.DatPlayerFirstNameTable
// 0x0010 (0x0040 - 0x0030)
class UDatPlayerFirstNameTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPlayerNameOne>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPlayerFirstNameTable">();
	}
	static class UDatPlayerFirstNameTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPlayerFirstNameTable>();
	}
};
static_assert(alignof(UDatPlayerFirstNameTable) == 0x000008, "Wrong alignment on UDatPlayerFirstNameTable");
static_assert(sizeof(UDatPlayerFirstNameTable) == 0x000040, "Wrong size on UDatPlayerFirstNameTable");
static_assert(offsetof(UDatPlayerFirstNameTable, Data) == 0x000030, "Member 'UDatPlayerFirstNameTable::Data' has a wrong offset!");

// Class xrd777.DatShuffleCard
// 0x0078 (0x00A0 - 0x0028)
class UDatShuffleCard final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableName;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableChoiceMajor;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableChoiceMinor;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TablePersona;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableWand;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableCoin;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableCup;                                          // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableSword;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableFool;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableMagician;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableLovers;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableFortune;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableStrength;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableHangedman;                                    // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatShuffleCard">();
	}
	static class UDatShuffleCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatShuffleCard>();
	}
};
static_assert(alignof(UDatShuffleCard) == 0x000008, "Wrong alignment on UDatShuffleCard");
static_assert(sizeof(UDatShuffleCard) == 0x0000A0, "Wrong size on UDatShuffleCard");
static_assert(offsetof(UDatShuffleCard, Loader) == 0x000028, "Member 'UDatShuffleCard::Loader' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableName) == 0x000030, "Member 'UDatShuffleCard::TableName' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableChoiceMajor) == 0x000038, "Member 'UDatShuffleCard::TableChoiceMajor' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableChoiceMinor) == 0x000040, "Member 'UDatShuffleCard::TableChoiceMinor' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TablePersona) == 0x000048, "Member 'UDatShuffleCard::TablePersona' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableWand) == 0x000050, "Member 'UDatShuffleCard::TableWand' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableCoin) == 0x000058, "Member 'UDatShuffleCard::TableCoin' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableCup) == 0x000060, "Member 'UDatShuffleCard::TableCup' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableSword) == 0x000068, "Member 'UDatShuffleCard::TableSword' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableFool) == 0x000070, "Member 'UDatShuffleCard::TableFool' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableMagician) == 0x000078, "Member 'UDatShuffleCard::TableMagician' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableLovers) == 0x000080, "Member 'UDatShuffleCard::TableLovers' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableFortune) == 0x000088, "Member 'UDatShuffleCard::TableFortune' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableStrength) == 0x000090, "Member 'UDatShuffleCard::TableStrength' has a wrong offset!");
static_assert(offsetof(UDatShuffleCard, TableHangedman) == 0x000098, "Member 'UDatShuffleCard::TableHangedman' has a wrong offset!");

// Class xrd777.DatSuggestion
// 0x0018 (0x0040 - 0x0028)
class UDatSuggestion final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableSuggestion;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             TableSuggestionText;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSuggestion">();
	}
	static class UDatSuggestion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSuggestion>();
	}
};
static_assert(alignof(UDatSuggestion) == 0x000008, "Wrong alignment on UDatSuggestion");
static_assert(sizeof(UDatSuggestion) == 0x000040, "Wrong size on UDatSuggestion");
static_assert(offsetof(UDatSuggestion, Loader) == 0x000028, "Member 'UDatSuggestion::Loader' has a wrong offset!");
static_assert(offsetof(UDatSuggestion, TableSuggestion) == 0x000030, "Member 'UDatSuggestion::TableSuggestion' has a wrong offset!");
static_assert(offsetof(UDatSuggestion, TableSuggestionText) == 0x000038, "Member 'UDatSuggestion::TableSuggestionText' has a wrong offset!");

// Class xrd777.DatSystemText
// 0x0070 (0x0098 - 0x0028)
class UDatSystemText final : public UObject
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTable;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableEx;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class FString>                    SystemTextTable;                                   // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatSystemText">();
	}
	static class UDatSystemText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatSystemText>();
	}
};
static_assert(alignof(UDatSystemText) == 0x000008, "Wrong alignment on UDatSystemText");
static_assert(sizeof(UDatSystemText) == 0x000098, "Wrong size on UDatSystemText");
static_assert(offsetof(UDatSystemText, Loader) == 0x000028, "Member 'UDatSystemText::Loader' has a wrong offset!");
static_assert(offsetof(UDatSystemText, DataTable) == 0x000030, "Member 'UDatSystemText::DataTable' has a wrong offset!");
static_assert(offsetof(UDatSystemText, DataTableEx) == 0x000038, "Member 'UDatSystemText::DataTableEx' has a wrong offset!");
static_assert(offsetof(UDatSystemText, SystemTextTable) == 0x000040, "Member 'UDatSystemText::SystemTextTable' has a wrong offset!");

// Class xrd777.DatTownMapInfo
// 0x0048 (0x0078 - 0x0030)
class UDatTownMapInfo final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTownMapInfoTable>              M_aTownMapInfoList;                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTownMapInfoNameTable>          M_aNameList;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTownMapDetailTextTable>        M_aDetailTextList;                                 // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatTownMapInfo">();
	}
	static class UDatTownMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatTownMapInfo>();
	}
};
static_assert(alignof(UDatTownMapInfo) == 0x000008, "Wrong alignment on UDatTownMapInfo");
static_assert(sizeof(UDatTownMapInfo) == 0x000078, "Wrong size on UDatTownMapInfo");
static_assert(offsetof(UDatTownMapInfo, M_aTownMapInfoList) == 0x000048, "Member 'UDatTownMapInfo::M_aTownMapInfoList' has a wrong offset!");
static_assert(offsetof(UDatTownMapInfo, M_aNameList) == 0x000058, "Member 'UDatTownMapInfo::M_aNameList' has a wrong offset!");
static_assert(offsetof(UDatTownMapInfo, M_aDetailTextList) == 0x000068, "Member 'UDatTownMapInfo::M_aDetailTextList' has a wrong offset!");

// Class xrd777.DatTownMapTime
// 0x0028 (0x0058 - 0x0030)
class UDatTownMapTime final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatTownMapTime">();
	}
	static class UDatTownMapTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatTownMapTime>();
	}
};
static_assert(alignof(UDatTownMapTime) == 0x000008, "Wrong alignment on UDatTownMapTime");
static_assert(sizeof(UDatTownMapTime) == 0x000058, "Wrong size on UDatTownMapTime");

// Class xrd777.DatUnit
// 0x0000 (0x0028 - 0x0028)
class UDatUnit final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatUnit">();
	}
	static class UDatUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatUnit>();
	}
};
static_assert(alignof(UDatUnit) == 0x000008, "Wrong alignment on UDatUnit");
static_assert(sizeof(UDatUnit) == 0x000028, "Wrong size on UDatUnit");

// Class xrd777.DictionaryTableDataAsset
// 0x0010 (0x0040 - 0x0030)
class UDictionaryTableDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FDictionaryTableData>           Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DictionaryTableDataAsset">();
	}
	static class UDictionaryTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDictionaryTableDataAsset>();
	}
};
static_assert(alignof(UDictionaryTableDataAsset) == 0x000008, "Wrong alignment on UDictionaryTableDataAsset");
static_assert(sizeof(UDictionaryTableDataAsset) == 0x000040, "Wrong size on UDictionaryTableDataAsset");
static_assert(offsetof(UDictionaryTableDataAsset, Tables) == 0x000030, "Member 'UDictionaryTableDataAsset::Tables' has a wrong offset!");

// Class xrd777.DifficultySelectionActor
// 0x0498 (0x0750 - 0x02B8)
class ADifficultySelectionActor final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x90];                                     // 0x02B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader;                                       // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              TitleSpr;                                          // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              TitleSprAstrea;                                    // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              TitlePlg;                                          // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               InheritanceTex;                                    // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TitleSelectDataTable;                              // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             LayoutDataTable;                                   // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     UILayoutLayoutDataTable;                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DiffBGScaleAnimFrame;                              // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DiffBGAlphaAnimFrame;                              // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DiffBGGradAlphaAnimFrame;                          // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ListWaitFrame;                                     // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoInAnimRange;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoInAnimFrame;                                   // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoInWaitFrame;                                   // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoChangeAnimRange;                               // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoChangeFrame;                                   // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoChangeAnimWaitFrame;                           // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloseListAndHelpFrame;                             // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloseListY;                                        // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CloseBGFrame;                                      // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InheritanceBGFrame;                                // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InheritanceFadeFrame;                              // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CloseBGNotScaleFlag;                               // 0x03C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeAnimDisable;                                // 0x03C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C6[0x2];                                      // 0x03C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiffBGX;                                           // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiffBGY;                                           // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x380];                                    // 0x03D0(0x0380)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeInfoL();
	void ChangeInfoR();
	void DrawBG();
	void DrawBlackFade();
	void DrawDescriptionText(const struct FVector2D& InPos, const struct FColor& InColor);
	void DrawDiffList();
	void DrawHelp(float AddX, float AddY);
	void DrawInfoText(const struct FVector2D& InPos, const struct FColor& InColor);
	int32 GetCursorIndex();
	struct FVector2D GetScreenSize();
	bool HasMsgInstance();
	bool LoadCheck();
	void ProcessCompleted__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultySelectionActor">();
	}
	static class ADifficultySelectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADifficultySelectionActor>();
	}
};
static_assert(alignof(ADifficultySelectionActor) == 0x000008, "Wrong alignment on ADifficultySelectionActor");
static_assert(sizeof(ADifficultySelectionActor) == 0x000750, "Wrong size on ADifficultySelectionActor");
static_assert(offsetof(ADifficultySelectionActor, AssetLoader) == 0x000348, "Member 'ADifficultySelectionActor::AssetLoader' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, TitleSpr) == 0x000350, "Member 'ADifficultySelectionActor::TitleSpr' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, TitleSprAstrea) == 0x000358, "Member 'ADifficultySelectionActor::TitleSprAstrea' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, TitlePlg) == 0x000360, "Member 'ADifficultySelectionActor::TitlePlg' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InheritanceTex) == 0x000368, "Member 'ADifficultySelectionActor::InheritanceTex' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, TitleSelectDataTable) == 0x000370, "Member 'ADifficultySelectionActor::TitleSelectDataTable' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, LayoutDataTable) == 0x000378, "Member 'ADifficultySelectionActor::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, UILayoutLayoutDataTable) == 0x000380, "Member 'ADifficultySelectionActor::UILayoutLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, DiffBGScaleAnimFrame) == 0x000388, "Member 'ADifficultySelectionActor::DiffBGScaleAnimFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, DiffBGAlphaAnimFrame) == 0x00038C, "Member 'ADifficultySelectionActor::DiffBGAlphaAnimFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, DiffBGGradAlphaAnimFrame) == 0x000390, "Member 'ADifficultySelectionActor::DiffBGGradAlphaAnimFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, ListWaitFrame) == 0x000394, "Member 'ADifficultySelectionActor::ListWaitFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoInAnimRange) == 0x000398, "Member 'ADifficultySelectionActor::InfoInAnimRange' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoInAnimFrame) == 0x00039C, "Member 'ADifficultySelectionActor::InfoInAnimFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoInWaitFrame) == 0x0003A0, "Member 'ADifficultySelectionActor::InfoInWaitFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoChangeAnimRange) == 0x0003A4, "Member 'ADifficultySelectionActor::InfoChangeAnimRange' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoChangeFrame) == 0x0003A8, "Member 'ADifficultySelectionActor::InfoChangeFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InfoChangeAnimWaitFrame) == 0x0003AC, "Member 'ADifficultySelectionActor::InfoChangeAnimWaitFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, CloseListAndHelpFrame) == 0x0003B0, "Member 'ADifficultySelectionActor::CloseListAndHelpFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, CloseListY) == 0x0003B4, "Member 'ADifficultySelectionActor::CloseListY' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, CloseBGFrame) == 0x0003B8, "Member 'ADifficultySelectionActor::CloseBGFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InheritanceBGFrame) == 0x0003BC, "Member 'ADifficultySelectionActor::InheritanceBGFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, InheritanceFadeFrame) == 0x0003C0, "Member 'ADifficultySelectionActor::InheritanceFadeFrame' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, CloseBGNotScaleFlag) == 0x0003C4, "Member 'ADifficultySelectionActor::CloseBGNotScaleFlag' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, bChangeAnimDisable) == 0x0003C5, "Member 'ADifficultySelectionActor::bChangeAnimDisable' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, DiffBGX) == 0x0003C8, "Member 'ADifficultySelectionActor::DiffBGX' has a wrong offset!");
static_assert(offsetof(ADifficultySelectionActor, DiffBGY) == 0x0003CC, "Member 'ADifficultySelectionActor::DiffBGY' has a wrong offset!");

// Class xrd777.Draft_EventManager
// 0x0048 (0x0268 - 0x0220)
class ADraft_EventManager final : public AActor
{
public:
	class UBmdAsset*                              MpBmdAsset;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExecutingMessageNo;                                // 0x0230(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EEventManagerMessageState                     MessageState;                                      // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieSceneSequencePlayer*              EventSequencePlayer;                               // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestedSeqClosedEventMessageID;                  // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEventManagerSeqControllerState               SeqControllerState;                                // 0x0254(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEvtLocalData                          EvtLocalData;                                      // 0x0258(0x0010)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void CloseMessage();
	void ExecuteMessage(class UBmdAsset* InAsset, int32 InMessageNo, int32 InEventMessageID);
	void ExecuteMessageWithSelect(class UBmdAsset* InAsset, int32 InMessageNo, int32 InSelectNo, int32 InEventMessageID);
	int32 ExecuteMsgScript();
	int32 ExecuteSelectScript();
	void ForcedRemoveMessage();
	void ResumeEventSequencer();
	void SetLocalData(int32 Index_0, int32 Data);

	int32 GetLocalData(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Draft_EventManager">();
	}
	static class ADraft_EventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADraft_EventManager>();
	}
};
static_assert(alignof(ADraft_EventManager) == 0x000008, "Wrong alignment on ADraft_EventManager");
static_assert(sizeof(ADraft_EventManager) == 0x000268, "Wrong size on ADraft_EventManager");
static_assert(offsetof(ADraft_EventManager, MpBmdAsset) == 0x000220, "Member 'ADraft_EventManager::MpBmdAsset' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, ExecutingMessageNo) == 0x000230, "Member 'ADraft_EventManager::ExecutingMessageNo' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, MessageState) == 0x000238, "Member 'ADraft_EventManager::MessageState' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, EventSequencePlayer) == 0x000240, "Member 'ADraft_EventManager::EventSequencePlayer' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, RequestedSeqClosedEventMessageID) == 0x000250, "Member 'ADraft_EventManager::RequestedSeqClosedEventMessageID' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, SeqControllerState) == 0x000254, "Member 'ADraft_EventManager::SeqControllerState' has a wrong offset!");
static_assert(offsetof(ADraft_EventManager, EvtLocalData) == 0x000258, "Member 'ADraft_EventManager::EvtLocalData' has a wrong offset!");

// Class xrd777.DungeonSoundTableTypes
// 0x0000 (0x0028 - 0x0028)
class UDungeonSoundTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSoundTableTypes">();
	}
	static class UDungeonSoundTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSoundTableTypes>();
	}
};
static_assert(alignof(UDungeonSoundTableTypes) == 0x000008, "Wrong alignment on UDungeonSoundTableTypes");
static_assert(sizeof(UDungeonSoundTableTypes) == 0x000028, "Wrong size on UDungeonSoundTableTypes");

// Class xrd777.EntranceDoorBase
// 0x0010 (0x0230 - 0x0220)
class AEntranceDoorBase final : public AActor
{
public:
	int32                                         DoorShineIndex;                                    // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      DoorShineNiagara;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntranceDoorBase">();
	}
	static class AEntranceDoorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEntranceDoorBase>();
	}
};
static_assert(alignof(AEntranceDoorBase) == 0x000008, "Wrong alignment on AEntranceDoorBase");
static_assert(sizeof(AEntranceDoorBase) == 0x000230, "Wrong size on AEntranceDoorBase");
static_assert(offsetof(AEntranceDoorBase, DoorShineIndex) == 0x000220, "Member 'AEntranceDoorBase::DoorShineIndex' has a wrong offset!");
static_assert(offsetof(AEntranceDoorBase, DoorShineNiagara) == 0x000228, "Member 'AEntranceDoorBase::DoorShineNiagara' has a wrong offset!");

// Class xrd777.EventSkipWidgetDelegate
// 0x0018 (0x0278 - 0x0260)
class UEventSkipWidgetDelegate : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnEventDispather;                                  // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallDelegate(bool InSetEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSkipWidgetDelegate">();
	}
	static class UEventSkipWidgetDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSkipWidgetDelegate>();
	}
};
static_assert(alignof(UEventSkipWidgetDelegate) == 0x000008, "Wrong alignment on UEventSkipWidgetDelegate");
static_assert(sizeof(UEventSkipWidgetDelegate) == 0x000278, "Wrong size on UEventSkipWidgetDelegate");
static_assert(offsetof(UEventSkipWidgetDelegate, OnEventDispather) == 0x000260, "Member 'UEventSkipWidgetDelegate::OnEventDispather' has a wrong offset!");

// Class xrd777.EvtDataAssets
// 0x0000 (0x0028 - 0x0028)
class UEvtDataAssets final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtDataAssets">();
	}
	static class UEvtDataAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtDataAssets>();
	}
};
static_assert(alignof(UEvtDataAssets) == 0x000008, "Wrong alignment on UEvtDataAssets");
static_assert(sizeof(UEvtDataAssets) == 0x000028, "Wrong size on UEvtDataAssets");

// Class xrd777.DatDataOffTable
// 0x0010 (0x0040 - 0x0030)
class UDatDataOffTable final : public UAppDataAsset
{
public:
	TArray<struct FDatDataOffDataTable>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatDataOffTable">();
	}
	static class UDatDataOffTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatDataOffTable>();
	}
};
static_assert(alignof(UDatDataOffTable) == 0x000008, "Wrong alignment on UDatDataOffTable");
static_assert(sizeof(UDatDataOffTable) == 0x000040, "Wrong size on UDatDataOffTable");
static_assert(offsetof(UDatDataOffTable, Data) == 0x000030, "Member 'UDatDataOffTable::Data' has a wrong offset!");

// Class xrd777.DatFadeOutTable
// 0x0010 (0x0040 - 0x0030)
class UDatFadeOutTable final : public UAppDataAsset
{
public:
	TArray<struct FDatFadeOutDataTable>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatFadeOutTable">();
	}
	static class UDatFadeOutTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatFadeOutTable>();
	}
};
static_assert(alignof(UDatFadeOutTable) == 0x000008, "Wrong alignment on UDatFadeOutTable");
static_assert(sizeof(UDatFadeOutTable) == 0x000040, "Wrong size on UDatFadeOutTable");
static_assert(offsetof(UDatFadeOutTable, Data) == 0x000030, "Member 'UDatFadeOutTable::Data' has a wrong offset!");

// Class xrd777.DatAssetOverWriteEventTable
// 0x0010 (0x0040 - 0x0030)
class UDatAssetOverWriteEventTable final : public UAppDataAsset
{
public:
	TArray<struct FDatAssetOverWriteEventDataTable> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatAssetOverWriteEventTable">();
	}
	static class UDatAssetOverWriteEventTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatAssetOverWriteEventTable>();
	}
};
static_assert(alignof(UDatAssetOverWriteEventTable) == 0x000008, "Wrong alignment on UDatAssetOverWriteEventTable");
static_assert(sizeof(UDatAssetOverWriteEventTable) == 0x000040, "Wrong size on UDatAssetOverWriteEventTable");
static_assert(offsetof(UDatAssetOverWriteEventTable, Data) == 0x000030, "Member 'UDatAssetOverWriteEventTable::Data' has a wrong offset!");

// Class xrd777.DatPersonaCombineAdjustTable
// 0x0010 (0x0040 - 0x0030)
class UDatPersonaCombineAdjustTable final : public UAppDataAsset
{
public:
	TArray<struct FDatPersonaCombineAdjustDataTable> Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatPersonaCombineAdjustTable">();
	}
	static class UDatPersonaCombineAdjustTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatPersonaCombineAdjustTable>();
	}
};
static_assert(alignof(UDatPersonaCombineAdjustTable) == 0x000008, "Wrong alignment on UDatPersonaCombineAdjustTable");
static_assert(sizeof(UDatPersonaCombineAdjustTable) == 0x000040, "Wrong size on UDatPersonaCombineAdjustTable");
static_assert(offsetof(UDatPersonaCombineAdjustTable, Data) == 0x000030, "Member 'UDatPersonaCombineAdjustTable::Data' has a wrong offset!");

// Class xrd777.EvtDataLoad
// 0x0048 (0x0070 - 0x0028)
class UEvtDataLoad final : public UObject
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PDataOffTable;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PFadeOutTable;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PAssetOverWriteTable;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PAssetOverWriteEventTable;                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PBagEnableTable;                                   // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PEvtPreDataTable;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PPersonaCombineAdjustTable;                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             PObjectVisibleTable;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtDataLoad">();
	}
	static class UEvtDataLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtDataLoad>();
	}
};
static_assert(alignof(UEvtDataLoad) == 0x000008, "Wrong alignment on UEvtDataLoad");
static_assert(sizeof(UEvtDataLoad) == 0x000070, "Wrong size on UEvtDataLoad");
static_assert(offsetof(UEvtDataLoad, PAssetLoader) == 0x000028, "Member 'UEvtDataLoad::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PDataOffTable) == 0x000030, "Member 'UEvtDataLoad::PDataOffTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PFadeOutTable) == 0x000038, "Member 'UEvtDataLoad::PFadeOutTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PAssetOverWriteTable) == 0x000040, "Member 'UEvtDataLoad::PAssetOverWriteTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PAssetOverWriteEventTable) == 0x000048, "Member 'UEvtDataLoad::PAssetOverWriteEventTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PBagEnableTable) == 0x000050, "Member 'UEvtDataLoad::PBagEnableTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PEvtPreDataTable) == 0x000058, "Member 'UEvtDataLoad::PEvtPreDataTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PPersonaCombineAdjustTable) == 0x000060, "Member 'UEvtDataLoad::PPersonaCombineAdjustTable' has a wrong offset!");
static_assert(offsetof(UEvtDataLoad, PObjectVisibleTable) == 0x000068, "Member 'UEvtDataLoad::PObjectVisibleTable' has a wrong offset!");

// Class xrd777.EvtManagerStateBacklog
// 0x0010 (0x0048 - 0x0038)
class UEvtManagerStateBacklog final : public UEvtManagerStateBase
{
public:
	class AUIBackLog*                             UIBackLogActor;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackLogFinishDelegte();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtManagerStateBacklog">();
	}
	static class UEvtManagerStateBacklog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtManagerStateBacklog>();
	}
};
static_assert(alignof(UEvtManagerStateBacklog) == 0x000008, "Wrong alignment on UEvtManagerStateBacklog");
static_assert(sizeof(UEvtManagerStateBacklog) == 0x000048, "Wrong size on UEvtManagerStateBacklog");
static_assert(offsetof(UEvtManagerStateBacklog, UIBackLogActor) == 0x000038, "Member 'UEvtManagerStateBacklog::UIBackLogActor' has a wrong offset!");

// Class xrd777.UIVelvetRoomPanel
// 0x0138 (0x03B0 - 0x0278)
class AUIVelvetRoomPanel final : public AAppActor
{
public:
	uint8                                         Pad_278[0x138];                                    // 0x0278(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomPanel">();
	}
	static class AUIVelvetRoomPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVelvetRoomPanel>();
	}
};
static_assert(alignof(AUIVelvetRoomPanel) == 0x000008, "Wrong alignment on AUIVelvetRoomPanel");
static_assert(sizeof(AUIVelvetRoomPanel) == 0x0003B0, "Wrong size on AUIVelvetRoomPanel");

// Class xrd777.EvtManagerStateExit
// 0x0000 (0x0038 - 0x0038)
class UEvtManagerStateExit final : public UEvtManagerStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtManagerStateExit">();
	}
	static class UEvtManagerStateExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtManagerStateExit>();
	}
};
static_assert(alignof(UEvtManagerStateExit) == 0x000008, "Wrong alignment on UEvtManagerStateExit");
static_assert(sizeof(UEvtManagerStateExit) == 0x000038, "Wrong size on UEvtManagerStateExit");

// Class xrd777.EvtManagerStateNetAnswer
// 0x0010 (0x0048 - 0x0038)
class UEvtManagerStateNetAnswer final : public UEvtManagerStateBase
{
public:
	class AUIVoiceAnswer*                         UINetAnswerActor;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNetAnswerFinishDelegte();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvtManagerStateNetAnswer">();
	}
	static class UEvtManagerStateNetAnswer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvtManagerStateNetAnswer>();
	}
};
static_assert(alignof(UEvtManagerStateNetAnswer) == 0x000008, "Wrong alignment on UEvtManagerStateNetAnswer");
static_assert(sizeof(UEvtManagerStateNetAnswer) == 0x000048, "Wrong size on UEvtManagerStateNetAnswer");
static_assert(offsetof(UEvtManagerStateNetAnswer, UINetAnswerActor) == 0x000038, "Member 'UEvtManagerStateNetAnswer::UINetAnswerActor' has a wrong offset!");

// Class xrd777.VelvetRoomUnimDataAsset
// 0x0010 (0x0040 - 0x0030)
class UVelvetRoomUnimDataAsset final : public UAppDataAsset
{
public:
	TArray<class UUimAsset*>                      Asset;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelvetRoomUnimDataAsset">();
	}
	static class UVelvetRoomUnimDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelvetRoomUnimDataAsset>();
	}
};
static_assert(alignof(UVelvetRoomUnimDataAsset) == 0x000008, "Wrong alignment on UVelvetRoomUnimDataAsset");
static_assert(sizeof(UVelvetRoomUnimDataAsset) == 0x000040, "Wrong size on UVelvetRoomUnimDataAsset");
static_assert(offsetof(UVelvetRoomUnimDataAsset, Asset) == 0x000030, "Member 'UVelvetRoomUnimDataAsset::Asset' has a wrong offset!");

// Class xrd777.FadePgBattleEventWipeActor
// 0x0008 (0x0280 - 0x0278)
class AFadePgBattleEventWipeActor final : public AAppActor
{
public:
	bool                                          IsAnimation;                                       // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateForBP();
	void DeleteForBP();
	void DrawForBP(float DeltaTime);
	void RequestFadeInForBP();
	void RequestFadeOutForBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgBattleEventWipeActor">();
	}
	static class AFadePgBattleEventWipeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadePgBattleEventWipeActor>();
	}
};
static_assert(alignof(AFadePgBattleEventWipeActor) == 0x000008, "Wrong alignment on AFadePgBattleEventWipeActor");
static_assert(sizeof(AFadePgBattleEventWipeActor) == 0x000280, "Wrong size on AFadePgBattleEventWipeActor");
static_assert(offsetof(AFadePgBattleEventWipeActor, IsAnimation) == 0x000278, "Member 'AFadePgBattleEventWipeActor::IsAnimation' has a wrong offset!");

// Class xrd777.FadePgBattleEventWipe
// 0x0020 (0x0060 - 0x0040)
class UFadePgBattleEventWipe final : public UFadeProgramBase
{
public:
	class AFadePgBattleEventWipeActor*            PActor;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFadePgBattleEventWipeActor> LoadClass;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           PAssetLoader;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLoading;                                        // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLoaded;                                         // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bMainLoaded;                                     // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsAnimation;                                    // 0x005B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestNo;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgBattleEventWipe">();
	}
	static class UFadePgBattleEventWipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgBattleEventWipe>();
	}
};
static_assert(alignof(UFadePgBattleEventWipe) == 0x000008, "Wrong alignment on UFadePgBattleEventWipe");
static_assert(sizeof(UFadePgBattleEventWipe) == 0x000060, "Wrong size on UFadePgBattleEventWipe");
static_assert(offsetof(UFadePgBattleEventWipe, PActor) == 0x000040, "Member 'UFadePgBattleEventWipe::PActor' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, LoadClass) == 0x000048, "Member 'UFadePgBattleEventWipe::LoadClass' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, PAssetLoader) == 0x000050, "Member 'UFadePgBattleEventWipe::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, M_bLoading) == 0x000058, "Member 'UFadePgBattleEventWipe::M_bLoading' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, M_bLoaded) == 0x000059, "Member 'UFadePgBattleEventWipe::M_bLoaded' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, M_bMainLoaded) == 0x00005A, "Member 'UFadePgBattleEventWipe::M_bMainLoaded' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, M_bIsAnimation) == 0x00005B, "Member 'UFadePgBattleEventWipe::M_bIsAnimation' has a wrong offset!");
static_assert(offsetof(UFadePgBattleEventWipe, RequestNo) == 0x00005C, "Member 'UFadePgBattleEventWipe::RequestNo' has a wrong offset!");

// Class xrd777.BattleResultWatcher
// 0x0010 (0x0038 - 0x0028)
class UBattleResultWatcher final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleResultWatcher">();
	}
	static class UBattleResultWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleResultWatcher>();
	}
};
static_assert(alignof(UBattleResultWatcher) == 0x000008, "Wrong alignment on UBattleResultWatcher");
static_assert(sizeof(UBattleResultWatcher) == 0x000038, "Wrong size on UBattleResultWatcher");

// Class xrd777.FadePgBattleResultEnd
// 0x0000 (0x0110 - 0x0110)
class UFadePgBattleResultEnd final : public UFadePgBattleResult
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgBattleResultEnd">();
	}
	static class UFadePgBattleResultEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgBattleResultEnd>();
	}
};
static_assert(alignof(UFadePgBattleResultEnd) == 0x000008, "Wrong alignment on UFadePgBattleResultEnd");
static_assert(sizeof(UFadePgBattleResultEnd) == 0x000110, "Wrong size on UFadePgBattleResultEnd");

// Class xrd777.FadePgSlide
// 0x0030 (0x0070 - 0x0040)
class UFadePgSlide final : public UFadeProgramBase
{
public:
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgSlide">();
	}
	static class UFadePgSlide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgSlide>();
	}
};
static_assert(alignof(UFadePgSlide) == 0x000008, "Wrong alignment on UFadePgSlide");
static_assert(sizeof(UFadePgSlide) == 0x000070, "Wrong size on UFadePgSlide");

// Class xrd777.FadePgSlideVertical
// 0x0028 (0x0068 - 0x0040)
class UFadePgSlideVertical final : public UFadeProgramBase
{
public:
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgSlideVertical">();
	}
	static class UFadePgSlideVertical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgSlideVertical>();
	}
};
static_assert(alignof(UFadePgSlideVertical) == 0x000008, "Wrong alignment on UFadePgSlideVertical");
static_assert(sizeof(UFadePgSlideVertical) == 0x000068, "Wrong size on UFadePgSlideVertical");

// Class xrd777.FadePgVelvet
// 0x2418 (0x2458 - 0x0040)
class UFadePgVelvet final : public UFadeProgramBase
{
public:
	struct FVelvetWipe                            M_velvetWipe;                                      // 0x0040(0x2418)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePgVelvet">();
	}
	static class UFadePgVelvet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePgVelvet>();
	}
};
static_assert(alignof(UFadePgVelvet) == 0x000008, "Wrong alignment on UFadePgVelvet");
static_assert(sizeof(UFadePgVelvet) == 0x002458, "Wrong size on UFadePgVelvet");
static_assert(offsetof(UFadePgVelvet, M_velvetWipe) == 0x000040, "Member 'UFadePgVelvet::M_velvetWipe' has a wrong offset!");

// Class xrd777.FadePlayer
// 0x0070 (0x0098 - 0x0028)
class UFadePlayer final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFadeProgramBase*>               Programs_;                                         // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void FadeIn(int32 Type, const struct FFadeProperties& Props);
	void FadeOut(int32 Type, const struct FFadeProperties& Props);
	const struct FFadeProperties GetDefaultProperties(int32 Type);
	void OnTick(float DeltaTime);
	void SetColor(float R, float G, float B);

	struct FColor GetColor() const;
	float GetCurrentStateTime() const;
	float GetFadeDuration() const;
	EFadeMode GetFadeMode() const;
	EFadingState GetFadingState() const;
	float GetProgressRate(bool Inverse) const;
	float GetRemainDuration() const;
	bool IsExistNextFade() const;
	bool IsFading() const;
	bool IsFilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadePlayer">();
	}
	static class UFadePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadePlayer>();
	}
};
static_assert(alignof(UFadePlayer) == 0x000008, "Wrong alignment on UFadePlayer");
static_assert(sizeof(UFadePlayer) == 0x000098, "Wrong size on UFadePlayer");
static_assert(offsetof(UFadePlayer, Programs_) == 0x000088, "Member 'UFadePlayer::Programs_' has a wrong offset!");

// Class xrd777.AntiqueShopDrawCommon
// 0x23A8 (0x23D0 - 0x0028)
class UAntiqueShopDrawCommon final : public UObject
{
public:
	uint8                                         Pad_28[0x1E00];                                    // 0x0028(0x1E00)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICloudCursorDraw*                     _pCloudCursor;                                     // 0x1E28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E30[0x5A0];                                   // 0x1E30(0x05A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiqueShopDrawCommon">();
	}
	static class UAntiqueShopDrawCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiqueShopDrawCommon>();
	}
};
static_assert(alignof(UAntiqueShopDrawCommon) == 0x000008, "Wrong alignment on UAntiqueShopDrawCommon");
static_assert(sizeof(UAntiqueShopDrawCommon) == 0x0023D0, "Wrong size on UAntiqueShopDrawCommon");
static_assert(offsetof(UAntiqueShopDrawCommon, _pCloudCursor) == 0x001E28, "Member 'UAntiqueShopDrawCommon::_pCloudCursor' has a wrong offset!");

// Class xrd777.FclItemShop
// 0x0D68 (0x1128 - 0x03C0)
class AFclItemShop final : public AFclShopBase
{
public:
	uint8                                         Pad_3C0[0x5E0];                                    // 0x03C0(0x05E0)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pSpr_ItemShop;                                   // 0x09A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr_Common;                                     // 0x09A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pTex_ItemShopPlg;                                // 0x09B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pTex_CommonPlg;                                  // 0x09B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_Medisine1;                                  // 0x09C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_Medisine2;                                  // 0x09C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_Medisine3;                                  // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_Medisine4;                                  // 0x09D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_CapusleA_1;                                 // 0x09E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_CapusleB_1;                                 // 0x09E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_CapusleC_1;                                 // 0x09F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTex_CapusleShadow;                              // 0x09F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr_Common_Money;                               // 0x0A00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x5B8];                                    // 0x0A08(0x05B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0FC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemShopLineUpListTable*               LineupTable_;                                      // 0x0FC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               BfAsset_;                                          // 0x0FD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0FD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE0[0x8];                                      // 0x0FE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUimAsset*                              M_pUimCapsuleAIn;                                  // 0x0FE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleBIn;                                  // 0x0FF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleCIn;                                  // 0x0FF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleAChange;                              // 0x1000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleBChange;                              // 0x1008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleCChange;                              // 0x1010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleAOut1;                                // 0x1018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleBOut1;                                // 0x1020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleCOut1;                                // 0x1028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleAOut2;                                // 0x1030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleBOut2;                                // 0x1038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUimAsset*                              M_pUimCapsuleCOut2;                                // 0x1040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICloudCursorDraw*                     CloudCursor_;                                      // 0x1048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1050[0x30];                                    // 0x1050(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     M_pTextDataTable;                                  // 0x1080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pTextData;                                       // 0x1088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pLayoutDataTable;                                // 0x1090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pLayoutData;                                     // 0x1098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A0[0x88];                                    // 0x10A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclItemShop">();
	}
	static class AFclItemShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclItemShop>();
	}
};
static_assert(alignof(AFclItemShop) == 0x000008, "Wrong alignment on AFclItemShop");
static_assert(sizeof(AFclItemShop) == 0x001128, "Wrong size on AFclItemShop");
static_assert(offsetof(AFclItemShop, M_pSpr_ItemShop) == 0x0009A0, "Member 'AFclItemShop::M_pSpr_ItemShop' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pSpr_Common) == 0x0009A8, "Member 'AFclItemShop::M_pSpr_Common' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_ItemShopPlg) == 0x0009B0, "Member 'AFclItemShop::M_pTex_ItemShopPlg' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_CommonPlg) == 0x0009B8, "Member 'AFclItemShop::M_pTex_CommonPlg' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_Medisine1) == 0x0009C0, "Member 'AFclItemShop::M_pTex_Medisine1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_Medisine2) == 0x0009C8, "Member 'AFclItemShop::M_pTex_Medisine2' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_Medisine3) == 0x0009D0, "Member 'AFclItemShop::M_pTex_Medisine3' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_Medisine4) == 0x0009D8, "Member 'AFclItemShop::M_pTex_Medisine4' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_CapusleA_1) == 0x0009E0, "Member 'AFclItemShop::M_pTex_CapusleA_1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_CapusleB_1) == 0x0009E8, "Member 'AFclItemShop::M_pTex_CapusleB_1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_CapusleC_1) == 0x0009F0, "Member 'AFclItemShop::M_pTex_CapusleC_1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTex_CapusleShadow) == 0x0009F8, "Member 'AFclItemShop::M_pTex_CapusleShadow' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pSpr_Common_Money) == 0x000A00, "Member 'AFclItemShop::M_pSpr_Common_Money' has a wrong offset!");
static_assert(offsetof(AFclItemShop, Loader_) == 0x000FC0, "Member 'AFclItemShop::Loader_' has a wrong offset!");
static_assert(offsetof(AFclItemShop, LineupTable_) == 0x000FC8, "Member 'AFclItemShop::LineupTable_' has a wrong offset!");
static_assert(offsetof(AFclItemShop, BfAsset_) == 0x000FD0, "Member 'AFclItemShop::BfAsset_' has a wrong offset!");
static_assert(offsetof(AFclItemShop, BmdAsset_) == 0x000FD8, "Member 'AFclItemShop::BmdAsset_' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleAIn) == 0x000FE8, "Member 'AFclItemShop::M_pUimCapsuleAIn' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleBIn) == 0x000FF0, "Member 'AFclItemShop::M_pUimCapsuleBIn' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleCIn) == 0x000FF8, "Member 'AFclItemShop::M_pUimCapsuleCIn' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleAChange) == 0x001000, "Member 'AFclItemShop::M_pUimCapsuleAChange' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleBChange) == 0x001008, "Member 'AFclItemShop::M_pUimCapsuleBChange' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleCChange) == 0x001010, "Member 'AFclItemShop::M_pUimCapsuleCChange' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleAOut1) == 0x001018, "Member 'AFclItemShop::M_pUimCapsuleAOut1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleBOut1) == 0x001020, "Member 'AFclItemShop::M_pUimCapsuleBOut1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleCOut1) == 0x001028, "Member 'AFclItemShop::M_pUimCapsuleCOut1' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleAOut2) == 0x001030, "Member 'AFclItemShop::M_pUimCapsuleAOut2' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleBOut2) == 0x001038, "Member 'AFclItemShop::M_pUimCapsuleBOut2' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pUimCapsuleCOut2) == 0x001040, "Member 'AFclItemShop::M_pUimCapsuleCOut2' has a wrong offset!");
static_assert(offsetof(AFclItemShop, CloudCursor_) == 0x001048, "Member 'AFclItemShop::CloudCursor_' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTextDataTable) == 0x001080, "Member 'AFclItemShop::M_pTextDataTable' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pTextData) == 0x001088, "Member 'AFclItemShop::M_pTextData' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pLayoutDataTable) == 0x001090, "Member 'AFclItemShop::M_pLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AFclItemShop, M_pLayoutData) == 0x001098, "Member 'AFclItemShop::M_pLayoutData' has a wrong offset!");

// Class xrd777.FclWeaponShop
// 0x01C8 (0x0588 - 0x03C0)
class AFclWeaponShop final : public AFclShopBase
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponShopLineUpListTable*             LineupTable_;                                      // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               BfAsset_;                                          // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset_;                                         // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _ComSpr00;                                         // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _ComSpr00_Astrea;                                  // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              _ComPlg00;                                         // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _Spr00;                                            // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              _Plg00;                                            // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataRoot;                              // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableRoot;                              // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataChara;                             // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableChara;                             // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCharaText;                         // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableCharaText;                         // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataBuyText;                           // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableBuyText;                           // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataBuyHelpText;                       // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableBuyHelpText;                       // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSellText;                          // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableSellText;                          // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataTradeInText;                       // 0x0468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableTradeInText;                       // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataOther;                             // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableOther;                             // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AFclWeaponShopDrawActor>    _DrawActorClass;                                   // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFclWeaponShopDrawActor*                _DrawActor;                                        // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0xF0];                                     // 0x0498(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FclWeaponShop">();
	}
	static class AFclWeaponShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFclWeaponShop>();
	}
};
static_assert(alignof(AFclWeaponShop) == 0x000008, "Wrong alignment on AFclWeaponShop");
static_assert(sizeof(AFclWeaponShop) == 0x000588, "Wrong size on AFclWeaponShop");
static_assert(offsetof(AFclWeaponShop, Loader_) == 0x0003C0, "Member 'AFclWeaponShop::Loader_' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, LineupTable_) == 0x0003C8, "Member 'AFclWeaponShop::LineupTable_' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, BfAsset_) == 0x0003D0, "Member 'AFclWeaponShop::BfAsset_' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, BmdAsset_) == 0x0003D8, "Member 'AFclWeaponShop::BmdAsset_' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _ComSpr00) == 0x0003E0, "Member 'AFclWeaponShop::_ComSpr00' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _ComSpr00_Astrea) == 0x0003E8, "Member 'AFclWeaponShop::_ComSpr00_Astrea' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _ComPlg00) == 0x0003F0, "Member 'AFclWeaponShop::_ComPlg00' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _Spr00) == 0x0003F8, "Member 'AFclWeaponShop::_Spr00' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _Plg00) == 0x000400, "Member 'AFclWeaponShop::_Plg00' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataRoot) == 0x000408, "Member 'AFclWeaponShop::PParamLayoutDataRoot' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableRoot) == 0x000410, "Member 'AFclWeaponShop::PLayoutDataTableRoot' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataChara) == 0x000418, "Member 'AFclWeaponShop::PParamLayoutDataChara' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableChara) == 0x000420, "Member 'AFclWeaponShop::PLayoutDataTableChara' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataCharaText) == 0x000428, "Member 'AFclWeaponShop::PParamLayoutDataCharaText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableCharaText) == 0x000430, "Member 'AFclWeaponShop::PLayoutDataTableCharaText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataBuyText) == 0x000438, "Member 'AFclWeaponShop::PParamLayoutDataBuyText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableBuyText) == 0x000440, "Member 'AFclWeaponShop::PLayoutDataTableBuyText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataBuyHelpText) == 0x000448, "Member 'AFclWeaponShop::PParamLayoutDataBuyHelpText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableBuyHelpText) == 0x000450, "Member 'AFclWeaponShop::PLayoutDataTableBuyHelpText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataSellText) == 0x000458, "Member 'AFclWeaponShop::PParamLayoutDataSellText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableSellText) == 0x000460, "Member 'AFclWeaponShop::PLayoutDataTableSellText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataTradeInText) == 0x000468, "Member 'AFclWeaponShop::PParamLayoutDataTradeInText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableTradeInText) == 0x000470, "Member 'AFclWeaponShop::PLayoutDataTableTradeInText' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PParamLayoutDataOther) == 0x000478, "Member 'AFclWeaponShop::PParamLayoutDataOther' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, PLayoutDataTableOther) == 0x000480, "Member 'AFclWeaponShop::PLayoutDataTableOther' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _DrawActorClass) == 0x000488, "Member 'AFclWeaponShop::_DrawActorClass' has a wrong offset!");
static_assert(offsetof(AFclWeaponShop, _DrawActor) == 0x000490, "Member 'AFclWeaponShop::_DrawActor' has a wrong offset!");

// Class xrd777.UFileNameManagerrActor
// 0x0018 (0x0290 - 0x0278)
class AUFileNameManagerrActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UFileNameManagerrActor">();
	}
	static class AUFileNameManagerrActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUFileNameManagerrActor>();
	}
};
static_assert(alignof(AUFileNameManagerrActor) == 0x000008, "Wrong alignment on AUFileNameManagerrActor");
static_assert(sizeof(AUFileNameManagerrActor) == 0x000290, "Wrong size on AUFileNameManagerrActor");
static_assert(offsetof(AUFileNameManagerrActor, MAssetLoader_) == 0x000280, "Member 'AUFileNameManagerrActor::MAssetLoader_' has a wrong offset!");

// Class xrd777.FldAnimalComp_BIRD
// 0x0050 (0x01C0 - 0x0170)
class UFldAnimalComp_BIRD : public UFldAnimalCompCore
{
public:
	bool                                          bWalkAfterLanding_;                                // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFlyPitch_;                                        // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFlyAwayTime_;                                     // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFlyAwayDist_;                                     // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MComebackTime_;                                    // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MComebackDist_;                                    // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFlyAway_;                                     // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MAutoFlyAwayTimeFix_;                              // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAutoFlyAwayTimeRnd_;                              // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAutoFlyAwayYaw_;                                  // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMove_;                                          // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MMoveTimeFix_;                                     // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMoveTimeRnd_;                                     // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMoveDist_;                                        // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMoveRadius_;                                      // 0x01A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x1C];                                     // 0x01A4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimalComp_BIRD">();
	}
	static class UFldAnimalComp_BIRD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldAnimalComp_BIRD>();
	}
};
static_assert(alignof(UFldAnimalComp_BIRD) == 0x000010, "Wrong alignment on UFldAnimalComp_BIRD");
static_assert(sizeof(UFldAnimalComp_BIRD) == 0x0001C0, "Wrong size on UFldAnimalComp_BIRD");
static_assert(offsetof(UFldAnimalComp_BIRD, bWalkAfterLanding_) == 0x000168, "Member 'UFldAnimalComp_BIRD::bWalkAfterLanding_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MFlyPitch_) == 0x00016C, "Member 'UFldAnimalComp_BIRD::MFlyPitch_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MFlyAwayTime_) == 0x000170, "Member 'UFldAnimalComp_BIRD::MFlyAwayTime_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MFlyAwayDist_) == 0x000174, "Member 'UFldAnimalComp_BIRD::MFlyAwayDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MComebackTime_) == 0x000178, "Member 'UFldAnimalComp_BIRD::MComebackTime_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MComebackDist_) == 0x00017C, "Member 'UFldAnimalComp_BIRD::MComebackDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, bAutoFlyAway_) == 0x000180, "Member 'UFldAnimalComp_BIRD::bAutoFlyAway_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MAutoFlyAwayTimeFix_) == 0x000184, "Member 'UFldAnimalComp_BIRD::MAutoFlyAwayTimeFix_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MAutoFlyAwayTimeRnd_) == 0x000188, "Member 'UFldAnimalComp_BIRD::MAutoFlyAwayTimeRnd_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MAutoFlyAwayYaw_) == 0x00018C, "Member 'UFldAnimalComp_BIRD::MAutoFlyAwayYaw_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, bIsMove_) == 0x000190, "Member 'UFldAnimalComp_BIRD::bIsMove_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MMoveTimeFix_) == 0x000194, "Member 'UFldAnimalComp_BIRD::MMoveTimeFix_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MMoveTimeRnd_) == 0x000198, "Member 'UFldAnimalComp_BIRD::MMoveTimeRnd_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MMoveDist_) == 0x00019C, "Member 'UFldAnimalComp_BIRD::MMoveDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_BIRD, MMoveRadius_) == 0x0001A0, "Member 'UFldAnimalComp_BIRD::MMoveRadius_' has a wrong offset!");

// Class xrd777.FldAnimalComp_PIGEON
// 0x0010 (0x01D0 - 0x01C0)
class UFldAnimalComp_PIGEON final : public UFldAnimalComp_BIRD
{
public:
	float                                         MRunAwayDist_;                                     // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHeroNearDist_;                                    // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimalComp_PIGEON">();
	}
	static class UFldAnimalComp_PIGEON* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldAnimalComp_PIGEON>();
	}
};
static_assert(alignof(UFldAnimalComp_PIGEON) == 0x000010, "Wrong alignment on UFldAnimalComp_PIGEON");
static_assert(sizeof(UFldAnimalComp_PIGEON) == 0x0001D0, "Wrong size on UFldAnimalComp_PIGEON");
static_assert(offsetof(UFldAnimalComp_PIGEON, MRunAwayDist_) == 0x0001C0, "Member 'UFldAnimalComp_PIGEON::MRunAwayDist_' has a wrong offset!");
static_assert(offsetof(UFldAnimalComp_PIGEON, MHeroNearDist_) == 0x0001C4, "Member 'UFldAnimalComp_PIGEON::MHeroNearDist_' has a wrong offset!");

// Class xrd777.FldAnimalHit
// 0x0018 (0x0298 - 0x0280)
class AFldAnimalHit final : public AFldLocalActor
{
public:
	class UFldAnimalCompCore*                     MOwner_;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MHitRadius_;                                       // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       MHitComp_;                                         // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimalHit">();
	}
	static class AFldAnimalHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldAnimalHit>();
	}
};
static_assert(alignof(AFldAnimalHit) == 0x000008, "Wrong alignment on AFldAnimalHit");
static_assert(sizeof(AFldAnimalHit) == 0x000298, "Wrong size on AFldAnimalHit");
static_assert(offsetof(AFldAnimalHit, MOwner_) == 0x000280, "Member 'AFldAnimalHit::MOwner_' has a wrong offset!");
static_assert(offsetof(AFldAnimalHit, MHitRadius_) == 0x000288, "Member 'AFldAnimalHit::MHitRadius_' has a wrong offset!");
static_assert(offsetof(AFldAnimalHit, MHitComp_) == 0x000290, "Member 'AFldAnimalHit::MHitComp_' has a wrong offset!");

// Class xrd777.FldAnimObj
// 0x0078 (0x0310 - 0x0298)
class AFldAnimObj : public AFldObjBase
{
public:
	TArray<struct FFldAnimeObjAnimation>          MAnimeArray_;                                      // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MIndex_;                                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MNotPausedInLoop_;                                 // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MAnimeMesh_;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      MNiagaraComp_;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         MAnimeMeshList_;                                   // 0x02C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         MAnimIndex_;                                       // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInit_;                                          // 0x02D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MLoopAnimIndex_;                                   // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MIsHide_;                                          // 0x02DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MHideTransform_;                                   // 0x02E0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ChangeAnimationDEBUG();
	void ChangeDisableActorAction(bool IsHide);
	void DebugSetting();
	int32 GetAnimationNum();
	int32 GetNowAnimeID();
	void Initialize(class USkeletalMeshComponent* SkeletalMesh, int32 AnimeID);
	void InitializeArray(const TArray<class USkeletalMeshComponent*>& SkeleTalMeshList, int32 AnimeID);
	bool IsPlayingAnimation();
	void PlayAnimation(int32 AnimeID, bool LoopFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldAnimObj">();
	}
	static class AFldAnimObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldAnimObj>();
	}
};
static_assert(alignof(AFldAnimObj) == 0x000010, "Wrong alignment on AFldAnimObj");
static_assert(sizeof(AFldAnimObj) == 0x000310, "Wrong size on AFldAnimObj");
static_assert(offsetof(AFldAnimObj, MAnimeArray_) == 0x000298, "Member 'AFldAnimObj::MAnimeArray_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MIndex_) == 0x0002A8, "Member 'AFldAnimObj::MIndex_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MNotPausedInLoop_) == 0x0002AC, "Member 'AFldAnimObj::MNotPausedInLoop_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MAnimeMesh_) == 0x0002B0, "Member 'AFldAnimObj::MAnimeMesh_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MNiagaraComp_) == 0x0002B8, "Member 'AFldAnimObj::MNiagaraComp_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MAnimeMeshList_) == 0x0002C0, "Member 'AFldAnimObj::MAnimeMeshList_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MAnimIndex_) == 0x0002D0, "Member 'AFldAnimObj::MAnimIndex_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, bIsInit_) == 0x0002D4, "Member 'AFldAnimObj::bIsInit_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MLoopAnimIndex_) == 0x0002D8, "Member 'AFldAnimObj::MLoopAnimIndex_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MIsHide_) == 0x0002DC, "Member 'AFldAnimObj::MIsHide_' has a wrong offset!");
static_assert(offsetof(AFldAnimObj, MHideTransform_) == 0x0002E0, "Member 'AFldAnimObj::MHideTransform_' has a wrong offset!");

// Class xrd777.FldBossBattleScript
// 0x0000 (0x02B0 - 0x02B0)
class AFldBossBattleScript final : public AFldScriptManagerCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldBossBattleScript">();
	}
	static class AFldBossBattleScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldBossBattleScript>();
	}
};
static_assert(alignof(AFldBossBattleScript) == 0x000008, "Wrong alignment on AFldBossBattleScript");
static_assert(sizeof(AFldBossBattleScript) == 0x0002B0, "Wrong size on AFldBossBattleScript");

// Class xrd777.FldCamera
// 0x0000 (0x07B0 - 0x07B0)
class AFldCamera : public ACameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCamera">();
	}
	static class AFldCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCamera>();
	}
};
static_assert(alignof(AFldCamera) == 0x000010, "Wrong alignment on AFldCamera");
static_assert(sizeof(AFldCamera) == 0x0007B0, "Wrong size on AFldCamera");

// Class xrd777.FldCameraBehaviorFixed
// 0x0018 (0x00E0 - 0x00C8)
class UFldCameraBehaviorFixed final : public UFldCameraBehaviorBase
{
public:
	float                                         FixedYaw;                                          // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedPitch;                                        // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarginYaw;                                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarginPitch;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MarginForward;                                     // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraBehaviorFixed">();
	}
	static class UFldCameraBehaviorFixed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraBehaviorFixed>();
	}
};
static_assert(alignof(UFldCameraBehaviorFixed) == 0x000008, "Wrong alignment on UFldCameraBehaviorFixed");
static_assert(sizeof(UFldCameraBehaviorFixed) == 0x0000E0, "Wrong size on UFldCameraBehaviorFixed");
static_assert(offsetof(UFldCameraBehaviorFixed, FixedYaw) == 0x0000C8, "Member 'UFldCameraBehaviorFixed::FixedYaw' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFixed, FixedPitch) == 0x0000CC, "Member 'UFldCameraBehaviorFixed::FixedPitch' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFixed, MarginYaw) == 0x0000D0, "Member 'UFldCameraBehaviorFixed::MarginYaw' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFixed, MarginPitch) == 0x0000D4, "Member 'UFldCameraBehaviorFixed::MarginPitch' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFixed, RotSpeed) == 0x0000D8, "Member 'UFldCameraBehaviorFixed::RotSpeed' has a wrong offset!");
static_assert(offsetof(UFldCameraBehaviorFixed, MarginForward) == 0x0000DC, "Member 'UFldCameraBehaviorFixed::MarginForward' has a wrong offset!");

// Class xrd777.FldCameraFixed
// 0x0008 (0x0278 - 0x0270)
class AFldCameraFixed final : public AFldCameraBase
{
public:
	class UFldCameraBehaviorFixed*                Behavior;                                          // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraFixed">();
	}
	static class AFldCameraFixed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraFixed>();
	}
};
static_assert(alignof(AFldCameraFixed) == 0x000008, "Wrong alignment on AFldCameraFixed");
static_assert(sizeof(AFldCameraFixed) == 0x000278, "Wrong size on AFldCameraFixed");
static_assert(offsetof(AFldCameraFixed, Behavior) == 0x000270, "Member 'AFldCameraFixed::Behavior' has a wrong offset!");

// Class xrd777.FldCameraHitSpline
// 0x00C8 (0x03A8 - 0x02E0)
class AFldCameraHitSpline final : public AFldCameraHitBase
{
public:
	class UBoxComponent*                          BoxComp;                                           // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComp;                                        // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       CameraSplineComp;                                  // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class AFldCameraSpline*>          CameraList;                                        // 0x02F8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	EFldCameraForwardType                         ForwardType;                                       // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FreeForward;                                       // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTracking;                                         // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrackingDistance;                                  // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingBufferZone_Player;                         // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingBufferZone_Camera;                         // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarginYaw;                                         // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarginPitch;                                       // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MarginSpeed;                                       // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MarginForward;                                     // 0x0374(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_375[0x1F];                                     // 0x0375(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFanShape;                                         // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw_FrontOffset;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw_BackOffset;                                    // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraHitSpline">();
	}
	static class AFldCameraHitSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCameraHitSpline>();
	}
};
static_assert(alignof(AFldCameraHitSpline) == 0x000008, "Wrong alignment on AFldCameraHitSpline");
static_assert(sizeof(AFldCameraHitSpline) == 0x0003A8, "Wrong size on AFldCameraHitSpline");
static_assert(offsetof(AFldCameraHitSpline, BoxComp) == 0x0002E0, "Member 'AFldCameraHitSpline::BoxComp' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, SplineComp) == 0x0002E8, "Member 'AFldCameraHitSpline::SplineComp' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, CameraSplineComp) == 0x0002F0, "Member 'AFldCameraHitSpline::CameraSplineComp' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, CameraList) == 0x0002F8, "Member 'AFldCameraHitSpline::CameraList' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, ForwardType) == 0x000348, "Member 'AFldCameraHitSpline::ForwardType' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, FreeForward) == 0x000350, "Member 'AFldCameraHitSpline::FreeForward' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, bTracking) == 0x000358, "Member 'AFldCameraHitSpline::bTracking' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, TrackingDistance) == 0x00035C, "Member 'AFldCameraHitSpline::TrackingDistance' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, TrackingBufferZone_Player) == 0x000360, "Member 'AFldCameraHitSpline::TrackingBufferZone_Player' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, TrackingBufferZone_Camera) == 0x000364, "Member 'AFldCameraHitSpline::TrackingBufferZone_Camera' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, MarginYaw) == 0x000368, "Member 'AFldCameraHitSpline::MarginYaw' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, MarginPitch) == 0x00036C, "Member 'AFldCameraHitSpline::MarginPitch' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, MarginSpeed) == 0x000370, "Member 'AFldCameraHitSpline::MarginSpeed' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, MarginForward) == 0x000374, "Member 'AFldCameraHitSpline::MarginForward' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, bFanShape) == 0x000394, "Member 'AFldCameraHitSpline::bFanShape' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, Yaw_FrontOffset) == 0x000398, "Member 'AFldCameraHitSpline::Yaw_FrontOffset' has a wrong offset!");
static_assert(offsetof(AFldCameraHitSpline, Yaw_BackOffset) == 0x00039C, "Member 'AFldCameraHitSpline::Yaw_BackOffset' has a wrong offset!");

// Class xrd777.FldCameraUtility
// 0x0000 (0x0028 - 0x0028)
class UFldCameraUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCameraUtility">();
	}
	static class UFldCameraUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCameraUtility>();
	}
};
static_assert(alignof(UFldCameraUtility) == 0x000008, "Wrong alignment on UFldCameraUtility");
static_assert(sizeof(UFldCameraUtility) == 0x000028, "Wrong size on UFldCameraUtility");

// Class xrd777.FldCharAttackAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UFldCharAttackAnimNotify final : public UAnimNotify
{
public:
	EFldCharAttackAnimNotifyFlag                  Flag;                                              // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharAttackAnimNotify">();
	}
	static class UFldCharAttackAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharAttackAnimNotify>();
	}
};
static_assert(alignof(UFldCharAttackAnimNotify) == 0x000008, "Wrong alignment on UFldCharAttackAnimNotify");
static_assert(sizeof(UFldCharAttackAnimNotify) == 0x000040, "Wrong size on UFldCharAttackAnimNotify");
static_assert(offsetof(UFldCharAttackAnimNotify, Flag) == 0x000038, "Member 'UFldCharAttackAnimNotify::Flag' has a wrong offset!");
static_assert(offsetof(UFldCharAttackAnimNotify, bEnable) == 0x00003C, "Member 'UFldCharAttackAnimNotify::bEnable' has a wrong offset!");

// Class xrd777.FldCharDashAttackAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UFldCharDashAttackAnimNotify final : public UAnimNotify
{
public:
	EFldCharAttackAnimNotifyFlag                  Flag;                                              // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharDashAttackAnimNotify">();
	}
	static class UFldCharDashAttackAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharDashAttackAnimNotify>();
	}
};
static_assert(alignof(UFldCharDashAttackAnimNotify) == 0x000008, "Wrong alignment on UFldCharDashAttackAnimNotify");
static_assert(sizeof(UFldCharDashAttackAnimNotify) == 0x000040, "Wrong size on UFldCharDashAttackAnimNotify");
static_assert(offsetof(UFldCharDashAttackAnimNotify, Flag) == 0x000038, "Member 'UFldCharDashAttackAnimNotify::Flag' has a wrong offset!");
static_assert(offsetof(UFldCharDashAttackAnimNotify, bEnable) == 0x00003C, "Member 'UFldCharDashAttackAnimNotify::bEnable' has a wrong offset!");

// Class xrd777.FldCharDataAsset
// 0x0290 (0x02C0 - 0x0030)
class UFldCharDataAsset final : public UDataAsset
{
public:
	struct FFldCharSpeed                          DailySpeed;                                        // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldCharSpeed                          DungeonSpeed;                                      // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FFldCharMajorBgData>       MajorBg;                                           // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FFldPlayerData                         Player;                                            // 0x00A0(0x01E8)(Edit, NativeAccessSpecifierPublic)
	struct FFldPartnerData                        Partner;                                           // 0x0288(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldCharKeyParam                       Key;                                               // 0x0298(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	void PlayerOutputLog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharDataAsset">();
	}
	static class UFldCharDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharDataAsset>();
	}
};
static_assert(alignof(UFldCharDataAsset) == 0x000008, "Wrong alignment on UFldCharDataAsset");
static_assert(sizeof(UFldCharDataAsset) == 0x0002C0, "Wrong size on UFldCharDataAsset");
static_assert(offsetof(UFldCharDataAsset, DailySpeed) == 0x000030, "Member 'UFldCharDataAsset::DailySpeed' has a wrong offset!");
static_assert(offsetof(UFldCharDataAsset, DungeonSpeed) == 0x000040, "Member 'UFldCharDataAsset::DungeonSpeed' has a wrong offset!");
static_assert(offsetof(UFldCharDataAsset, MajorBg) == 0x000050, "Member 'UFldCharDataAsset::MajorBg' has a wrong offset!");
static_assert(offsetof(UFldCharDataAsset, Player) == 0x0000A0, "Member 'UFldCharDataAsset::Player' has a wrong offset!");
static_assert(offsetof(UFldCharDataAsset, Partner) == 0x000288, "Member 'UFldCharDataAsset::Partner' has a wrong offset!");
static_assert(offsetof(UFldCharDataAsset, Key) == 0x000298, "Member 'UFldCharDataAsset::Key' has a wrong offset!");

// Class xrd777.FldCharEmotionIconMngComp
// 0x0010 (0x00D8 - 0x00C8)
class UFldCharEmotionIconMngComp final : public UFldLocalActorComp
{
public:
	class UAppCharBaseComp*                       MCharaBaseComp_;                                   // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHandwritingSpawner*                    MHandwritingSpawner_;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharEmotionIconMngComp">();
	}
	static class UFldCharEmotionIconMngComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharEmotionIconMngComp>();
	}
};
static_assert(alignof(UFldCharEmotionIconMngComp) == 0x000008, "Wrong alignment on UFldCharEmotionIconMngComp");
static_assert(sizeof(UFldCharEmotionIconMngComp) == 0x0000D8, "Wrong size on UFldCharEmotionIconMngComp");
static_assert(offsetof(UFldCharEmotionIconMngComp, MCharaBaseComp_) == 0x0000C8, "Member 'UFldCharEmotionIconMngComp::MCharaBaseComp_' has a wrong offset!");
static_assert(offsetof(UFldCharEmotionIconMngComp, MHandwritingSpawner_) == 0x0000D0, "Member 'UFldCharEmotionIconMngComp::MHandwritingSpawner_' has a wrong offset!");

// Class xrd777.FldCharSysBPFL
// 0x0000 (0x0028 - 0x0028)
class UFldCharSysBPFL final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* PlayAnimSequence(class USkeletalMeshComponent* Target, class UAnimSequenceBase* Anim, bool Loop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCharSysBPFL">();
	}
	static class UFldCharSysBPFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCharSysBPFL>();
	}
};
static_assert(alignof(UFldCharSysBPFL) == 0x000008, "Wrong alignment on UFldCharSysBPFL");
static_assert(sizeof(UFldCharSysBPFL) == 0x000028, "Wrong size on UFldCharSysBPFL");

// Class xrd777.FldCmnDataActor
// 0x0020 (0x02A0 - 0x0280)
class AFldCmnDataActor final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFldCommonData*                         MParent_;                                          // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArcAsset*                              MArcAsset_;                                        // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCmnDataActor">();
	}
	static class AFldCmnDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCmnDataActor>();
	}
};
static_assert(alignof(AFldCmnDataActor) == 0x000008, "Wrong alignment on AFldCmnDataActor");
static_assert(sizeof(AFldCmnDataActor) == 0x0002A0, "Wrong size on AFldCmnDataActor");
static_assert(offsetof(AFldCmnDataActor, MParent_) == 0x000288, "Member 'AFldCmnDataActor::MParent_' has a wrong offset!");
static_assert(offsetof(AFldCmnDataActor, MAssetLoader_) == 0x000290, "Member 'AFldCmnDataActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AFldCmnDataActor, MArcAsset_) == 0x000298, "Member 'AFldCmnDataActor::MArcAsset_' has a wrong offset!");

// Class xrd777.FldCrowdIdleBehaviorComp
// 0x0048 (0x0110 - 0x00C8)
class UFldCrowdIdleBehaviorComp final : public UFldLocalActorComp
{
public:
	float                                         MLoopPitchTime_;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MPitchRadius_;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLoopRollTime_;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MRollRadius_;                                      // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MPitchTimer_;                                      // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MPitchDir_;                                        // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MRollTimer_;                                       // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MRollDir_;                                         // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               MBaseRotator_;                                     // 0x00E8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                MForwardVector_;                                   // 0x00F4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MRightVector_;                                     // 0x0100(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateProc(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdIdleBehaviorComp">();
	}
	static class UFldCrowdIdleBehaviorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCrowdIdleBehaviorComp>();
	}
};
static_assert(alignof(UFldCrowdIdleBehaviorComp) == 0x000008, "Wrong alignment on UFldCrowdIdleBehaviorComp");
static_assert(sizeof(UFldCrowdIdleBehaviorComp) == 0x000110, "Wrong size on UFldCrowdIdleBehaviorComp");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MLoopPitchTime_) == 0x0000C8, "Member 'UFldCrowdIdleBehaviorComp::MLoopPitchTime_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MPitchRadius_) == 0x0000CC, "Member 'UFldCrowdIdleBehaviorComp::MPitchRadius_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MLoopRollTime_) == 0x0000D0, "Member 'UFldCrowdIdleBehaviorComp::MLoopRollTime_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MRollRadius_) == 0x0000D4, "Member 'UFldCrowdIdleBehaviorComp::MRollRadius_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MPitchTimer_) == 0x0000D8, "Member 'UFldCrowdIdleBehaviorComp::MPitchTimer_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MPitchDir_) == 0x0000DC, "Member 'UFldCrowdIdleBehaviorComp::MPitchDir_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MRollTimer_) == 0x0000E0, "Member 'UFldCrowdIdleBehaviorComp::MRollTimer_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MRollDir_) == 0x0000E4, "Member 'UFldCrowdIdleBehaviorComp::MRollDir_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MBaseRotator_) == 0x0000E8, "Member 'UFldCrowdIdleBehaviorComp::MBaseRotator_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MForwardVector_) == 0x0000F4, "Member 'UFldCrowdIdleBehaviorComp::MForwardVector_' has a wrong offset!");
static_assert(offsetof(UFldCrowdIdleBehaviorComp, MRightVector_) == 0x000100, "Member 'UFldCrowdIdleBehaviorComp::MRightVector_' has a wrong offset!");

// Class xrd777.FldCrowdOpacityComp
// 0x0020 (0x00E8 - 0x00C8)
class UFldCrowdOpacityComp : public UFldLocalActorComp
{
public:
	float                                         MTargetOpacity_;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSpeed_;                                           // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MInvisibleRadius_;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDisappearRadius_;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOpacity_;                                         // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAppCharTransparency                   MTransparency_;                                    // 0x00DC(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void UpdateProc(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdOpacityComp">();
	}
	static class UFldCrowdOpacityComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCrowdOpacityComp>();
	}
};
static_assert(alignof(UFldCrowdOpacityComp) == 0x000008, "Wrong alignment on UFldCrowdOpacityComp");
static_assert(sizeof(UFldCrowdOpacityComp) == 0x0000E8, "Wrong size on UFldCrowdOpacityComp");
static_assert(offsetof(UFldCrowdOpacityComp, MTargetOpacity_) == 0x0000C8, "Member 'UFldCrowdOpacityComp::MTargetOpacity_' has a wrong offset!");
static_assert(offsetof(UFldCrowdOpacityComp, MSpeed_) == 0x0000CC, "Member 'UFldCrowdOpacityComp::MSpeed_' has a wrong offset!");
static_assert(offsetof(UFldCrowdOpacityComp, MInvisibleRadius_) == 0x0000D0, "Member 'UFldCrowdOpacityComp::MInvisibleRadius_' has a wrong offset!");
static_assert(offsetof(UFldCrowdOpacityComp, MDisappearRadius_) == 0x0000D4, "Member 'UFldCrowdOpacityComp::MDisappearRadius_' has a wrong offset!");
static_assert(offsetof(UFldCrowdOpacityComp, MOpacity_) == 0x0000D8, "Member 'UFldCrowdOpacityComp::MOpacity_' has a wrong offset!");
static_assert(offsetof(UFldCrowdOpacityComp, MTransparency_) == 0x0000DC, "Member 'UFldCrowdOpacityComp::MTransparency_' has a wrong offset!");

// Class xrd777.FldCrowdTarget_STOP
// 0x0020 (0x0258 - 0x0238)
class AFldCrowdTarget_STOP final : public AFldCrowdTarget
{
public:
	int32                                         MStopRatio_;                                       // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MStopTime_;                                        // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdTarget_STOP">();
	}
	static class AFldCrowdTarget_STOP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldCrowdTarget_STOP>();
	}
};
static_assert(alignof(AFldCrowdTarget_STOP) == 0x000008, "Wrong alignment on AFldCrowdTarget_STOP");
static_assert(sizeof(AFldCrowdTarget_STOP) == 0x000258, "Wrong size on AFldCrowdTarget_STOP");
static_assert(offsetof(AFldCrowdTarget_STOP, MStopRatio_) == 0x000238, "Member 'AFldCrowdTarget_STOP::MStopRatio_' has a wrong offset!");
static_assert(offsetof(AFldCrowdTarget_STOP, MStopTime_) == 0x00023C, "Member 'AFldCrowdTarget_STOP::MStopTime_' has a wrong offset!");

// Class xrd777.FldCrowdWalkOpacityComp
// 0x0028 (0x0110 - 0x00E8)
class UFldCrowdWalkOpacityComp final : public UFldCrowdOpacityComp
{
public:
	float                                         MSpeedLoc_;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MInvisibleRadiusLoc_;                              // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDisappearRadiusLoc_;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MStartPoint_;                                      // 0x00F4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MEndPoint_;                                        // 0x0100(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOpacityLoc_;                                      // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetPointLocation(const struct FVector& StartPoint, const struct FVector& EndPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldCrowdWalkOpacityComp">();
	}
	static class UFldCrowdWalkOpacityComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldCrowdWalkOpacityComp>();
	}
};
static_assert(alignof(UFldCrowdWalkOpacityComp) == 0x000008, "Wrong alignment on UFldCrowdWalkOpacityComp");
static_assert(sizeof(UFldCrowdWalkOpacityComp) == 0x000110, "Wrong size on UFldCrowdWalkOpacityComp");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MSpeedLoc_) == 0x0000E8, "Member 'UFldCrowdWalkOpacityComp::MSpeedLoc_' has a wrong offset!");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MInvisibleRadiusLoc_) == 0x0000EC, "Member 'UFldCrowdWalkOpacityComp::MInvisibleRadiusLoc_' has a wrong offset!");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MDisappearRadiusLoc_) == 0x0000F0, "Member 'UFldCrowdWalkOpacityComp::MDisappearRadiusLoc_' has a wrong offset!");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MStartPoint_) == 0x0000F4, "Member 'UFldCrowdWalkOpacityComp::MStartPoint_' has a wrong offset!");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MEndPoint_) == 0x000100, "Member 'UFldCrowdWalkOpacityComp::MEndPoint_' has a wrong offset!");
static_assert(offsetof(UFldCrowdWalkOpacityComp, MOpacityLoc_) == 0x00010C, "Member 'UFldCrowdWalkOpacityComp::MOpacityLoc_' has a wrong offset!");

// Class xrd777.FldDbgChLoad
// 0x0090 (0x02B0 - 0x0220)
class AFldDbgChLoad final : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           AnimInsList;                                       // 0x0238(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UObject*                                InitSkel;                                          // 0x0248(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                InitAnim;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        LoadedAssets;                                      // 0x0258(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x40];                                     // 0x0268(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharLoader*                         Loader;                                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDbgChLoad">();
	}
	static class AFldDbgChLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDbgChLoad>();
	}
};
static_assert(alignof(AFldDbgChLoad) == 0x000008, "Wrong alignment on AFldDbgChLoad");
static_assert(sizeof(AFldDbgChLoad) == 0x0002B0, "Wrong size on AFldDbgChLoad");
static_assert(offsetof(AFldDbgChLoad, AnimInsList) == 0x000238, "Member 'AFldDbgChLoad::AnimInsList' has a wrong offset!");
static_assert(offsetof(AFldDbgChLoad, InitSkel) == 0x000248, "Member 'AFldDbgChLoad::InitSkel' has a wrong offset!");
static_assert(offsetof(AFldDbgChLoad, InitAnim) == 0x000250, "Member 'AFldDbgChLoad::InitAnim' has a wrong offset!");
static_assert(offsetof(AFldDbgChLoad, LoadedAssets) == 0x000258, "Member 'AFldDbgChLoad::LoadedAssets' has a wrong offset!");
static_assert(offsetof(AFldDbgChLoad, Loader) == 0x0002A8, "Member 'AFldDbgChLoad::Loader' has a wrong offset!");

// Class xrd777.FldDbgMaker
// 0x00B8 (0x02D8 - 0x0220)
class AFldDbgMaker final : public AActor
{
public:
	class UClass*                                 PlayerClass;                                       // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PlayerPoints;                                      // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerCharaId;                                     // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldPlayerHolder                       Player;                                            // 0x0238(0x0018)(Edit, EditConst, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 PartnerClass;                                      // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 KoroPartnerClass;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 PartnerId;                                         // 0x0260(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         PartnerPoints;                                     // 0x0270(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class APawn*>                          PartnerActors;                                     // 0x0280(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFldPartnerHolder>              Partners;                                          // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CostumeID;                                         // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimPackID                                   AnimPackID;                                        // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeapon;                                           // 0x02A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A6[0x2];                                      // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponId;                                          // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBag;                                              // 0x02AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BagId;                                             // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharFootstepsDataAsset*             FootstepsData;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Loaded;                                            // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          IsLoad;                                            // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReLoadCostume;                                     // 0x02D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceWaitPose(const bool Enable);
	bool Load();

	const TArray<class APawn*> GetPartnerActors() const;
	const class APawn* GetPlayerActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDbgMaker">();
	}
	static class AFldDbgMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDbgMaker>();
	}
};
static_assert(alignof(AFldDbgMaker) == 0x000008, "Wrong alignment on AFldDbgMaker");
static_assert(sizeof(AFldDbgMaker) == 0x0002D8, "Wrong size on AFldDbgMaker");
static_assert(offsetof(AFldDbgMaker, PlayerClass) == 0x000220, "Member 'AFldDbgMaker::PlayerClass' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PlayerPoints) == 0x000228, "Member 'AFldDbgMaker::PlayerPoints' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PlayerCharaId) == 0x000230, "Member 'AFldDbgMaker::PlayerCharaId' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, Player) == 0x000238, "Member 'AFldDbgMaker::Player' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PartnerClass) == 0x000250, "Member 'AFldDbgMaker::PartnerClass' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, KoroPartnerClass) == 0x000258, "Member 'AFldDbgMaker::KoroPartnerClass' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PartnerId) == 0x000260, "Member 'AFldDbgMaker::PartnerId' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PartnerPoints) == 0x000270, "Member 'AFldDbgMaker::PartnerPoints' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, PartnerActors) == 0x000280, "Member 'AFldDbgMaker::PartnerActors' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, Partners) == 0x000290, "Member 'AFldDbgMaker::Partners' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, CostumeID) == 0x0002A0, "Member 'AFldDbgMaker::CostumeID' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, AnimPackID) == 0x0002A4, "Member 'AFldDbgMaker::AnimPackID' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, bWeapon) == 0x0002A5, "Member 'AFldDbgMaker::bWeapon' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, WeaponId) == 0x0002A8, "Member 'AFldDbgMaker::WeaponId' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, bBag) == 0x0002AC, "Member 'AFldDbgMaker::bBag' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, BagId) == 0x0002B0, "Member 'AFldDbgMaker::BagId' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, FootstepsData) == 0x0002B8, "Member 'AFldDbgMaker::FootstepsData' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, Loaded) == 0x0002C0, "Member 'AFldDbgMaker::Loaded' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, IsLoad) == 0x0002D0, "Member 'AFldDbgMaker::IsLoad' has a wrong offset!");
static_assert(offsetof(AFldDbgMaker, ReLoadCostume) == 0x0002D1, "Member 'AFldDbgMaker::ReLoadCostume' has a wrong offset!");

// Class xrd777.FldDungeonTable
// 0x0070 (0x00A0 - 0x0030)
class UFldDungeonTable final : public UDataAsset
{
public:
	TArray<struct FFldDungeonPartsSelDataAssetRecord> PartsSelData;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonLayoutCombDataAssetRecord> LayoutCombData;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonFloorDataAssetRecord> FloorData;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonTBoxTypeDataAssetRecord> TBoxTypeData;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonTBoxItemDataAssetRecord> TBoxItemData;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonTBoxPacDataAssetRecord> TBoxPacData;                                       // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFldDungeonEncountPacDataAssetRecord> EncountPacData;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonTable">();
	}
	static class UFldDungeonTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonTable>();
	}
};
static_assert(alignof(UFldDungeonTable) == 0x000008, "Wrong alignment on UFldDungeonTable");
static_assert(sizeof(UFldDungeonTable) == 0x0000A0, "Wrong size on UFldDungeonTable");
static_assert(offsetof(UFldDungeonTable, PartsSelData) == 0x000030, "Member 'UFldDungeonTable::PartsSelData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, LayoutCombData) == 0x000040, "Member 'UFldDungeonTable::LayoutCombData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, FloorData) == 0x000050, "Member 'UFldDungeonTable::FloorData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, TBoxTypeData) == 0x000060, "Member 'UFldDungeonTable::TBoxTypeData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, TBoxItemData) == 0x000070, "Member 'UFldDungeonTable::TBoxItemData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, TBoxPacData) == 0x000080, "Member 'UFldDungeonTable::TBoxPacData' has a wrong offset!");
static_assert(offsetof(UFldDungeonTable, EncountPacData) == 0x000090, "Member 'UFldDungeonTable::EncountPacData' has a wrong offset!");

// Class xrd777.FldDoorObjCore
// 0x0090 (0x03A0 - 0x0310)
class AFldDoorObjCore : public AFldAnimObj
{
public:
	float                                         MWalkSpeed_;                                       // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDoorCloseRange_;                                  // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MEnableMovePlayer_;                                // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        MWaitAsset_CLOSE_;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFldDoorAnimationData                  MAnime_FRONT_;                                     // 0x0328(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldDoorAnimationData                  MAnime_BACK_;                                      // 0x0340(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFldDoorPointComp*                      FrontPoint;                                        // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFldDoorPointComp*                      BackPoint;                                         // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MFlag_;                                            // 0x0378(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x24];                                     // 0x037C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallStateEndDelicate();
	bool IsPlayingOpen();
	void PlayDoorOpen(EFldDoorOpenType OpenType);
	void PlayDoorOpenWithFade(EFldDoorOpenType OpenType, int32 FadeType, int32 FadeFrame, int32 FadePattern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDoorObjCore">();
	}
	static class AFldDoorObjCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDoorObjCore>();
	}
};
static_assert(alignof(AFldDoorObjCore) == 0x000010, "Wrong alignment on AFldDoorObjCore");
static_assert(sizeof(AFldDoorObjCore) == 0x0003A0, "Wrong size on AFldDoorObjCore");
static_assert(offsetof(AFldDoorObjCore, MWalkSpeed_) == 0x000310, "Member 'AFldDoorObjCore::MWalkSpeed_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MDoorCloseRange_) == 0x000314, "Member 'AFldDoorObjCore::MDoorCloseRange_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MEnableMovePlayer_) == 0x000318, "Member 'AFldDoorObjCore::MEnableMovePlayer_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MWaitAsset_CLOSE_) == 0x000320, "Member 'AFldDoorObjCore::MWaitAsset_CLOSE_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MAnime_FRONT_) == 0x000328, "Member 'AFldDoorObjCore::MAnime_FRONT_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MAnime_BACK_) == 0x000340, "Member 'AFldDoorObjCore::MAnime_BACK_' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, Root) == 0x000358, "Member 'AFldDoorObjCore::Root' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, SkeletalMesh) == 0x000360, "Member 'AFldDoorObjCore::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, FrontPoint) == 0x000368, "Member 'AFldDoorObjCore::FrontPoint' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, BackPoint) == 0x000370, "Member 'AFldDoorObjCore::BackPoint' has a wrong offset!");
static_assert(offsetof(AFldDoorObjCore, MFlag_) == 0x000378, "Member 'AFldDoorObjCore::MFlag_' has a wrong offset!");

// Class xrd777.FldDungeonAccidentController
// 0x0008 (0x0150 - 0x0148)
class UFldDungeonAccidentController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonAccidentController">();
	}
	static class UFldDungeonAccidentController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonAccidentController>();
	}
};
static_assert(alignof(UFldDungeonAccidentController) == 0x000008, "Wrong alignment on UFldDungeonAccidentController");
static_assert(sizeof(UFldDungeonAccidentController) == 0x000150, "Wrong size on UFldDungeonAccidentController");

// Class xrd777.FldDungeonAutoGenerateBaseActor
// 0x0000 (0x0278 - 0x0278)
class AFldDungeonAutoGenerateBaseActor : public AAppActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonAutoGenerateBaseActor">();
	}
	static class AFldDungeonAutoGenerateBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonAutoGenerateBaseActor>();
	}
};
static_assert(alignof(AFldDungeonAutoGenerateBaseActor) == 0x000008, "Wrong alignment on AFldDungeonAutoGenerateBaseActor");
static_assert(sizeof(AFldDungeonAutoGenerateBaseActor) == 0x000278, "Wrong size on AFldDungeonAutoGenerateBaseActor");

// Class xrd777.FldDungeonAutoGenerateActor
// 0x0000 (0x0278 - 0x0278)
class AFldDungeonAutoGenerateActor final : public AFldDungeonAutoGenerateBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonAutoGenerateActor">();
	}
	static class AFldDungeonAutoGenerateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonAutoGenerateActor>();
	}
};
static_assert(alignof(AFldDungeonAutoGenerateActor) == 0x000008, "Wrong alignment on AFldDungeonAutoGenerateActor");
static_assert(sizeof(AFldDungeonAutoGenerateActor) == 0x000278, "Wrong size on AFldDungeonAutoGenerateActor");

// Class xrd777.FldDungeonBase
// 0x0298 (0x0510 - 0x0278)
class alignas(0x10) AFldDungeonBase : public AAppActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x38];                                     // 0x0280(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonSoundActor*                  M_pEnvSEActor;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonAutoGenerateActor*           M_pFloorAutoGenerator;                             // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldEnemyManager*                       M_pEnemyManager;                                   // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldPartnerManager*                     M_pPartnerManager;                                 // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFldDungeonComponentBase*>       M_ControlComponent;                                // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x50];                                     // 0x02F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonParamActor*                  M_pDungeonParam;                                   // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x1C8];                                    // 0x0348(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonBase">();
	}
	static class AFldDungeonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonBase>();
	}
};
static_assert(alignof(AFldDungeonBase) == 0x000010, "Wrong alignment on AFldDungeonBase");
static_assert(sizeof(AFldDungeonBase) == 0x000510, "Wrong size on AFldDungeonBase");
static_assert(offsetof(AFldDungeonBase, Root) == 0x000278, "Member 'AFldDungeonBase::Root' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_pEnvSEActor) == 0x0002B8, "Member 'AFldDungeonBase::M_pEnvSEActor' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_pFloorAutoGenerator) == 0x0002C8, "Member 'AFldDungeonBase::M_pFloorAutoGenerator' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_pEnemyManager) == 0x0002D0, "Member 'AFldDungeonBase::M_pEnemyManager' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_pPartnerManager) == 0x0002D8, "Member 'AFldDungeonBase::M_pPartnerManager' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_ControlComponent) == 0x0002E0, "Member 'AFldDungeonBase::M_ControlComponent' has a wrong offset!");
static_assert(offsetof(AFldDungeonBase, M_pDungeonParam) == 0x000340, "Member 'AFldDungeonBase::M_pDungeonParam' has a wrong offset!");

// Class xrd777.BustupGradationDataAsset
// 0x0050 (0x0080 - 0x0030)
class UBustupGradationDataAsset final : public UAppDataAsset
{
public:
	TMap<uint8, struct FBustupGradation>          Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupGradationDataAsset">();
	}
	static class UBustupGradationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupGradationDataAsset>();
	}
};
static_assert(alignof(UBustupGradationDataAsset) == 0x000008, "Wrong alignment on UBustupGradationDataAsset");
static_assert(sizeof(UBustupGradationDataAsset) == 0x000080, "Wrong size on UBustupGradationDataAsset");
static_assert(offsetof(UBustupGradationDataAsset, Data) == 0x000030, "Member 'UBustupGradationDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonBattleEncount
// 0x0088 (0x0300 - 0x0278)
class AFldDungeonBattleEncount final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             M_pCharacter;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x68];                                     // 0x0298(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureWait();
	void End();
	void ExcuteWipe();
	void Idle();
	void WaitEnd();
	void WaitFadeOut();
	void WaitVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonBattleEncount">();
	}
	static class AFldDungeonBattleEncount* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonBattleEncount>();
	}
};
static_assert(alignof(AFldDungeonBattleEncount) == 0x000008, "Wrong alignment on AFldDungeonBattleEncount");
static_assert(sizeof(AFldDungeonBattleEncount) == 0x000300, "Wrong size on AFldDungeonBattleEncount");
static_assert(offsetof(AFldDungeonBattleEncount, M_pCharacter) == 0x000290, "Member 'AFldDungeonBattleEncount::M_pCharacter' has a wrong offset!");

// Class xrd777.FldDungeonBattleResult
// 0x0038 (0x02B0 - 0x0278)
class AFldDungeonBattleResult final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               M_pBfAsset;                                        // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void End();
	void Init();
	void Load();
	void Run();
	void StartScript();
	void Wait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonBattleResult">();
	}
	static class AFldDungeonBattleResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonBattleResult>();
	}
};
static_assert(alignof(AFldDungeonBattleResult) == 0x000008, "Wrong alignment on AFldDungeonBattleResult");
static_assert(sizeof(AFldDungeonBattleResult) == 0x0002B0, "Wrong size on AFldDungeonBattleResult");
static_assert(offsetof(AFldDungeonBattleResult, M_pLoader) == 0x000290, "Member 'AFldDungeonBattleResult::M_pLoader' has a wrong offset!");
static_assert(offsetof(AFldDungeonBattleResult, M_pBfAsset) == 0x000298, "Member 'AFldDungeonBattleResult::M_pBfAsset' has a wrong offset!");

// Class xrd777.FldDungeonRollBack
// 0x0010 (0x0288 - 0x0278)
class AFldDungeonRollBack final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAddContent*                            M_pAddContentCheck;                                // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonRollBack">();
	}
	static class AFldDungeonRollBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonRollBack>();
	}
};
static_assert(alignof(AFldDungeonRollBack) == 0x000008, "Wrong alignment on AFldDungeonRollBack");
static_assert(sizeof(AFldDungeonRollBack) == 0x000288, "Wrong size on AFldDungeonRollBack");
static_assert(offsetof(AFldDungeonRollBack, M_pAddContentCheck) == 0x000280, "Member 'AFldDungeonRollBack::M_pAddContentCheck' has a wrong offset!");

// Class xrd777.FldDungeonBattleRetry
// 0x0010 (0x0288 - 0x0278)
class AFldDungeonBattleRetry final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonBattleRetry">();
	}
	static class AFldDungeonBattleRetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonBattleRetry>();
	}
};
static_assert(alignof(AFldDungeonBattleRetry) == 0x000008, "Wrong alignment on AFldDungeonBattleRetry");
static_assert(sizeof(AFldDungeonBattleRetry) == 0x000288, "Wrong size on AFldDungeonBattleRetry");

// Class xrd777.WeaponShopAwardDataAsset
// 0x0050 (0x0080 - 0x0030)
class UWeaponShopAwardDataAsset final : public UAppDataAsset
{
public:
	TMap<uint16, struct FWeaponShopAwardData>     Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponShopAwardDataAsset">();
	}
	static class UWeaponShopAwardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponShopAwardDataAsset>();
	}
};
static_assert(alignof(UWeaponShopAwardDataAsset) == 0x000008, "Wrong alignment on UWeaponShopAwardDataAsset");
static_assert(sizeof(UWeaponShopAwardDataAsset) == 0x000080, "Wrong size on UWeaponShopAwardDataAsset");
static_assert(offsetof(UWeaponShopAwardDataAsset, Data) == 0x000030, "Member 'UWeaponShopAwardDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonBrokenObjController
// 0x0038 (0x0180 - 0x0148)
class UFldDungeonBrokenObjController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldDungeonObjectActor*>         M_BrokenActor;                                     // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutBrokenActor*>   M_LayoutArray;                                     // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitEvent(EDungeonObjHitEvent EventType, int32 ID, class AFldDungeonObjectActor* PObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonBrokenObjController">();
	}
	static class UFldDungeonBrokenObjController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonBrokenObjController>();
	}
};
static_assert(alignof(UFldDungeonBrokenObjController) == 0x000008, "Wrong alignment on UFldDungeonBrokenObjController");
static_assert(sizeof(UFldDungeonBrokenObjController) == 0x000180, "Wrong size on UFldDungeonBrokenObjController");
static_assert(offsetof(UFldDungeonBrokenObjController, M_BrokenActor) == 0x000150, "Member 'UFldDungeonBrokenObjController::M_BrokenActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonBrokenObjController, M_LayoutArray) == 0x000160, "Member 'UFldDungeonBrokenObjController::M_LayoutArray' has a wrong offset!");

// Class xrd777.FldDungeonClockController
// 0x0018 (0x0160 - 0x0148)
class UFldDungeonClockController final : public UFldDungeonComponentBase
{
public:
	class AFldDungeonObjectActor*                 M_ClockActor;                                      // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonLayoutActor*                 M_pLayoutClock;                                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonClockController">();
	}
	static class UFldDungeonClockController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonClockController>();
	}
};
static_assert(alignof(UFldDungeonClockController) == 0x000008, "Wrong alignment on UFldDungeonClockController");
static_assert(sizeof(UFldDungeonClockController) == 0x000160, "Wrong size on UFldDungeonClockController");
static_assert(offsetof(UFldDungeonClockController, M_ClockActor) == 0x000148, "Member 'UFldDungeonClockController::M_ClockActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonClockController, M_pLayoutClock) == 0x000150, "Member 'UFldDungeonClockController::M_pLayoutClock' has a wrong offset!");

// Class xrd777.FldDungeonScriptActor
// 0x0010 (0x0288 - 0x0278)
class AFldDungeonScriptActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonScriptActor">();
	}
	static class AFldDungeonScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonScriptActor>();
	}
};
static_assert(alignof(AFldDungeonScriptActor) == 0x000008, "Wrong alignment on AFldDungeonScriptActor");
static_assert(sizeof(AFldDungeonScriptActor) == 0x000288, "Wrong size on AFldDungeonScriptActor");

// Class xrd777.FldDungeonGameBase
// 0x0000 (0x0510 - 0x0510)
class AFldDungeonGameBase : public AFldDungeonBase
{
public:
	void NotifyLevelLoadedDesignMap();
	void NotifyLevelLoadedEnvironment();
	void NotifyLevelLoadedFixedFloor();
	void NotifyLevelLoadedFloor();
	void NotifyLevelLoadedFloorBase();
	void NotifyLevelLoadedNavMesh();
	void NotifyLevelUnLoadedEnv();
	void NotifyLevelUnLoadedMap();
	void NotifyLevelUnLoadedNavMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonGameBase">();
	}
	static class AFldDungeonGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonGameBase>();
	}
};
static_assert(alignof(AFldDungeonGameBase) == 0x000010, "Wrong alignment on AFldDungeonGameBase");
static_assert(sizeof(AFldDungeonGameBase) == 0x000510, "Wrong size on AFldDungeonGameBase");

// Class xrd777.SkillAffinityDataAsset
// 0x0010 (0x0040 - 0x0030)
class USkillAffinityDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSkillAffinityItem>             Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillAffinityDataAsset">();
	}
	static class USkillAffinityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillAffinityDataAsset>();
	}
};
static_assert(alignof(USkillAffinityDataAsset) == 0x000008, "Wrong alignment on USkillAffinityDataAsset");
static_assert(sizeof(USkillAffinityDataAsset) == 0x000040, "Wrong size on USkillAffinityDataAsset");
static_assert(offsetof(USkillAffinityDataAsset, Data) == 0x000030, "Member 'USkillAffinityDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonGameInit
// 0x0030 (0x0540 - 0x0510)
class AFldDungeonGameInit : public AFldDungeonGameBase
{
public:
	uint8                                         Pad_510[0x30];                                     // 0x0510(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ADVANCE_LOAD();
	void ADVANCE_PROCESS();
	void ADVANCE_PROCESS_WAIT();
	void ATTACH_OBJ_WAIT();
	void CREATE_END();
	void CREATE_LAYOUT();
	void DungeonInit();
	void FloorInit();
	void INIT_DESIGIN_MAP();
	void INIT_END();
	void INIT_FIXED_FLOOR();
	void INIT_FLOOR_LEVEL();
	void LOAD_START();
	void LOAD_WAIT_LEVEL();
	void NAVMESH_LOAD_WAIT();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonGameInit">();
	}
	static class AFldDungeonGameInit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonGameInit>();
	}
};
static_assert(alignof(AFldDungeonGameInit) == 0x000010, "Wrong alignment on AFldDungeonGameInit");
static_assert(sizeof(AFldDungeonGameInit) == 0x000540, "Wrong size on AFldDungeonGameInit");

// Class xrd777.FldDungeonGame
// 0x0000 (0x0540 - 0x0540)
class AFldDungeonGame : public AFldDungeonGameInit
{
public:
	void BattleSync();
	void ForceEncount();
	bool IsBattle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonGame">();
	}
	static class AFldDungeonGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonGame>();
	}
};
static_assert(alignof(AFldDungeonGame) == 0x000010, "Wrong alignment on AFldDungeonGame");
static_assert(sizeof(AFldDungeonGame) == 0x000540, "Wrong size on AFldDungeonGame");

// Class xrd777.FldDungeonControlActor
// 0x0000 (0x0540 - 0x0540)
class AFldDungeonControlActor final : public AFldDungeonGame
{
public:
	static bool CheckReady();
	static class AFldDungeonControlActor* Create();
	static void DebugSetNextFieldFloor();
	static void DebugSetPrevFieldFloor();
	static void Delete();
	static bool IsExist();
	static void SetField(int32 Major, int32 Minor, int32 Idx);
	static void SetNextFieldFloor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonControlActor">();
	}
	static class AFldDungeonControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonControlActor>();
	}
};
static_assert(alignof(AFldDungeonControlActor) == 0x000010, "Wrong alignment on AFldDungeonControlActor");
static_assert(sizeof(AFldDungeonControlActor) == 0x000540, "Wrong size on AFldDungeonControlActor");

// Class xrd777.FldDungeonDebugController
// 0x0008 (0x0150 - 0x0148)
class UFldDungeonDebugController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonDebugController">();
	}
	static class UFldDungeonDebugController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonDebugController>();
	}
};
static_assert(alignof(UFldDungeonDebugController) == 0x000008, "Wrong alignment on UFldDungeonDebugController");
static_assert(sizeof(UFldDungeonDebugController) == 0x000150, "Wrong size on UFldDungeonDebugController");

// Class xrd777.MoonAgeProbabilityDataAsset
// 0x0010 (0x0040 - 0x0030)
class UMoonAgeProbabilityDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FMoonAgeProbabilityItem>        Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoonAgeProbabilityDataAsset">();
	}
	static class UMoonAgeProbabilityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoonAgeProbabilityDataAsset>();
	}
};
static_assert(alignof(UMoonAgeProbabilityDataAsset) == 0x000008, "Wrong alignment on UMoonAgeProbabilityDataAsset");
static_assert(sizeof(UMoonAgeProbabilityDataAsset) == 0x000040, "Wrong size on UMoonAgeProbabilityDataAsset");
static_assert(offsetof(UMoonAgeProbabilityDataAsset, Data) == 0x000030, "Member 'UMoonAgeProbabilityDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonEffectController
// 0x00E8 (0x0230 - 0x0148)
class UFldDungeonEffectController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonEffectActor*>         M_EffectActor;                                     // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0xD8];                                     // 0x0158(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEffectController">();
	}
	static class UFldDungeonEffectController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEffectController>();
	}
};
static_assert(alignof(UFldDungeonEffectController) == 0x000008, "Wrong alignment on UFldDungeonEffectController");
static_assert(sizeof(UFldDungeonEffectController) == 0x000230, "Wrong size on UFldDungeonEffectController");
static_assert(offsetof(UFldDungeonEffectController, M_EffectActor) == 0x000148, "Member 'UFldDungeonEffectController::M_EffectActor' has a wrong offset!");

// Class xrd777.FldDungeonEffectActor
// 0x0058 (0x02D0 - 0x0278)
class AFldDungeonEffectActor final : public AAppActor
{
public:
	EDungeonEffectType                            Type;                                              // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        NiagaraPath;                                       // 0x0280(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      M_pNiagara;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPInit();
	void BPUpdate();
	float GetFadeInTime();
	float GetFadeOutTime();
	float GetFadeValue();
	float GetPlayTime();
	bool IsPlay();
	void RequestFadeOut();
	void SetPlayEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEffectActor">();
	}
	static class AFldDungeonEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonEffectActor>();
	}
};
static_assert(alignof(AFldDungeonEffectActor) == 0x000008, "Wrong alignment on AFldDungeonEffectActor");
static_assert(sizeof(AFldDungeonEffectActor) == 0x0002D0, "Wrong size on AFldDungeonEffectActor");
static_assert(offsetof(AFldDungeonEffectActor, Type) == 0x000278, "Member 'AFldDungeonEffectActor::Type' has a wrong offset!");
static_assert(offsetof(AFldDungeonEffectActor, NiagaraPath) == 0x000280, "Member 'AFldDungeonEffectActor::NiagaraPath' has a wrong offset!");
static_assert(offsetof(AFldDungeonEffectActor, FadeInTime) == 0x000298, "Member 'AFldDungeonEffectActor::FadeInTime' has a wrong offset!");
static_assert(offsetof(AFldDungeonEffectActor, FadeOutTime) == 0x00029C, "Member 'AFldDungeonEffectActor::FadeOutTime' has a wrong offset!");
static_assert(offsetof(AFldDungeonEffectActor, M_pNiagara) == 0x0002C0, "Member 'AFldDungeonEffectActor::M_pNiagara' has a wrong offset!");

// Class xrd777.FldDungeonEffectTartarosSearch
// 0x0010 (0x00D8 - 0x00C8)
class UFldDungeonEffectTartarosSearch final : public UAppActorComponent
{
public:
	float                                         LifeSpan;                                          // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrightness;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetIntensity();
	float GetLifeSpan();
	float GetMaxBrightness();
	float GetRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEffectTartarosSearch">();
	}
	static class UFldDungeonEffectTartarosSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEffectTartarosSearch>();
	}
};
static_assert(alignof(UFldDungeonEffectTartarosSearch) == 0x000008, "Wrong alignment on UFldDungeonEffectTartarosSearch");
static_assert(sizeof(UFldDungeonEffectTartarosSearch) == 0x0000D8, "Wrong size on UFldDungeonEffectTartarosSearch");
static_assert(offsetof(UFldDungeonEffectTartarosSearch, LifeSpan) == 0x0000C8, "Member 'UFldDungeonEffectTartarosSearch::LifeSpan' has a wrong offset!");
static_assert(offsetof(UFldDungeonEffectTartarosSearch, Intensity) == 0x0000CC, "Member 'UFldDungeonEffectTartarosSearch::Intensity' has a wrong offset!");
static_assert(offsetof(UFldDungeonEffectTartarosSearch, MaxBrightness) == 0x0000D0, "Member 'UFldDungeonEffectTartarosSearch::MaxBrightness' has a wrong offset!");
static_assert(offsetof(UFldDungeonEffectTartarosSearch, Radius) == 0x0000D4, "Member 'UFldDungeonEffectTartarosSearch::Radius' has a wrong offset!");

// Class xrd777.FldDungeonEffectCameraAttachActor
// 0x0018 (0x0290 - 0x0278)
class AFldDungeonEffectCameraAttachActor final : public AAppActor
{
public:
	class UNiagaraCameraAttachComponent*          M_pEffec;                                          // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComplete(class UNiagaraComponent* PSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEffectCameraAttachActor">();
	}
	static class AFldDungeonEffectCameraAttachActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonEffectCameraAttachActor>();
	}
};
static_assert(alignof(AFldDungeonEffectCameraAttachActor) == 0x000008, "Wrong alignment on AFldDungeonEffectCameraAttachActor");
static_assert(sizeof(AFldDungeonEffectCameraAttachActor) == 0x000290, "Wrong size on AFldDungeonEffectCameraAttachActor");
static_assert(offsetof(AFldDungeonEffectCameraAttachActor, M_pEffec) == 0x000278, "Member 'AFldDungeonEffectCameraAttachActor::M_pEffec' has a wrong offset!");

// Class xrd777.UICloudCursorDraw
// 0x0030 (0x02D0 - 0x02A0)
class AUICloudCursorDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICloudCursorDraw">();
	}
	static class AUICloudCursorDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICloudCursorDraw>();
	}
};
static_assert(alignof(AUICloudCursorDraw) == 0x000008, "Wrong alignment on AUICloudCursorDraw");
static_assert(sizeof(AUICloudCursorDraw) == 0x0002D0, "Wrong size on AUICloudCursorDraw");

// Class xrd777.FldDungeonEncountController
// 0x0198 (0x02E0 - 0x0148)
class UFldDungeonEncountController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0xD8];                                     // 0x0148(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldEnemyHolder>                M_EnemyCompArray;                                  // 0x0220(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0xB0];                                     // 0x0230(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEncountController">();
	}
	static class UFldDungeonEncountController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEncountController>();
	}
};
static_assert(alignof(UFldDungeonEncountController) == 0x000008, "Wrong alignment on UFldDungeonEncountController");
static_assert(sizeof(UFldDungeonEncountController) == 0x0002E0, "Wrong size on UFldDungeonEncountController");
static_assert(offsetof(UFldDungeonEncountController, M_EnemyCompArray) == 0x000220, "Member 'UFldDungeonEncountController::M_EnemyCompArray' has a wrong offset!");

// Class xrd777.FldDungeonEnemyController
// 0x0138 (0x0280 - 0x0148)
class UFldDungeonEnemyController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonLayoutDirectEnemyActor*> M_pLayoutDirectArray;                              // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFldEnemyHolder>                M_EnemyList;                                       // 0x0158(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, struct FFldEnemyHolder>           M_DirectEnemy;                                     // 0x0168(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFldEnemyHolder>                M_MonadEnemy;                                      // 0x01B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFldEnemyHolder>                M_FDoorEnemy;                                      // 0x01C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFldEnemyHolder>                M_Reaper;                                          // 0x01D8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutEnemyActor*>    M_FixedLayoutArray;                                // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_FixedLayoutPathArray;                            // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutEnemyActor*>    M_DesignLayoutArray;                               // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_DesignLayoutPathArray;                           // 0x0218(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutDirectEnemyActor*> M_MonadLayoutArray;                                // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x48];                                     // 0x0238(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoFloorAdvanceProcess();
	void AutoFloorCreateActor();
	void AutoFloorLoad();
	void DesignFloorAdvanceProcess();
	void DesignFloorCreateActor();
	void DesignFloorLoad();
	void FixedFloorAdvanceProcess();
	void FixedFloorCreateActor();
	void FixedFloorLoad();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEnemyController">();
	}
	static class UFldDungeonEnemyController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEnemyController>();
	}
};
static_assert(alignof(UFldDungeonEnemyController) == 0x000008, "Wrong alignment on UFldDungeonEnemyController");
static_assert(sizeof(UFldDungeonEnemyController) == 0x000280, "Wrong size on UFldDungeonEnemyController");
static_assert(offsetof(UFldDungeonEnemyController, M_pLayoutDirectArray) == 0x000148, "Member 'UFldDungeonEnemyController::M_pLayoutDirectArray' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_EnemyList) == 0x000158, "Member 'UFldDungeonEnemyController::M_EnemyList' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_DirectEnemy) == 0x000168, "Member 'UFldDungeonEnemyController::M_DirectEnemy' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_MonadEnemy) == 0x0001B8, "Member 'UFldDungeonEnemyController::M_MonadEnemy' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_FDoorEnemy) == 0x0001C8, "Member 'UFldDungeonEnemyController::M_FDoorEnemy' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_Reaper) == 0x0001D8, "Member 'UFldDungeonEnemyController::M_Reaper' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_FixedLayoutArray) == 0x0001E8, "Member 'UFldDungeonEnemyController::M_FixedLayoutArray' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_FixedLayoutPathArray) == 0x0001F8, "Member 'UFldDungeonEnemyController::M_FixedLayoutPathArray' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_DesignLayoutArray) == 0x000208, "Member 'UFldDungeonEnemyController::M_DesignLayoutArray' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_DesignLayoutPathArray) == 0x000218, "Member 'UFldDungeonEnemyController::M_DesignLayoutPathArray' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnemyController, M_MonadLayoutArray) == 0x000228, "Member 'UFldDungeonEnemyController::M_MonadLayoutArray' has a wrong offset!");

// Class xrd777.FldDungeonEnvController
// 0x0030 (0x0178 - 0x0148)
class UFldDungeonEnvController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonEnvActor*>            M_EnvActor;                                        // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     M_DungeonFilterTimeline;                           // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            M_DungeonFilterCurve;                              // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           M_DungeonFilterMPC;                                // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FadeOutDungeonFilter(float Alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEnvController">();
	}
	static class UFldDungeonEnvController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEnvController>();
	}
};
static_assert(alignof(UFldDungeonEnvController) == 0x000008, "Wrong alignment on UFldDungeonEnvController");
static_assert(sizeof(UFldDungeonEnvController) == 0x000178, "Wrong size on UFldDungeonEnvController");
static_assert(offsetof(UFldDungeonEnvController, M_EnvActor) == 0x000148, "Member 'UFldDungeonEnvController::M_EnvActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnvController, M_DungeonFilterTimeline) == 0x000160, "Member 'UFldDungeonEnvController::M_DungeonFilterTimeline' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnvController, M_DungeonFilterCurve) == 0x000168, "Member 'UFldDungeonEnvController::M_DungeonFilterCurve' has a wrong offset!");
static_assert(offsetof(UFldDungeonEnvController, M_DungeonFilterMPC) == 0x000170, "Member 'UFldDungeonEnvController::M_DungeonFilterMPC' has a wrong offset!");

// Class xrd777.FldDungeonEnvActor
// 0x0008 (0x0280 - 0x0278)
class AFldDungeonEnvActor final : public AAppActor
{
public:
	EDungeonEnvType                               Type;                                              // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPGetDefault();
	void BPPause();
	void BPReflect();
	void BPResume();
	void BPSetDefault();
	void BPUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEnvActor">();
	}
	static class AFldDungeonEnvActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonEnvActor>();
	}
};
static_assert(alignof(AFldDungeonEnvActor) == 0x000008, "Wrong alignment on AFldDungeonEnvActor");
static_assert(sizeof(AFldDungeonEnvActor) == 0x000280, "Wrong size on AFldDungeonEnvActor");
static_assert(offsetof(AFldDungeonEnvActor, Type) == 0x000278, "Member 'AFldDungeonEnvActor::Type' has a wrong offset!");

// Class xrd777.CmpCldCursor
// 0x0148 (0x0170 - 0x0028)
class UCmpCldCursor final : public UObject
{
public:
	uint8                                         Pad_28[0x148];                                     // 0x0028(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CmpCldCursor">();
	}
	static class UCmpCldCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCmpCldCursor>();
	}
};
static_assert(alignof(UCmpCldCursor) == 0x000008, "Wrong alignment on UCmpCldCursor");
static_assert(sizeof(UCmpCldCursor) == 0x000170, "Wrong size on UCmpCldCursor");

// Class xrd777.FldDungeonEventController
// 0x0010 (0x0158 - 0x0148)
class UFldDungeonEventController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEventController">();
	}
	static class UFldDungeonEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonEventController>();
	}
};
static_assert(alignof(UFldDungeonEventController) == 0x000008, "Wrong alignment on UFldDungeonEventController");
static_assert(sizeof(UFldDungeonEventController) == 0x000158, "Wrong size on UFldDungeonEventController");

// Class xrd777.FldDungeonEventRefActor
// 0x0008 (0x0280 - 0x0278)
class AFldDungeonEventRefActor final : public AAppActor
{
public:
	int32                                         RefID;                                             // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonEventRefActor">();
	}
	static class AFldDungeonEventRefActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonEventRefActor>();
	}
};
static_assert(alignof(AFldDungeonEventRefActor) == 0x000008, "Wrong alignment on AFldDungeonEventRefActor");
static_assert(sizeof(AFldDungeonEventRefActor) == 0x000280, "Wrong size on AFldDungeonEventRefActor");
static_assert(offsetof(AFldDungeonEventRefActor, RefID) == 0x000278, "Member 'AFldDungeonEventRefActor::RefID' has a wrong offset!");

// Class xrd777.FldDungeonFloorFlagsDataAsset
// 0x0028 (0x0058 - 0x0030)
class UFldDungeonFloorFlagsDataAsset final : public UDataAsset
{
public:
	TArray<struct FDungeonFloorFlagsIDData>       IDList;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDungeonFloorFlagsDataTableRow         FloorFlagsTbl;                                     // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	void Input();
	void SearchFlag();
	void SearchFloor();
	void SearchTag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonFloorFlagsDataAsset">();
	}
	static class UFldDungeonFloorFlagsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonFloorFlagsDataAsset>();
	}
};
static_assert(alignof(UFldDungeonFloorFlagsDataAsset) == 0x000008, "Wrong alignment on UFldDungeonFloorFlagsDataAsset");
static_assert(sizeof(UFldDungeonFloorFlagsDataAsset) == 0x000058, "Wrong size on UFldDungeonFloorFlagsDataAsset");
static_assert(offsetof(UFldDungeonFloorFlagsDataAsset, IDList) == 0x000030, "Member 'UFldDungeonFloorFlagsDataAsset::IDList' has a wrong offset!");
static_assert(offsetof(UFldDungeonFloorFlagsDataAsset, FloorFlagsTbl) == 0x000040, "Member 'UFldDungeonFloorFlagsDataAsset::FloorFlagsTbl' has a wrong offset!");

// Class xrd777.UICmpPersona
// 0x0778 (0x09F0 - 0x0278)
class AUICmpPersona final : public AAppActor
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISceneFSM*                            SceneFSM_;                                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpPersonaList*                        PersonaList_;                                      // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PSStatusActor_;                                    // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x720];                                    // 0x02B0(0x0720)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCmpPersona*                            PParent;                                           // 0x09D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E0[0x10];                                     // 0x09E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpPersona">();
	}
	static class AUICmpPersona* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmpPersona>();
	}
};
static_assert(alignof(AUICmpPersona) == 0x000008, "Wrong alignment on AUICmpPersona");
static_assert(sizeof(AUICmpPersona) == 0x0009F0, "Wrong size on AUICmpPersona");
static_assert(offsetof(AUICmpPersona, SceneFSM_) == 0x000298, "Member 'AUICmpPersona::SceneFSM_' has a wrong offset!");
static_assert(offsetof(AUICmpPersona, PersonaList_) == 0x0002A0, "Member 'AUICmpPersona::PersonaList_' has a wrong offset!");
static_assert(offsetof(AUICmpPersona, PSStatusActor_) == 0x0002A8, "Member 'AUICmpPersona::PSStatusActor_' has a wrong offset!");
static_assert(offsetof(AUICmpPersona, PMainActor) == 0x0009D0, "Member 'AUICmpPersona::PMainActor' has a wrong offset!");
static_assert(offsetof(AUICmpPersona, PParent) == 0x0009D8, "Member 'AUICmpPersona::PParent' has a wrong offset!");

// Class xrd777.FldDungeonFloorFlags
// 0x0060 (0x0088 - 0x0028)
class UFldDungeonFloorFlags final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonFloorFlags">();
	}
	static class UFldDungeonFloorFlags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonFloorFlags>();
	}
};
static_assert(alignof(UFldDungeonFloorFlags) == 0x000008, "Wrong alignment on UFldDungeonFloorFlags");
static_assert(sizeof(UFldDungeonFloorFlags) == 0x000088, "Wrong size on UFldDungeonFloorFlags");

// Class xrd777.FldDungeonForbiddenDoorController
// 0x0098 (0x01E0 - 0x0148)
class UFldDungeonForbiddenDoorController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AFldDungeonPartActor*>      M_pForbiddenDoors_Astrea;                          // 0x0158(0x0050)(NativeAccessSpecifierPrivate)
	class AFldDungeonPartActor*                   M_pForbiddenDoor;                                  // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutActor*>         M_LayoutActor;                                     // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x20];                                     // 0x01C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonForbiddenDoorController">();
	}
	static class UFldDungeonForbiddenDoorController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonForbiddenDoorController>();
	}
};
static_assert(alignof(UFldDungeonForbiddenDoorController) == 0x000008, "Wrong alignment on UFldDungeonForbiddenDoorController");
static_assert(sizeof(UFldDungeonForbiddenDoorController) == 0x0001E0, "Wrong size on UFldDungeonForbiddenDoorController");
static_assert(offsetof(UFldDungeonForbiddenDoorController, M_pForbiddenDoors_Astrea) == 0x000158, "Member 'UFldDungeonForbiddenDoorController::M_pForbiddenDoors_Astrea' has a wrong offset!");
static_assert(offsetof(UFldDungeonForbiddenDoorController, M_pForbiddenDoor) == 0x0001A8, "Member 'UFldDungeonForbiddenDoorController::M_pForbiddenDoor' has a wrong offset!");
static_assert(offsetof(UFldDungeonForbiddenDoorController, M_LayoutActor) == 0x0001B0, "Member 'UFldDungeonForbiddenDoorController::M_LayoutActor' has a wrong offset!");

// Class xrd777.FldDungeonInfoActor
// 0x0008 (0x0280 - 0x0278)
class AFldDungeonInfoActor : public AAppActor
{
public:
	EDungeonInfoType                              Type;                                              // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonInfoActor">();
	}
	static class AFldDungeonInfoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonInfoActor>();
	}
};
static_assert(alignof(AFldDungeonInfoActor) == 0x000008, "Wrong alignment on AFldDungeonInfoActor");
static_assert(sizeof(AFldDungeonInfoActor) == 0x000280, "Wrong size on AFldDungeonInfoActor");
static_assert(offsetof(AFldDungeonInfoActor, Type) == 0x000278, "Member 'AFldDungeonInfoActor::Type' has a wrong offset!");

// Class xrd777.FldDungeonObjectInfoActor
// 0x0008 (0x0288 - 0x0280)
class AFldDungeonObjectInfoActor final : public AFldDungeonInfoActor
{
public:
	EDungeonObjectInfoType                        ObjectType;                                        // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonObjectInfoActor">();
	}
	static class AFldDungeonObjectInfoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonObjectInfoActor>();
	}
};
static_assert(alignof(AFldDungeonObjectInfoActor) == 0x000008, "Wrong alignment on AFldDungeonObjectInfoActor");
static_assert(sizeof(AFldDungeonObjectInfoActor) == 0x000288, "Wrong size on AFldDungeonObjectInfoActor");
static_assert(offsetof(AFldDungeonObjectInfoActor, ObjectType) == 0x000280, "Member 'AFldDungeonObjectInfoActor::ObjectType' has a wrong offset!");

// Class xrd777.UICombineCalcFunction
// 0x0000 (0x0028 - 0x0028)
class UUICombineCalcFunction final : public UObject
{
public:
	int32 GetBookDrawOut(int32 Power, int32 Magic, int32 Endurance, int32 Quick, int32 Luck, int32 CommuLevel, int32 MaxSkillLevel);
	int32 GetFoolAccidentLevel(int32 PlayerLevel);
	int32 GetNormalSpreadLevel(int32 LevelA, int32 LevelB);
	int32 GetSuccessionIncense(int32 IncenseParam, int32 SuccessionParam, int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICombineCalcFunction">();
	}
	static class UUICombineCalcFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICombineCalcFunction>();
	}
};
static_assert(alignof(UUICombineCalcFunction) == 0x000008, "Wrong alignment on UUICombineCalcFunction");
static_assert(sizeof(UUICombineCalcFunction) == 0x000028, "Wrong size on UUICombineCalcFunction");

// Class xrd777.FldDungeonInfoSupportController
// 0x0010 (0x0158 - 0x0148)
class UFldDungeonInfoSupportController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonInfoSupportController">();
	}
	static class UFldDungeonInfoSupportController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonInfoSupportController>();
	}
};
static_assert(alignof(UFldDungeonInfoSupportController) == 0x000008, "Wrong alignment on UFldDungeonInfoSupportController");
static_assert(sizeof(UFldDungeonInfoSupportController) == 0x000158, "Wrong size on UFldDungeonInfoSupportController");

// Class xrd777.FldDungeonLayoutStartActor
// 0x0010 (0x02A8 - 0x0298)
class AFldDungeonLayoutStartActor final : public AFldDungeonLayoutActor
{
public:
	ELayoutStartType                              StartType;                                         // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FreeID;                                            // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartID;                                           // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutStartActor">();
	}
	static class AFldDungeonLayoutStartActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutStartActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutStartActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutStartActor");
static_assert(sizeof(AFldDungeonLayoutStartActor) == 0x0002A8, "Wrong size on AFldDungeonLayoutStartActor");
static_assert(offsetof(AFldDungeonLayoutStartActor, StartType) == 0x000298, "Member 'AFldDungeonLayoutStartActor::StartType' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutStartActor, FreeID) == 0x00029C, "Member 'AFldDungeonLayoutStartActor::FreeID' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutStartActor, StartID) == 0x0002A0, "Member 'AFldDungeonLayoutStartActor::StartID' has a wrong offset!");

// Class xrd777.FldDungeonLayoutEnemyActor
// 0x0008 (0x02A0 - 0x0298)
class AFldDungeonLayoutEnemyActor final : public AFldDungeonLayoutActor
{
public:
	EDungeonEnemyType                             EnemyType;                                         // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EncountID;                                         // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutEnemyActor">();
	}
	static class AFldDungeonLayoutEnemyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutEnemyActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutEnemyActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutEnemyActor");
static_assert(sizeof(AFldDungeonLayoutEnemyActor) == 0x0002A0, "Wrong size on AFldDungeonLayoutEnemyActor");
static_assert(offsetof(AFldDungeonLayoutEnemyActor, EnemyType) == 0x000298, "Member 'AFldDungeonLayoutEnemyActor::EnemyType' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutEnemyActor, EncountID) == 0x00029C, "Member 'AFldDungeonLayoutEnemyActor::EncountID' has a wrong offset!");

// Class xrd777.SystemViewer
// 0x0008 (0x0298 - 0x0290)
class ASystemViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SystemViewer">();
	}
	static class ASystemViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASystemViewer>();
	}
};
static_assert(alignof(ASystemViewer) == 0x000008, "Wrong alignment on ASystemViewer");
static_assert(sizeof(ASystemViewer) == 0x000298, "Wrong size on ASystemViewer");

// Class xrd777.FldDungeonLayoutDirectActor
// 0x0028 (0x02C0 - 0x0298)
class AFldDungeonLayoutDirectActor : public AFldDungeonLayoutActor
{
public:
	int32                                         LayoutId;                                          // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Eigenvalue;                                        // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GateKeeper;                                        // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PacIdListOfFbdAstrea;                              // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UsePacIdListOfFbdAstrea;                           // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutDirectActor">();
	}
	static class AFldDungeonLayoutDirectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutDirectActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutDirectActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutDirectActor");
static_assert(sizeof(AFldDungeonLayoutDirectActor) == 0x0002C0, "Wrong size on AFldDungeonLayoutDirectActor");
static_assert(offsetof(AFldDungeonLayoutDirectActor, LayoutId) == 0x000298, "Member 'AFldDungeonLayoutDirectActor::LayoutId' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectActor, Eigenvalue) == 0x00029C, "Member 'AFldDungeonLayoutDirectActor::Eigenvalue' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectActor, GateKeeper) == 0x0002A0, "Member 'AFldDungeonLayoutDirectActor::GateKeeper' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectActor, PacIdListOfFbdAstrea) == 0x0002A8, "Member 'AFldDungeonLayoutDirectActor::PacIdListOfFbdAstrea' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectActor, UsePacIdListOfFbdAstrea) == 0x0002B8, "Member 'AFldDungeonLayoutDirectActor::UsePacIdListOfFbdAstrea' has a wrong offset!");

// Class xrd777.FldDungeonLayoutDirectEnemyActor
// 0x0010 (0x02D0 - 0x02C0)
class AFldDungeonLayoutDirectEnemyActor final : public AFldDungeonLayoutDirectActor
{
public:
	uint32                                        ModelID;                                           // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SymbolID;                                          // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DefeatFlagID;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutDirectEnemyActor">();
	}
	static class AFldDungeonLayoutDirectEnemyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutDirectEnemyActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutDirectEnemyActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutDirectEnemyActor");
static_assert(sizeof(AFldDungeonLayoutDirectEnemyActor) == 0x0002D0, "Wrong size on AFldDungeonLayoutDirectEnemyActor");
static_assert(offsetof(AFldDungeonLayoutDirectEnemyActor, ModelID) == 0x0002C0, "Member 'AFldDungeonLayoutDirectEnemyActor::ModelID' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectEnemyActor, SymbolID) == 0x0002C4, "Member 'AFldDungeonLayoutDirectEnemyActor::SymbolID' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectEnemyActor, DefeatFlagID) == 0x0002C8, "Member 'AFldDungeonLayoutDirectEnemyActor::DefeatFlagID' has a wrong offset!");

// Class xrd777.FldDungeonLayoutDirectTBoxActor
// 0x0018 (0x02D8 - 0x02C0)
class AFldDungeonLayoutDirectTBoxActor final : public AFldDungeonLayoutDirectActor
{
public:
	EDungeonTBoxType                              TboxType;                                          // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Money;                                             // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Encount;                                           // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckFlag;                                         // 0x02C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FlagName;                                          // 0x02CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonLayoutDirectTBoxActor">();
	}
	static class AFldDungeonLayoutDirectTBoxActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonLayoutDirectTBoxActor>();
	}
};
static_assert(alignof(AFldDungeonLayoutDirectTBoxActor) == 0x000008, "Wrong alignment on AFldDungeonLayoutDirectTBoxActor");
static_assert(sizeof(AFldDungeonLayoutDirectTBoxActor) == 0x0002D8, "Wrong size on AFldDungeonLayoutDirectTBoxActor");
static_assert(offsetof(AFldDungeonLayoutDirectTBoxActor, TboxType) == 0x0002C0, "Member 'AFldDungeonLayoutDirectTBoxActor::TboxType' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectTBoxActor, Money) == 0x0002C4, "Member 'AFldDungeonLayoutDirectTBoxActor::Money' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectTBoxActor, Encount) == 0x0002C8, "Member 'AFldDungeonLayoutDirectTBoxActor::Encount' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectTBoxActor, CheckFlag) == 0x0002C9, "Member 'AFldDungeonLayoutDirectTBoxActor::CheckFlag' has a wrong offset!");
static_assert(offsetof(AFldDungeonLayoutDirectTBoxActor, FlagName) == 0x0002CC, "Member 'AFldDungeonLayoutDirectTBoxActor::FlagName' has a wrong offset!");

// Class xrd777.FldDungeonMenuScript
// 0x0008 (0x02B8 - 0x02B0)
class AFldDungeonMenuScript final : public AFldScriptManagerCore
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonMenuScript">();
	}
	static class AFldDungeonMenuScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonMenuScript>();
	}
};
static_assert(alignof(AFldDungeonMenuScript) == 0x000008, "Wrong alignment on AFldDungeonMenuScript");
static_assert(sizeof(AFldDungeonMenuScript) == 0x0002B8, "Wrong size on AFldDungeonMenuScript");

// Class xrd777.FldDungeonMissingController
// 0x0028 (0x0170 - 0x0148)
class UFldDungeonMissingController final : public UFldDungeonComponentBase
{
public:
	class ANpcBaseCore*                           M_pMissingPerson;                                  // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonSoundBaseActor*              M_pMisNpcSE;                                       // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonPartActor*                   M_pPartRoom;                                       // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonMissingController">();
	}
	static class UFldDungeonMissingController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonMissingController>();
	}
};
static_assert(alignof(UFldDungeonMissingController) == 0x000008, "Wrong alignment on UFldDungeonMissingController");
static_assert(sizeof(UFldDungeonMissingController) == 0x000170, "Wrong size on UFldDungeonMissingController");
static_assert(offsetof(UFldDungeonMissingController, M_pMissingPerson) == 0x000148, "Member 'UFldDungeonMissingController::M_pMissingPerson' has a wrong offset!");
static_assert(offsetof(UFldDungeonMissingController, M_pMisNpcSE) == 0x000150, "Member 'UFldDungeonMissingController::M_pMisNpcSE' has a wrong offset!");
static_assert(offsetof(UFldDungeonMissingController, M_pPartRoom) == 0x000160, "Member 'UFldDungeonMissingController::M_pPartRoom' has a wrong offset!");

// Class xrd777.FldDungeonObjectActor
// 0x00E8 (0x0360 - 0x0278)
class AFldDungeonObjectActor final : public AAppActor
{
public:
	EDungeonObjType                               ObjType;                                           // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BaseObject;                                        // 0x0280(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitAnimNo;                                        // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnimNo;                                         // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAnimNo;                                         // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x2C];                                     // 0x02A4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonObjectActor*                 M_pBaseObject;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFldHitActor*>                   M_pHitActorList;                                   // 0x02D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldAnimObj*>                    M_AnimObjList;                                     // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          M_pBox;                                            // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULightComponent*>                M_pLightComps;                                     // 0x0320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x30];                                     // 0x0330(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitActionNotice(class APawn* Player);
	void HitInNotice(class AActor* OtherActor);
	void HitOutNotice(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonObjectActor">();
	}
	static class AFldDungeonObjectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonObjectActor>();
	}
};
static_assert(alignof(AFldDungeonObjectActor) == 0x000008, "Wrong alignment on AFldDungeonObjectActor");
static_assert(sizeof(AFldDungeonObjectActor) == 0x000360, "Wrong size on AFldDungeonObjectActor");
static_assert(offsetof(AFldDungeonObjectActor, ObjType) == 0x000278, "Member 'AFldDungeonObjectActor::ObjType' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, BaseObject) == 0x000280, "Member 'AFldDungeonObjectActor::BaseObject' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, InitAnimNo) == 0x000298, "Member 'AFldDungeonObjectActor::InitAnimNo' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, HitAnimNo) == 0x00029C, "Member 'AFldDungeonObjectActor::HitAnimNo' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, EndAnimNo) == 0x0002A0, "Member 'AFldDungeonObjectActor::EndAnimNo' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, M_pBaseObject) == 0x0002D0, "Member 'AFldDungeonObjectActor::M_pBaseObject' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, M_pHitActorList) == 0x0002D8, "Member 'AFldDungeonObjectActor::M_pHitActorList' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, M_AnimObjList) == 0x0002F8, "Member 'AFldDungeonObjectActor::M_AnimObjList' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, M_pBox) == 0x000310, "Member 'AFldDungeonObjectActor::M_pBox' has a wrong offset!");
static_assert(offsetof(AFldDungeonObjectActor, M_pLightComps) == 0x000320, "Member 'AFldDungeonObjectActor::M_pLightComps' has a wrong offset!");

// Class xrd777.TestPauseSoundClass
// 0x0000 (0x0028 - 0x0028)
class UTestPauseSoundClass final : public UObject
{
public:
	static void TestPauseSoundPasue(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestPauseSoundClass">();
	}
	static class UTestPauseSoundClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestPauseSoundClass>();
	}
};
static_assert(alignof(UTestPauseSoundClass) == 0x000008, "Wrong alignment on UTestPauseSoundClass");
static_assert(sizeof(UTestPauseSoundClass) == 0x000028, "Wrong size on UTestPauseSoundClass");

// Class xrd777.FldDungeonParamDataAsset
// 0x03E8 (0x0418 - 0x0030)
class UFldDungeonParamDataAsset final : public UDataAsset
{
public:
	struct FDungeonParamDataTableRow              ParamData;                                         // 0x0030(0x03E8)(Edit, NativeAccessSpecifierPublic)

public:
	void AddResetData();
	void DelResetData();
	void GenEnemyModelIdOfAstrea();
	void GenEnemyModelIdOfTartarus();
	void ImportDataPathOfAstrea();
	void ImportDataPathOfTartarus();
	void ImportLevelPathOfAstrea();
	void ImportLevelPathOfTartarus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonParamDataAsset">();
	}
	static class UFldDungeonParamDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonParamDataAsset>();
	}
};
static_assert(alignof(UFldDungeonParamDataAsset) == 0x000008, "Wrong alignment on UFldDungeonParamDataAsset");
static_assert(sizeof(UFldDungeonParamDataAsset) == 0x000418, "Wrong size on UFldDungeonParamDataAsset");
static_assert(offsetof(UFldDungeonParamDataAsset, ParamData) == 0x000030, "Member 'UFldDungeonParamDataAsset::ParamData' has a wrong offset!");

// Class xrd777.FldDungeonParamActor
// 0x0078 (0x02F0 - 0x0278)
class AFldDungeonParamActor final : public AAppActor
{
public:
	struct FSoftObjectPath                        DataAsset;                                         // 0x0278(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DungeonTable;                                      // 0x0290(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        PartVariationData;                                 // 0x02A8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        FloorFlagsData;                                    // 0x02C0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFldDungeonPartVariation*               M_pPartVariation;                                  // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldDungeonFloorFlags*                  M_pFloorFlags;                                     // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonParamActor">();
	}
	static class AFldDungeonParamActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonParamActor>();
	}
};
static_assert(alignof(AFldDungeonParamActor) == 0x000008, "Wrong alignment on AFldDungeonParamActor");
static_assert(sizeof(AFldDungeonParamActor) == 0x0002F0, "Wrong size on AFldDungeonParamActor");
static_assert(offsetof(AFldDungeonParamActor, DataAsset) == 0x000278, "Member 'AFldDungeonParamActor::DataAsset' has a wrong offset!");
static_assert(offsetof(AFldDungeonParamActor, DungeonTable) == 0x000290, "Member 'AFldDungeonParamActor::DungeonTable' has a wrong offset!");
static_assert(offsetof(AFldDungeonParamActor, PartVariationData) == 0x0002A8, "Member 'AFldDungeonParamActor::PartVariationData' has a wrong offset!");
static_assert(offsetof(AFldDungeonParamActor, FloorFlagsData) == 0x0002C0, "Member 'AFldDungeonParamActor::FloorFlagsData' has a wrong offset!");
static_assert(offsetof(AFldDungeonParamActor, M_pPartVariation) == 0x0002E0, "Member 'AFldDungeonParamActor::M_pPartVariation' has a wrong offset!");
static_assert(offsetof(AFldDungeonParamActor, M_pFloorFlags) == 0x0002E8, "Member 'AFldDungeonParamActor::M_pFloorFlags' has a wrong offset!");

// Class xrd777.FldDungeonPartController
// 0x0080 (0x01C8 - 0x0148)
class UFldDungeonPartController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonPartActor*>           M_PartActor;                                       // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         M_WallActor;                                       // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         M_PartActorRef;                                    // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x50];                                     // 0x0178(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoCreatePart();
	void AutoLoadPart();
	void InitDesignMap();
	void InitFixedMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonPartController">();
	}
	static class UFldDungeonPartController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonPartController>();
	}
};
static_assert(alignof(UFldDungeonPartController) == 0x000008, "Wrong alignment on UFldDungeonPartController");
static_assert(sizeof(UFldDungeonPartController) == 0x0001C8, "Wrong size on UFldDungeonPartController");
static_assert(offsetof(UFldDungeonPartController, M_PartActor) == 0x000148, "Member 'UFldDungeonPartController::M_PartActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartController, M_WallActor) == 0x000158, "Member 'UFldDungeonPartController::M_WallActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartController, M_PartActorRef) == 0x000168, "Member 'UFldDungeonPartController::M_PartActorRef' has a wrong offset!");

// Class xrd777.FldDungeonPartnerController
// 0x0090 (0x01D8 - 0x0148)
class UFldDungeonPartnerController final : public UFldDungeonComponentBase
{
public:
	TArray<struct FFldPartnerHolder>              M_Partners;                                        // 0x0148(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AFldDungeonLayoutStartActor*>    M_StartList;                                       // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x70];                                     // 0x0168(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonPartnerController">();
	}
	static class UFldDungeonPartnerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonPartnerController>();
	}
};
static_assert(alignof(UFldDungeonPartnerController) == 0x000008, "Wrong alignment on UFldDungeonPartnerController");
static_assert(sizeof(UFldDungeonPartnerController) == 0x0001D8, "Wrong size on UFldDungeonPartnerController");
static_assert(offsetof(UFldDungeonPartnerController, M_Partners) == 0x000148, "Member 'UFldDungeonPartnerController::M_Partners' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartnerController, M_StartList) == 0x000158, "Member 'UFldDungeonPartnerController::M_StartList' has a wrong offset!");

// Class xrd777.FldDungeonPartVariationDataAsset
// 0x01D8 (0x0208 - 0x0030)
class UFldDungeonPartVariationDataAsset final : public UDataAsset
{
public:
	struct FDungeonPartVariationDataTableRow      Area1;                                             // 0x0030(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area2;                                             // 0x0068(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area3;                                             // 0x00A0(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area4;                                             // 0x00D8(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area5;                                             // 0x0110(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area6;                                             // 0x0148(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartVariationDataTableRow      Area7;                                             // 0x0180(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FDungeonDesignTypesData>        DungeonDesignTypesDataList;                        // 0x01B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDungeonPartFDoorTypeDataTableRow      FDoorTypeTbl;                                      // 0x01C8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FDungeonPartMisRoomTypeDataTableRow    MisRoomTypeTbl;                                    // 0x01E8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonPartVariationDataAsset">();
	}
	static class UFldDungeonPartVariationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonPartVariationDataAsset>();
	}
};
static_assert(alignof(UFldDungeonPartVariationDataAsset) == 0x000008, "Wrong alignment on UFldDungeonPartVariationDataAsset");
static_assert(sizeof(UFldDungeonPartVariationDataAsset) == 0x000208, "Wrong size on UFldDungeonPartVariationDataAsset");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area1) == 0x000030, "Member 'UFldDungeonPartVariationDataAsset::Area1' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area2) == 0x000068, "Member 'UFldDungeonPartVariationDataAsset::Area2' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area3) == 0x0000A0, "Member 'UFldDungeonPartVariationDataAsset::Area3' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area4) == 0x0000D8, "Member 'UFldDungeonPartVariationDataAsset::Area4' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area5) == 0x000110, "Member 'UFldDungeonPartVariationDataAsset::Area5' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area6) == 0x000148, "Member 'UFldDungeonPartVariationDataAsset::Area6' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, Area7) == 0x000180, "Member 'UFldDungeonPartVariationDataAsset::Area7' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, DungeonDesignTypesDataList) == 0x0001B8, "Member 'UFldDungeonPartVariationDataAsset::DungeonDesignTypesDataList' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, FDoorTypeTbl) == 0x0001C8, "Member 'UFldDungeonPartVariationDataAsset::FDoorTypeTbl' has a wrong offset!");
static_assert(offsetof(UFldDungeonPartVariationDataAsset, MisRoomTypeTbl) == 0x0001E8, "Member 'UFldDungeonPartVariationDataAsset::MisRoomTypeTbl' has a wrong offset!");

// Class xrd777.FldDungeonPartVariation
// 0x0000 (0x0028 - 0x0028)
class UFldDungeonPartVariation final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonPartVariation">();
	}
	static class UFldDungeonPartVariation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonPartVariation>();
	}
};
static_assert(alignof(UFldDungeonPartVariation) == 0x000008, "Wrong alignment on UFldDungeonPartVariation");
static_assert(sizeof(UFldDungeonPartVariation) == 0x000028, "Wrong size on UFldDungeonPartVariation");

// Class xrd777.SimpleShopDataAsset
// 0x0010 (0x0040 - 0x0030)
class USimpleShopDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FSimpleShopData>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleShopDataAsset">();
	}
	static class USimpleShopDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleShopDataAsset>();
	}
};
static_assert(alignof(USimpleShopDataAsset) == 0x000008, "Wrong alignment on USimpleShopDataAsset");
static_assert(sizeof(USimpleShopDataAsset) == 0x000040, "Wrong size on USimpleShopDataAsset");
static_assert(offsetof(USimpleShopDataAsset, Data) == 0x000030, "Member 'USimpleShopDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonReaperController
// 0x0020 (0x0168 - 0x0148)
class UFldDungeonReaperController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonEffectCameraAttachActor*     M_pEffect;                                         // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonReaperController">();
	}
	static class UFldDungeonReaperController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonReaperController>();
	}
};
static_assert(alignof(UFldDungeonReaperController) == 0x000008, "Wrong alignment on UFldDungeonReaperController");
static_assert(sizeof(UFldDungeonReaperController) == 0x000168, "Wrong size on UFldDungeonReaperController");
static_assert(offsetof(UFldDungeonReaperController, M_pEffect) == 0x000160, "Member 'UFldDungeonReaperController::M_pEffect' has a wrong offset!");

// Class xrd777.FldDungeonRecoverController
// 0x0018 (0x0160 - 0x0148)
class UFldDungeonRecoverController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraCameraAttachComponent*          M_pEffectCameraAttach;                             // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonRecoverController">();
	}
	static class UFldDungeonRecoverController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonRecoverController>();
	}
};
static_assert(alignof(UFldDungeonRecoverController) == 0x000008, "Wrong alignment on UFldDungeonRecoverController");
static_assert(sizeof(UFldDungeonRecoverController) == 0x000160, "Wrong size on UFldDungeonRecoverController");
static_assert(offsetof(UFldDungeonRecoverController, M_pEffectCameraAttach) == 0x000158, "Member 'UFldDungeonRecoverController::M_pEffectCameraAttach' has a wrong offset!");

// Class xrd777.FldDungeonResourceServer
// 0x00E8 (0x0360 - 0x0278)
class AFldDungeonResourceServer final : public AAppActor
{
public:
	uint8                                         Pad_278[0xE8];                                     // 0x0278(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonResourceServer">();
	}
	static class AFldDungeonResourceServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonResourceServer>();
	}
};
static_assert(alignof(AFldDungeonResourceServer) == 0x000008, "Wrong alignment on AFldDungeonResourceServer");
static_assert(sizeof(AFldDungeonResourceServer) == 0x000360, "Wrong size on AFldDungeonResourceServer");

// Class xrd777.FldDungeonSetupController
// 0x0008 (0x0150 - 0x0148)
class UFldDungeonSetupController final : public UFldDungeonComponentBase
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSetupController">();
	}
	static class UFldDungeonSetupController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonSetupController>();
	}
};
static_assert(alignof(UFldDungeonSetupController) == 0x000008, "Wrong alignment on UFldDungeonSetupController");
static_assert(sizeof(UFldDungeonSetupController) == 0x000150, "Wrong size on UFldDungeonSetupController");

// Class xrd777.FldDungeonSoundBaseActor
// 0x0008 (0x0280 - 0x0278)
class AFldDungeonSoundBaseActor : public AAppActor
{
public:
	EDungeonSuondType                             Type;                                              // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPPlay();
	void BPStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSoundBaseActor">();
	}
	static class AFldDungeonSoundBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonSoundBaseActor>();
	}
};
static_assert(alignof(AFldDungeonSoundBaseActor) == 0x000008, "Wrong alignment on AFldDungeonSoundBaseActor");
static_assert(sizeof(AFldDungeonSoundBaseActor) == 0x000280, "Wrong size on AFldDungeonSoundBaseActor");
static_assert(offsetof(AFldDungeonSoundBaseActor, Type) == 0x000278, "Member 'AFldDungeonSoundBaseActor::Type' has a wrong offset!");

// Class xrd777.FldDungeonSoundActor
// 0x0030 (0x02B0 - 0x0280)
class AFldDungeonSoundActor final : public AFldDungeonSoundBaseActor
{
public:
	TArray<int32>                                 CueIDList;                                         // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSoundActor">();
	}
	static class AFldDungeonSoundActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonSoundActor>();
	}
};
static_assert(alignof(AFldDungeonSoundActor) == 0x000008, "Wrong alignment on AFldDungeonSoundActor");
static_assert(sizeof(AFldDungeonSoundActor) == 0x0002B0, "Wrong size on AFldDungeonSoundActor");
static_assert(offsetof(AFldDungeonSoundActor, CueIDList) == 0x000280, "Member 'AFldDungeonSoundActor::CueIDList' has a wrong offset!");

// Class xrd777.TownMapInfoDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTownMapInfoDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTownMapInfoTable>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownMapInfoDataAsset">();
	}
	static class UTownMapInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownMapInfoDataAsset>();
	}
};
static_assert(alignof(UTownMapInfoDataAsset) == 0x000008, "Wrong alignment on UTownMapInfoDataAsset");
static_assert(sizeof(UTownMapInfoDataAsset) == 0x000040, "Wrong size on UTownMapInfoDataAsset");
static_assert(offsetof(UTownMapInfoDataAsset, Data) == 0x000030, "Member 'UTownMapInfoDataAsset::Data' has a wrong offset!");

// Class xrd777.FldDungeonStartParam
// 0x0010 (0x0038 - 0x0028)
class UFldDungeonStartParam final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckStartParam();
	static void SetStartParam(int32 Major, int32 Minor, int32 Idx, bool bScript);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonStartParam">();
	}
	static class UFldDungeonStartParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonStartParam>();
	}
};
static_assert(alignof(UFldDungeonStartParam) == 0x000008, "Wrong alignment on UFldDungeonStartParam");
static_assert(sizeof(UFldDungeonStartParam) == 0x000038, "Wrong size on UFldDungeonStartParam");

// Class xrd777.FldDungeonStartActor
// 0x0008 (0x0280 - 0x0278)
class AFldDungeonStartActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonStartActor">();
	}
	static class AFldDungeonStartActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonStartActor>();
	}
};
static_assert(alignof(AFldDungeonStartActor) == 0x000008, "Wrong alignment on AFldDungeonStartActor");
static_assert(sizeof(AFldDungeonStartActor) == 0x000280, "Wrong size on AFldDungeonStartActor");

// Class xrd777.FldDungeonSupportSkillController
// 0x0030 (0x0178 - 0x0148)
class UFldDungeonSupportSkillController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonEffectCameraAttachActor*> M_pEffectList;                                     // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x20];                                     // 0x0158(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonSupportSkillController">();
	}
	static class UFldDungeonSupportSkillController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonSupportSkillController>();
	}
};
static_assert(alignof(UFldDungeonSupportSkillController) == 0x000008, "Wrong alignment on UFldDungeonSupportSkillController");
static_assert(sizeof(UFldDungeonSupportSkillController) == 0x000178, "Wrong size on UFldDungeonSupportSkillController");
static_assert(offsetof(UFldDungeonSupportSkillController, M_pEffectList) == 0x000148, "Member 'UFldDungeonSupportSkillController::M_pEffectList' has a wrong offset!");

// Class xrd777.FldDungeonTransferController
// 0x0028 (0x0170 - 0x0148)
class UFldDungeonTransferController final : public UFldDungeonComponentBase
{
public:
	class AFldDungeonObjectActor*                 M_ReturnActor;                                     // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonObjectActor*                 M_pFixedReturn;                                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonObjectActor*                 M_pFixedTransfer;                                  // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDungeonPartActor*                   M_pPartActor;                                      // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonTransferController">();
	}
	static class UFldDungeonTransferController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonTransferController>();
	}
};
static_assert(alignof(UFldDungeonTransferController) == 0x000008, "Wrong alignment on UFldDungeonTransferController");
static_assert(sizeof(UFldDungeonTransferController) == 0x000170, "Wrong size on UFldDungeonTransferController");
static_assert(offsetof(UFldDungeonTransferController, M_ReturnActor) == 0x000148, "Member 'UFldDungeonTransferController::M_ReturnActor' has a wrong offset!");
static_assert(offsetof(UFldDungeonTransferController, M_pFixedReturn) == 0x000150, "Member 'UFldDungeonTransferController::M_pFixedReturn' has a wrong offset!");
static_assert(offsetof(UFldDungeonTransferController, M_pFixedTransfer) == 0x000158, "Member 'UFldDungeonTransferController::M_pFixedTransfer' has a wrong offset!");
static_assert(offsetof(UFldDungeonTransferController, M_pPartActor) == 0x000160, "Member 'UFldDungeonTransferController::M_pPartActor' has a wrong offset!");

// Class xrd777.FldDungeonUIController
// 0x0018 (0x0160 - 0x0148)
class UFldDungeonUIController final : public UFldDungeonComponentBase
{
public:
	TArray<class AFldDungeonUIActor*>             M_UIActor;                                         // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonUIController">();
	}
	static class UFldDungeonUIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldDungeonUIController>();
	}
};
static_assert(alignof(UFldDungeonUIController) == 0x000008, "Wrong alignment on UFldDungeonUIController");
static_assert(sizeof(UFldDungeonUIController) == 0x000160, "Wrong size on UFldDungeonUIController");
static_assert(offsetof(UFldDungeonUIController, M_UIActor) == 0x000148, "Member 'UFldDungeonUIController::M_UIActor' has a wrong offset!");

// Class xrd777.FldDungeonUIActor
// 0x0100 (0x0378 - 0x0278)
class AFldDungeonUIActor final : public AAppActor
{
public:
	EDungeonUIType                                Type;                                              // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDungeonUIDrawDataTable                DrawTbl;                                           // 0x0280(0x0058)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x88];                                     // 0x02D8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           M_pLoader;                                         // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldDungeonUIActor">();
	}
	static class AFldDungeonUIActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldDungeonUIActor>();
	}
};
static_assert(alignof(AFldDungeonUIActor) == 0x000008, "Wrong alignment on AFldDungeonUIActor");
static_assert(sizeof(AFldDungeonUIActor) == 0x000378, "Wrong size on AFldDungeonUIActor");
static_assert(offsetof(AFldDungeonUIActor, Type) == 0x000278, "Member 'AFldDungeonUIActor::Type' has a wrong offset!");
static_assert(offsetof(AFldDungeonUIActor, DrawTbl) == 0x000280, "Member 'AFldDungeonUIActor::DrawTbl' has a wrong offset!");
static_assert(offsetof(AFldDungeonUIActor, LayoutData) == 0x000360, "Member 'AFldDungeonUIActor::LayoutData' has a wrong offset!");
static_assert(offsetof(AFldDungeonUIActor, LayoutDataTable) == 0x000368, "Member 'AFldDungeonUIActor::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AFldDungeonUIActor, M_pLoader) == 0x000370, "Member 'AFldDungeonUIActor::M_pLoader' has a wrong offset!");

// Class xrd777.MiniMapAssetLoader
// 0x1080 (0x10A8 - 0x0028)
class UMiniMapAssetLoader final : public UObject
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoadedFlag;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               PMapTex;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMiniMapIconListTable*                  PFldMiniMapIconTable;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               PMapParts[0x82];                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               PWallTex;                                          // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              PPartMaskSpr;                                      // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldType                                      EFldType;                                          // 0x0468(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0xC3F];                                    // 0x0469(0x0C3F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAssetLoader* GetAssetLoader();
	class UMiniMapIconListTable* GetFldMiniMapIconTable();
	SDK::EFldType GetFldType();
	class UTexture* GetMapParts(int32 Index_0);
	class UTexture* GetMapTex();
	class UTexture* GetMapTexture();
	TArray<uint8> GetPartList(int32 Index_0);
	class USprAsset* GetPartMaskSpr();
	TMap<int32, int32> GetTartarusMapPartIndexList(int32 Index_0);
	class UTexture* GetWallTex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapAssetLoader">();
	}
	static class UMiniMapAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapAssetLoader>();
	}
};
static_assert(alignof(UMiniMapAssetLoader) == 0x000008, "Wrong alignment on UMiniMapAssetLoader");
static_assert(sizeof(UMiniMapAssetLoader) == 0x0010A8, "Wrong size on UMiniMapAssetLoader");
static_assert(offsetof(UMiniMapAssetLoader, PAssetLoader) == 0x000028, "Member 'UMiniMapAssetLoader::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, bLoadedFlag) == 0x000030, "Member 'UMiniMapAssetLoader::bLoadedFlag' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, PMapTex) == 0x000038, "Member 'UMiniMapAssetLoader::PMapTex' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, PFldMiniMapIconTable) == 0x000040, "Member 'UMiniMapAssetLoader::PFldMiniMapIconTable' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, PMapParts) == 0x000048, "Member 'UMiniMapAssetLoader::PMapParts' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, PWallTex) == 0x000458, "Member 'UMiniMapAssetLoader::PWallTex' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, PPartMaskSpr) == 0x000460, "Member 'UMiniMapAssetLoader::PPartMaskSpr' has a wrong offset!");
static_assert(offsetof(UMiniMapAssetLoader, EFldType) == 0x000468, "Member 'UMiniMapAssetLoader::EFldType' has a wrong offset!");

// Class xrd777.FldEnemyComp
// 0x00C8 (0x0190 - 0x00C8)
#pragma pack(push, 0x1)
class alignas(0x10) UFldEnemyComp : public UFldLocalActorComp
{
public:
	class AFldEnemyController*                    ControllerRef;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            MovementComp;                                      // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   SearchAreaComp;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCharArea*                           SearchArea;                                        // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   AttackAreaComp;                                    // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCharArea*                           AttackArea;                                        // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontage;                                       // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      CurrentAnimSequence;                               // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldEnemyType                                 EnemyType;                                         // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EncountID;                                         // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Group;                                             // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbnormalStateId;                                   // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUpset;                                       // 0x012C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGroupEnable;                                      // 0x012D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisibleEnable;                                    // 0x012E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollisionEnable;                                  // 0x012F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FlagID;                                            // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RespawnProhibited;                                 // 0x0134(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TypeChanged;                                       // 0x0135(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowStandbyToFinish;                             // 0x0136(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137[0x1];                                      // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAppCharTransparency                   Transparency;                                      // 0x0138(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0xC];                                      // 0x0144(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BeginTransform;                                    // 0x0150(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyComp">();
	}
	static class UFldEnemyComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyComp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFldEnemyComp) == 0x000010, "Wrong alignment on UFldEnemyComp");
static_assert(sizeof(UFldEnemyComp) == 0x000190, "Wrong size on UFldEnemyComp");
static_assert(offsetof(UFldEnemyComp, ControllerRef) == 0x0000C8, "Member 'UFldEnemyComp::ControllerRef' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, MeshComp) == 0x0000D0, "Member 'UFldEnemyComp::MeshComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, MovementComp) == 0x0000D8, "Member 'UFldEnemyComp::MovementComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, CapsuleComp) == 0x0000E0, "Member 'UFldEnemyComp::CapsuleComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, SearchAreaComp) == 0x0000E8, "Member 'UFldEnemyComp::SearchAreaComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, SearchArea) == 0x0000F0, "Member 'UFldEnemyComp::SearchArea' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, AttackAreaComp) == 0x0000F8, "Member 'UFldEnemyComp::AttackAreaComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, AttackArea) == 0x000100, "Member 'UFldEnemyComp::AttackArea' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, AnimMontage) == 0x000108, "Member 'UFldEnemyComp::AnimMontage' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, CurrentAnimSequence) == 0x000110, "Member 'UFldEnemyComp::CurrentAnimSequence' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, EnemyType) == 0x000118, "Member 'UFldEnemyComp::EnemyType' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, ID) == 0x00011C, "Member 'UFldEnemyComp::ID' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, EncountID) == 0x000120, "Member 'UFldEnemyComp::EncountID' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, Group) == 0x000124, "Member 'UFldEnemyComp::Group' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, AbnormalStateId) == 0x000128, "Member 'UFldEnemyComp::AbnormalStateId' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, bForceUpset) == 0x00012C, "Member 'UFldEnemyComp::bForceUpset' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, bGroupEnable) == 0x00012D, "Member 'UFldEnemyComp::bGroupEnable' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, bVisibleEnable) == 0x00012E, "Member 'UFldEnemyComp::bVisibleEnable' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, bCollisionEnable) == 0x00012F, "Member 'UFldEnemyComp::bCollisionEnable' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, FlagID) == 0x000130, "Member 'UFldEnemyComp::FlagID' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, RespawnProhibited) == 0x000134, "Member 'UFldEnemyComp::RespawnProhibited' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, TypeChanged) == 0x000135, "Member 'UFldEnemyComp::TypeChanged' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, bAllowStandbyToFinish) == 0x000136, "Member 'UFldEnemyComp::bAllowStandbyToFinish' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, Transparency) == 0x000138, "Member 'UFldEnemyComp::Transparency' has a wrong offset!");
static_assert(offsetof(UFldEnemyComp, BeginTransform) == 0x000150, "Member 'UFldEnemyComp::BeginTransform' has a wrong offset!");

// Class xrd777.FldEnemyForbiddenDoorComp
// 0x0150 (0x02E0 - 0x0190)
class UFldEnemyForbiddenDoorComp final : public UFldEnemyComp
{
public:
	class UChildActorComponent*                   DisplayChildActorComp;                             // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AuraNiagaraComp;                                   // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldEnemyState                                State;                                             // 0x0198(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldEnemyState                                NextState;                                         // 0x019C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoading;                                        // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSetupDisplay;                                   // 0x01A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DisplayClassPtr;                                   // 0x01A8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0xF8];                                     // 0x01D0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldEnemyEffectParam                   AuraEffect;                                        // 0x02C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyForbiddenDoorComp">();
	}
	static class UFldEnemyForbiddenDoorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyForbiddenDoorComp>();
	}
};
static_assert(alignof(UFldEnemyForbiddenDoorComp) == 0x000010, "Wrong alignment on UFldEnemyForbiddenDoorComp");
static_assert(sizeof(UFldEnemyForbiddenDoorComp) == 0x0002E0, "Wrong size on UFldEnemyForbiddenDoorComp");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, DisplayChildActorComp) == 0x000188, "Member 'UFldEnemyForbiddenDoorComp::DisplayChildActorComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, AuraNiagaraComp) == 0x000190, "Member 'UFldEnemyForbiddenDoorComp::AuraNiagaraComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, State) == 0x000198, "Member 'UFldEnemyForbiddenDoorComp::State' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, NextState) == 0x00019C, "Member 'UFldEnemyForbiddenDoorComp::NextState' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, bIsLoading) == 0x0001A0, "Member 'UFldEnemyForbiddenDoorComp::bIsLoading' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, bIsSetupDisplay) == 0x0001A1, "Member 'UFldEnemyForbiddenDoorComp::bIsSetupDisplay' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, DisplayClassPtr) == 0x0001A8, "Member 'UFldEnemyForbiddenDoorComp::DisplayClassPtr' has a wrong offset!");
static_assert(offsetof(UFldEnemyForbiddenDoorComp, AuraEffect) == 0x0002C8, "Member 'UFldEnemyForbiddenDoorComp::AuraEffect' has a wrong offset!");

// Class xrd777.FldEnemyManager
// 0x0030 (0x02A8 - 0x0278)
class AFldEnemyManager final : public AAppActor
{
public:
	TArray<struct FFldEnemyHolder>                Enemies;                                           // 0x0278(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bBattle;                                           // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DisableleList;                                     // 0x0290(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      VanishNiagaraComp;                                 // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Add(class AActor* Actor);
	void Cleanup();
	void ForceEncount();
	void SetEnable(const bool Enable, const int32 Group);
	void Setup(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyManager">();
	}
	static class AFldEnemyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldEnemyManager>();
	}
};
static_assert(alignof(AFldEnemyManager) == 0x000008, "Wrong alignment on AFldEnemyManager");
static_assert(sizeof(AFldEnemyManager) == 0x0002A8, "Wrong size on AFldEnemyManager");
static_assert(offsetof(AFldEnemyManager, Enemies) == 0x000278, "Member 'AFldEnemyManager::Enemies' has a wrong offset!");
static_assert(offsetof(AFldEnemyManager, bBattle) == 0x000288, "Member 'AFldEnemyManager::bBattle' has a wrong offset!");
static_assert(offsetof(AFldEnemyManager, DisableleList) == 0x000290, "Member 'AFldEnemyManager::DisableleList' has a wrong offset!");
static_assert(offsetof(AFldEnemyManager, VanishNiagaraComp) == 0x0002A0, "Member 'AFldEnemyManager::VanishNiagaraComp' has a wrong offset!");

// Class xrd777.UIMiscEnemySymbolDraw
// 0x0108 (0x03A8 - 0x02A0)
class AUIMiscEnemySymbolDraw final : public AUIBaseActor
{
public:
	class USprAsset*                              M_pSpr;                                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0xF8];                                     // 0x02A8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pEnemyRef;                                       // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscEnemySymbolDraw">();
	}
	static class AUIMiscEnemySymbolDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscEnemySymbolDraw>();
	}
};
static_assert(alignof(AUIMiscEnemySymbolDraw) == 0x000008, "Wrong alignment on AUIMiscEnemySymbolDraw");
static_assert(sizeof(AUIMiscEnemySymbolDraw) == 0x0003A8, "Wrong size on AUIMiscEnemySymbolDraw");
static_assert(offsetof(AUIMiscEnemySymbolDraw, M_pSpr) == 0x0002A0, "Member 'AUIMiscEnemySymbolDraw::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscEnemySymbolDraw, M_pEnemyRef) == 0x0003A0, "Member 'AUIMiscEnemySymbolDraw::M_pEnemyRef' has a wrong offset!");

// Class xrd777.FldEnemyNormalComp
// 0x0210 (0x03A0 - 0x0190)
class UFldEnemyNormalComp final : public UFldEnemyComp
{
public:
	class UNiagaraComponent*                      MarkNiagaraComp;                                   // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DirectionNiagaraComp;                              // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      AuraNiagaraComp;                                   // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ConditionNiagaraComp;                              // 0x01A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFldEnemySkillReactionParam            SkillReaction;                                     // 0x01A8(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x2];                                      // 0x01AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EFldEnemyState                                State;                                             // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFldEnemyState                                NextState;                                         // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldEnemyEffectParam                   CurrentMarkEffectParam;                            // 0x01B8(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   CurrentConditionEffectParam;                       // 0x01D0(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LoiterPoints;                                      // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFldPlayerHolder                       TrackingTarget;                                    // 0x01F8(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0210(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVanish;                                           // 0x0211(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModalMenu;                                        // 0x0212(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleMenu;                                         // 0x0213(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFldEnemyDataAsset*                     EnemyData;                                         // 0x0218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFldEnemyFootprintDA*                   FootprintDA;                                       // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdelAnim;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      DamageAnim;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      RunAnim;                                           // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      WalkAnim;                                          // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AttackAnim;                                        // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FindAnim;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SearchAnim;                                        // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      VanishAnim;                                        // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ArrivalAnim;                                       // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      WinceAnim;                                         // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      WinceIdleAnim;                                     // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   AuraEffect;                                        // 0x0280(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   ExclamationEffect;                                 // 0x0298(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   QuestionEffect;                                    // 0x02B0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   SweatEffect;                                       // 0x02C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   VanishEffect;                                      // 0x02E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   ArrivalEffect;                                     // 0x02F8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   AngerEffect;                                       // 0x0310(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   ConfusionEffect;                                   // 0x0328(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   FearEffect;                                        // 0x0340(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemyEffectParam                   UpsetEffect;                                       // 0x0358(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x30];                                     // 0x0370(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyNormalComp">();
	}
	static class UFldEnemyNormalComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyNormalComp>();
	}
};
static_assert(alignof(UFldEnemyNormalComp) == 0x000010, "Wrong alignment on UFldEnemyNormalComp");
static_assert(sizeof(UFldEnemyNormalComp) == 0x0003A0, "Wrong size on UFldEnemyNormalComp");
static_assert(offsetof(UFldEnemyNormalComp, MarkNiagaraComp) == 0x000188, "Member 'UFldEnemyNormalComp::MarkNiagaraComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, DirectionNiagaraComp) == 0x000190, "Member 'UFldEnemyNormalComp::DirectionNiagaraComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, AuraNiagaraComp) == 0x000198, "Member 'UFldEnemyNormalComp::AuraNiagaraComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, ConditionNiagaraComp) == 0x0001A0, "Member 'UFldEnemyNormalComp::ConditionNiagaraComp' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, SkillReaction) == 0x0001A8, "Member 'UFldEnemyNormalComp::SkillReaction' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, State) == 0x0001AC, "Member 'UFldEnemyNormalComp::State' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, NextState) == 0x0001B0, "Member 'UFldEnemyNormalComp::NextState' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, CurrentMarkEffectParam) == 0x0001B8, "Member 'UFldEnemyNormalComp::CurrentMarkEffectParam' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, CurrentConditionEffectParam) == 0x0001D0, "Member 'UFldEnemyNormalComp::CurrentConditionEffectParam' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, LoiterPoints) == 0x0001E8, "Member 'UFldEnemyNormalComp::LoiterPoints' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, TrackingTarget) == 0x0001F8, "Member 'UFldEnemyNormalComp::TrackingTarget' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, bIsDead) == 0x000210, "Member 'UFldEnemyNormalComp::bIsDead' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, bVanish) == 0x000211, "Member 'UFldEnemyNormalComp::bVanish' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, bModalMenu) == 0x000212, "Member 'UFldEnemyNormalComp::bModalMenu' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, bIdleMenu) == 0x000213, "Member 'UFldEnemyNormalComp::bIdleMenu' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, EnemyData) == 0x000218, "Member 'UFldEnemyNormalComp::EnemyData' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, FootprintDA) == 0x000220, "Member 'UFldEnemyNormalComp::FootprintDA' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, IdelAnim) == 0x000228, "Member 'UFldEnemyNormalComp::IdelAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, DamageAnim) == 0x000230, "Member 'UFldEnemyNormalComp::DamageAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, RunAnim) == 0x000238, "Member 'UFldEnemyNormalComp::RunAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, WalkAnim) == 0x000240, "Member 'UFldEnemyNormalComp::WalkAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, AttackAnim) == 0x000248, "Member 'UFldEnemyNormalComp::AttackAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, FindAnim) == 0x000250, "Member 'UFldEnemyNormalComp::FindAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, SearchAnim) == 0x000258, "Member 'UFldEnemyNormalComp::SearchAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, VanishAnim) == 0x000260, "Member 'UFldEnemyNormalComp::VanishAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, ArrivalAnim) == 0x000268, "Member 'UFldEnemyNormalComp::ArrivalAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, WinceAnim) == 0x000270, "Member 'UFldEnemyNormalComp::WinceAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, WinceIdleAnim) == 0x000278, "Member 'UFldEnemyNormalComp::WinceIdleAnim' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, AuraEffect) == 0x000280, "Member 'UFldEnemyNormalComp::AuraEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, ExclamationEffect) == 0x000298, "Member 'UFldEnemyNormalComp::ExclamationEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, QuestionEffect) == 0x0002B0, "Member 'UFldEnemyNormalComp::QuestionEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, SweatEffect) == 0x0002C8, "Member 'UFldEnemyNormalComp::SweatEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, VanishEffect) == 0x0002E0, "Member 'UFldEnemyNormalComp::VanishEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, ArrivalEffect) == 0x0002F8, "Member 'UFldEnemyNormalComp::ArrivalEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, AngerEffect) == 0x000310, "Member 'UFldEnemyNormalComp::AngerEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, ConfusionEffect) == 0x000328, "Member 'UFldEnemyNormalComp::ConfusionEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, FearEffect) == 0x000340, "Member 'UFldEnemyNormalComp::FearEffect' has a wrong offset!");
static_assert(offsetof(UFldEnemyNormalComp, UpsetEffect) == 0x000358, "Member 'UFldEnemyNormalComp::UpsetEffect' has a wrong offset!");

// Class xrd777.FldEnemyDataAsset
// 0x03A0 (0x03D0 - 0x0030)
class UFldEnemyDataAsset final : public UDataAsset
{
public:
	float                                         ScaleMax;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScaleStep;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldEnemyNormalParam                   Normal;                                            // 0x0040(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyConditionAngerParam           Anger;                                             // 0x00D8(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyConditionConfusionParam       Confusion;                                         // 0x0168(0x00A0)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyConditionFearParam            Fear;                                              // 0x0208(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyNormalParam                   Upset;                                             // 0x02A0(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyRareParam                     Rare;                                              // 0x0338(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FFldEnemyReaperParam                   Death;                                             // 0x0398(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFldEnemySkillReaction                 SkillReaction;                                     // 0x03C8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyDataAsset">();
	}
	static class UFldEnemyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyDataAsset>();
	}
};
static_assert(alignof(UFldEnemyDataAsset) == 0x000008, "Wrong alignment on UFldEnemyDataAsset");
static_assert(sizeof(UFldEnemyDataAsset) == 0x0003D0, "Wrong size on UFldEnemyDataAsset");
static_assert(offsetof(UFldEnemyDataAsset, ScaleMax) == 0x000030, "Member 'UFldEnemyDataAsset::ScaleMax' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, ScaleMin) == 0x000034, "Member 'UFldEnemyDataAsset::ScaleMin' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, ScaleStep) == 0x000038, "Member 'UFldEnemyDataAsset::ScaleStep' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Normal) == 0x000040, "Member 'UFldEnemyDataAsset::Normal' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Anger) == 0x0000D8, "Member 'UFldEnemyDataAsset::Anger' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Confusion) == 0x000168, "Member 'UFldEnemyDataAsset::Confusion' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Fear) == 0x000208, "Member 'UFldEnemyDataAsset::Fear' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Upset) == 0x0002A0, "Member 'UFldEnemyDataAsset::Upset' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Rare) == 0x000338, "Member 'UFldEnemyDataAsset::Rare' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, Death) == 0x000398, "Member 'UFldEnemyDataAsset::Death' has a wrong offset!");
static_assert(offsetof(UFldEnemyDataAsset, SkillReaction) == 0x0003C8, "Member 'UFldEnemyDataAsset::SkillReaction' has a wrong offset!");

// Class xrd777.FldEnemyFootprintDA
// 0x0020 (0x0050 - 0x0030)
class UFldEnemyFootprintDA final : public UDataAsset
{
public:
	TArray<struct FFldEnemyFootprintAsset>        Assets;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Span;                                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDelay;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyFootprintDA">();
	}
	static class UFldEnemyFootprintDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyFootprintDA>();
	}
};
static_assert(alignof(UFldEnemyFootprintDA) == 0x000008, "Wrong alignment on UFldEnemyFootprintDA");
static_assert(sizeof(UFldEnemyFootprintDA) == 0x000050, "Wrong size on UFldEnemyFootprintDA");
static_assert(offsetof(UFldEnemyFootprintDA, Assets) == 0x000030, "Member 'UFldEnemyFootprintDA::Assets' has a wrong offset!");
static_assert(offsetof(UFldEnemyFootprintDA, Span) == 0x000040, "Member 'UFldEnemyFootprintDA::Span' has a wrong offset!");
static_assert(offsetof(UFldEnemyFootprintDA, FadeDelay) == 0x000044, "Member 'UFldEnemyFootprintDA::FadeDelay' has a wrong offset!");
static_assert(offsetof(UFldEnemyFootprintDA, FadeDuration) == 0x000048, "Member 'UFldEnemyFootprintDA::FadeDuration' has a wrong offset!");

// Class xrd777.FldEnemyUniqueComp
// 0x0000 (0x0190 - 0x0190)
class UFldEnemyUniqueComp final : public UFldEnemyComp
{
public:
	EFldEnemyState                                State;                                             // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldEnemyState                                NextState;                                         // 0x018C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldEnemyUniqueComp">();
	}
	static class UFldEnemyUniqueComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldEnemyUniqueComp>();
	}
};
static_assert(alignof(UFldEnemyUniqueComp) == 0x000010, "Wrong alignment on UFldEnemyUniqueComp");
static_assert(sizeof(UFldEnemyUniqueComp) == 0x000190, "Wrong size on UFldEnemyUniqueComp");
static_assert(offsetof(UFldEnemyUniqueComp, State) == 0x000188, "Member 'UFldEnemyUniqueComp::State' has a wrong offset!");
static_assert(offsetof(UFldEnemyUniqueComp, NextState) == 0x00018C, "Member 'UFldEnemyUniqueComp::NextState' has a wrong offset!");

// Class xrd777.UIMiscSpecialKeyhelp
// 0x0430 (0x0458 - 0x0028)
class UUIMiscSpecialKeyhelp final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pSpecialKeyHelpSpr;                              // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pSpecialKeyHelpTextSpr;                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pDataTable;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x3D8];                                     // 0x0080(0x03D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscSpecialKeyhelp">();
	}
	static class UUIMiscSpecialKeyhelp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiscSpecialKeyhelp>();
	}
};
static_assert(alignof(UUIMiscSpecialKeyhelp) == 0x000008, "Wrong alignment on UUIMiscSpecialKeyhelp");
static_assert(sizeof(UUIMiscSpecialKeyhelp) == 0x000458, "Wrong size on UUIMiscSpecialKeyhelp");
static_assert(offsetof(UUIMiscSpecialKeyhelp, M_pLoader) == 0x000060, "Member 'UUIMiscSpecialKeyhelp::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUIMiscSpecialKeyhelp, M_pSpecialKeyHelpSpr) == 0x000068, "Member 'UUIMiscSpecialKeyhelp::M_pSpecialKeyHelpSpr' has a wrong offset!");
static_assert(offsetof(UUIMiscSpecialKeyhelp, M_pSpecialKeyHelpTextSpr) == 0x000070, "Member 'UUIMiscSpecialKeyhelp::M_pSpecialKeyHelpTextSpr' has a wrong offset!");
static_assert(offsetof(UUIMiscSpecialKeyhelp, M_pDataTable) == 0x000078, "Member 'UUIMiscSpecialKeyhelp::M_pDataTable' has a wrong offset!");

// Class xrd777.FldFieldEventActor
// 0x0078 (0x02F8 - 0x0280)
class AFldFieldEventActor final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharacterComp*                      MChgHeroComp_;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UAppCharacterComp*>         MChgPartnerComps_;                                 // 0x02A8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldFieldEventActor">();
	}
	static class AFldFieldEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldFieldEventActor>();
	}
};
static_assert(alignof(AFldFieldEventActor) == 0x000008, "Wrong alignment on AFldFieldEventActor");
static_assert(sizeof(AFldFieldEventActor) == 0x0002F8, "Wrong size on AFldFieldEventActor");
static_assert(offsetof(AFldFieldEventActor, MChgHeroComp_) == 0x0002A0, "Member 'AFldFieldEventActor::MChgHeroComp_' has a wrong offset!");
static_assert(offsetof(AFldFieldEventActor, MChgPartnerComps_) == 0x0002A8, "Member 'AFldFieldEventActor::MChgPartnerComps_' has a wrong offset!");

// Class xrd777.FldFollowerController
// 0x0000 (0x0328 - 0x0328)
class AFldFollowerController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldFollowerController">();
	}
	static class AFldFollowerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldFollowerController>();
	}
};
static_assert(alignof(AFldFollowerController) == 0x000008, "Wrong alignment on AFldFollowerController");
static_assert(sizeof(AFldFollowerController) == 0x000328, "Wrong size on AFldFollowerController");

// Class xrd777.FldFollowerPointComp
// 0x0000 (0x0200 - 0x0200)
class UFldFollowerPointComp final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldFollowerPointComp">();
	}
	static class UFldFollowerPointComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldFollowerPointComp>();
	}
};
static_assert(alignof(UFldFollowerPointComp) == 0x000010, "Wrong alignment on UFldFollowerPointComp");
static_assert(sizeof(UFldFollowerPointComp) == 0x000200, "Wrong size on UFldFollowerPointComp");

// Class xrd777.ModelCaptureUpdater
// 0x0040 (0x02B8 - 0x0278)
class AModelCaptureUpdater : public AAppActor
{
public:
	class APreviewWorldUpdater*                   PreviewWorldUpdater_;                              // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor_;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           LightSource_;                                      // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                BlueprintClass_;                                   // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader_;                                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetTargetActor(class AActor* AActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelCaptureUpdater">();
	}
	static class AModelCaptureUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModelCaptureUpdater>();
	}
};
static_assert(alignof(AModelCaptureUpdater) == 0x000008, "Wrong alignment on AModelCaptureUpdater");
static_assert(sizeof(AModelCaptureUpdater) == 0x0002B8, "Wrong size on AModelCaptureUpdater");
static_assert(offsetof(AModelCaptureUpdater, PreviewWorldUpdater_) == 0x000278, "Member 'AModelCaptureUpdater::PreviewWorldUpdater_' has a wrong offset!");
static_assert(offsetof(AModelCaptureUpdater, TargetActor_) == 0x000280, "Member 'AModelCaptureUpdater::TargetActor_' has a wrong offset!");
static_assert(offsetof(AModelCaptureUpdater, LightSource_) == 0x000288, "Member 'AModelCaptureUpdater::LightSource_' has a wrong offset!");
static_assert(offsetof(AModelCaptureUpdater, BlueprintClass_) == 0x000298, "Member 'AModelCaptureUpdater::BlueprintClass_' has a wrong offset!");
static_assert(offsetof(AModelCaptureUpdater, Loader_) == 0x0002A0, "Member 'AModelCaptureUpdater::Loader_' has a wrong offset!");

// Class xrd777.FldSaveCallField
// 0x0000 (0x0028 - 0x0028)
class UFldSaveCallField final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldSaveCallField">();
	}
	static class UFldSaveCallField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldSaveCallField>();
	}
};
static_assert(alignof(UFldSaveCallField) == 0x000008, "Wrong alignment on UFldSaveCallField");
static_assert(sizeof(UFldSaveCallField) == 0x000028, "Wrong size on UFldSaveCallField");

// Class xrd777.FldHitActor
// 0x0058 (0x03A8 - 0x0350)
class AFldHitActor : public AFldHitCore
{
public:
	int32                                         MMajorID_;                                         // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MMinorID_;                                         // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldHitType                                   MType_;                                            // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MNameIndex_;                                       // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldHitActorIconType                          MIconType_;                                        // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldHitActorChgIconParam>       MChangeIconParam_;                                 // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   MReadedFlagName_;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MFloorIndex_;                                      // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MOffFlagName_;                                     // 0x0384(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MExecutedFlagName_;                                // 0x038C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MIgnoreFlagName_;                                  // 0x0394(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MIconActor_;                                       // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitActor">();
	}
	static class AFldHitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitActor>();
	}
};
static_assert(alignof(AFldHitActor) == 0x000008, "Wrong alignment on AFldHitActor");
static_assert(sizeof(AFldHitActor) == 0x0003A8, "Wrong size on AFldHitActor");
static_assert(offsetof(AFldHitActor, MMajorID_) == 0x000350, "Member 'AFldHitActor::MMajorID_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MMinorID_) == 0x000354, "Member 'AFldHitActor::MMinorID_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MType_) == 0x000358, "Member 'AFldHitActor::MType_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MNameIndex_) == 0x00035C, "Member 'AFldHitActor::MNameIndex_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MIconType_) == 0x000360, "Member 'AFldHitActor::MIconType_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MChangeIconParam_) == 0x000368, "Member 'AFldHitActor::MChangeIconParam_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MReadedFlagName_) == 0x000378, "Member 'AFldHitActor::MReadedFlagName_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MFloorIndex_) == 0x000380, "Member 'AFldHitActor::MFloorIndex_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MOffFlagName_) == 0x000384, "Member 'AFldHitActor::MOffFlagName_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MExecutedFlagName_) == 0x00038C, "Member 'AFldHitActor::MExecutedFlagName_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MIgnoreFlagName_) == 0x000394, "Member 'AFldHitActor::MIgnoreFlagName_' has a wrong offset!");
static_assert(offsetof(AFldHitActor, MIconActor_) == 0x0003A0, "Member 'AFldHitActor::MIconActor_' has a wrong offset!");

// Class xrd777.FldHitActorBOX
// 0x0000 (0x03A8 - 0x03A8)
class AFldHitActorBOX final : public AFldHitActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitActorBOX">();
	}
	static class AFldHitActorBOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitActorBOX>();
	}
};
static_assert(alignof(AFldHitActorBOX) == 0x000008, "Wrong alignment on AFldHitActorBOX");
static_assert(sizeof(AFldHitActorBOX) == 0x0003A8, "Wrong size on AFldHitActorBOX");

// Class xrd777.OtHUD
// 0x0000 (0x0310 - 0x0310)
class AOtHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OtHUD">();
	}
	static class AOtHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOtHUD>();
	}
};
static_assert(alignof(AOtHUD) == 0x000008, "Wrong alignment on AOtHUD");
static_assert(sizeof(AOtHUD) == 0x000310, "Wrong size on AOtHUD");

// Class xrd777.FldHitActorCAPSULE
// 0x0000 (0x03A8 - 0x03A8)
class AFldHitActorCAPSULE final : public AFldHitActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitActorCAPSULE">();
	}
	static class AFldHitActorCAPSULE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitActorCAPSULE>();
	}
};
static_assert(alignof(AFldHitActorCAPSULE) == 0x000008, "Wrong alignment on AFldHitActorCAPSULE");
static_assert(sizeof(AFldHitActorCAPSULE) == 0x0003A8, "Wrong size on AFldHitActorCAPSULE");

// Class xrd777.SkillPowerUpDataAsset
// 0x0010 (0x0040 - 0x0030)
class USkillPowerUpDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSkillPowerUpItem>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillPowerUpDataAsset">();
	}
	static class USkillPowerUpDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillPowerUpDataAsset>();
	}
};
static_assert(alignof(USkillPowerUpDataAsset) == 0x000008, "Wrong alignment on USkillPowerUpDataAsset");
static_assert(sizeof(USkillPowerUpDataAsset) == 0x000040, "Wrong size on USkillPowerUpDataAsset");
static_assert(offsetof(USkillPowerUpDataAsset, Data) == 0x000030, "Member 'USkillPowerUpDataAsset::Data' has a wrong offset!");

// Class xrd777.FldHitActorEachPlayer
// 0x0010 (0x03B8 - 0x03A8)
class AFldHitActorEachPlayer final : public AFldHitActor
{
public:
	TArray<struct FFldHitActorEachPlayerProc>     MProcList_;                                        // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitActorEachPlayer">();
	}
	static class AFldHitActorEachPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitActorEachPlayer>();
	}
};
static_assert(alignof(AFldHitActorEachPlayer) == 0x000008, "Wrong alignment on AFldHitActorEachPlayer");
static_assert(sizeof(AFldHitActorEachPlayer) == 0x0003B8, "Wrong size on AFldHitActorEachPlayer");
static_assert(offsetof(AFldHitActorEachPlayer, MProcList_) == 0x0003A8, "Member 'AFldHitActorEachPlayer::MProcList_' has a wrong offset!");

// Class xrd777.FldHitCharaIdleBehaviorComp
// 0x0048 (0x0110 - 0x00C8)
class UFldHitCharaIdleBehaviorComp final : public UFldLocalActorComp
{
public:
	float                                         MIdleMinTime_;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MIdleMaxTime_;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookMinTime_;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookMaxTime_;                                     // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSideMinTime_;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSideMaxTime_;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MInterpSpeed_;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        MFlag_;                                            // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldNpcComp*                            MNpcComp_;                                         // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLookAt_;                                        // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MLookTimer_;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MLookEndTime_;                                     // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MLookBaseLocation_;                                // 0x00FC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MLookYawDir_;                                      // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MLookCount_;                                       // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitCharaIdleBehaviorComp">();
	}
	static class UFldHitCharaIdleBehaviorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldHitCharaIdleBehaviorComp>();
	}
};
static_assert(alignof(UFldHitCharaIdleBehaviorComp) == 0x000008, "Wrong alignment on UFldHitCharaIdleBehaviorComp");
static_assert(sizeof(UFldHitCharaIdleBehaviorComp) == 0x000110, "Wrong size on UFldHitCharaIdleBehaviorComp");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MIdleMinTime_) == 0x0000C8, "Member 'UFldHitCharaIdleBehaviorComp::MIdleMinTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MIdleMaxTime_) == 0x0000CC, "Member 'UFldHitCharaIdleBehaviorComp::MIdleMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookMinTime_) == 0x0000D0, "Member 'UFldHitCharaIdleBehaviorComp::MLookMinTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookMaxTime_) == 0x0000D4, "Member 'UFldHitCharaIdleBehaviorComp::MLookMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MSideMinTime_) == 0x0000D8, "Member 'UFldHitCharaIdleBehaviorComp::MSideMinTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MSideMaxTime_) == 0x0000DC, "Member 'UFldHitCharaIdleBehaviorComp::MSideMaxTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MInterpSpeed_) == 0x0000E0, "Member 'UFldHitCharaIdleBehaviorComp::MInterpSpeed_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MFlag_) == 0x0000E4, "Member 'UFldHitCharaIdleBehaviorComp::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MNpcComp_) == 0x0000E8, "Member 'UFldHitCharaIdleBehaviorComp::MNpcComp_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, bIsLookAt_) == 0x0000F0, "Member 'UFldHitCharaIdleBehaviorComp::bIsLookAt_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookTimer_) == 0x0000F4, "Member 'UFldHitCharaIdleBehaviorComp::MLookTimer_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookEndTime_) == 0x0000F8, "Member 'UFldHitCharaIdleBehaviorComp::MLookEndTime_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookBaseLocation_) == 0x0000FC, "Member 'UFldHitCharaIdleBehaviorComp::MLookBaseLocation_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookYawDir_) == 0x000108, "Member 'UFldHitCharaIdleBehaviorComp::MLookYawDir_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleBehaviorComp, MLookCount_) == 0x00010C, "Member 'UFldHitCharaIdleBehaviorComp::MLookCount_' has a wrong offset!");

// Class xrd777.FldHitCharaIdleTalkComp
// 0x0030 (0x00F8 - 0x00C8)
class UFldHitCharaIdleTalkComp final : public UFldLocalActorComp
{
public:
	struct FFldHitCitTimeParam                    MMotionParam_;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFldHitCitLookParam                    MLookParam_;                                       // 0x00D0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLookAtFlag_;                                      // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MFlag_;                                            // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFldHitCharaIdleTalkCharacterParam> MParamArray_;                                      // 0x00E8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitCharaIdleTalkComp">();
	}
	static class UFldHitCharaIdleTalkComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldHitCharaIdleTalkComp>();
	}
};
static_assert(alignof(UFldHitCharaIdleTalkComp) == 0x000008, "Wrong alignment on UFldHitCharaIdleTalkComp");
static_assert(sizeof(UFldHitCharaIdleTalkComp) == 0x0000F8, "Wrong size on UFldHitCharaIdleTalkComp");
static_assert(offsetof(UFldHitCharaIdleTalkComp, MMotionParam_) == 0x0000C8, "Member 'UFldHitCharaIdleTalkComp::MMotionParam_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleTalkComp, MLookParam_) == 0x0000D0, "Member 'UFldHitCharaIdleTalkComp::MLookParam_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleTalkComp, bLookAtFlag_) == 0x0000E0, "Member 'UFldHitCharaIdleTalkComp::bLookAtFlag_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleTalkComp, MFlag_) == 0x0000E4, "Member 'UFldHitCharaIdleTalkComp::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldHitCharaIdleTalkComp, MParamArray_) == 0x0000E8, "Member 'UFldHitCharaIdleTalkComp::MParamArray_' has a wrong offset!");

// Class xrd777.PauseUserWidget
// 0x0008 (0x0268 - 0x0260)
class UPauseUserWidget final : public UUserWidget
{
public:
	bool                                          bTickEvenWhenPaused;                               // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetTickableWhenPaused();
	void SetTickableWhenPaused(bool bTickableWhenPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseUserWidget">();
	}
	static class UPauseUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseUserWidget>();
	}
};
static_assert(alignof(UPauseUserWidget) == 0x000008, "Wrong alignment on UPauseUserWidget");
static_assert(sizeof(UPauseUserWidget) == 0x000268, "Wrong size on UPauseUserWidget");
static_assert(offsetof(UPauseUserWidget, bTickEvenWhenPaused) == 0x000260, "Member 'UPauseUserWidget::bTickEvenWhenPaused' has a wrong offset!");

// Class xrd777.FldHitPartner
// 0x0058 (0x03A8 - 0x0350)
class AFldHitPartner final : public AFldHitCore
{
public:
	TMap<int32, struct FFldHitPartnerProcs>       Procs;                                             // 0x0350(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         CharId;                                            // 0x03A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTalkFirst;                                        // 0x03A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A5[0x3];                                      // 0x03A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitPartner">();
	}
	static class AFldHitPartner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitPartner>();
	}
};
static_assert(alignof(AFldHitPartner) == 0x000008, "Wrong alignment on AFldHitPartner");
static_assert(sizeof(AFldHitPartner) == 0x0003A8, "Wrong size on AFldHitPartner");
static_assert(offsetof(AFldHitPartner, Procs) == 0x000350, "Member 'AFldHitPartner::Procs' has a wrong offset!");
static_assert(offsetof(AFldHitPartner, CharId) == 0x0003A0, "Member 'AFldHitPartner::CharId' has a wrong offset!");
static_assert(offsetof(AFldHitPartner, bTalkFirst) == 0x0003A4, "Member 'AFldHitPartner::bTalkFirst' has a wrong offset!");

// Class xrd777.ModelCaptureLayoutDataAsset
// 0x0030 (0x0060 - 0x0030)
class UModelCaptureLayoutDataAsset final : public UAppDataAsset
{
public:
	struct FModelCaptureEnvironment               Environment;                                       // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FModelCaptureLayoutItem>        Data;                                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelCaptureLayoutDataAsset">();
	}
	static class UModelCaptureLayoutDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelCaptureLayoutDataAsset>();
	}
};
static_assert(alignof(UModelCaptureLayoutDataAsset) == 0x000008, "Wrong alignment on UModelCaptureLayoutDataAsset");
static_assert(sizeof(UModelCaptureLayoutDataAsset) == 0x000060, "Wrong size on UModelCaptureLayoutDataAsset");
static_assert(offsetof(UModelCaptureLayoutDataAsset, Environment) == 0x000030, "Member 'UModelCaptureLayoutDataAsset::Environment' has a wrong offset!");
static_assert(offsetof(UModelCaptureLayoutDataAsset, Data) == 0x000050, "Member 'UModelCaptureLayoutDataAsset::Data' has a wrong offset!");

// Class xrd777.FldHitSoundCore
// 0x0010 (0x02B8 - 0x02A8)
class AFldHitSoundCore : public AFldAtomSound
{
public:
	class UShapeComponent*                        HitComp;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MFlag_;                                            // 0x02B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MTimer_;                                           // 0x02B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSoundCore">();
	}
	static class AFldHitSoundCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSoundCore>();
	}
};
static_assert(alignof(AFldHitSoundCore) == 0x000008, "Wrong alignment on AFldHitSoundCore");
static_assert(sizeof(AFldHitSoundCore) == 0x0002B8, "Wrong size on AFldHitSoundCore");
static_assert(offsetof(AFldHitSoundCore, HitComp) == 0x0002A8, "Member 'AFldHitSoundCore::HitComp' has a wrong offset!");
static_assert(offsetof(AFldHitSoundCore, MFlag_) == 0x0002B0, "Member 'AFldHitSoundCore::MFlag_' has a wrong offset!");
static_assert(offsetof(AFldHitSoundCore, MTimer_) == 0x0002B4, "Member 'AFldHitSoundCore::MTimer_' has a wrong offset!");

// Class xrd777.FldHitSound_BOX
// 0x0000 (0x02B8 - 0x02B8)
class AFldHitSound_BOX final : public AFldHitSoundCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSound_BOX">();
	}
	static class AFldHitSound_BOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSound_BOX>();
	}
};
static_assert(alignof(AFldHitSound_BOX) == 0x000008, "Wrong alignment on AFldHitSound_BOX");
static_assert(sizeof(AFldHitSound_BOX) == 0x0002B8, "Wrong size on AFldHitSound_BOX");

// Class xrd777.FldHitSound_CIRCLE
// 0x0000 (0x02B8 - 0x02B8)
class AFldHitSound_CIRCLE final : public AFldHitSoundCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSound_CIRCLE">();
	}
	static class AFldHitSound_CIRCLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSound_CIRCLE>();
	}
};
static_assert(alignof(AFldHitSound_CIRCLE) == 0x000008, "Wrong alignment on AFldHitSound_CIRCLE");
static_assert(sizeof(AFldHitSound_CIRCLE) == 0x0002B8, "Wrong size on AFldHitSound_CIRCLE");

// Class xrd777.PlatformFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetFPS();
	static EPlatformName Platform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformFunctionLibrary">();
	}
	static class UPlatformFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformFunctionLibrary>();
	}
};
static_assert(alignof(UPlatformFunctionLibrary) == 0x000008, "Wrong alignment on UPlatformFunctionLibrary");
static_assert(sizeof(UPlatformFunctionLibrary) == 0x000028, "Wrong size on UPlatformFunctionLibrary");

// Class xrd777.FldHitSoundSnapshotCore
// 0x0020 (0x02A0 - 0x0280)
class AFldHitSoundSnapshotCore : public AFldLocalActor
{
public:
	bool                                          MOffInEvent_;                                      // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MSnapshotName_;                                    // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        HitComp;                                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSoundSnapshotCore">();
	}
	static class AFldHitSoundSnapshotCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSoundSnapshotCore>();
	}
};
static_assert(alignof(AFldHitSoundSnapshotCore) == 0x000008, "Wrong alignment on AFldHitSoundSnapshotCore");
static_assert(sizeof(AFldHitSoundSnapshotCore) == 0x0002A0, "Wrong size on AFldHitSoundSnapshotCore");
static_assert(offsetof(AFldHitSoundSnapshotCore, MOffInEvent_) == 0x000280, "Member 'AFldHitSoundSnapshotCore::MOffInEvent_' has a wrong offset!");
static_assert(offsetof(AFldHitSoundSnapshotCore, MSnapshotName_) == 0x000288, "Member 'AFldHitSoundSnapshotCore::MSnapshotName_' has a wrong offset!");
static_assert(offsetof(AFldHitSoundSnapshotCore, HitComp) == 0x000298, "Member 'AFldHitSoundSnapshotCore::HitComp' has a wrong offset!");

// Class xrd777.HiddenArbeitDataAsset
// 0x0010 (0x0040 - 0x0030)
class UHiddenArbeitDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FHiddenArbeitData>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HiddenArbeitDataAsset">();
	}
	static class UHiddenArbeitDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHiddenArbeitDataAsset>();
	}
};
static_assert(alignof(UHiddenArbeitDataAsset) == 0x000008, "Wrong alignment on UHiddenArbeitDataAsset");
static_assert(sizeof(UHiddenArbeitDataAsset) == 0x000040, "Wrong size on UHiddenArbeitDataAsset");
static_assert(offsetof(UHiddenArbeitDataAsset, Data) == 0x000030, "Member 'UHiddenArbeitDataAsset::Data' has a wrong offset!");

// Class xrd777.FldHitSoundSnapshot_BOX
// 0x0000 (0x02A0 - 0x02A0)
class AFldHitSoundSnapshot_BOX final : public AFldHitSoundSnapshotCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSoundSnapshot_BOX">();
	}
	static class AFldHitSoundSnapshot_BOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSoundSnapshot_BOX>();
	}
};
static_assert(alignof(AFldHitSoundSnapshot_BOX) == 0x000008, "Wrong alignment on AFldHitSoundSnapshot_BOX");
static_assert(sizeof(AFldHitSoundSnapshot_BOX) == 0x0002A0, "Wrong size on AFldHitSoundSnapshot_BOX");

// Class xrd777.FldHitSoundSnapshot_CIRCLE
// 0x0000 (0x02A0 - 0x02A0)
class AFldHitSoundSnapshot_CIRCLE final : public AFldHitSoundSnapshotCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldHitSoundSnapshot_CIRCLE">();
	}
	static class AFldHitSoundSnapshot_CIRCLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldHitSoundSnapshot_CIRCLE>();
	}
};
static_assert(alignof(AFldHitSoundSnapshot_CIRCLE) == 0x000008, "Wrong alignment on AFldHitSoundSnapshot_CIRCLE");
static_assert(sizeof(AFldHitSoundSnapshot_CIRCLE) == 0x0002A0, "Wrong size on AFldHitSoundSnapshot_CIRCLE");

// Class xrd777.FldInitScriptManager
// 0x0008 (0x02B8 - 0x02B0)
class AFldInitScriptManager final : public AFldScriptManagerCore
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldInitScriptManager">();
	}
	static class AFldInitScriptManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldInitScriptManager>();
	}
};
static_assert(alignof(AFldInitScriptManager) == 0x000008, "Wrong alignment on AFldInitScriptManager");
static_assert(sizeof(AFldInitScriptManager) == 0x0002B8, "Wrong size on AFldInitScriptManager");

// Class xrd777.QuestDisappearList
// 0x0030 (0x0070 - 0x0040)
class UQuestDisappearList final : public UUIScene
{
public:
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpQuest*                            Context_;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDisappearList">();
	}
	static class UQuestDisappearList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestDisappearList>();
	}
};
static_assert(alignof(UQuestDisappearList) == 0x000008, "Wrong alignment on UQuestDisappearList");
static_assert(sizeof(UQuestDisappearList) == 0x000070, "Wrong size on UQuestDisappearList");
static_assert(offsetof(UQuestDisappearList, Context_) == 0x000068, "Member 'UQuestDisappearList::Context_' has a wrong offset!");

// Class xrd777.FldKeyFreeAnnounceActor
// 0x0038 (0x02B8 - 0x0280)
class AFldKeyFreeAnnounceActor final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               MBfAsset_;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              MBmdAsset_;                                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldScriptActor*                        MScriptActor_;                                     // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldKeyFreeAnnounceActor">();
	}
	static class AFldKeyFreeAnnounceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldKeyFreeAnnounceActor>();
	}
};
static_assert(alignof(AFldKeyFreeAnnounceActor) == 0x000008, "Wrong alignment on AFldKeyFreeAnnounceActor");
static_assert(sizeof(AFldKeyFreeAnnounceActor) == 0x0002B8, "Wrong size on AFldKeyFreeAnnounceActor");
static_assert(offsetof(AFldKeyFreeAnnounceActor, MAssetLoader_) == 0x000298, "Member 'AFldKeyFreeAnnounceActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeAnnounceActor, MBfAsset_) == 0x0002A0, "Member 'AFldKeyFreeAnnounceActor::MBfAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeAnnounceActor, MBmdAsset_) == 0x0002A8, "Member 'AFldKeyFreeAnnounceActor::MBmdAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeAnnounceActor, MScriptActor_) == 0x0002B0, "Member 'AFldKeyFreeAnnounceActor::MScriptActor_' has a wrong offset!");

// Class xrd777.AddContentTableDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAddContentTableDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAddContentTable>               Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentTableDataAsset">();
	}
	static class UAddContentTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentTableDataAsset>();
	}
};
static_assert(alignof(UAddContentTableDataAsset) == 0x000008, "Wrong alignment on UAddContentTableDataAsset");
static_assert(sizeof(UAddContentTableDataAsset) == 0x000040, "Wrong size on UAddContentTableDataAsset");
static_assert(offsetof(UAddContentTableDataAsset, Data) == 0x000030, "Member 'UAddContentTableDataAsset::Data' has a wrong offset!");

// Class xrd777.FldKeyFreeEventActor
// 0x0050 (0x02D0 - 0x0280)
class AFldKeyFreeEventActor final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               MBfAsset_;                                         // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              MBmdAsset_;                                        // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               MAncBfAsset_;                                      // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              MAncBmdAsset_;                                     // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldScriptActor*                        MScriptActor_;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldKeyFreeEventActor">();
	}
	static class AFldKeyFreeEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldKeyFreeEventActor>();
	}
};
static_assert(alignof(AFldKeyFreeEventActor) == 0x000008, "Wrong alignment on AFldKeyFreeEventActor");
static_assert(sizeof(AFldKeyFreeEventActor) == 0x0002D0, "Wrong size on AFldKeyFreeEventActor");
static_assert(offsetof(AFldKeyFreeEventActor, MAssetLoader_) == 0x0002A0, "Member 'AFldKeyFreeEventActor::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeEventActor, MBfAsset_) == 0x0002A8, "Member 'AFldKeyFreeEventActor::MBfAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeEventActor, MBmdAsset_) == 0x0002B0, "Member 'AFldKeyFreeEventActor::MBmdAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeEventActor, MAncBfAsset_) == 0x0002B8, "Member 'AFldKeyFreeEventActor::MAncBfAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeEventActor, MAncBmdAsset_) == 0x0002C0, "Member 'AFldKeyFreeEventActor::MAncBmdAsset_' has a wrong offset!");
static_assert(offsetof(AFldKeyFreeEventActor, MScriptActor_) == 0x0002C8, "Member 'AFldKeyFreeEventActor::MScriptActor_' has a wrong offset!");

// Class xrd777.FldLevelLoaderMonitorActor
// 0x0028 (0x0248 - 0x0220)
class AFldLevelLoaderMonitorActor final : public AActor
{
public:
	int32                                         MUniqueId_;                                        // 0x0220(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldLevelLoaderType                           MType_;                                            // 0x0224(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MLevelAssetPath_;                                  // 0x0228(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MProcTimer_;                                       // 0x0240(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadLevelStreaming();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLevelLoaderMonitorActor">();
	}
	static class AFldLevelLoaderMonitorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLevelLoaderMonitorActor>();
	}
};
static_assert(alignof(AFldLevelLoaderMonitorActor) == 0x000008, "Wrong alignment on AFldLevelLoaderMonitorActor");
static_assert(sizeof(AFldLevelLoaderMonitorActor) == 0x000248, "Wrong size on AFldLevelLoaderMonitorActor");
static_assert(offsetof(AFldLevelLoaderMonitorActor, MUniqueId_) == 0x000220, "Member 'AFldLevelLoaderMonitorActor::MUniqueId_' has a wrong offset!");
static_assert(offsetof(AFldLevelLoaderMonitorActor, MType_) == 0x000224, "Member 'AFldLevelLoaderMonitorActor::MType_' has a wrong offset!");
static_assert(offsetof(AFldLevelLoaderMonitorActor, MLevelAssetPath_) == 0x000228, "Member 'AFldLevelLoaderMonitorActor::MLevelAssetPath_' has a wrong offset!");
static_assert(offsetof(AFldLevelLoaderMonitorActor, MProcTimer_) == 0x000240, "Member 'AFldLevelLoaderMonitorActor::MProcTimer_' has a wrong offset!");

// Class xrd777.FldLevelManager
// 0x00B0 (0x0330 - 0x0280)
class AFldLevelManager final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0xB0];                                     // 0x0280(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLevelManager">();
	}
	static class AFldLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLevelManager>();
	}
};
static_assert(alignof(AFldLevelManager) == 0x000008, "Wrong alignment on AFldLevelManager");
static_assert(sizeof(AFldLevelManager) == 0x000330, "Wrong size on AFldLevelManager");

// Class xrd777.FldLevelPoolManager
// 0x0030 (0x02B0 - 0x0280)
class AFldLevelPoolManager final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MLevelPaths_;                                      // 0x02A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLevelPoolManager">();
	}
	static class AFldLevelPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLevelPoolManager>();
	}
};
static_assert(alignof(AFldLevelPoolManager) == 0x000008, "Wrong alignment on AFldLevelPoolManager");
static_assert(sizeof(AFldLevelPoolManager) == 0x0002B0, "Wrong size on AFldLevelPoolManager");
static_assert(offsetof(AFldLevelPoolManager, MLevelPaths_) == 0x0002A0, "Member 'AFldLevelPoolManager::MLevelPaths_' has a wrong offset!");

// Class xrd777.UIConfiguration
// 0x0AE8 (0x0D88 - 0x02A0)
class AUIConfiguration final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x150];                                    // 0x02A0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UConfigBGMSelectDialog*                 ConfigBGMSelect;                                   // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfigBGMSelectDialog*                 ConfigBossBattleBGMSelect;                         // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConfigDungeonBGMSelectDialog*          ConfigDungeonBGMSelect;                            // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ConfigTable;                                       // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ConfigTableEx;                                     // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUISystemMsgActor*                      NetWaitDialog;                                     // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUIConfigurationDraw>       DrawActorSC;                                       // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIConfigurationDraw*                   DrawActor;                                         // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              PKeySpr;                                           // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGetUIParameter                        UiConfigurationUIP;                                // 0x0440(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x8B8];                                    // 0x04B8(0x08B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HelpLayoutData;                                    // 0x0D78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PParamLayoutDataConfigText;                        // 0x0D80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsWindowDraw();
	void OnBGMInAnimFinished();
	void OnBgmSetAnimFinished();
	void OnConfigCancel(bool InIsCancel);
	void OnConfigInAnimFinished();
	void OnDifficultCancel(bool InIsCancel);
	void OnDrawClosed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfiguration">();
	}
	static class AUIConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIConfiguration>();
	}
};
static_assert(alignof(AUIConfiguration) == 0x000008, "Wrong alignment on AUIConfiguration");
static_assert(sizeof(AUIConfiguration) == 0x000D88, "Wrong size on AUIConfiguration");
static_assert(offsetof(AUIConfiguration, ConfigBGMSelect) == 0x0003F0, "Member 'AUIConfiguration::ConfigBGMSelect' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, ConfigBossBattleBGMSelect) == 0x0003F8, "Member 'AUIConfiguration::ConfigBossBattleBGMSelect' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, ConfigDungeonBGMSelect) == 0x000400, "Member 'AUIConfiguration::ConfigDungeonBGMSelect' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, ConfigTable) == 0x000408, "Member 'AUIConfiguration::ConfigTable' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, ConfigTableEx) == 0x000410, "Member 'AUIConfiguration::ConfigTableEx' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, Loader) == 0x000418, "Member 'AUIConfiguration::Loader' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, NetWaitDialog) == 0x000420, "Member 'AUIConfiguration::NetWaitDialog' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, DrawActorSC) == 0x000428, "Member 'AUIConfiguration::DrawActorSC' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, DrawActor) == 0x000430, "Member 'AUIConfiguration::DrawActor' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, PKeySpr) == 0x000438, "Member 'AUIConfiguration::PKeySpr' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, UiConfigurationUIP) == 0x000440, "Member 'AUIConfiguration::UiConfigurationUIP' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, LayoutData) == 0x000D70, "Member 'AUIConfiguration::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, HelpLayoutData) == 0x000D78, "Member 'AUIConfiguration::HelpLayoutData' has a wrong offset!");
static_assert(offsetof(AUIConfiguration, PParamLayoutDataConfigText) == 0x000D80, "Member 'AUIConfiguration::PParamLayoutDataConfigText' has a wrong offset!");

// Class xrd777.FldLinkAnimHitBase
// 0x0028 (0x02A8 - 0x0280)
class AFldLinkAnimHitBase : public AFldLocalActor
{
public:
	class USceneComponent*                        RootComp_;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        HitComp_;                                          // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFldLinkAnimObj*>                MLinkObjectArray_;                                 // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MOneshotFlag_;                                     // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MFlag_;                                            // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimHitBase">();
	}
	static class AFldLinkAnimHitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLinkAnimHitBase>();
	}
};
static_assert(alignof(AFldLinkAnimHitBase) == 0x000008, "Wrong alignment on AFldLinkAnimHitBase");
static_assert(sizeof(AFldLinkAnimHitBase) == 0x0002A8, "Wrong size on AFldLinkAnimHitBase");
static_assert(offsetof(AFldLinkAnimHitBase, RootComp_) == 0x000280, "Member 'AFldLinkAnimHitBase::RootComp_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimHitBase, HitComp_) == 0x000288, "Member 'AFldLinkAnimHitBase::HitComp_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimHitBase, MLinkObjectArray_) == 0x000290, "Member 'AFldLinkAnimHitBase::MLinkObjectArray_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimHitBase, MOneshotFlag_) == 0x0002A0, "Member 'AFldLinkAnimHitBase::MOneshotFlag_' has a wrong offset!");
static_assert(offsetof(AFldLinkAnimHitBase, MFlag_) == 0x0002A4, "Member 'AFldLinkAnimHitBase::MFlag_' has a wrong offset!");

// Class xrd777.FldLinkAnimHit_BOX
// 0x0000 (0x02A8 - 0x02A8)
class AFldLinkAnimHit_BOX final : public AFldLinkAnimHitBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimHit_BOX">();
	}
	static class AFldLinkAnimHit_BOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLinkAnimHit_BOX>();
	}
};
static_assert(alignof(AFldLinkAnimHit_BOX) == 0x000008, "Wrong alignment on AFldLinkAnimHit_BOX");
static_assert(sizeof(AFldLinkAnimHit_BOX) == 0x0002A8, "Wrong size on AFldLinkAnimHit_BOX");

// Class xrd777.FldLinkAnimHit_CIRCLE
// 0x0000 (0x02A8 - 0x02A8)
class AFldLinkAnimHit_CIRCLE final : public AFldLinkAnimHitBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimHit_CIRCLE">();
	}
	static class AFldLinkAnimHit_CIRCLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldLinkAnimHit_CIRCLE>();
	}
};
static_assert(alignof(AFldLinkAnimHit_CIRCLE) == 0x000008, "Wrong alignment on AFldLinkAnimHit_CIRCLE");
static_assert(sizeof(AFldLinkAnimHit_CIRCLE) == 0x0002A8, "Wrong size on AFldLinkAnimHit_CIRCLE");

// Class xrd777.FldLinkAnimHitComp_BOX
// 0x0020 (0x04A0 - 0x0480)
class UFldLinkAnimHitComp_BOX final : public UBoxComponent
{
public:
	TArray<class FString>                         MLinkCompNameArray_;                               // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          MOneshotFlag_;                                     // 0x0488(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MFlag_;                                            // 0x048C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UChildActorComponent*>           MLinkChildArray_;                                  // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimHitComp_BOX">();
	}
	static class UFldLinkAnimHitComp_BOX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldLinkAnimHitComp_BOX>();
	}
};
static_assert(alignof(UFldLinkAnimHitComp_BOX) == 0x000010, "Wrong alignment on UFldLinkAnimHitComp_BOX");
static_assert(sizeof(UFldLinkAnimHitComp_BOX) == 0x0004A0, "Wrong size on UFldLinkAnimHitComp_BOX");
static_assert(offsetof(UFldLinkAnimHitComp_BOX, MLinkCompNameArray_) == 0x000478, "Member 'UFldLinkAnimHitComp_BOX::MLinkCompNameArray_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_BOX, MOneshotFlag_) == 0x000488, "Member 'UFldLinkAnimHitComp_BOX::MOneshotFlag_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_BOX, MFlag_) == 0x00048C, "Member 'UFldLinkAnimHitComp_BOX::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_BOX, MLinkChildArray_) == 0x000490, "Member 'UFldLinkAnimHitComp_BOX::MLinkChildArray_' has a wrong offset!");

// Class xrd777.WeaponItemListTable
// 0x0010 (0x0040 - 0x0030)
class UWeaponItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FWeaponItemList>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponItemListTable">();
	}
	static class UWeaponItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponItemListTable>();
	}
};
static_assert(alignof(UWeaponItemListTable) == 0x000008, "Wrong alignment on UWeaponItemListTable");
static_assert(sizeof(UWeaponItemListTable) == 0x000040, "Wrong size on UWeaponItemListTable");
static_assert(offsetof(UWeaponItemListTable, Data) == 0x000030, "Member 'UWeaponItemListTable::Data' has a wrong offset!");

// Class xrd777.FldLinkAnimHitComp_CIRCLE
// 0x0030 (0x04A0 - 0x0470)
class UFldLinkAnimHitComp_CIRCLE final : public USphereComponent
{
public:
	TArray<class FString>                         MLinkCompNameArray_;                               // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          MOneshotFlag_;                                     // 0x0480(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0x3];                                      // 0x0481(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MFlag_;                                            // 0x0484(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UChildActorComponent*>           MLinkChildArray_;                                  // 0x0488(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLinkAnimHitComp_CIRCLE">();
	}
	static class UFldLinkAnimHitComp_CIRCLE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldLinkAnimHitComp_CIRCLE>();
	}
};
static_assert(alignof(UFldLinkAnimHitComp_CIRCLE) == 0x000010, "Wrong alignment on UFldLinkAnimHitComp_CIRCLE");
static_assert(sizeof(UFldLinkAnimHitComp_CIRCLE) == 0x0004A0, "Wrong size on UFldLinkAnimHitComp_CIRCLE");
static_assert(offsetof(UFldLinkAnimHitComp_CIRCLE, MLinkCompNameArray_) == 0x000470, "Member 'UFldLinkAnimHitComp_CIRCLE::MLinkCompNameArray_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_CIRCLE, MOneshotFlag_) == 0x000480, "Member 'UFldLinkAnimHitComp_CIRCLE::MOneshotFlag_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_CIRCLE, MFlag_) == 0x000484, "Member 'UFldLinkAnimHitComp_CIRCLE::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldLinkAnimHitComp_CIRCLE, MLinkChildArray_) == 0x000488, "Member 'UFldLinkAnimHitComp_CIRCLE::MLinkChildArray_' has a wrong offset!");

// Class xrd777.FldLmapManager
// 0x0000 (0x0028 - 0x0028)
class UFldLmapManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldLmapManager">();
	}
	static class UFldLmapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldLmapManager>();
	}
};
static_assert(alignof(UFldLmapManager) == 0x000008, "Wrong alignment on UFldLmapManager");
static_assert(sizeof(UFldLmapManager) == 0x000028, "Wrong size on UFldLmapManager");

// Class xrd777.FldMailOrderScript
// 0x0000 (0x02B0 - 0x02B0)
class AFldMailOrderScript final : public AFldScriptManagerCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMailOrderScript">();
	}
	static class AFldMailOrderScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldMailOrderScript>();
	}
};
static_assert(alignof(AFldMailOrderScript) == 0x000008, "Wrong alignment on AFldMailOrderScript");
static_assert(sizeof(AFldMailOrderScript) == 0x0002B0, "Wrong size on AFldMailOrderScript");

// Class xrd777.SkillcardItemListTable
// 0x0010 (0x0040 - 0x0030)
class USkillcardItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FSkillcardItemList>             Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillcardItemListTable">();
	}
	static class USkillcardItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillcardItemListTable>();
	}
};
static_assert(alignof(USkillcardItemListTable) == 0x000008, "Wrong alignment on USkillcardItemListTable");
static_assert(sizeof(USkillcardItemListTable) == 0x000040, "Wrong size on USkillcardItemListTable");
static_assert(offsetof(USkillcardItemListTable, Data) == 0x000030, "Member 'USkillcardItemListTable::Data' has a wrong offset!");

// Class xrd777.FldManagerSubsystem
// 0x03D0 (0x0400 - 0x0030)
class UFldManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             MOnEventCallField_;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x78];                                      // 0x0040(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldLevelManager*                       MLevelManager_;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharacterComp*                      MPlayerComp_;                                      // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             MPlayerTransform;                                  // 0x00D0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class AFldOperator*                           MOparetator_;                                      // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldInitScriptManager*                  MInitScrManager_;                                  // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldKeyFreeAnnounceActor*               MKeyFreeAnnounceActor_;                            // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldKeyFreeEventActor*                  MKeyFreeEventActor_;                               // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldFieldEventActor*                    MFieldEventActor_;                                 // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppActor*                              MLargeMapActor_;                                   // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldSoundManager*                       MSoundManager_;                                    // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldMiniMapManager*                     MMiniMapManager_;                                  // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x158];                                    // 0x0170(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldDungeonMenuScript*                  MDungeonMenuScript_;                               // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldDailyMenuScript*                    MDailyMenuScript_;                                 // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUISaveLoad*                            MSaveMenu_;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIBackLog*                             MBackLogDisp_;                                     // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 MVoiceActionDisp_;                                 // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldHitCore*                            MKeyLockedActor_;                                  // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldAutoRecoverMenuScript*              MAutoRecoverMenuScript_;                           // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         MHiddenActorArray_;                                // 0x0300(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AFldMiscCharBaseReload*                 MCharBaseReload_;                                  // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EFldCmnProps, class AAppPropsCore*>      MCmnPropsActors_;                                  // 0x0318(0x0050)(NativeAccessSpecifierPrivate)
	class AFldMiscCameraShake*                    MCameraShake_;                                     // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MKeyHelpDelayTimer_;                               // 0x0370(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMoveFloorTimer_;                                  // 0x0374(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterBaseCore>         MDefaultPlayerClass_;                              // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterBaseCore>         MDungeonPlayerClass_;                              // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterBaseCore>         MDungeonPlayerClass_Astrea_;                       // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFldCameraBase>             MDefaultCameraClass_;                              // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFldCameraBase>             MDungeonCameraClass_;                              // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFldCameraBase>             MDngEntranceCameraClassAstrea_;                    // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFldCameraBase>             MDngFinalFloorCameraClassAstrea_;                  // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFldCamera>                 MTransCameraClass_;                                // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterBaseCore>         MFollowerClass_;                                   // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterBaseCore>         MFollowerKoromaruClass_;                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                MWorldContextObject_;                              // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFldMiscCharaBaseMove*                  MMoveActor_;                                       // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MCameraLock_;                                      // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldMiscCameraMove*                     MCameraMoveActor_;                                 // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFldHitCore*>                    MOverlapedHitArray_;                               // 0x03E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AAppActor*                              MDebugMenu_;                                       // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class AFldMiscCameraShake* GetFieldCameraShakeActor();
	static void SetFieldCameraShakeActor(class AFldMiscCameraShake* InActor);

	void ChangeFieldSubLevelDebug(int32 FieldMajorID, int32 FieldMinorID, int32 TotalDay, ECldTimeZone TimeZone, EFldLoadPattern Pattern, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	bool CheckKeyFree();
	bool IsEnablePartyChange();
	bool IsKeyFreeEvent();
	bool IsLoadingField();
	bool IsProcField();
	bool IsProcFldEvent();
	void LoadFieldSubLevelDebug(int32 FieldMajorID, int32 FieldMinorID, int32 TotalDay, ECldTimeZone TimeZone, EFldLoadPattern Pattern, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void ProcLevelBluePrint(TSubclassOf<class ACharacterBaseCore> DefaultPlayerClass, TSubclassOf<class ACharacterBaseCore> DungeonPlayerClass, TSubclassOf<class ACharacterBaseCore> DungeonPlayerClass_Astrea, TSubclassOf<class AFldCameraBase> DefaultCameraClass, TSubclassOf<class AFldCameraBase> DungeonCameraClass, TSubclassOf<class AFldCamera> TransCameraClass, TSubclassOf<class ACharacterBaseCore> FollowerClass, TSubclassOf<class ACharacterBaseCore> FollowerKoromaruClass, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class AFldCameraBase> DngEntranceCameraClassAstrea, TSubclassOf<class AFldCameraBase> DngFinalFloorCameraClassAstrea);
	void SetParamDebug(int32 FieldMajorID, int32 FieldMinorID);
	void SetPlayerEnable(bool Visible, bool KeyEnable);
	void SetPlayerKeyEnable(bool KeyEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldManagerSubsystem">();
	}
	static class UFldManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldManagerSubsystem>();
	}
};
static_assert(alignof(UFldManagerSubsystem) == 0x000010, "Wrong alignment on UFldManagerSubsystem");
static_assert(sizeof(UFldManagerSubsystem) == 0x000400, "Wrong size on UFldManagerSubsystem");
static_assert(offsetof(UFldManagerSubsystem, MOnEventCallField_) == 0x000030, "Member 'UFldManagerSubsystem::MOnEventCallField_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MLevelManager_) == 0x0000B8, "Member 'UFldManagerSubsystem::MLevelManager_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MPlayerComp_) == 0x0000C8, "Member 'UFldManagerSubsystem::MPlayerComp_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MPlayerTransform) == 0x0000D0, "Member 'UFldManagerSubsystem::MPlayerTransform' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MOparetator_) == 0x000100, "Member 'UFldManagerSubsystem::MOparetator_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MInitScrManager_) == 0x000108, "Member 'UFldManagerSubsystem::MInitScrManager_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MKeyFreeAnnounceActor_) == 0x000140, "Member 'UFldManagerSubsystem::MKeyFreeAnnounceActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MKeyFreeEventActor_) == 0x000148, "Member 'UFldManagerSubsystem::MKeyFreeEventActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MFieldEventActor_) == 0x000150, "Member 'UFldManagerSubsystem::MFieldEventActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MLargeMapActor_) == 0x000158, "Member 'UFldManagerSubsystem::MLargeMapActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MSoundManager_) == 0x000160, "Member 'UFldManagerSubsystem::MSoundManager_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MMiniMapManager_) == 0x000168, "Member 'UFldManagerSubsystem::MMiniMapManager_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDungeonMenuScript_) == 0x0002C8, "Member 'UFldManagerSubsystem::MDungeonMenuScript_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDailyMenuScript_) == 0x0002D0, "Member 'UFldManagerSubsystem::MDailyMenuScript_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MSaveMenu_) == 0x0002D8, "Member 'UFldManagerSubsystem::MSaveMenu_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MBackLogDisp_) == 0x0002E0, "Member 'UFldManagerSubsystem::MBackLogDisp_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MVoiceActionDisp_) == 0x0002E8, "Member 'UFldManagerSubsystem::MVoiceActionDisp_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MKeyLockedActor_) == 0x0002F0, "Member 'UFldManagerSubsystem::MKeyLockedActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MAutoRecoverMenuScript_) == 0x0002F8, "Member 'UFldManagerSubsystem::MAutoRecoverMenuScript_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MHiddenActorArray_) == 0x000300, "Member 'UFldManagerSubsystem::MHiddenActorArray_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MCharBaseReload_) == 0x000310, "Member 'UFldManagerSubsystem::MCharBaseReload_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MCmnPropsActors_) == 0x000318, "Member 'UFldManagerSubsystem::MCmnPropsActors_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MCameraShake_) == 0x000368, "Member 'UFldManagerSubsystem::MCameraShake_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MKeyHelpDelayTimer_) == 0x000370, "Member 'UFldManagerSubsystem::MKeyHelpDelayTimer_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MMoveFloorTimer_) == 0x000374, "Member 'UFldManagerSubsystem::MMoveFloorTimer_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDefaultPlayerClass_) == 0x000378, "Member 'UFldManagerSubsystem::MDefaultPlayerClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDungeonPlayerClass_) == 0x000380, "Member 'UFldManagerSubsystem::MDungeonPlayerClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDungeonPlayerClass_Astrea_) == 0x000388, "Member 'UFldManagerSubsystem::MDungeonPlayerClass_Astrea_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDefaultCameraClass_) == 0x000390, "Member 'UFldManagerSubsystem::MDefaultCameraClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDungeonCameraClass_) == 0x000398, "Member 'UFldManagerSubsystem::MDungeonCameraClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDngEntranceCameraClassAstrea_) == 0x0003A0, "Member 'UFldManagerSubsystem::MDngEntranceCameraClassAstrea_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDngFinalFloorCameraClassAstrea_) == 0x0003A8, "Member 'UFldManagerSubsystem::MDngFinalFloorCameraClassAstrea_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MTransCameraClass_) == 0x0003B0, "Member 'UFldManagerSubsystem::MTransCameraClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MFollowerClass_) == 0x0003B8, "Member 'UFldManagerSubsystem::MFollowerClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MFollowerKoromaruClass_) == 0x0003C0, "Member 'UFldManagerSubsystem::MFollowerKoromaruClass_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MWorldContextObject_) == 0x0003C8, "Member 'UFldManagerSubsystem::MWorldContextObject_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MMoveActor_) == 0x0003D0, "Member 'UFldManagerSubsystem::MMoveActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MCameraLock_) == 0x0003D8, "Member 'UFldManagerSubsystem::MCameraLock_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MCameraMoveActor_) == 0x0003E0, "Member 'UFldManagerSubsystem::MCameraMoveActor_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MOverlapedHitArray_) == 0x0003E8, "Member 'UFldManagerSubsystem::MOverlapedHitArray_' has a wrong offset!");
static_assert(offsetof(UFldManagerSubsystem, MDebugMenu_) == 0x0003F8, "Member 'UFldManagerSubsystem::MDebugMenu_' has a wrong offset!");

// Class xrd777.FldMiniMapManager
// 0x0058 (0x0080 - 0x0028)
class UFldMiniMapManager final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFldHitCharacter*>               MCharactorList_;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMiniMapManager">();
	}
	static class UFldMiniMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldMiniMapManager>();
	}
};
static_assert(alignof(UFldMiniMapManager) == 0x000008, "Wrong alignment on UFldMiniMapManager");
static_assert(sizeof(UFldMiniMapManager) == 0x000080, "Wrong size on UFldMiniMapManager");
static_assert(offsetof(UFldMiniMapManager, MCharactorList_) == 0x000070, "Member 'UFldMiniMapManager::MCharactorList_' has a wrong offset!");

// Class xrd777.FldMiscCameraMove
// 0x0010 (0x07C0 - 0x07B0)
class AFldMiscCameraMove final : public ACameraActor
{
public:
	uint32                                        MFlag_;                                            // 0x07B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MTimer_;                                           // 0x07B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldMiscCameraMove*                     MPrevCamera_;                                      // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMiscCameraMove">();
	}
	static class AFldMiscCameraMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldMiscCameraMove>();
	}
};
static_assert(alignof(AFldMiscCameraMove) == 0x000010, "Wrong alignment on AFldMiscCameraMove");
static_assert(sizeof(AFldMiscCameraMove) == 0x0007C0, "Wrong size on AFldMiscCameraMove");
static_assert(offsetof(AFldMiscCameraMove, MFlag_) == 0x0007B0, "Member 'AFldMiscCameraMove::MFlag_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraMove, MTimer_) == 0x0007B4, "Member 'AFldMiscCameraMove::MTimer_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraMove, MPrevCamera_) == 0x0007B8, "Member 'AFldMiscCameraMove::MPrevCamera_' has a wrong offset!");

// Class xrd777.FldMiscCameraShake
// 0x0018 (0x0298 - 0x0280)
class AFldMiscCameraShake : public AFldLocalActor
{
public:
	class UMaterialParameterCollection*           MCollection_;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSetTime_;                                         // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MSetFrequency_;                                    // 0x028C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MSetPowerX_;                                       // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MSetPowerY_;                                       // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMiscCameraShake">();
	}
	static class AFldMiscCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldMiscCameraShake>();
	}
};
static_assert(alignof(AFldMiscCameraShake) == 0x000008, "Wrong alignment on AFldMiscCameraShake");
static_assert(sizeof(AFldMiscCameraShake) == 0x000298, "Wrong size on AFldMiscCameraShake");
static_assert(offsetof(AFldMiscCameraShake, MCollection_) == 0x000280, "Member 'AFldMiscCameraShake::MCollection_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraShake, MSetTime_) == 0x000288, "Member 'AFldMiscCameraShake::MSetTime_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraShake, MSetFrequency_) == 0x00028C, "Member 'AFldMiscCameraShake::MSetFrequency_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraShake, MSetPowerX_) == 0x000290, "Member 'AFldMiscCameraShake::MSetPowerX_' has a wrong offset!");
static_assert(offsetof(AFldMiscCameraShake, MSetPowerY_) == 0x000294, "Member 'AFldMiscCameraShake::MSetPowerY_' has a wrong offset!");

// Class xrd777.CommonItemListTable
// 0x0010 (0x0040 - 0x0030)
class UCommonItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FCommonItemList>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonItemListTable">();
	}
	static class UCommonItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonItemListTable>();
	}
};
static_assert(alignof(UCommonItemListTable) == 0x000008, "Wrong alignment on UCommonItemListTable");
static_assert(sizeof(UCommonItemListTable) == 0x000040, "Wrong size on UCommonItemListTable");
static_assert(offsetof(UCommonItemListTable, Data) == 0x000030, "Member 'UCommonItemListTable::Data' has a wrong offset!");

// Class xrd777.FldMiscCharaBaseMove
// 0x0070 (0x02F0 - 0x0280)
class AFldMiscCharaBaseMove final : public AFldLocalActor
{
public:
	FMulticastInlineDelegateProperty_             MEndDelegate_;                                     // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MCharactor_;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldNpcComp*                            MNpcComp_;                                         // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x40];                                     // 0x02B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMiscCharaBaseMove">();
	}
	static class AFldMiscCharaBaseMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldMiscCharaBaseMove>();
	}
};
static_assert(alignof(AFldMiscCharaBaseMove) == 0x000008, "Wrong alignment on AFldMiscCharaBaseMove");
static_assert(sizeof(AFldMiscCharaBaseMove) == 0x0002F0, "Wrong size on AFldMiscCharaBaseMove");
static_assert(offsetof(AFldMiscCharaBaseMove, MEndDelegate_) == 0x000280, "Member 'AFldMiscCharaBaseMove::MEndDelegate_' has a wrong offset!");
static_assert(offsetof(AFldMiscCharaBaseMove, MCharactor_) == 0x0002A0, "Member 'AFldMiscCharaBaseMove::MCharactor_' has a wrong offset!");
static_assert(offsetof(AFldMiscCharaBaseMove, MNpcComp_) == 0x0002A8, "Member 'AFldMiscCharaBaseMove::MNpcComp_' has a wrong offset!");

// Class xrd777.FldMiscCharBaseReload
// 0x0020 (0x0298 - 0x0278)
class AFldMiscCharBaseReload final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldMiscCharBaseReload_Data>    MDataArray_;                                       // 0x0288(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldMiscCharBaseReload">();
	}
	static class AFldMiscCharBaseReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldMiscCharBaseReload>();
	}
};
static_assert(alignof(AFldMiscCharBaseReload) == 0x000008, "Wrong alignment on AFldMiscCharBaseReload");
static_assert(sizeof(AFldMiscCharBaseReload) == 0x000298, "Wrong size on AFldMiscCharBaseReload");
static_assert(offsetof(AFldMiscCharBaseReload, MDataArray_) == 0x000288, "Member 'AFldMiscCharBaseReload::MDataArray_' has a wrong offset!");

// Class xrd777.FldNpcActor
// 0x0038 (0x04A0 - 0x0468)
class AFldNpcActor final : public AFldHitCharacter
{
public:
	int32                                         MMajorID_;                                         // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MMinorID_;                                         // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldNpcActorType                              MType_;                                            // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MNameIndex_;                                       // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MNotMapInfoDisp_;                                  // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MMapIconDirectLocation_;                           // 0x047C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMapIconDirectLocation_;                           // 0x0488(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MOnFlagName_;                                      // 0x048C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0494(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldNpcActor">();
	}
	static class AFldNpcActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldNpcActor>();
	}
};
static_assert(alignof(AFldNpcActor) == 0x000008, "Wrong alignment on AFldNpcActor");
static_assert(sizeof(AFldNpcActor) == 0x0004A0, "Wrong size on AFldNpcActor");
static_assert(offsetof(AFldNpcActor, MMajorID_) == 0x000468, "Member 'AFldNpcActor::MMajorID_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MMinorID_) == 0x00046C, "Member 'AFldNpcActor::MMinorID_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MType_) == 0x000470, "Member 'AFldNpcActor::MType_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MNameIndex_) == 0x000474, "Member 'AFldNpcActor::MNameIndex_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MNotMapInfoDisp_) == 0x000478, "Member 'AFldNpcActor::MNotMapInfoDisp_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MMapIconDirectLocation_) == 0x00047C, "Member 'AFldNpcActor::MMapIconDirectLocation_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, bMapIconDirectLocation_) == 0x000488, "Member 'AFldNpcActor::bMapIconDirectLocation_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MOnFlagName_) == 0x00048C, "Member 'AFldNpcActor::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AFldNpcActor, MOffFlagName_) == 0x000494, "Member 'AFldNpcActor::MOffFlagName_' has a wrong offset!");

// Class xrd777.FldNpcComp
// 0x0070 (0x0138 - 0x00C8)
class UFldNpcComp final : public UFldLocalActorComp
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAppCharBaseComp*                       MCharaBaseComp_;                                   // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MListIndex_;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MMajorID_;                                         // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MMinorID_;                                         // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MFbnNumber_;                                       // 0x00F4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSpeakMotionBlendInTime_;                          // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MSpeakMotionBlendOutTime_;                         // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFldNpcCompPropsInfo>           MPropsArray_;                                      // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFldNpcCompOrnamentsInfo>       MOrnamentsArray_;                                  // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class UAppCharBaseComp* GetCharBaseComp();
	void RequestLookAtPlayerByMotion();
	void RequestPauseAnimProcByMotion();
	void RequestRestartAnimProcByMotion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldNpcComp">();
	}
	static class UFldNpcComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldNpcComp>();
	}
};
static_assert(alignof(UFldNpcComp) == 0x000008, "Wrong alignment on UFldNpcComp");
static_assert(sizeof(UFldNpcComp) == 0x000138, "Wrong size on UFldNpcComp");
static_assert(offsetof(UFldNpcComp, MCharaBaseComp_) == 0x0000D8, "Member 'UFldNpcComp::MCharaBaseComp_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MListIndex_) == 0x0000E8, "Member 'UFldNpcComp::MListIndex_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MMajorID_) == 0x0000EC, "Member 'UFldNpcComp::MMajorID_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MMinorID_) == 0x0000F0, "Member 'UFldNpcComp::MMinorID_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MFbnNumber_) == 0x0000F4, "Member 'UFldNpcComp::MFbnNumber_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MSpeakMotionBlendInTime_) == 0x0000F8, "Member 'UFldNpcComp::MSpeakMotionBlendInTime_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MSpeakMotionBlendOutTime_) == 0x0000FC, "Member 'UFldNpcComp::MSpeakMotionBlendOutTime_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MPropsArray_) == 0x000118, "Member 'UFldNpcComp::MPropsArray_' has a wrong offset!");
static_assert(offsetof(UFldNpcComp, MOrnamentsArray_) == 0x000128, "Member 'UFldNpcComp::MOrnamentsArray_' has a wrong offset!");

// Class xrd777.UIFieldType
// 0x0000 (0x0028 - 0x0028)
class UUIFieldType final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldType">();
	}
	static class UUIFieldType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldType>();
	}
};
static_assert(alignof(UUIFieldType) == 0x000008, "Wrong alignment on UUIFieldType");
static_assert(sizeof(UUIFieldType) == 0x000028, "Wrong size on UUIFieldType");

// Class xrd777.FldOperationBase
// 0x0008 (0x00B8 - 0x00B0)
class UFldOperationBase : public UActorComponent
{
public:
	class AFldOperator*                           Holder;                                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldOperationBase">();
	}
	static class UFldOperationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldOperationBase>();
	}
};
static_assert(alignof(UFldOperationBase) == 0x000008, "Wrong alignment on UFldOperationBase");
static_assert(sizeof(UFldOperationBase) == 0x0000B8, "Wrong size on UFldOperationBase");
static_assert(offsetof(UFldOperationBase, Holder) == 0x0000B0, "Member 'UFldOperationBase::Holder' has a wrong offset!");

// Class xrd777.FldOperationPrePhysics
// 0x0008 (0x00B8 - 0x00B0)
class UFldOperationPrePhysics final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldOperationPrePhysics">();
	}
	static class UFldOperationPrePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldOperationPrePhysics>();
	}
};
static_assert(alignof(UFldOperationPrePhysics) == 0x000008, "Wrong alignment on UFldOperationPrePhysics");
static_assert(sizeof(UFldOperationPrePhysics) == 0x0000B8, "Wrong size on UFldOperationPrePhysics");

// Class xrd777.FldOperationCamera
// 0x0048 (0x0100 - 0x00B8)
class UFldOperationCamera final : public UFldOperationBase
{
public:
	class AFldCameraHitBase*                      CurrentHitRef;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLock;                                             // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3F];                                      // 0x00C1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldOperationCamera">();
	}
	static class UFldOperationCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldOperationCamera>();
	}
};
static_assert(alignof(UFldOperationCamera) == 0x000008, "Wrong alignment on UFldOperationCamera");
static_assert(sizeof(UFldOperationCamera) == 0x000100, "Wrong size on UFldOperationCamera");
static_assert(offsetof(UFldOperationCamera, CurrentHitRef) == 0x0000B8, "Member 'UFldOperationCamera::CurrentHitRef' has a wrong offset!");
static_assert(offsetof(UFldOperationCamera, bLock) == 0x0000C0, "Member 'UFldOperationCamera::bLock' has a wrong offset!");

// Class xrd777.FldOperationPlayer
// 0x0098 (0x0150 - 0x00B8)
class UFldOperationPlayer final : public UFldOperationBase
{
public:
	bool                                          HitUI;                                             // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                Direction;                                         // 0x00C0(0x0040)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              PreviousAxisL;                                     // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldEnemyHolder                        EncountEnemy;                                      // 0x0108(0x0010)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         Timer;                                             // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StackTimer;                                        // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CameraChanged;                                     // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Clamp;                                             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              D_AxisL;                                           // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              D_AxisR;                                           // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              D_ClampAxisL;                                      // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              D_ClampAxisR;                                      // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldOperationPlayer">();
	}
	static class UFldOperationPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldOperationPlayer>();
	}
};
static_assert(alignof(UFldOperationPlayer) == 0x000010, "Wrong alignment on UFldOperationPlayer");
static_assert(sizeof(UFldOperationPlayer) == 0x000150, "Wrong size on UFldOperationPlayer");
static_assert(offsetof(UFldOperationPlayer, HitUI) == 0x0000B8, "Member 'UFldOperationPlayer::HitUI' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, Direction) == 0x0000C0, "Member 'UFldOperationPlayer::Direction' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, PreviousAxisL) == 0x000100, "Member 'UFldOperationPlayer::PreviousAxisL' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, EncountEnemy) == 0x000108, "Member 'UFldOperationPlayer::EncountEnemy' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, Timer) == 0x000118, "Member 'UFldOperationPlayer::Timer' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, StackTimer) == 0x00011C, "Member 'UFldOperationPlayer::StackTimer' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, CameraChanged) == 0x000120, "Member 'UFldOperationPlayer::CameraChanged' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, Clamp) == 0x000124, "Member 'UFldOperationPlayer::Clamp' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, D_AxisL) == 0x000128, "Member 'UFldOperationPlayer::D_AxisL' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, D_AxisR) == 0x000130, "Member 'UFldOperationPlayer::D_AxisR' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, D_ClampAxisL) == 0x000138, "Member 'UFldOperationPlayer::D_ClampAxisL' has a wrong offset!");
static_assert(offsetof(UFldOperationPlayer, D_ClampAxisR) == 0x000140, "Member 'UFldOperationPlayer::D_ClampAxisR' has a wrong offset!");

// Class xrd777.UIGenericSelectCharacter
// 0x0038 (0x0060 - 0x0028)
class UUIGenericSelectCharacter final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGenericSelectCharacter">();
	}
	static class UUIGenericSelectCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGenericSelectCharacter>();
	}
};
static_assert(alignof(UUIGenericSelectCharacter) == 0x000008, "Wrong alignment on UUIGenericSelectCharacter");
static_assert(sizeof(UUIGenericSelectCharacter) == 0x000060, "Wrong size on UUIGenericSelectCharacter");

// Class xrd777.FldOperator
// 0x00A0 (0x02C0 - 0x0220)
class AFldOperator final : public AActor
{
public:
	class UFldOperationCamera*                    OpCameraComp;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldOperationPlayer*                    OpPlayerComp;                                      // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFldOperationPrePhysics*                OpPrePhysicsComp;                                  // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCamera*                             MainCamera;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCameraFree*                         FreeCamera;                                        // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPlayerHolder                       PlayerHolder;                                      // 0x0248(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AController*                            PlayerController;                                  // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AKernelInput*                           KernelInput;                                       // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFldHitCore*>                    OverloapHits;                                      // 0x0270(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFldOperatorKeyState                          KeyState;                                          // 0x0280(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldOperatorState                             State;                                             // 0x0284(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldOperatorState                             NextState;                                         // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldEnemyHolder                        EncountEnemy;                                      // 0x0290(0x0010)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EFldOperatorEncountType                       EncountType;                                       // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldPartnerHolder                      AssembleEvent;                                     // 0x02A8(0x0010)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugStandalone;                                  // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginEvent();
	void BeginFadeIn();
	void BeginFadeOut();
	void Cleanup();
	void EndEvent(bool bNotCameraReset);
	void FreeCameraReset();
	void KeyEnable(const bool Enable);
	void SetFreeCameraPitch(const float Angle);
	void SetFreeCameraYaw(const float Angle);
	void Setup(class AKernelInput* KernelInput_0, class APawn* Player, class AFldCameraFree* FreeCamera_0, class AFldCamera* Camera);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldOperator">();
	}
	static class AFldOperator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldOperator>();
	}
};
static_assert(alignof(AFldOperator) == 0x000008, "Wrong alignment on AFldOperator");
static_assert(sizeof(AFldOperator) == 0x0002C0, "Wrong size on AFldOperator");
static_assert(offsetof(AFldOperator, OpCameraComp) == 0x000220, "Member 'AFldOperator::OpCameraComp' has a wrong offset!");
static_assert(offsetof(AFldOperator, OpPlayerComp) == 0x000228, "Member 'AFldOperator::OpPlayerComp' has a wrong offset!");
static_assert(offsetof(AFldOperator, OpPrePhysicsComp) == 0x000230, "Member 'AFldOperator::OpPrePhysicsComp' has a wrong offset!");
static_assert(offsetof(AFldOperator, MainCamera) == 0x000238, "Member 'AFldOperator::MainCamera' has a wrong offset!");
static_assert(offsetof(AFldOperator, FreeCamera) == 0x000240, "Member 'AFldOperator::FreeCamera' has a wrong offset!");
static_assert(offsetof(AFldOperator, PlayerHolder) == 0x000248, "Member 'AFldOperator::PlayerHolder' has a wrong offset!");
static_assert(offsetof(AFldOperator, PlayerController) == 0x000260, "Member 'AFldOperator::PlayerController' has a wrong offset!");
static_assert(offsetof(AFldOperator, KernelInput) == 0x000268, "Member 'AFldOperator::KernelInput' has a wrong offset!");
static_assert(offsetof(AFldOperator, OverloapHits) == 0x000270, "Member 'AFldOperator::OverloapHits' has a wrong offset!");
static_assert(offsetof(AFldOperator, KeyState) == 0x000280, "Member 'AFldOperator::KeyState' has a wrong offset!");
static_assert(offsetof(AFldOperator, State) == 0x000284, "Member 'AFldOperator::State' has a wrong offset!");
static_assert(offsetof(AFldOperator, NextState) == 0x000288, "Member 'AFldOperator::NextState' has a wrong offset!");
static_assert(offsetof(AFldOperator, EncountEnemy) == 0x000290, "Member 'AFldOperator::EncountEnemy' has a wrong offset!");
static_assert(offsetof(AFldOperator, EncountType) == 0x0002A0, "Member 'AFldOperator::EncountType' has a wrong offset!");
static_assert(offsetof(AFldOperator, AssembleEvent) == 0x0002A8, "Member 'AFldOperator::AssembleEvent' has a wrong offset!");
static_assert(offsetof(AFldOperator, bDebugStandalone) == 0x0002B8, "Member 'AFldOperator::bDebugStandalone' has a wrong offset!");

// Class xrd777.FldPartnerPointComp
// 0x0000 (0x0200 - 0x0200)
class UFldPartnerPointComp final : public USceneComponent
{
public:
	int32                                         UsePartyId;                                        // 0x01F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPartnerPointComp">();
	}
	static class UFldPartnerPointComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPartnerPointComp>();
	}
};
static_assert(alignof(UFldPartnerPointComp) == 0x000010, "Wrong alignment on UFldPartnerPointComp");
static_assert(sizeof(UFldPartnerPointComp) == 0x000200, "Wrong size on UFldPartnerPointComp");
static_assert(offsetof(UFldPartnerPointComp, UsePartyId) == 0x0001F8, "Member 'UFldPartnerPointComp::UsePartyId' has a wrong offset!");

// Class xrd777.FldPartnerStartPointComp
// 0x0000 (0x0200 - 0x0200)
class UFldPartnerStartPointComp final : public USceneComponent
{
public:
	int32                                         ID;                                                // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPartnerStartPointComp">();
	}
	static class UFldPartnerStartPointComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPartnerStartPointComp>();
	}
};
static_assert(alignof(UFldPartnerStartPointComp) == 0x000010, "Wrong alignment on UFldPartnerStartPointComp");
static_assert(sizeof(UFldPartnerStartPointComp) == 0x000200, "Wrong size on UFldPartnerStartPointComp");
static_assert(offsetof(UFldPartnerStartPointComp, ID) == 0x0001F8, "Member 'UFldPartnerStartPointComp::ID' has a wrong offset!");

// Class xrd777.FldPartnerComp
// 0x0130 (0x01F8 - 0x00C8)
class UFldPartnerComp final : public UFldLocalActorComp
{
public:
	class UAppCharacterComp*                      AppCharacter;                                      // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterLipsyncAppComponent*          LipComp;                                           // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterSimpleLipsAnimAppComponent*   SimpleLipComp;                                     // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldPartnerController*                  ControllerRef;                                     // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPlayerHolder                       Player;                                            // 0x00E8(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         PartyID;                                           // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPartnerData                        Data;                                              // 0x0104(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFldCharSpeed                          SpeedData;                                         // 0x0114(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowStandbyToFinish;                             // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFldPartnerState                              State;                                             // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldPartnerState                              NextState;                                         // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldPartnerBehavior                           Behavior;                                          // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldPartnerBehavior                           NextBehavior;                                      // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TrackingPointId;                                   // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TrackingLocation;                                  // 0x013C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TrackingPlayerLocation;                            // 0x0148(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AvoidLocation;                                     // 0x0154(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             UseRootMotionDelegate;                             // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             EnableRootMotionDelegate;                          // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DisableRootMotionDelegate;                         // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetSpeedThresholdDelegate;                         // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             EnableForceWaitPoseDelegate;                       // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DisableForceWaitPoseDelegate;                      // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetSpeedDelegate;                                  // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FVector                                MoveForce;                                         // 0x01D0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFldCharPersonalMotionComp*             PersonalMotionComp;                                // 0x01E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetDashThreshold() const;
	const float GetRunThreshold() const;
	const float GetWalkThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPartnerComp">();
	}
	static class UFldPartnerComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPartnerComp>();
	}
};
static_assert(alignof(UFldPartnerComp) == 0x000008, "Wrong alignment on UFldPartnerComp");
static_assert(sizeof(UFldPartnerComp) == 0x0001F8, "Wrong size on UFldPartnerComp");
static_assert(offsetof(UFldPartnerComp, AppCharacter) == 0x0000C8, "Member 'UFldPartnerComp::AppCharacter' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, LipComp) == 0x0000D0, "Member 'UFldPartnerComp::LipComp' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, SimpleLipComp) == 0x0000D8, "Member 'UFldPartnerComp::SimpleLipComp' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, ControllerRef) == 0x0000E0, "Member 'UFldPartnerComp::ControllerRef' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, Player) == 0x0000E8, "Member 'UFldPartnerComp::Player' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, PartyID) == 0x000100, "Member 'UFldPartnerComp::PartyID' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, Data) == 0x000104, "Member 'UFldPartnerComp::Data' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, SpeedData) == 0x000114, "Member 'UFldPartnerComp::SpeedData' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, bAllowStandbyToFinish) == 0x000124, "Member 'UFldPartnerComp::bAllowStandbyToFinish' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, State) == 0x000128, "Member 'UFldPartnerComp::State' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, NextState) == 0x00012C, "Member 'UFldPartnerComp::NextState' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, Behavior) == 0x000130, "Member 'UFldPartnerComp::Behavior' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, NextBehavior) == 0x000134, "Member 'UFldPartnerComp::NextBehavior' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, TrackingPointId) == 0x000138, "Member 'UFldPartnerComp::TrackingPointId' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, TrackingLocation) == 0x00013C, "Member 'UFldPartnerComp::TrackingLocation' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, TrackingPlayerLocation) == 0x000148, "Member 'UFldPartnerComp::TrackingPlayerLocation' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, AvoidLocation) == 0x000154, "Member 'UFldPartnerComp::AvoidLocation' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, UseRootMotionDelegate) == 0x000160, "Member 'UFldPartnerComp::UseRootMotionDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, EnableRootMotionDelegate) == 0x000170, "Member 'UFldPartnerComp::EnableRootMotionDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, DisableRootMotionDelegate) == 0x000180, "Member 'UFldPartnerComp::DisableRootMotionDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, SetSpeedThresholdDelegate) == 0x000190, "Member 'UFldPartnerComp::SetSpeedThresholdDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, EnableForceWaitPoseDelegate) == 0x0001A0, "Member 'UFldPartnerComp::EnableForceWaitPoseDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, DisableForceWaitPoseDelegate) == 0x0001B0, "Member 'UFldPartnerComp::DisableForceWaitPoseDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, SetSpeedDelegate) == 0x0001C0, "Member 'UFldPartnerComp::SetSpeedDelegate' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, MoveForce) == 0x0001D0, "Member 'UFldPartnerComp::MoveForce' has a wrong offset!");
static_assert(offsetof(UFldPartnerComp, PersonalMotionComp) == 0x0001E0, "Member 'UFldPartnerComp::PersonalMotionComp' has a wrong offset!");

// Class xrd777.UIHeroParameterStatus
// 0x0018 (0x02B8 - 0x02A0)
class AUIHeroParameterStatus final : public AUIBaseActor
{
public:
	class UAssetLoader*                           M_pLoader;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUIHeroParameterStatusDraw*             M_pHeroParamDrawActor;                             // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUIHeroParameterStatusDraw> M_pHeroParamDrawActorSC;                           // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHeroParameterStatus">();
	}
	static class AUIHeroParameterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIHeroParameterStatus>();
	}
};
static_assert(alignof(AUIHeroParameterStatus) == 0x000008, "Wrong alignment on AUIHeroParameterStatus");
static_assert(sizeof(AUIHeroParameterStatus) == 0x0002B8, "Wrong size on AUIHeroParameterStatus");
static_assert(offsetof(AUIHeroParameterStatus, M_pLoader) == 0x0002A0, "Member 'AUIHeroParameterStatus::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIHeroParameterStatus, M_pHeroParamDrawActor) == 0x0002A8, "Member 'AUIHeroParameterStatus::M_pHeroParamDrawActor' has a wrong offset!");
static_assert(offsetof(AUIHeroParameterStatus, M_pHeroParamDrawActorSC) == 0x0002B0, "Member 'AUIHeroParameterStatus::M_pHeroParamDrawActorSC' has a wrong offset!");

// Class xrd777.FldPartnerController
// 0x0000 (0x0328 - 0x0328)
class AFldPartnerController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPartnerController">();
	}
	static class AFldPartnerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldPartnerController>();
	}
};
static_assert(alignof(AFldPartnerController) == 0x000008, "Wrong alignment on AFldPartnerController");
static_assert(sizeof(AFldPartnerController) == 0x000328, "Wrong size on AFldPartnerController");

// Class xrd777.FldPartnerManager
// 0x0038 (0x0258 - 0x0220)
class AFldPartnerManager final : public AActor
{
public:
	TArray<struct FFldPartnerHolder>              Partners;                                          // 0x0220(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPartnerManager">();
	}
	static class AFldPartnerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldPartnerManager>();
	}
};
static_assert(alignof(AFldPartnerManager) == 0x000008, "Wrong alignment on AFldPartnerManager");
static_assert(sizeof(AFldPartnerManager) == 0x000258, "Wrong size on AFldPartnerManager");
static_assert(offsetof(AFldPartnerManager, Partners) == 0x000220, "Member 'AFldPartnerManager::Partners' has a wrong offset!");

// Class xrd777.FldPlayerComp
// 0x0288 (0x0350 - 0x00C8)
class UFldPlayerComp : public UFldLocalActorComp
{
public:
	class AController*                            ControllerRef;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppCharacterComp*                      AppCharComp;                                       // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldHitCore*                            HitCoreRef;                                        // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldCameraHitBase*                      CameraHitRef;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFldPlayerData                         PlayerData;                                        // 0x00E8(0x01E8)(Protected, NativeAccessSpecifierProtected)
	struct FFldCharSpeed                          SpeedData;                                         // 0x02D0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFldPlayerState                               State;                                             // 0x02E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFldPlayerState                               NextState;                                         // 0x02E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDash;                                       // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAssault;                                    // 0x02E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJammingSkill;                                     // 0x02EA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPressureSkill;                                    // 0x02EB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnceAnimStop;                                     // 0x02EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotSearchedByEnemies;                             // 0x02ED(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackMontage;                                     // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetSpeedThresholdDelegate;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             EnableForceWaitPoseDelegate;                       // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DisableForceWaitPoseDelegate;                      // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             EnableIsTurnedDelegate;                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DisableIsTurnedDelegate;                           // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UFldCharPersonalMotionComp*             PersonalMotionComp;                                // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);

	const float GetDashThreshold() const;
	const float GetRunThreshold() const;
	const float GetWalkThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerComp">();
	}
	static class UFldPlayerComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPlayerComp>();
	}
};
static_assert(alignof(UFldPlayerComp) == 0x000008, "Wrong alignment on UFldPlayerComp");
static_assert(sizeof(UFldPlayerComp) == 0x000350, "Wrong size on UFldPlayerComp");
static_assert(offsetof(UFldPlayerComp, ControllerRef) == 0x0000C8, "Member 'UFldPlayerComp::ControllerRef' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, AppCharComp) == 0x0000D0, "Member 'UFldPlayerComp::AppCharComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, HitCoreRef) == 0x0000D8, "Member 'UFldPlayerComp::HitCoreRef' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, CameraHitRef) == 0x0000E0, "Member 'UFldPlayerComp::CameraHitRef' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, PlayerData) == 0x0000E8, "Member 'UFldPlayerComp::PlayerData' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, SpeedData) == 0x0002D0, "Member 'UFldPlayerComp::SpeedData' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, State) == 0x0002E0, "Member 'UFldPlayerComp::State' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, NextState) == 0x0002E4, "Member 'UFldPlayerComp::NextState' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bEnableDash) == 0x0002E8, "Member 'UFldPlayerComp::bEnableDash' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bEnableAssault) == 0x0002E9, "Member 'UFldPlayerComp::bEnableAssault' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bJammingSkill) == 0x0002EA, "Member 'UFldPlayerComp::bJammingSkill' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bPressureSkill) == 0x0002EB, "Member 'UFldPlayerComp::bPressureSkill' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bOnceAnimStop) == 0x0002EC, "Member 'UFldPlayerComp::bOnceAnimStop' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, bNotSearchedByEnemies) == 0x0002ED, "Member 'UFldPlayerComp::bNotSearchedByEnemies' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, AttackMontage) == 0x0002F0, "Member 'UFldPlayerComp::AttackMontage' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, SetSpeedThresholdDelegate) == 0x0002F8, "Member 'UFldPlayerComp::SetSpeedThresholdDelegate' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, EnableForceWaitPoseDelegate) == 0x000308, "Member 'UFldPlayerComp::EnableForceWaitPoseDelegate' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, DisableForceWaitPoseDelegate) == 0x000318, "Member 'UFldPlayerComp::DisableForceWaitPoseDelegate' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, EnableIsTurnedDelegate) == 0x000328, "Member 'UFldPlayerComp::EnableIsTurnedDelegate' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, DisableIsTurnedDelegate) == 0x000338, "Member 'UFldPlayerComp::DisableIsTurnedDelegate' has a wrong offset!");
static_assert(offsetof(UFldPlayerComp, PersonalMotionComp) == 0x000348, "Member 'UFldPlayerComp::PersonalMotionComp' has a wrong offset!");

// Class xrd777.FldPlayerAbsComp
// 0x00F0 (0x0440 - 0x0350)
class UFldPlayerAbsComp : public UFldPlayerComp
{
public:
	uint8                                         Pad_350[0x84];                                     // 0x0350(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLdPlayerInputInterpolation            InputInterpolation;                                // 0x03D4(0x0044)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x28];                                     // 0x0418(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerAbsComp">();
	}
	static class UFldPlayerAbsComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPlayerAbsComp>();
	}
};
static_assert(alignof(UFldPlayerAbsComp) == 0x000008, "Wrong alignment on UFldPlayerAbsComp");
static_assert(sizeof(UFldPlayerAbsComp) == 0x000440, "Wrong size on UFldPlayerAbsComp");
static_assert(offsetof(UFldPlayerAbsComp, InputInterpolation) == 0x0003D4, "Member 'UFldPlayerAbsComp::InputInterpolation' has a wrong offset!");

// Class xrd777.FldPlayerDailyComp
// 0x0010 (0x0450 - 0x0440)
class UFldPlayerDailyComp final : public UFldPlayerAbsComp
{
public:
	EFldPlayerDailyBehavior                       Behavior;                                          // 0x0440(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldPlayerDailyBehavior                       NextBehavior;                                      // 0x0444(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerDailyComp">();
	}
	static class UFldPlayerDailyComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPlayerDailyComp>();
	}
};
static_assert(alignof(UFldPlayerDailyComp) == 0x000008, "Wrong alignment on UFldPlayerDailyComp");
static_assert(sizeof(UFldPlayerDailyComp) == 0x000450, "Wrong size on UFldPlayerDailyComp");
static_assert(offsetof(UFldPlayerDailyComp, Behavior) == 0x000440, "Member 'UFldPlayerDailyComp::Behavior' has a wrong offset!");
static_assert(offsetof(UFldPlayerDailyComp, NextBehavior) == 0x000444, "Member 'UFldPlayerDailyComp::NextBehavior' has a wrong offset!");

// Class xrd777.FldPlayerDungeonComp
// 0x0210 (0x0650 - 0x0440)
class UFldPlayerDungeonComp final : public UFldPlayerAbsComp
{
public:
	class UChildActorComponent*                   AttackAreaComp;                                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           AttackArea;                                        // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   AttackAreaLongRangeComp;                           // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           AttackAreaLongRange;                               // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   TargetDetectAreaLongRangeComp;                     // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           TargetDetectAreaLongRange;                         // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   ObjectAutoDestroyAreaComp;                         // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           ObjectAutoDestroyArea;                             // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   DashAttackAreaComp;                                // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           DashAttackArea;                                    // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   SearchAreaComp;                                    // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldCharArea*                           SearchArea;                                        // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UFldPartnerStartPointComp*> PartnerStartPoints;                                // 0x04A0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFldPartnerPointComp*>           PartnerPoints;                                     // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  PostProcessComp;                                   // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldPlayerDngBehavior                         Behavior;                                          // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFldPlayerDngBehavior                         NextBehavior;                                      // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Timer;                                             // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttackId;                                          // 0x0514(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNextAttack;                                       // 0x0518(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRotAttack;                                        // 0x0519(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51A[0x2];                                      // 0x051A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttackForward;                                     // 0x051C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootMoveY;                                         // 0x0538(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AssaultTimer;                                      // 0x053C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEncountingPause;                                  // 0x0540(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_541[0xF];                                      // 0x0541(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFldCharEffectParam                    AssaultEffect;                                     // 0x0550(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AssaultNiagara;                                    // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                AttackOrbitBegin;                                  // 0x0598(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                AttackOrbitEnd;                                    // 0x05A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsPlayingLongRangeAttackEffect;                    // 0x05B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LockOnActor;                                       // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LockOnEffectId;                                    // 0x05C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LockOnNearSideLength;                              // 0x05C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAttackHitObjectOrEnemy;                         // 0x05C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsUsingLongRangeAttack;                            // 0x05C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5CA[0x2];                                      // 0x05CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnDistanceCheckAngle;                          // 0x05CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsUsingDashAttack;                                 // 0x05D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsUsingAssaultAttack;                              // 0x05D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D2[0x6];                                      // 0x05D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LongRangeAttackHitArray;                           // 0x05D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x1C];                                     // 0x05E8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DashAttackPlayingEffect[0x6];                      // 0x0604(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         DashAttackHitActorEffectArray;                     // 0x0620(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FFldEnemyHolder                        DashAttackEnemyHitCache;                           // 0x0630(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         DashAttackTimer;                                   // 0x0640(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   SizeCheckComp;                                     // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerDungeonComp">();
	}
	static class UFldPlayerDungeonComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPlayerDungeonComp>();
	}
};
static_assert(alignof(UFldPlayerDungeonComp) == 0x000010, "Wrong alignment on UFldPlayerDungeonComp");
static_assert(sizeof(UFldPlayerDungeonComp) == 0x000650, "Wrong size on UFldPlayerDungeonComp");
static_assert(offsetof(UFldPlayerDungeonComp, AttackAreaComp) == 0x000440, "Member 'UFldPlayerDungeonComp::AttackAreaComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackArea) == 0x000448, "Member 'UFldPlayerDungeonComp::AttackArea' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackAreaLongRangeComp) == 0x000450, "Member 'UFldPlayerDungeonComp::AttackAreaLongRangeComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackAreaLongRange) == 0x000458, "Member 'UFldPlayerDungeonComp::AttackAreaLongRange' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, TargetDetectAreaLongRangeComp) == 0x000460, "Member 'UFldPlayerDungeonComp::TargetDetectAreaLongRangeComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, TargetDetectAreaLongRange) == 0x000468, "Member 'UFldPlayerDungeonComp::TargetDetectAreaLongRange' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, ObjectAutoDestroyAreaComp) == 0x000470, "Member 'UFldPlayerDungeonComp::ObjectAutoDestroyAreaComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, ObjectAutoDestroyArea) == 0x000478, "Member 'UFldPlayerDungeonComp::ObjectAutoDestroyArea' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackAreaComp) == 0x000480, "Member 'UFldPlayerDungeonComp::DashAttackAreaComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackArea) == 0x000488, "Member 'UFldPlayerDungeonComp::DashAttackArea' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, SearchAreaComp) == 0x000490, "Member 'UFldPlayerDungeonComp::SearchAreaComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, SearchArea) == 0x000498, "Member 'UFldPlayerDungeonComp::SearchArea' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, PartnerStartPoints) == 0x0004A0, "Member 'UFldPlayerDungeonComp::PartnerStartPoints' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, PartnerPoints) == 0x0004F0, "Member 'UFldPlayerDungeonComp::PartnerPoints' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, PostProcessComp) == 0x000500, "Member 'UFldPlayerDungeonComp::PostProcessComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, Behavior) == 0x000508, "Member 'UFldPlayerDungeonComp::Behavior' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, NextBehavior) == 0x00050C, "Member 'UFldPlayerDungeonComp::NextBehavior' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, Timer) == 0x000510, "Member 'UFldPlayerDungeonComp::Timer' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackId) == 0x000514, "Member 'UFldPlayerDungeonComp::AttackId' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, bNextAttack) == 0x000518, "Member 'UFldPlayerDungeonComp::bNextAttack' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, bRotAttack) == 0x000519, "Member 'UFldPlayerDungeonComp::bRotAttack' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackForward) == 0x00051C, "Member 'UFldPlayerDungeonComp::AttackForward' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, RootMoveY) == 0x000538, "Member 'UFldPlayerDungeonComp::RootMoveY' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AssaultTimer) == 0x00053C, "Member 'UFldPlayerDungeonComp::AssaultTimer' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, bEncountingPause) == 0x000540, "Member 'UFldPlayerDungeonComp::bEncountingPause' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AssaultEffect) == 0x000550, "Member 'UFldPlayerDungeonComp::AssaultEffect' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AssaultNiagara) == 0x000590, "Member 'UFldPlayerDungeonComp::AssaultNiagara' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackOrbitBegin) == 0x000598, "Member 'UFldPlayerDungeonComp::AttackOrbitBegin' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, AttackOrbitEnd) == 0x0005A4, "Member 'UFldPlayerDungeonComp::AttackOrbitEnd' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, IsPlayingLongRangeAttackEffect) == 0x0005B0, "Member 'UFldPlayerDungeonComp::IsPlayingLongRangeAttackEffect' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, LockOnActor) == 0x0005B8, "Member 'UFldPlayerDungeonComp::LockOnActor' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, LockOnEffectId) == 0x0005C0, "Member 'UFldPlayerDungeonComp::LockOnEffectId' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, LockOnNearSideLength) == 0x0005C4, "Member 'UFldPlayerDungeonComp::LockOnNearSideLength' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, HasAttackHitObjectOrEnemy) == 0x0005C8, "Member 'UFldPlayerDungeonComp::HasAttackHitObjectOrEnemy' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, IsUsingLongRangeAttack) == 0x0005C9, "Member 'UFldPlayerDungeonComp::IsUsingLongRangeAttack' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, LockOnDistanceCheckAngle) == 0x0005CC, "Member 'UFldPlayerDungeonComp::LockOnDistanceCheckAngle' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, IsUsingDashAttack) == 0x0005D0, "Member 'UFldPlayerDungeonComp::IsUsingDashAttack' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, IsUsingAssaultAttack) == 0x0005D1, "Member 'UFldPlayerDungeonComp::IsUsingAssaultAttack' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, LongRangeAttackHitArray) == 0x0005D8, "Member 'UFldPlayerDungeonComp::LongRangeAttackHitArray' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackPlayingEffect) == 0x000604, "Member 'UFldPlayerDungeonComp::DashAttackPlayingEffect' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackHitActorEffectArray) == 0x000620, "Member 'UFldPlayerDungeonComp::DashAttackHitActorEffectArray' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackEnemyHitCache) == 0x000630, "Member 'UFldPlayerDungeonComp::DashAttackEnemyHitCache' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, DashAttackTimer) == 0x000640, "Member 'UFldPlayerDungeonComp::DashAttackTimer' has a wrong offset!");
static_assert(offsetof(UFldPlayerDungeonComp, SizeCheckComp) == 0x000648, "Member 'UFldPlayerDungeonComp::SizeCheckComp' has a wrong offset!");

// Class xrd777.FldPlayerEncountComp
// 0x0020 (0x00E8 - 0x00C8)
class UFldPlayerEncountComp final : public UAppActorComponent
{
public:
	class UAppCharacterComp*                      AppCharComp;                                       // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           AnimMontage;                                       // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      RunAnim;                                           // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      AttackAnim;                                        // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerEncountComp">();
	}
	static class UFldPlayerEncountComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldPlayerEncountComp>();
	}
};
static_assert(alignof(UFldPlayerEncountComp) == 0x000008, "Wrong alignment on UFldPlayerEncountComp");
static_assert(sizeof(UFldPlayerEncountComp) == 0x0000E8, "Wrong size on UFldPlayerEncountComp");
static_assert(offsetof(UFldPlayerEncountComp, AppCharComp) == 0x0000C8, "Member 'UFldPlayerEncountComp::AppCharComp' has a wrong offset!");
static_assert(offsetof(UFldPlayerEncountComp, AnimMontage) == 0x0000D0, "Member 'UFldPlayerEncountComp::AnimMontage' has a wrong offset!");
static_assert(offsetof(UFldPlayerEncountComp, RunAnim) == 0x0000D8, "Member 'UFldPlayerEncountComp::RunAnim' has a wrong offset!");
static_assert(offsetof(UFldPlayerEncountComp, AttackAnim) == 0x0000E0, "Member 'UFldPlayerEncountComp::AttackAnim' has a wrong offset!");

// Class xrd777.MovieSceneEvtConditionalBranchTrack
// 0x0028 (0x00B8 - 0x0090)
class UMovieSceneEvtConditionalBranchTrack : public UMovieSceneNameableTrack
{
public:
	struct FMovieSceneEvtConditionalBranchData    CondBranchData;                                    // 0x0090(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtConditionalBranchTrack">();
	}
	static class UMovieSceneEvtConditionalBranchTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtConditionalBranchTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtConditionalBranchTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtConditionalBranchTrack");
static_assert(sizeof(UMovieSceneEvtConditionalBranchTrack) == 0x0000B8, "Wrong size on UMovieSceneEvtConditionalBranchTrack");
static_assert(offsetof(UMovieSceneEvtConditionalBranchTrack, CondBranchData) == 0x000090, "Member 'UMovieSceneEvtConditionalBranchTrack::CondBranchData' has a wrong offset!");

// Class xrd777.MovieSceneEvtMovieTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtMovieTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtMovieTrack">();
	}
	static class UMovieSceneEvtMovieTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtMovieTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtMovieTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtMovieTrack");
static_assert(sizeof(UMovieSceneEvtMovieTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtMovieTrack");
static_assert(offsetof(UMovieSceneEvtMovieTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtMovieTrack::Sections' has a wrong offset!");

// Class xrd777.FldPlayerStart
// 0x0010 (0x0260 - 0x0250)
class AFldPlayerStart final : public APlayerStart
{
public:
	int32                                         MIndex_;                                           // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CameraDir;                                         // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPlayerStart">();
	}
	static class AFldPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldPlayerStart>();
	}
};
static_assert(alignof(AFldPlayerStart) == 0x000008, "Wrong alignment on AFldPlayerStart");
static_assert(sizeof(AFldPlayerStart) == 0x000260, "Wrong size on AFldPlayerStart");
static_assert(offsetof(AFldPlayerStart, MIndex_) == 0x000250, "Member 'AFldPlayerStart::MIndex_' has a wrong offset!");
static_assert(offsetof(AFldPlayerStart, CameraDir) == 0x000258, "Member 'AFldPlayerStart::CameraDir' has a wrong offset!");

// Class xrd777.FldPostValumeSound
// 0x0028 (0x02A8 - 0x0280)
class AFldPostValumeSound final : public AFldLocalActor
{
public:
	float                                         MOutRadius_;                                       // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MInRadius_;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXdirOnly_;                                        // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYdirOnly_;                                        // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootComp;                                          // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        HitComp;                                           // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldPostValumeSound">();
	}
	static class AFldPostValumeSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldPostValumeSound>();
	}
};
static_assert(alignof(AFldPostValumeSound) == 0x000008, "Wrong alignment on AFldPostValumeSound");
static_assert(sizeof(AFldPostValumeSound) == 0x0002A8, "Wrong size on AFldPostValumeSound");
static_assert(offsetof(AFldPostValumeSound, MOutRadius_) == 0x000280, "Member 'AFldPostValumeSound::MOutRadius_' has a wrong offset!");
static_assert(offsetof(AFldPostValumeSound, MInRadius_) == 0x000284, "Member 'AFldPostValumeSound::MInRadius_' has a wrong offset!");
static_assert(offsetof(AFldPostValumeSound, bXdirOnly_) == 0x000288, "Member 'AFldPostValumeSound::bXdirOnly_' has a wrong offset!");
static_assert(offsetof(AFldPostValumeSound, bYdirOnly_) == 0x000289, "Member 'AFldPostValumeSound::bYdirOnly_' has a wrong offset!");
static_assert(offsetof(AFldPostValumeSound, RootComp) == 0x000290, "Member 'AFldPostValumeSound::RootComp' has a wrong offset!");
static_assert(offsetof(AFldPostValumeSound, HitComp) == 0x000298, "Member 'AFldPostValumeSound::HitComp' has a wrong offset!");

// Class xrd777.MovieSceneEvtSeqControllerTrack
// 0x0030 (0x00E8 - 0x00B8)
class UMovieSceneEvtSeqControllerTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtSeqControllerTrack">();
	}
	static class UMovieSceneEvtSeqControllerTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtSeqControllerTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtSeqControllerTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtSeqControllerTrack");
static_assert(sizeof(UMovieSceneEvtSeqControllerTrack) == 0x0000E8, "Wrong size on UMovieSceneEvtSeqControllerTrack");
static_assert(offsetof(UMovieSceneEvtSeqControllerTrack, EventReceivers) == 0x0000C8, "Member 'UMovieSceneEvtSeqControllerTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtSeqControllerTrack, Sections) == 0x0000D8, "Member 'UMovieSceneEvtSeqControllerTrack::Sections' has a wrong offset!");

// Class xrd777.FldScriptActor
// 0x0020 (0x02A0 - 0x0280)
class AFldScriptActor final : public AFldLocalActor
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldScriptActor">();
	}
	static class AFldScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldScriptActor>();
	}
};
static_assert(alignof(AFldScriptActor) == 0x000008, "Wrong alignment on AFldScriptActor");
static_assert(sizeof(AFldScriptActor) == 0x0002A0, "Wrong size on AFldScriptActor");

// Class xrd777.FldShortcutMove
// 0x0038 (0x02B0 - 0x0278)
class AFldShortcutMove final : public AAppActor
{
public:
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               MBfAsset_;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldScriptActor*                        MScriptActor_;                                     // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldShortcutMove">();
	}
	static class AFldShortcutMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldShortcutMove>();
	}
};
static_assert(alignof(AFldShortcutMove) == 0x000008, "Wrong alignment on AFldShortcutMove");
static_assert(sizeof(AFldShortcutMove) == 0x0002B0, "Wrong size on AFldShortcutMove");
static_assert(offsetof(AFldShortcutMove, MAssetLoader_) == 0x000298, "Member 'AFldShortcutMove::MAssetLoader_' has a wrong offset!");
static_assert(offsetof(AFldShortcutMove, MBfAsset_) == 0x0002A0, "Member 'AFldShortcutMove::MBfAsset_' has a wrong offset!");
static_assert(offsetof(AFldShortcutMove, MScriptActor_) == 0x0002A8, "Member 'AFldShortcutMove::MScriptActor_' has a wrong offset!");

// Class xrd777.FldShortcutManager
// 0x0000 (0x0028 - 0x0028)
class UFldShortcutManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldShortcutManager">();
	}
	static class UFldShortcutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldShortcutManager>();
	}
};
static_assert(alignof(UFldShortcutManager) == 0x000008, "Wrong alignment on UFldShortcutManager");
static_assert(sizeof(UFldShortcutManager) == 0x000028, "Wrong size on UFldShortcutManager");

// Class xrd777.FldSoundMngChangeTownmapActor
// 0x0018 (0x0290 - 0x0278)
class AFldSoundMngChangeTownmapActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldSoundMngChangeTownmapActor">();
	}
	static class AFldSoundMngChangeTownmapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldSoundMngChangeTownmapActor>();
	}
};
static_assert(alignof(AFldSoundMngChangeTownmapActor) == 0x000008, "Wrong alignment on AFldSoundMngChangeTownmapActor");
static_assert(sizeof(AFldSoundMngChangeTownmapActor) == 0x000290, "Wrong size on AFldSoundMngChangeTownmapActor");

// Class xrd777.MyActor
// 0x0000 (0x0220 - 0x0220)
class AMyActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyActor">();
	}
	static class AMyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyActor>();
	}
};
static_assert(alignof(AMyActor) == 0x000008, "Wrong alignment on AMyActor");
static_assert(sizeof(AMyActor) == 0x000220, "Wrong size on AMyActor");

// Class xrd777.FldSoundMngChangeAISAC
// 0x0018 (0x0290 - 0x0278)
class AFldSoundMngChangeAISAC final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldSoundMngChangeAISAC">();
	}
	static class AFldSoundMngChangeAISAC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldSoundMngChangeAISAC>();
	}
};
static_assert(alignof(AFldSoundMngChangeAISAC) == 0x000008, "Wrong alignment on AFldSoundMngChangeAISAC");
static_assert(sizeof(AFldSoundMngChangeAISAC) == 0x000290, "Wrong size on AFldSoundMngChangeAISAC");

// Class xrd777.FldSoundManager
// 0x0098 (0x00C0 - 0x0028)
class UFldSoundManager final : public UObject
{
public:
	uint32                                        MFlag_;                                            // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFldSoundMngChangeAISAC*                MChgActorAISAC_;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MComVoicePath_;                                    // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MComSePath_;                                       // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MGayaSePath_;                                      // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MComSeExtPath_;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFldAtomSound*>                  MActorArrays_;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAtomComponent*>                 MAtomCompArray_;                                   // 0x0088(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFldSoundMngAisacSet>           MAisacArray_;                                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AFldPostValumeSound*>            MPostVolumeArray_;                                 // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AFldSoundMngChangeTownmapActor*         MChangeActor_;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldSoundManager">();
	}
	static class UFldSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFldSoundManager>();
	}
};
static_assert(alignof(UFldSoundManager) == 0x000008, "Wrong alignment on UFldSoundManager");
static_assert(sizeof(UFldSoundManager) == 0x0000C0, "Wrong size on UFldSoundManager");
static_assert(offsetof(UFldSoundManager, MFlag_) == 0x000028, "Member 'UFldSoundManager::MFlag_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MChgActorAISAC_) == 0x000030, "Member 'UFldSoundManager::MChgActorAISAC_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MComVoicePath_) == 0x000038, "Member 'UFldSoundManager::MComVoicePath_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MComSePath_) == 0x000048, "Member 'UFldSoundManager::MComSePath_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MGayaSePath_) == 0x000058, "Member 'UFldSoundManager::MGayaSePath_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MComSeExtPath_) == 0x000068, "Member 'UFldSoundManager::MComSeExtPath_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MActorArrays_) == 0x000078, "Member 'UFldSoundManager::MActorArrays_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MAtomCompArray_) == 0x000088, "Member 'UFldSoundManager::MAtomCompArray_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MAisacArray_) == 0x000098, "Member 'UFldSoundManager::MAisacArray_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MPostVolumeArray_) == 0x0000A8, "Member 'UFldSoundManager::MPostVolumeArray_' has a wrong offset!");
static_assert(offsetof(UFldSoundManager, MChangeActor_) == 0x0000B8, "Member 'UFldSoundManager::MChangeActor_' has a wrong offset!");

// Class xrd777.FldTargetIcon
// 0x0010 (0x0288 - 0x0278)
class AFldTargetIcon final : public AAppActor
{
public:
	class FName                                   MOnFlagName_;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MOffFlagName_;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldTargetIcon">();
	}
	static class AFldTargetIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldTargetIcon>();
	}
};
static_assert(alignof(AFldTargetIcon) == 0x000008, "Wrong alignment on AFldTargetIcon");
static_assert(sizeof(AFldTargetIcon) == 0x000288, "Wrong size on AFldTargetIcon");
static_assert(offsetof(AFldTargetIcon, MOnFlagName_) == 0x000278, "Member 'AFldTargetIcon::MOnFlagName_' has a wrong offset!");
static_assert(offsetof(AFldTargetIcon, MOffFlagName_) == 0x000280, "Member 'AFldTargetIcon::MOffFlagName_' has a wrong offset!");

// Class xrd777.FldTvProgramScript
// 0x0000 (0x02B0 - 0x02B0)
class AFldTvProgramScript final : public AFldScriptManagerCore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FldTvProgramScript">();
	}
	static class AFldTvProgramScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFldTvProgramScript>();
	}
};
static_assert(alignof(AFldTvProgramScript) == 0x000008, "Wrong alignment on AFldTvProgramScript");
static_assert(sizeof(AFldTvProgramScript) == 0x0002B0, "Wrong size on AFldTvProgramScript");

// Class xrd777.NowatariTestMenu
// 0x0018 (0x0290 - 0x0278)
class ANowatariTestMenu final : public AAppActor
{
public:
	class AActor*                                 Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NowatariTestMenu">();
	}
	static class ANowatariTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANowatariTestMenu>();
	}
};
static_assert(alignof(ANowatariTestMenu) == 0x000008, "Wrong alignment on ANowatariTestMenu");
static_assert(sizeof(ANowatariTestMenu) == 0x000290, "Wrong size on ANowatariTestMenu");
static_assert(offsetof(ANowatariTestMenu, Actor_) == 0x000278, "Member 'ANowatariTestMenu::Actor_' has a wrong offset!");
static_assert(offsetof(ANowatariTestMenu, BmdAsset_) == 0x000280, "Member 'ANowatariTestMenu::BmdAsset_' has a wrong offset!");
static_assert(offsetof(ANowatariTestMenu, DebugMenu_) == 0x000288, "Member 'ANowatariTestMenu::DebugMenu_' has a wrong offset!");

// Class xrd777.FrameBufferCapture
// 0x0020 (0x0048 - 0x0028)
class UFrameBufferCapture final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFrameBufferCaptureDebugWork>   DebugInfo;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameBufferCapture">();
	}
	static class UFrameBufferCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrameBufferCapture>();
	}
};
static_assert(alignof(UFrameBufferCapture) == 0x000008, "Wrong alignment on UFrameBufferCapture");
static_assert(sizeof(UFrameBufferCapture) == 0x000048, "Wrong size on UFrameBufferCapture");
static_assert(offsetof(UFrameBufferCapture, DebugInfo) == 0x000038, "Member 'UFrameBufferCapture::DebugInfo' has a wrong offset!");

// Class xrd777.GenericSelectSystemBase
// 0x0000 (0x0028 - 0x0028)
class UGenericSelectSystemBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericSelectSystemBase">();
	}
	static class UGenericSelectSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericSelectSystemBase>();
	}
};
static_assert(alignof(UGenericSelectSystemBase) == 0x000008, "Wrong alignment on UGenericSelectSystemBase");
static_assert(sizeof(UGenericSelectSystemBase) == 0x000028, "Wrong size on UGenericSelectSystemBase");

// Class xrd777.GenericSelectItem
// 0x0058 (0x0080 - 0x0028)
class UGenericSelectItem final : public UGenericSelectSystemBase
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericSelectItem">();
	}
	static class UGenericSelectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericSelectItem>();
	}
};
static_assert(alignof(UGenericSelectItem) == 0x000008, "Wrong alignment on UGenericSelectItem");
static_assert(sizeof(UGenericSelectItem) == 0x000080, "Wrong size on UGenericSelectItem");

// Class xrd777.GenericSelectMsg
// 0x0050 (0x0078 - 0x0028)
class UGenericSelectMsg : public UGenericSelectSystemBase
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               SelectionImage_;                                   // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericSelectMsg">();
	}
	static class UGenericSelectMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericSelectMsg>();
	}
};
static_assert(alignof(UGenericSelectMsg) == 0x000008, "Wrong alignment on UGenericSelectMsg");
static_assert(sizeof(UGenericSelectMsg) == 0x000078, "Wrong size on UGenericSelectMsg");
static_assert(offsetof(UGenericSelectMsg, SelectionImage_) == 0x000060, "Member 'UGenericSelectMsg::SelectionImage_' has a wrong offset!");

// Class xrd777.TitleStateCaution
// 0x00B0 (0x00E8 - 0x0038)
class UTitleStateCaution final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0xB0];                                      // 0x0038(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateCaution">();
	}
	static class UTitleStateCaution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateCaution>();
	}
};
static_assert(alignof(UTitleStateCaution) == 0x000008, "Wrong alignment on UTitleStateCaution");
static_assert(sizeof(UTitleStateCaution) == 0x0000E8, "Wrong size on UTitleStateCaution");

// Class xrd777.GenericSelectShop
// 0x0000 (0x0078 - 0x0078)
class UGenericSelectShop final : public UGenericSelectMsg
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericSelectShop">();
	}
	static class UGenericSelectShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericSelectShop>();
	}
};
static_assert(alignof(UGenericSelectShop) == 0x000008, "Wrong alignment on UGenericSelectShop");
static_assert(sizeof(UGenericSelectShop) == 0x000078, "Wrong size on UGenericSelectShop");

// Class xrd777.GlobalGameData
// 0x00A0 (0x00C8 - 0x0028)
class UGlobalGameData final : public UObject
{
public:
	TArray<int32>                                 MFlags_ALWAYS_;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MFlags_ANY_;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MCounters_ALWAYS_;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MCounters_ANY_;                                    // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MComItems_ALWAYS_;                                 // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MComItems_ANY_;                                    // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MEvtItems_ALWAYS_;                                 // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MEvtItems_ANY_;                                    // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MDlcItems_ALWAYS_;                                 // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                MNotInheritanceItems_;                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void ClearDataInheritance();
	static void RestoreAstreaClearDataDifficulty();
	static void SetDataInheritance();
	static void SetDataInheritance_ALWAYS();
	static void SetDataInheritance_AstreaClearData();
	static void SetDataInheritance_LibraToAstrea();
	static void StartDataInitialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalGameData">();
	}
	static class UGlobalGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalGameData>();
	}
};
static_assert(alignof(UGlobalGameData) == 0x000008, "Wrong alignment on UGlobalGameData");
static_assert(sizeof(UGlobalGameData) == 0x0000C8, "Wrong size on UGlobalGameData");
static_assert(offsetof(UGlobalGameData, MFlags_ALWAYS_) == 0x000028, "Member 'UGlobalGameData::MFlags_ALWAYS_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MFlags_ANY_) == 0x000038, "Member 'UGlobalGameData::MFlags_ANY_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MCounters_ALWAYS_) == 0x000048, "Member 'UGlobalGameData::MCounters_ALWAYS_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MCounters_ANY_) == 0x000058, "Member 'UGlobalGameData::MCounters_ANY_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MComItems_ALWAYS_) == 0x000068, "Member 'UGlobalGameData::MComItems_ALWAYS_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MComItems_ANY_) == 0x000078, "Member 'UGlobalGameData::MComItems_ANY_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MEvtItems_ALWAYS_) == 0x000088, "Member 'UGlobalGameData::MEvtItems_ALWAYS_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MEvtItems_ANY_) == 0x000098, "Member 'UGlobalGameData::MEvtItems_ANY_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MDlcItems_ALWAYS_) == 0x0000A8, "Member 'UGlobalGameData::MDlcItems_ALWAYS_' has a wrong offset!");
static_assert(offsetof(UGlobalGameData, MNotInheritanceItems_) == 0x0000B8, "Member 'UGlobalGameData::MNotInheritanceItems_' has a wrong offset!");

// Class xrd777.GlobalWork
// 0x30888 (0x30A30 - 0x01A8)
class alignas(0x10) UGlobalWork final : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x2FEC0];                                  // 0x01A8(0x2FEC0)(Fixing Size After Last Property [ Dumper-7 ])
	class USequence*                              MSequenceInstance_;                                // 0x30068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCalendar*                              MCalendarInstance_;                                // 0x30070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCldCommonData*                         MCldCommonData_;                                   // 0x30078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAstreaProgress*                        MAstreaProgressInstance_;                          // 0x30080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrgssCommonData*                       MAstreaPrgssCommonData_;                           // 0x30088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFileNameManager*                       MFileNameData_;                                    // 0x30090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFldCommonData*                         MFldCommonData_;                                   // 0x30098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatItem*                               MItemData_;                                        // 0x300A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTrophyManager*                         MTrophy_;                                          // 0x300A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULeaderBoardManager*                    MLeaderBoard_;                                     // 0x300B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USignedInDialog*                        MSignedInDialog_;                                  // 0x300B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UErrorDialog*                           MErrorDialog_;                                     // 0x300C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMessageDialog*                         MMessageDialog_;                                   // 0x300C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBustupController*                      PBustupController;                                 // 0x300D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommunityWork*                         PCommunityWork;                                    // 0x300D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMsgWork*                               PMsgWork;                                          // 0x300E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEvtDataLoad*                           PEvtDataLoad;                                      // 0x300E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    PFrameBufferCapture;                               // 0x300F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPadRumble*                             PPadRumble;                                        // 0x300F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30100[0xD0];                                   // 0x30100(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UFldCharParamTable*                     MFldCharParamTable_;                               // 0x301D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppCharFootstepsTable*                 MFootstepsTable_;                                  // 0x301D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppCharacterPoolManager*               MCharacterPoolManager_;                            // 0x301E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatSystemText*                         MSystemTextTable;                                  // 0x301E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatUIUseText*                          MUIUseTextTable;                                   // 0x301F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatUICalendarText*                     MUICalendarTextTable;                              // 0x301F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UXrd777SaveManager*                     MSaveManager_;                                     // 0x30200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAddContent*                            MAddContent_;                                      // 0x30208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30210[0x688];                                  // 0x30210(0x0688)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoading*                               PLoadingInst;                                      // 0x30898(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          MCmpMainActor_;                                    // 0x308A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlGuiResourcesBase*                   MBtlGuiResourcesActor_;                            // 0x308A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBtlEncountWipeLoader*                  MBtlEncountWipeLoader_;                            // 0x308B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABtlEncountWipeCore*                    MBtlEncountWipeCore_;                              // 0x308B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFldLevelPoolManager*                   MLevelPoolManager_;                                // 0x308C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MPoolSetting_;                                     // 0x308C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308C9[0x4F];                                   // 0x308C9(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSaveGameHeadder                       MTempSaveHeader_;                                  // 0x30918(0x00D0)(NativeAccessSpecifierPrivate)
	bool                                          bTempSaveHeaderUsed_;                              // 0x309E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309E9[0x7];                                    // 0x309E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGlobalGameData*                        MGameDataProc_;                                    // 0x309F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAppActor*                              MSystemMonitor_;                                   // 0x309F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A00[0x18];                                   // 0x30A00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AResidentReloadActor*                   ResidentReloadActor;                               // 0x30A18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A20[0x10];                                   // 0x30A20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ClearSubLevelActor(ESubLevelIndex SubLevelNum);
	static class AActor* GetSubLevelActor(ESubLevelIndex SubLevelNum);
	static void SetSubLevelActor(ESubLevelIndex SubLevelNum, class AActor* Actor);
	static class AActor* SpawnActorFromClassSubLevelIndex(TSubclassOf<class AActor> ActorClass, ESubLevelIndex SubLevelIndex, const struct FTransform& Transform);

	void SetSequenceParam(EGWorkSeqType Type, int32 Major, int32 Minor);
	void SetSequenceParam_DEBUG(EGWorkSeqType Type, int32 Major, int32 Minor, int32 MKfEvent, const class FString& Tag);
	void SetSequenceParam_KEY_FREE_EVENT(EGWorkSeqType Type, int32 Major, int32 Minor, int32 MKfEvent);

	void GetSequenceParam(EGWorkSeqType* Type, int32* Major, int32* Minor, int32* MKfEvent) const;
	void GetSequenceParam_DEBUG(EGWorkSeqType* Type, int32* Major, int32* Minor, int32* MKfEvent, class FString* Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalWork">();
	}
	static class UGlobalWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalWork>();
	}
};
static_assert(alignof(UGlobalWork) == 0x000010, "Wrong alignment on UGlobalWork");
static_assert(sizeof(UGlobalWork) == 0x030A30, "Wrong size on UGlobalWork");
static_assert(offsetof(UGlobalWork, MSequenceInstance_) == 0x030068, "Member 'UGlobalWork::MSequenceInstance_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MCalendarInstance_) == 0x030070, "Member 'UGlobalWork::MCalendarInstance_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MCldCommonData_) == 0x030078, "Member 'UGlobalWork::MCldCommonData_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MAstreaProgressInstance_) == 0x030080, "Member 'UGlobalWork::MAstreaProgressInstance_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MAstreaPrgssCommonData_) == 0x030088, "Member 'UGlobalWork::MAstreaPrgssCommonData_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MFileNameData_) == 0x030090, "Member 'UGlobalWork::MFileNameData_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MFldCommonData_) == 0x030098, "Member 'UGlobalWork::MFldCommonData_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MItemData_) == 0x0300A0, "Member 'UGlobalWork::MItemData_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MTrophy_) == 0x0300A8, "Member 'UGlobalWork::MTrophy_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MLeaderBoard_) == 0x0300B0, "Member 'UGlobalWork::MLeaderBoard_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MSignedInDialog_) == 0x0300B8, "Member 'UGlobalWork::MSignedInDialog_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MErrorDialog_) == 0x0300C0, "Member 'UGlobalWork::MErrorDialog_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MMessageDialog_) == 0x0300C8, "Member 'UGlobalWork::MMessageDialog_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PBustupController) == 0x0300D0, "Member 'UGlobalWork::PBustupController' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PCommunityWork) == 0x0300D8, "Member 'UGlobalWork::PCommunityWork' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PMsgWork) == 0x0300E0, "Member 'UGlobalWork::PMsgWork' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PEvtDataLoad) == 0x0300E8, "Member 'UGlobalWork::PEvtDataLoad' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PFrameBufferCapture) == 0x0300F0, "Member 'UGlobalWork::PFrameBufferCapture' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PPadRumble) == 0x0300F8, "Member 'UGlobalWork::PPadRumble' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MFldCharParamTable_) == 0x0301D0, "Member 'UGlobalWork::MFldCharParamTable_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MFootstepsTable_) == 0x0301D8, "Member 'UGlobalWork::MFootstepsTable_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MCharacterPoolManager_) == 0x0301E0, "Member 'UGlobalWork::MCharacterPoolManager_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MSystemTextTable) == 0x0301E8, "Member 'UGlobalWork::MSystemTextTable' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MUIUseTextTable) == 0x0301F0, "Member 'UGlobalWork::MUIUseTextTable' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MUICalendarTextTable) == 0x0301F8, "Member 'UGlobalWork::MUICalendarTextTable' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MSaveManager_) == 0x030200, "Member 'UGlobalWork::MSaveManager_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MAddContent_) == 0x030208, "Member 'UGlobalWork::MAddContent_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, PLoadingInst) == 0x030898, "Member 'UGlobalWork::PLoadingInst' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MCmpMainActor_) == 0x0308A0, "Member 'UGlobalWork::MCmpMainActor_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MBtlGuiResourcesActor_) == 0x0308A8, "Member 'UGlobalWork::MBtlGuiResourcesActor_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MBtlEncountWipeLoader_) == 0x0308B0, "Member 'UGlobalWork::MBtlEncountWipeLoader_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MBtlEncountWipeCore_) == 0x0308B8, "Member 'UGlobalWork::MBtlEncountWipeCore_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MLevelPoolManager_) == 0x0308C0, "Member 'UGlobalWork::MLevelPoolManager_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MPoolSetting_) == 0x0308C8, "Member 'UGlobalWork::MPoolSetting_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MTempSaveHeader_) == 0x030918, "Member 'UGlobalWork::MTempSaveHeader_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, bTempSaveHeaderUsed_) == 0x0309E8, "Member 'UGlobalWork::bTempSaveHeaderUsed_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MGameDataProc_) == 0x0309F0, "Member 'UGlobalWork::MGameDataProc_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, MSystemMonitor_) == 0x0309F8, "Member 'UGlobalWork::MSystemMonitor_' has a wrong offset!");
static_assert(offsetof(UGlobalWork, ResidentReloadActor) == 0x030A18, "Member 'UGlobalWork::ResidentReloadActor' has a wrong offset!");

// Class xrd777.GWSettings
// 0x0008 (0x0040 - 0x0038)
class UGWSettings final : public UDeveloperSettings
{
public:
	bool                                          bIsDeterminedByCross;                              // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GWSettings">();
	}
	static class UGWSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGWSettings>();
	}
};
static_assert(alignof(UGWSettings) == 0x000008, "Wrong alignment on UGWSettings");
static_assert(sizeof(UGWSettings) == 0x000040, "Wrong size on UGWSettings");
static_assert(offsetof(UGWSettings, bIsDeterminedByCross) == 0x000038, "Member 'UGWSettings::bIsDeterminedByCross' has a wrong offset!");

// Class xrd777.TitleStateExit
// 0x0000 (0x0038 - 0x0038)
class UTitleStateExit final : public UTitleStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateExit">();
	}
	static class UTitleStateExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateExit>();
	}
};
static_assert(alignof(UTitleStateExit) == 0x000008, "Wrong alignment on UTitleStateExit");
static_assert(sizeof(UTitleStateExit) == 0x000038, "Wrong size on UTitleStateExit");

// Class xrd777.GlobalWorkBpLib
// 0x0000 (0x0028 - 0x0028)
class UGlobalWorkBpLib final : public UBlueprintFunctionLibrary
{
public:
	static int32 GWorkAddMoney(int32 SetMoeny);
	static bool GWorkCheckPartyFull();
	static void GWorkCreateErrorDialog();
	static void GWorkCreateLeaderBoardManagere();
	static void GWorkCreateMessageDialog();
	static void GWorkCreateSignedInDialog();
	static void GWorkCreateTrophyManagere();
	static void GWorkDecCounter(class FName CntName);
	static void GWorkDecCounterValue(int32 CntNo);
	static void GWorkFlagChk(class FName FlagName, EGWorkOnOffEnum* OnOff);
	static void GWorkFlagChkValue(int32 Index_0, EGWorkOnOffEnum* OnOff);
	static void GWorkFlagOff(class FName FlagName);
	static void GWorkFlagOffValue(int32 Index_0);
	static void GWorkFlagOn(class FName FlagName);
	static void GWorkFlagOnValue(int32 Index_0);
	static void GWorkFlagSet(class FName FlagName, EGWorkOnOffEnum* OnOff);
	static void GWorkFlagSetValue(int32 Index_0, EGWorkOnOffEnum* OnOff);
	static void GWorkFullRecoveryAllPartyMember();
	static int32 GWorkGetCounter(class FName CntName);
	static int32 GWorkGetCounterValue(int32 CntNo);
	static float GWorkGetMaxFPS();
	static int32 GWorkGetMoney();
	static int32 GWorkGetPartyID(int32 Index_0);
	static float GWorkGetRealTimeDelta();
	static void GWorkIncCounter(class FName CntName);
	static void GWorkIncCounterValue(int32 CntNo);
	static bool GWorkIsAsiaLanguages();
	static bool GWorkIsEFIGSLanguages();
	static bool GWorkIsFullHpSpAllPartyMember();
	static bool GWorkIsJapaneseLanguage();
	static bool GWorkIsPartyExists(int32 PCID);
	static void GWorkSetCounter(class FName CntName, int32 Value);
	static void GWorkSetCounterValue(int32 CntNo, int32 Value);
	static void GWorkSetMoney(int32 SetMoeny);
	static void GWorkSetPartyIN(int32 PCID);
	static void GWorkSetPartyOUT(int32 PCID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalWorkBpLib">();
	}
	static class UGlobalWorkBpLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalWorkBpLib>();
	}
};
static_assert(alignof(UGlobalWorkBpLib) == 0x000008, "Wrong alignment on UGlobalWorkBpLib");
static_assert(sizeof(UGlobalWorkBpLib) == 0x000028, "Wrong size on UGlobalWorkBpLib");

// Class xrd777.GWFlagWork
// 0x36898 (0x368C0 - 0x0028)
class UGWFlagWork final : public UObject
{
public:
	class UDataTable*                             PBattleDataTable;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PCommuDataTable;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PEventDataTable;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PFieldDataTable;                                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PProgramDataTable;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PSystemDataTable;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PCounterDataTable;                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            BattleDataHashArry[0x200];                         // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            CommuDataHashArry[0xC00];                          // 0x2060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            EventDataHashArry[0xC00];                          // 0xE060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            FieldDataHashArry[0x1400];                         // 0x1A060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            ProgramDataHashArry[0x200];                        // 0x2E060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            SystemDataHashArry[0x200];                         // 0x30060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            CounterDataHashArry[0x181];                        // 0x32060(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         BattleDataHashNum;                                 // 0x33870(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CommuDataHashNum;                                  // 0x33874(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EventDataHashNum;                                  // 0x33878(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FieldDataHashNum;                                  // 0x3387C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ProgramDataHashNum;                                // 0x33880(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SystemDataHashNum;                                 // 0x33884(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CounterDataHashNum;                                // 0x33888(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3388C[0x4];                                    // 0x3388C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MFldLocalFlagDataTable_;                           // 0x33890(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            MFldLocalFlagDataHashArry_[0x100];                 // 0x33898(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         MFldLocalFlagDataHashNum_;                         // 0x34898(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3489C[0x4];                                    // 0x3489C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MFldLocalCounterDataTable_;                        // 0x348A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            MFldLocalCounterDataHashArry_[0x100];              // 0x348A8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         MFldLocalCounterDataHashNum_;                      // 0x358A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358AC[0x4];                                    // 0x358AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MFldNpcFlagDataTable_;                             // 0x358B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGWHashBase                            MFldNpcFlagDataHashArry_[0x100];                   // 0x358B8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         MFldNpcFlagDataHashNum_;                           // 0x368B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368BC[0x4];                                    // 0x368BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GWFlagWork">();
	}
	static class UGWFlagWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGWFlagWork>();
	}
};
static_assert(alignof(UGWFlagWork) == 0x000008, "Wrong alignment on UGWFlagWork");
static_assert(sizeof(UGWFlagWork) == 0x0368C0, "Wrong size on UGWFlagWork");
static_assert(offsetof(UGWFlagWork, PBattleDataTable) == 0x000028, "Member 'UGWFlagWork::PBattleDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PCommuDataTable) == 0x000030, "Member 'UGWFlagWork::PCommuDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PEventDataTable) == 0x000038, "Member 'UGWFlagWork::PEventDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PFieldDataTable) == 0x000040, "Member 'UGWFlagWork::PFieldDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PProgramDataTable) == 0x000048, "Member 'UGWFlagWork::PProgramDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PSystemDataTable) == 0x000050, "Member 'UGWFlagWork::PSystemDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, PCounterDataTable) == 0x000058, "Member 'UGWFlagWork::PCounterDataTable' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, BattleDataHashArry) == 0x000060, "Member 'UGWFlagWork::BattleDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, CommuDataHashArry) == 0x002060, "Member 'UGWFlagWork::CommuDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, EventDataHashArry) == 0x00E060, "Member 'UGWFlagWork::EventDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, FieldDataHashArry) == 0x01A060, "Member 'UGWFlagWork::FieldDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, ProgramDataHashArry) == 0x02E060, "Member 'UGWFlagWork::ProgramDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, SystemDataHashArry) == 0x030060, "Member 'UGWFlagWork::SystemDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, CounterDataHashArry) == 0x032060, "Member 'UGWFlagWork::CounterDataHashArry' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, BattleDataHashNum) == 0x033870, "Member 'UGWFlagWork::BattleDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, CommuDataHashNum) == 0x033874, "Member 'UGWFlagWork::CommuDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, EventDataHashNum) == 0x033878, "Member 'UGWFlagWork::EventDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, FieldDataHashNum) == 0x03387C, "Member 'UGWFlagWork::FieldDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, ProgramDataHashNum) == 0x033880, "Member 'UGWFlagWork::ProgramDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, SystemDataHashNum) == 0x033884, "Member 'UGWFlagWork::SystemDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, CounterDataHashNum) == 0x033888, "Member 'UGWFlagWork::CounterDataHashNum' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalFlagDataTable_) == 0x033890, "Member 'UGWFlagWork::MFldLocalFlagDataTable_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalFlagDataHashArry_) == 0x033898, "Member 'UGWFlagWork::MFldLocalFlagDataHashArry_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalFlagDataHashNum_) == 0x034898, "Member 'UGWFlagWork::MFldLocalFlagDataHashNum_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalCounterDataTable_) == 0x0348A0, "Member 'UGWFlagWork::MFldLocalCounterDataTable_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalCounterDataHashArry_) == 0x0348A8, "Member 'UGWFlagWork::MFldLocalCounterDataHashArry_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldLocalCounterDataHashNum_) == 0x0358A8, "Member 'UGWFlagWork::MFldLocalCounterDataHashNum_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldNpcFlagDataTable_) == 0x0358B0, "Member 'UGWFlagWork::MFldNpcFlagDataTable_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldNpcFlagDataHashArry_) == 0x0358B8, "Member 'UGWFlagWork::MFldNpcFlagDataHashArry_' has a wrong offset!");
static_assert(offsetof(UGWFlagWork, MFldNpcFlagDataHashNum_) == 0x0368B8, "Member 'UGWFlagWork::MFldNpcFlagDataHashNum_' has a wrong offset!");

// Class xrd777.HandwritingEffectBase
// 0x0010 (0x0288 - 0x0278)
class AHandwritingEffectBase final : public AAppActor
{
public:
	class UNiagaraComponent*                      NiagaraComp;                                       // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtomComponent*                         AtomComp;                                          // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandwritingEffectBase">();
	}
	static class AHandwritingEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHandwritingEffectBase>();
	}
};
static_assert(alignof(AHandwritingEffectBase) == 0x000008, "Wrong alignment on AHandwritingEffectBase");
static_assert(sizeof(AHandwritingEffectBase) == 0x000288, "Wrong size on AHandwritingEffectBase");
static_assert(offsetof(AHandwritingEffectBase, NiagaraComp) == 0x000278, "Member 'AHandwritingEffectBase::NiagaraComp' has a wrong offset!");
static_assert(offsetof(AHandwritingEffectBase, AtomComp) == 0x000280, "Member 'AHandwritingEffectBase::AtomComp' has a wrong offset!");

// Class xrd777.HandwritingSpawner
// 0x0160 (0x03D8 - 0x0278)
class AHandwritingSpawner : public AAppActor
{
public:
	TSubclassOf<class AHandwritingEffectBase>     HandwritingEffectObj;                              // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlHandwritingGroupType                      HandwritingGroupType;                              // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyWhenFinishedHandwriting;               // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0x6];                                      // 0x0282(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtlHandwritingDataAsset*               DataAsset;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtlHandwritingNiagaraRequestParam     NiagaraRequestedParam;                             // 0x0290(0x0038)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHandwritingSpawnRules                        SpawnRule;                                         // 0x02C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAtlEvtHandwritingType                        HandwritingType;                                   // 0x02C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AHandwritingEffectBase>  HandwritingEffectBaseActor;                        // 0x02CC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UNiagaraComponent>       HandwritingComp;                                   // 0x02D4(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0xFC];                                     // 0x02DC(0x00FC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadEffectEnded();
	void OnCompleteNiagara(class UNiagaraComponent* PSystem);
	void RequestPlayEffect(EAtlEvtHandwritingType InType, EHandwritingSpawnRules InSpawnRule, bool bInLoop);
	void RequestPlayEffectAtSpawnerAttachedTo(EAtlEvtHandwritingType InType, class ACharacter* Character, class FName AttachSocketName, EHandwritingSpawnRules InSpawnRule, bool bInLoop, const struct FVector& InLocation, const struct FRotator& InRotator, int32 InLoopCount, int32 InCameraOffset, const struct FVector& InScale);
	void RequestPlayEffectAtSpawnerAttachedToNpc(EAtlEvtHandwritingType InType, class ANpcBaseCore* NpcBase, class FName AttachSocketName, EHandwritingSpawnRules InSpawnRule, bool bInLoop, const struct FVector& InLocation, const struct FRotator& InRotator, int32 InLoopCount, int32 InCameraOffset, const struct FVector& InScale);
	void RequestPlayEffectAtSpawnerLocation(EAtlEvtHandwritingType InType, bool bInLoop, const struct FVector& InLocation, const struct FRotator& InRotator, int32 InLoopCount, int32 InCameraOffset, const struct FVector& InScale);
	void RequestPlayEffectFromParam(EAtlEvtHandwritingType InType, const struct FAtlHandwritingNiagaraRequestParam& InParam, EHandwritingSpawnRules InSpawnRule, bool bInLoop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandwritingSpawner">();
	}
	static class AHandwritingSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHandwritingSpawner>();
	}
};
static_assert(alignof(AHandwritingSpawner) == 0x000008, "Wrong alignment on AHandwritingSpawner");
static_assert(sizeof(AHandwritingSpawner) == 0x0003D8, "Wrong size on AHandwritingSpawner");
static_assert(offsetof(AHandwritingSpawner, HandwritingEffectObj) == 0x000278, "Member 'AHandwritingSpawner::HandwritingEffectObj' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, HandwritingGroupType) == 0x000280, "Member 'AHandwritingSpawner::HandwritingGroupType' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, bAutoDestroyWhenFinishedHandwriting) == 0x000281, "Member 'AHandwritingSpawner::bAutoDestroyWhenFinishedHandwriting' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, DataAsset) == 0x000288, "Member 'AHandwritingSpawner::DataAsset' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, NiagaraRequestedParam) == 0x000290, "Member 'AHandwritingSpawner::NiagaraRequestedParam' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, SpawnRule) == 0x0002C8, "Member 'AHandwritingSpawner::SpawnRule' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, HandwritingType) == 0x0002C9, "Member 'AHandwritingSpawner::HandwritingType' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, HandwritingEffectBaseActor) == 0x0002CC, "Member 'AHandwritingSpawner::HandwritingEffectBaseActor' has a wrong offset!");
static_assert(offsetof(AHandwritingSpawner, HandwritingComp) == 0x0002D4, "Member 'AHandwritingSpawner::HandwritingComp' has a wrong offset!");

// Class xrd777.TitleStateNewGame
// 0x0088 (0x00C0 - 0x0038)
class UTitleStateNewGame final : public UTitleStateBase
{
public:
	class UAddContent*                            AddContentCheck;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADifficultySelectionActor*              DifficultySelection;                               // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADifficultySelectionActor>  DifficultySelectionSC;                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x68];                                      // 0x0058(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCanselDifficultySelection();
	void OnCloseDifficultySelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateNewGame">();
	}
	static class UTitleStateNewGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateNewGame>();
	}
};
static_assert(alignof(UTitleStateNewGame) == 0x000008, "Wrong alignment on UTitleStateNewGame");
static_assert(sizeof(UTitleStateNewGame) == 0x0000C0, "Wrong size on UTitleStateNewGame");
static_assert(offsetof(UTitleStateNewGame, AddContentCheck) == 0x000038, "Member 'UTitleStateNewGame::AddContentCheck' has a wrong offset!");
static_assert(offsetof(UTitleStateNewGame, Loader) == 0x000040, "Member 'UTitleStateNewGame::Loader' has a wrong offset!");
static_assert(offsetof(UTitleStateNewGame, DifficultySelection) == 0x000048, "Member 'UTitleStateNewGame::DifficultySelection' has a wrong offset!");
static_assert(offsetof(UTitleStateNewGame, DifficultySelectionSC) == 0x000050, "Member 'UTitleStateNewGame::DifficultySelectionSC' has a wrong offset!");

// Class xrd777.HandwritingSubsystem
// 0x0118 (0x0148 - 0x0030)
class UHandwritingSubsystem final : public UGameInstanceSubsystem
{
public:
	class UAtlHandwritingDataAsset*               HandwritingDataAsset;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAtlEvtHandwritingType, TSoftClassPtr<class UClass>> PreloadedHandwritingEffectObjMap;                  // 0x0038(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EAtlEvtHandwritingType, TSoftClassPtr<class UClass>> PreloadedHandwritingEffectObjMap_Field;            // 0x0088(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EAtlEvtHandwritingType, TSoftClassPtr<class UClass>> PreloadedHandwritingEffectObjMap_Event;            // 0x00D8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AHandwritingSpawner>        HandwritingSpawnerDefaultClass;                    // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AHandwritingSpawner>> HandwritingSpawnerClassArray;                      // 0x0130(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetAdjustedAllLayoutData(EHandwritingLayout InIndexPosRot, struct FVector* OutPosition, float* OutAngle, EHandwritingLayout InIndexScale, struct FVector* OutScale, float* OutSize);
	bool GetAdjustedCallingLayoutData(float* OutScale1, float* OutScale2, float* OutScale3);
	bool GetAdjustedDoubleExclamationLayoutData(struct FVector* OutPosition1, struct FVector* OutPosition2);
	bool GetAdjustedExclamationQuestionLayoutData(struct FVector* OutPosition1, struct FVector* OutPosition2, struct FVector* OutScale, float* OutScaleFloat);
	bool GetAdjustedLayoutData(EHandwritingLayout InIndex, struct FVector* OutPosition, float* OutAngle, float* OutScale);
	bool GetAdjustedLayoutPosition(EHandwritingLayout InIndex, struct FVector* OutPosition);
	bool GetAdjustedLayoutRotation(EHandwritingLayout InIndex, float* OutAngle);
	bool GetAdjustedLayoutScale(EHandwritingLayout InIndex, float* OutScale);
	bool GetAdjustedQuestionLayoutData(struct FVector* OutPosition1, struct FVector* OutPosition2, struct FVector* OutPosition3);
	bool GetAdjustedWhineLayoutData(struct FVector* OutPosition, struct FVector* OutScale, float* OutSize);
	bool GetAdjustedWoofLayoutData(struct FVector* OutPosition1, struct FVector* OutPosition2, struct FVector* OutPosition3, struct FVector* OutPosition4);
	bool IsPolandLanguage();
	class AHandwritingSpawner* SpawnHandwritingAtLocation(const class UObject* WorldContextObject, EAtlHandwritingGroupType GroupType, EAtlEvtHandwritingType Type, const struct FAtlHandwritingNiagaraRequestParam& InParam, bool bAutoDestroySpawner, bool InbLoop);
	class AHandwritingSpawner* SpawnHandwritingAttached(EAtlHandwritingGroupType GroupType, EAtlEvtHandwritingType Type, class ACharacter* Character, class FName AttachSocketName, EHandwritingSpawnRules InSpawnRule, const struct FAtlHandwritingNiagaraRequestParam& InParam, bool bAutoDestroySpawner, bool InbLoop);
	class AHandwritingSpawner* SpawnHandwritingAttachedNpc(EAtlHandwritingGroupType GroupType, EAtlEvtHandwritingType Type, class ANpcBaseCore* NpcBase, class FName AttachSocketName, EHandwritingSpawnRules InSpawnRule, const struct FAtlHandwritingNiagaraRequestParam& InParam, bool bAutoDestroySpawner, bool InbLoop);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandwritingSubsystem">();
	}
	static class UHandwritingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHandwritingSubsystem>();
	}
};
static_assert(alignof(UHandwritingSubsystem) == 0x000008, "Wrong alignment on UHandwritingSubsystem");
static_assert(sizeof(UHandwritingSubsystem) == 0x000148, "Wrong size on UHandwritingSubsystem");
static_assert(offsetof(UHandwritingSubsystem, HandwritingDataAsset) == 0x000030, "Member 'UHandwritingSubsystem::HandwritingDataAsset' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, PreloadedHandwritingEffectObjMap) == 0x000038, "Member 'UHandwritingSubsystem::PreloadedHandwritingEffectObjMap' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, PreloadedHandwritingEffectObjMap_Field) == 0x000088, "Member 'UHandwritingSubsystem::PreloadedHandwritingEffectObjMap_Field' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, PreloadedHandwritingEffectObjMap_Event) == 0x0000D8, "Member 'UHandwritingSubsystem::PreloadedHandwritingEffectObjMap_Event' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, HandwritingSpawnerDefaultClass) == 0x000128, "Member 'UHandwritingSubsystem::HandwritingSpawnerDefaultClass' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, HandwritingSpawnerClassArray) == 0x000130, "Member 'UHandwritingSubsystem::HandwritingSpawnerClassArray' has a wrong offset!");
static_assert(offsetof(UHandwritingSubsystem, LayoutDataTable) == 0x000140, "Member 'UHandwritingSubsystem::LayoutDataTable' has a wrong offset!");

// Class xrd777.HeroParameterHandle
// 0x0018 (0x0040 - 0x0028)
class UHeroParameterHandle final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeroParameterDataAsset*                PDataAsset;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParameterNameTable;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroParameterHandle">();
	}
	static class UHeroParameterHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroParameterHandle>();
	}
};
static_assert(alignof(UHeroParameterHandle) == 0x000008, "Wrong alignment on UHeroParameterHandle");
static_assert(sizeof(UHeroParameterHandle) == 0x000040, "Wrong size on UHeroParameterHandle");
static_assert(offsetof(UHeroParameterHandle, PDataAsset) == 0x000030, "Member 'UHeroParameterHandle::PDataAsset' has a wrong offset!");
static_assert(offsetof(UHeroParameterHandle, PParameterNameTable) == 0x000038, "Member 'UHeroParameterHandle::PParameterNameTable' has a wrong offset!");

// Class xrd777.HmModelTestActor
// 0x0130 (0x0350 - 0x0220)
class AHmModelTestActor final : public AActor
{
public:
	class UStaticMesh*                            MeshAry[0xA];                                      // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           PMayaCamera;                                       // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 POldCamera;                                        // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDarkHourWork                          Work;                                              // 0x0290(0x00C0)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HmModelTestActor">();
	}
	static class AHmModelTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHmModelTestActor>();
	}
};
static_assert(alignof(AHmModelTestActor) == 0x000008, "Wrong alignment on AHmModelTestActor");
static_assert(sizeof(AHmModelTestActor) == 0x000350, "Wrong size on AHmModelTestActor");
static_assert(offsetof(AHmModelTestActor, MeshAry) == 0x000220, "Member 'AHmModelTestActor::MeshAry' has a wrong offset!");
static_assert(offsetof(AHmModelTestActor, PMayaCamera) == 0x000270, "Member 'AHmModelTestActor::PMayaCamera' has a wrong offset!");
static_assert(offsetof(AHmModelTestActor, POldCamera) == 0x000278, "Member 'AHmModelTestActor::POldCamera' has a wrong offset!");
static_assert(offsetof(AHmModelTestActor, Work) == 0x000290, "Member 'AHmModelTestActor::Work' has a wrong offset!");

// Class xrd777.HT_UMGTestGameModeBase
// 0x0010 (0x02D0 - 0x02C0)
class AHT_UMGTestGameModeBase final : public AGameModeBase
{
public:
	TSubclassOf<class UUserWidget>                StartingWidgetClass;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            CurrentWidget;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeMenuWidget(TSubclassOf<class UUserWidget> NewWidgetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HT_UMGTestGameModeBase">();
	}
	static class AHT_UMGTestGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHT_UMGTestGameModeBase>();
	}
};
static_assert(alignof(AHT_UMGTestGameModeBase) == 0x000008, "Wrong alignment on AHT_UMGTestGameModeBase");
static_assert(sizeof(AHT_UMGTestGameModeBase) == 0x0002D0, "Wrong size on AHT_UMGTestGameModeBase");
static_assert(offsetof(AHT_UMGTestGameModeBase, StartingWidgetClass) == 0x0002C0, "Member 'AHT_UMGTestGameModeBase::StartingWidgetClass' has a wrong offset!");
static_assert(offsetof(AHT_UMGTestGameModeBase, CurrentWidget) == 0x0002C8, "Member 'AHT_UMGTestGameModeBase::CurrentWidget' has a wrong offset!");

// Class xrd777.HT_UMGTestPlayerController
// 0x0000 (0x0580 - 0x0580)
class AHT_UMGTestPlayerController final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HT_UMGTestPlayerController">();
	}
	static class AHT_UMGTestPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHT_UMGTestPlayerController>();
	}
};
static_assert(alignof(AHT_UMGTestPlayerController) == 0x000008, "Wrong alignment on AHT_UMGTestPlayerController");
static_assert(sizeof(AHT_UMGTestPlayerController) == 0x000580, "Wrong size on AHT_UMGTestPlayerController");

// Class xrd777.HttpBpLib
// 0x0000 (0x0028 - 0x0028)
class UHttpBpLib final : public UBlueprintFunctionLibrary
{
public:
	static void PostTeamsMessage(const class FString& URL, const class FString& Title, const class FString& Text);
	static void SpawnHttpActor(const class FString& BPActorReferencePath, const class FString& Arg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpBpLib">();
	}
	static class UHttpBpLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHttpBpLib>();
	}
};
static_assert(alignof(UHttpBpLib) == 0x000008, "Wrong alignment on UHttpBpLib");
static_assert(sizeof(UHttpBpLib) == 0x000028, "Wrong size on UHttpBpLib");

// Class xrd777.ResidentReloadActor
// 0x0010 (0x0288 - 0x0278)
class AResidentReloadActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResidentReloadActor">();
	}
	static class AResidentReloadActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResidentReloadActor>();
	}
};
static_assert(alignof(AResidentReloadActor) == 0x000008, "Wrong alignment on AResidentReloadActor");
static_assert(sizeof(AResidentReloadActor) == 0x000288, "Wrong size on AResidentReloadActor");

// Class xrd777.HumanParameterUpViewer
// 0x0030 (0x02C0 - 0x0290)
class AHumanParameterUpViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCmpHeroHumanStatus*                    PHeroParamSystem_;                                 // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpHeroHumanStatusDraw*                PHumanParamDraw_;                                  // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIScene*                               PScene;                                            // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanParameterUpViewer">();
	}
	static class AHumanParameterUpViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanParameterUpViewer>();
	}
};
static_assert(alignof(AHumanParameterUpViewer) == 0x000008, "Wrong alignment on AHumanParameterUpViewer");
static_assert(sizeof(AHumanParameterUpViewer) == 0x0002C0, "Wrong size on AHumanParameterUpViewer");
static_assert(offsetof(AHumanParameterUpViewer, PHeroParamSystem_) == 0x0002A8, "Member 'AHumanParameterUpViewer::PHeroParamSystem_' has a wrong offset!");
static_assert(offsetof(AHumanParameterUpViewer, PHumanParamDraw_) == 0x0002B0, "Member 'AHumanParameterUpViewer::PHumanParamDraw_' has a wrong offset!");
static_assert(offsetof(AHumanParameterUpViewer, PScene) == 0x0002B8, "Member 'AHumanParameterUpViewer::PScene' has a wrong offset!");

// Class xrd777.UITextDataAsset
// 0x0010 (0x0040 - 0x0030)
class UUITextDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FUITextTable>                   Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextDataAsset">();
	}
	static class UUITextDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextDataAsset>();
	}
};
static_assert(alignof(UUITextDataAsset) == 0x000008, "Wrong alignment on UUITextDataAsset");
static_assert(sizeof(UUITextDataAsset) == 0x000040, "Wrong size on UUITextDataAsset");
static_assert(offsetof(UUITextDataAsset, Data) == 0x000030, "Member 'UUITextDataAsset::Data' has a wrong offset!");

// Class xrd777.IKAnimInstanceBase
// 0x0070 (0x0330 - 0x02C0)
class UIKAnimInstanceBase final : public UAnimInstance
{
public:
	float                                         MoveSpeed;                                         // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingFootIK;                                      // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootIK;                                     // 0x02BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BE[0x22];                                     // 0x02BE(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftFootOffset;                                    // 0x02E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightFootOffset;                                   // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationOffsetInterpSpeed;                         // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZOffsetInterpSpeed;                                // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisOffset;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MinLimitStanding;                                  // 0x0304(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MaxLimitStanding;                                  // 0x0310(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootIKSocketName;                              // 0x031C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootIKSocketName;                             // 0x0324(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateLocomotionTick(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKAnimInstanceBase">();
	}
	static class UIKAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKAnimInstanceBase>();
	}
};
static_assert(alignof(UIKAnimInstanceBase) == 0x000010, "Wrong alignment on UIKAnimInstanceBase");
static_assert(sizeof(UIKAnimInstanceBase) == 0x000330, "Wrong size on UIKAnimInstanceBase");
static_assert(offsetof(UIKAnimInstanceBase, MoveSpeed) == 0x0002B8, "Member 'UIKAnimInstanceBase::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, bUsingFootIK) == 0x0002BC, "Member 'UIKAnimInstanceBase::bUsingFootIK' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, bEnableFootIK) == 0x0002BD, "Member 'UIKAnimInstanceBase::bEnableFootIK' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, LeftFootOffset) == 0x0002E0, "Member 'UIKAnimInstanceBase::LeftFootOffset' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, RightFootOffset) == 0x0002EC, "Member 'UIKAnimInstanceBase::RightFootOffset' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, RotationOffsetInterpSpeed) == 0x0002F8, "Member 'UIKAnimInstanceBase::RotationOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, ZOffsetInterpSpeed) == 0x0002FC, "Member 'UIKAnimInstanceBase::ZOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, PelvisOffset) == 0x000300, "Member 'UIKAnimInstanceBase::PelvisOffset' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, MinLimitStanding) == 0x000304, "Member 'UIKAnimInstanceBase::MinLimitStanding' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, MaxLimitStanding) == 0x000310, "Member 'UIKAnimInstanceBase::MaxLimitStanding' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, LeftFootIKSocketName) == 0x00031C, "Member 'UIKAnimInstanceBase::LeftFootIKSocketName' has a wrong offset!");
static_assert(offsetof(UIKAnimInstanceBase, RightFootIKSocketName) == 0x000324, "Member 'UIKAnimInstanceBase::RightFootIKSocketName' has a wrong offset!");

// Class xrd777.IKCharacterBase
// 0x0070 (0x0530 - 0x04C0)
class AIKCharacterBase final : public ACharacter
{
public:
	class USkeletalMeshComponent*                 IKMeshComp;                                        // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIKAnimInstanceBase*                    IKAnimInstance;                                    // 0x04C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFootIKSetupParam                      IKSetupParam;                                      // 0x04C8(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultCapsuleHalfHeight;                          // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TestLeg;                                           // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x40];                                     // 0x04F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableIK();
	void EnableIK();
	void InitializeIKSetup(bool bEnable, class USkeletalMeshComponent* InTargetMesh, class UIKAnimInstanceBase* InIKAnimInstance);
	void TickUpdateIK(float DeltaSeconds);
	void UpdateAnimInstanceParams();
	void UpdateCapsuleHalfHeight(float HipOffset, bool bResetCapsule, float DeltaSeconds);
	void UpdateInterpFloat(float& Value, float Target, float InterpSpeed, float DeltaSeconds);
	void UpdateInterpRotator(struct FRotator& Value, const struct FRotator& Target, float InterpSpeed, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKCharacterBase">();
	}
	static class AIKCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIKCharacterBase>();
	}
};
static_assert(alignof(AIKCharacterBase) == 0x000010, "Wrong alignment on AIKCharacterBase");
static_assert(sizeof(AIKCharacterBase) == 0x000530, "Wrong size on AIKCharacterBase");
static_assert(offsetof(AIKCharacterBase, IKMeshComp) == 0x0004B8, "Member 'AIKCharacterBase::IKMeshComp' has a wrong offset!");
static_assert(offsetof(AIKCharacterBase, IKAnimInstance) == 0x0004C0, "Member 'AIKCharacterBase::IKAnimInstance' has a wrong offset!");
static_assert(offsetof(AIKCharacterBase, IKSetupParam) == 0x0004C8, "Member 'AIKCharacterBase::IKSetupParam' has a wrong offset!");
static_assert(offsetof(AIKCharacterBase, DefaultCapsuleHalfHeight) == 0x0004E8, "Member 'AIKCharacterBase::DefaultCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(AIKCharacterBase, TestLeg) == 0x0004EC, "Member 'AIKCharacterBase::TestLeg' has a wrong offset!");

// Class xrd777.IkedaTestMenu
// 0x0010 (0x0288 - 0x0278)
class AIkedaTestMenu final : public AAppActor
{
public:
	class AActor*                                 _Actor;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             _DebugMenu;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IkedaTestMenu">();
	}
	static class AIkedaTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIkedaTestMenu>();
	}
};
static_assert(alignof(AIkedaTestMenu) == 0x000008, "Wrong alignment on AIkedaTestMenu");
static_assert(sizeof(AIkedaTestMenu) == 0x000288, "Wrong size on AIkedaTestMenu");
static_assert(offsetof(AIkedaTestMenu, _Actor) == 0x000278, "Member 'AIkedaTestMenu::_Actor' has a wrong offset!");
static_assert(offsetof(AIkedaTestMenu, _DebugMenu) == 0x000280, "Member 'AIkedaTestMenu::_DebugMenu' has a wrong offset!");

// Class xrd777.NetworkWindowTest
// 0x0008 (0x0298 - 0x0290)
class ANetworkWindowTest final : public ADebugViewer
{
public:
	class AUISystemMsgActor*                      PDialog;                                           // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkWindowTest">();
	}
	static class ANetworkWindowTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANetworkWindowTest>();
	}
};
static_assert(alignof(ANetworkWindowTest) == 0x000008, "Wrong alignment on ANetworkWindowTest");
static_assert(sizeof(ANetworkWindowTest) == 0x000298, "Wrong size on ANetworkWindowTest");
static_assert(offsetof(ANetworkWindowTest, PDialog) == 0x000290, "Member 'ANetworkWindowTest::PDialog' has a wrong offset!");

// Class xrd777.ImanishiTestMenu
// 0x0028 (0x02A0 - 0x0278)
class AImanishiTestMenu final : public AAppActor
{
public:
	class AActor*                                 Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUICloudCursorDraw*                     CloudCursor_;                                      // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAddContentDialog*                      AdcDialog_;                                        // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImanishiTestMenu">();
	}
	static class AImanishiTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AImanishiTestMenu>();
	}
};
static_assert(alignof(AImanishiTestMenu) == 0x000008, "Wrong alignment on AImanishiTestMenu");
static_assert(sizeof(AImanishiTestMenu) == 0x0002A0, "Wrong size on AImanishiTestMenu");
static_assert(offsetof(AImanishiTestMenu, Actor_) == 0x000278, "Member 'AImanishiTestMenu::Actor_' has a wrong offset!");
static_assert(offsetof(AImanishiTestMenu, CloudCursor_) == 0x000280, "Member 'AImanishiTestMenu::CloudCursor_' has a wrong offset!");
static_assert(offsetof(AImanishiTestMenu, AdcDialog_) == 0x000288, "Member 'AImanishiTestMenu::AdcDialog_' has a wrong offset!");
static_assert(offsetof(AImanishiTestMenu, BmdAsset_) == 0x000290, "Member 'AImanishiTestMenu::BmdAsset_' has a wrong offset!");
static_assert(offsetof(AImanishiTestMenu, DebugMenu_) == 0x000298, "Member 'AImanishiTestMenu::DebugMenu_' has a wrong offset!");

// Class xrd777.UIDateDraw
// 0x0558 (0x07F8 - 0x02A0)
class AUIDateDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAgePanel*                              M_pAgePanel;                                       // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pFieldSpr;                                       // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pFieldSprAstrea;                                 // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x518];                                    // 0x02C0(0x0518)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x07D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x07E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutDataAstrea;                                  // 0x07E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTableAstrea;                             // 0x07F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDateDraw">();
	}
	static class AUIDateDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDateDraw>();
	}
};
static_assert(alignof(AUIDateDraw) == 0x000008, "Wrong alignment on AUIDateDraw");
static_assert(sizeof(AUIDateDraw) == 0x0007F8, "Wrong size on AUIDateDraw");
static_assert(offsetof(AUIDateDraw, M_pAgePanel) == 0x0002A8, "Member 'AUIDateDraw::M_pAgePanel' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, M_pFieldSpr) == 0x0002B0, "Member 'AUIDateDraw::M_pFieldSpr' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, M_pFieldSprAstrea) == 0x0002B8, "Member 'AUIDateDraw::M_pFieldSprAstrea' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, LayoutData) == 0x0007D8, "Member 'AUIDateDraw::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, LayoutDataTable) == 0x0007E0, "Member 'AUIDateDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, LayoutDataAstrea) == 0x0007E8, "Member 'AUIDateDraw::LayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(AUIDateDraw, LayoutDataTableAstrea) == 0x0007F0, "Member 'AUIDateDraw::LayoutDataTableAstrea' has a wrong offset!");

// Class xrd777.InitReadActor
// 0x0018 (0x0290 - 0x0278)
class AInitReadActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitReadActor">();
	}
	static class AInitReadActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInitReadActor>();
	}
};
static_assert(alignof(AInitReadActor) == 0x000008, "Wrong alignment on AInitReadActor");
static_assert(sizeof(AInitReadActor) == 0x000290, "Wrong size on AInitReadActor");

// Class xrd777.MsgAssist
// 0x0000 (0x00B0 - 0x00B0)
class UMsgAssist final : public UMsgItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgAssist">();
	}
	static class UMsgAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgAssist>();
	}
};
static_assert(alignof(UMsgAssist) == 0x000008, "Wrong alignment on UMsgAssist");
static_assert(sizeof(UMsgAssist) == 0x0000B0, "Wrong size on UMsgAssist");

// Class xrd777.Sequence
// 0x0048 (0x0070 - 0x0028)
class USequence final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Sequence">();
	}
	static class USequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequence>();
	}
};
static_assert(alignof(USequence) == 0x000008, "Wrong alignment on USequence");
static_assert(sizeof(USequence) == 0x000070, "Wrong size on USequence");

// Class xrd777.KernelInput
// 0x0000 (0x2840 - 0x2840)
class AKernelInput : public AInputManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KernelInput">();
	}
	static class AKernelInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKernelInput>();
	}
};
static_assert(alignof(AKernelInput) == 0x000008, "Wrong alignment on AKernelInput");
static_assert(sizeof(AKernelInput) == 0x002840, "Wrong size on AKernelInput");

// Class xrd777.UIDialogDouble
// 0x0060 (0x0310 - 0x02B0)
class AUIDialogDouble final : public AUIDialogBase
{
public:
	uint8                                         Pad_2B0[0x30];                                     // 0x02B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstChoices;                                      // 0x02E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SecondChoices;                                     // 0x02F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PCmpMainActor;                                     // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDialogDouble">();
	}
	static class AUIDialogDouble* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDialogDouble>();
	}
};
static_assert(alignof(AUIDialogDouble) == 0x000008, "Wrong alignment on AUIDialogDouble");
static_assert(sizeof(AUIDialogDouble) == 0x000310, "Wrong size on AUIDialogDouble");
static_assert(offsetof(AUIDialogDouble, FirstChoices) == 0x0002E0, "Member 'AUIDialogDouble::FirstChoices' has a wrong offset!");
static_assert(offsetof(AUIDialogDouble, SecondChoices) == 0x0002F0, "Member 'AUIDialogDouble::SecondChoices' has a wrong offset!");
static_assert(offsetof(AUIDialogDouble, PCmpMainActor) == 0x000308, "Member 'AUIDialogDouble::PCmpMainActor' has a wrong offset!");

// Class xrd777.ItfController
// 0x0108 (0x2948 - 0x2840)
class AItfController final : public AKernelInput
{
public:
	uint8                                         Pad_2840[0x108];                                   // 0x2840(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItfController">();
	}
	static class AItfController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItfController>();
	}
};
static_assert(alignof(AItfController) == 0x000008, "Wrong alignment on AItfController");
static_assert(sizeof(AItfController) == 0x002948, "Wrong size on AItfController");

// Class xrd777.MsgDictionary
// 0x0018 (0x00C8 - 0x00B0)
class UMsgDictionary final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgDictionary">();
	}
	static class UMsgDictionary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgDictionary>();
	}
};
static_assert(alignof(UMsgDictionary) == 0x000008, "Wrong alignment on UMsgDictionary");
static_assert(sizeof(UMsgDictionary) == 0x0000C8, "Wrong size on UMsgDictionary");

// Class xrd777.MsgDLC
// 0x0018 (0x00C8 - 0x00B0)
class UMsgDLC final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgDLC">();
	}
	static class UMsgDLC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgDLC>();
	}
};
static_assert(alignof(UMsgDLC) == 0x000008, "Wrong alignment on UMsgDLC");
static_assert(sizeof(UMsgDLC) == 0x0000C8, "Wrong size on UMsgDLC");

// Class xrd777.MessageDialog
// 0x0020 (0x0048 - 0x0028)
class UMessageDialog final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageDialog">();
	}
	static class UMessageDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageDialog>();
	}
};
static_assert(alignof(UMessageDialog) == 0x000008, "Wrong alignment on UMessageDialog");
static_assert(sizeof(UMessageDialog) == 0x000048, "Wrong size on UMessageDialog");

// Class xrd777.MsgMessage
// 0x0000 (0x00B0 - 0x00B0)
class UMsgMessage final : public UMsgItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgMessage">();
	}
	static class UMsgMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgMessage>();
	}
};
static_assert(alignof(UMsgMessage) == 0x000008, "Wrong alignment on UMsgMessage");
static_assert(sizeof(UMsgMessage) == 0x0000B0, "Wrong size on UMsgMessage");

// Class xrd777.UIDrawGamerTag
// 0x0000 (0x0260 - 0x0260)
class UUIDrawGamerTag final : public UUserWidget
{
public:
	void DebugOnDestroy();
	void SetNameText(const class FString& NameText);
	void SetScale(float Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDrawGamerTag">();
	}
	static class UUIDrawGamerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDrawGamerTag>();
	}
};
static_assert(alignof(UUIDrawGamerTag) == 0x000008, "Wrong alignment on UUIDrawGamerTag");
static_assert(sizeof(UUIDrawGamerTag) == 0x000260, "Wrong size on UUIDrawGamerTag");

// Class xrd777.MsgMind
// 0x0010 (0x00C0 - 0x00B0)
class UMsgMind final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgMind">();
	}
	static class UMsgMind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgMind>();
	}
};
static_assert(alignof(UMsgMind) == 0x000008, "Wrong alignment on UMsgMind");
static_assert(sizeof(UMsgMind) == 0x0000C0, "Wrong size on UMsgMind");

// Class xrd777.MsgMindSubtitles
// 0x0060 (0x0110 - 0x00B0)
class UMsgMindSubtitles final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               PTexture;                                          // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgMindSubtitles">();
	}
	static class UMsgMindSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgMindSubtitles>();
	}
};
static_assert(alignof(UMsgMindSubtitles) == 0x000008, "Wrong alignment on UMsgMindSubtitles");
static_assert(sizeof(UMsgMindSubtitles) == 0x000110, "Wrong size on UMsgMindSubtitles");
static_assert(offsetof(UMsgMindSubtitles, PTexture) == 0x000100, "Member 'UMsgMindSubtitles::PTexture' has a wrong offset!");
static_assert(offsetof(UMsgMindSubtitles, PAssetLoader) == 0x000108, "Member 'UMsgMindSubtitles::PAssetLoader' has a wrong offset!");

// Class xrd777.MsgManager
// 0x00B0 (0x00D8 - 0x0028)
class UMsgManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMsgProcItem*>                   ProcList;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMsgItem*>                       MsgReleaseList;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             Simple_LayoutData;                                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SelectSimple_LayoutData;                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CS_A_LayoutData;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CS_A_LayoutDataTable;                              // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             AssistLayoutDataTextCol;                           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             AssistLayoutData;                                  // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BacklogLayoutDataTextCol;                          // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     AssistTextColLayoutDataTable;                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     AssistLayoutDataTable;                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     BacklogTextColLayoutDataTable;                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             Mind_LayoutData;                                   // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PCSAssetLoader;                                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgManager">();
	}
	static class UMsgManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgManager>();
	}
};
static_assert(alignof(UMsgManager) == 0x000008, "Wrong alignment on UMsgManager");
static_assert(sizeof(UMsgManager) == 0x0000D8, "Wrong size on UMsgManager");
static_assert(offsetof(UMsgManager, ProcList) == 0x000038, "Member 'UMsgManager::ProcList' has a wrong offset!");
static_assert(offsetof(UMsgManager, MsgReleaseList) == 0x000050, "Member 'UMsgManager::MsgReleaseList' has a wrong offset!");
static_assert(offsetof(UMsgManager, Simple_LayoutData) == 0x000070, "Member 'UMsgManager::Simple_LayoutData' has a wrong offset!");
static_assert(offsetof(UMsgManager, SelectSimple_LayoutData) == 0x000078, "Member 'UMsgManager::SelectSimple_LayoutData' has a wrong offset!");
static_assert(offsetof(UMsgManager, CS_A_LayoutData) == 0x000080, "Member 'UMsgManager::CS_A_LayoutData' has a wrong offset!");
static_assert(offsetof(UMsgManager, CS_A_LayoutDataTable) == 0x000088, "Member 'UMsgManager::CS_A_LayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgManager, AssistLayoutDataTextCol) == 0x000090, "Member 'UMsgManager::AssistLayoutDataTextCol' has a wrong offset!");
static_assert(offsetof(UMsgManager, AssistLayoutData) == 0x000098, "Member 'UMsgManager::AssistLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgManager, BacklogLayoutDataTextCol) == 0x0000A0, "Member 'UMsgManager::BacklogLayoutDataTextCol' has a wrong offset!");
static_assert(offsetof(UMsgManager, AssistTextColLayoutDataTable) == 0x0000A8, "Member 'UMsgManager::AssistTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgManager, AssistLayoutDataTable) == 0x0000B0, "Member 'UMsgManager::AssistLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgManager, BacklogTextColLayoutDataTable) == 0x0000B8, "Member 'UMsgManager::BacklogTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgManager, Mind_LayoutData) == 0x0000C0, "Member 'UMsgManager::Mind_LayoutData' has a wrong offset!");
static_assert(offsetof(UMsgManager, PAssetLoader) == 0x0000C8, "Member 'UMsgManager::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UMsgManager, PCSAssetLoader) == 0x0000D0, "Member 'UMsgManager::PCSAssetLoader' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaPackAnimationTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtCharaPackAnimationTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPackAnimationTrack">();
	}
	static class UMovieSceneEvtCharaPackAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPackAnimationTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPackAnimationTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPackAnimationTrack");
static_assert(sizeof(UMovieSceneEvtCharaPackAnimationTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtCharaPackAnimationTrack");
static_assert(offsetof(UMovieSceneEvtCharaPackAnimationTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtCharaPackAnimationTrack::Sections' has a wrong offset!");

// Class xrd777.MsgProcItem
// 0x0038 (0x0060 - 0x0028)
class UMsgProcItem final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMsgItem*                               PMsgItem;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USelItem*                               PSelItem;                                          // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcItem">();
	}
	static class UMsgProcItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcItem>();
	}
};
static_assert(alignof(UMsgProcItem) == 0x000008, "Wrong alignment on UMsgProcItem");
static_assert(sizeof(UMsgProcItem) == 0x000060, "Wrong size on UMsgProcItem");
static_assert(offsetof(UMsgProcItem, PMsgItem) == 0x000048, "Member 'UMsgProcItem::PMsgItem' has a wrong offset!");
static_assert(offsetof(UMsgProcItem, PSelItem) == 0x000050, "Member 'UMsgProcItem::PSelItem' has a wrong offset!");

// Class xrd777.MsgProcWindowBase
// 0x00E0 (0x0108 - 0x0028)
class UMsgProcWindowBase : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UMsgItem*                               PMsgWork;                                          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTutorialManager*                       PTutorialManager;                                  // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindowBase">();
	}
	static class UMsgProcWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindowBase>();
	}
};
static_assert(alignof(UMsgProcWindowBase) == 0x000008, "Wrong alignment on UMsgProcWindowBase");
static_assert(sizeof(UMsgProcWindowBase) == 0x000108, "Wrong size on UMsgProcWindowBase");
static_assert(offsetof(UMsgProcWindowBase, PMsgWork) == 0x000090, "Member 'UMsgProcWindowBase::PMsgWork' has a wrong offset!");
static_assert(offsetof(UMsgProcWindowBase, PTutorialManager) == 0x000098, "Member 'UMsgProcWindowBase::PTutorialManager' has a wrong offset!");

// Class xrd777.MsgProcWindow_Assist
// 0x00D0 (0x01D8 - 0x0108)
class UMsgProcWindow_Assist final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              MsgSpr_;                                           // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        SupportPos;                                        // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0xB0];                                     // 0x0128(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Assist">();
	}
	static class UMsgProcWindow_Assist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Assist>();
	}
};
static_assert(alignof(UMsgProcWindow_Assist) == 0x000008, "Wrong alignment on UMsgProcWindow_Assist");
static_assert(sizeof(UMsgProcWindow_Assist) == 0x0001D8, "Wrong size on UMsgProcWindow_Assist");
static_assert(offsetof(UMsgProcWindow_Assist, Loader_) == 0x000108, "Member 'UMsgProcWindow_Assist::Loader_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Assist, MsgSpr_) == 0x000110, "Member 'UMsgProcWindow_Assist::MsgSpr_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Assist, SupportPos) == 0x000118, "Member 'UMsgProcWindow_Assist::SupportPos' has a wrong offset!");

// Class xrd777.MsgProcWindow_Mind
// 0x0148 (0x0250 - 0x0108)
class UMsgProcWindow_Mind final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadMat_;                                          // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadaddMat_;                                       // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadblurMat_;                                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadlineMat_;                                      // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadMatInst_;                                      // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadaddMatInst_;                                   // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadblurMatInst_;                                  // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadlineMatInst_;                                  // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              _readSpr;                                          // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              MsgPlg_;                                           // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0xD8];                                     // 0x0160(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Mind">();
	}
	static class UMsgProcWindow_Mind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Mind>();
	}
};
static_assert(alignof(UMsgProcWindow_Mind) == 0x000008, "Wrong alignment on UMsgProcWindow_Mind");
static_assert(sizeof(UMsgProcWindow_Mind) == 0x000250, "Wrong size on UMsgProcWindow_Mind");
static_assert(offsetof(UMsgProcWindow_Mind, Loader_) == 0x000108, "Member 'UMsgProcWindow_Mind::Loader_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadMat_) == 0x000110, "Member 'UMsgProcWindow_Mind::ReadMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadaddMat_) == 0x000118, "Member 'UMsgProcWindow_Mind::ReadaddMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadblurMat_) == 0x000120, "Member 'UMsgProcWindow_Mind::ReadblurMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadlineMat_) == 0x000128, "Member 'UMsgProcWindow_Mind::ReadlineMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadMatInst_) == 0x000130, "Member 'UMsgProcWindow_Mind::ReadMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadaddMatInst_) == 0x000138, "Member 'UMsgProcWindow_Mind::ReadaddMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadblurMatInst_) == 0x000140, "Member 'UMsgProcWindow_Mind::ReadblurMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, ReadlineMatInst_) == 0x000148, "Member 'UMsgProcWindow_Mind::ReadlineMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, _readSpr) == 0x000150, "Member 'UMsgProcWindow_Mind::_readSpr' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, MsgPlg_) == 0x000158, "Member 'UMsgProcWindow_Mind::MsgPlg_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Mind, LayoutDataTable) == 0x000238, "Member 'UMsgProcWindow_Mind::LayoutDataTable' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaPropAttachTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtCharaPropAttachTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPropAttachTrack">();
	}
	static class UMovieSceneEvtCharaPropAttachTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPropAttachTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPropAttachTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPropAttachTrack");
static_assert(sizeof(UMovieSceneEvtCharaPropAttachTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtCharaPropAttachTrack");
static_assert(offsetof(UMovieSceneEvtCharaPropAttachTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtCharaPropAttachTrack::Sections' has a wrong offset!");

// Class xrd777.MsgProcWindow_Performance
// 0x0050 (0x0158 - 0x0108)
class UMsgProcWindow_Performance final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           M_pPerformanceLoader;                              // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItfMsgProgWindow_TUTRIALDraw> PerformanceDrawClass;                              // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItfMsgProgWindow_TUTRIALDraw*          PPerformanceDraw;                                  // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextColDataTable;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextColLayoutDataTable;                            // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextLayoutData;                                  // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextMaskLayoutData;                              // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Performance">();
	}
	static class UMsgProcWindow_Performance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Performance>();
	}
};
static_assert(alignof(UMsgProcWindow_Performance) == 0x000008, "Wrong alignment on UMsgProcWindow_Performance");
static_assert(sizeof(UMsgProcWindow_Performance) == 0x000158, "Wrong size on UMsgProcWindow_Performance");
static_assert(offsetof(UMsgProcWindow_Performance, M_pPerformanceLoader) == 0x000108, "Member 'UMsgProcWindow_Performance::M_pPerformanceLoader' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, PerformanceDrawClass) == 0x000110, "Member 'UMsgProcWindow_Performance::PerformanceDrawClass' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, PPerformanceDraw) == 0x000118, "Member 'UMsgProcWindow_Performance::PPerformanceDraw' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, TextColDataTable) == 0x000120, "Member 'UMsgProcWindow_Performance::TextColDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, TextColLayoutDataTable) == 0x000128, "Member 'UMsgProcWindow_Performance::TextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, OkNextLayoutData) == 0x000130, "Member 'UMsgProcWindow_Performance::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, OkNextLayoutDataTable) == 0x000138, "Member 'UMsgProcWindow_Performance::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, OkNextMaskLayoutData) == 0x000140, "Member 'UMsgProcWindow_Performance::OkNextMaskLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Performance, OkNextMaskLayoutDataTable) == 0x000148, "Member 'UMsgProcWindow_Performance::OkNextMaskLayoutDataTable' has a wrong offset!");

// Class xrd777.MsgProcWindow_Select
// 0x0008 (0x0110 - 0x0108)
class UMsgProcWindow_Select : public UMsgProcWindowBase
{
public:
	class USelItem*                               PSelWork;                                          // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Select">();
	}
	static class UMsgProcWindow_Select* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Select>();
	}
};
static_assert(alignof(UMsgProcWindow_Select) == 0x000008, "Wrong alignment on UMsgProcWindow_Select");
static_assert(sizeof(UMsgProcWindow_Select) == 0x000110, "Wrong size on UMsgProcWindow_Select");
static_assert(offsetof(UMsgProcWindow_Select, PSelWork) == 0x000108, "Member 'UMsgProcWindow_Select::PSelWork' has a wrong offset!");

// Class xrd777.MsgProcWindow_Select_Mind
// 0x0190 (0x02A0 - 0x0110)
class UMsgProcWindow_Select_Mind final : public UMsgProcWindow_Select
{
public:
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupObject*                          BustupObject_;                                     // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              MsgSpr_;                                           // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              MsgPlg_;                                           // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0xF0];                                     // 0x0140(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              MsgPlgExt_;                                        // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadInactiveMat_;                                  // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadAddBaseMat_;                                   // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadBaseMat_;                                      // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              ReadlineMat_;                                      // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadInactiveMatInst_;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadAddBaseMatInst_;                               // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadBaseMatInst_;                                  // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadlineMatInst_;                                  // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ReadLineUnderMatInst_;                             // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Select_Mind">();
	}
	static class UMsgProcWindow_Select_Mind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Select_Mind>();
	}
};
static_assert(alignof(UMsgProcWindow_Select_Mind) == 0x000008, "Wrong alignment on UMsgProcWindow_Select_Mind");
static_assert(sizeof(UMsgProcWindow_Select_Mind) == 0x0002A0, "Wrong size on UMsgProcWindow_Select_Mind");
static_assert(offsetof(UMsgProcWindow_Select_Mind, BustupObject_) == 0x000128, "Member 'UMsgProcWindow_Select_Mind::BustupObject_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, MsgSpr_) == 0x000130, "Member 'UMsgProcWindow_Select_Mind::MsgSpr_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, MsgPlg_) == 0x000138, "Member 'UMsgProcWindow_Select_Mind::MsgPlg_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, Loader_) == 0x000230, "Member 'UMsgProcWindow_Select_Mind::Loader_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, LayoutDataTable) == 0x000238, "Member 'UMsgProcWindow_Select_Mind::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, MsgPlgExt_) == 0x000240, "Member 'UMsgProcWindow_Select_Mind::MsgPlgExt_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadInactiveMat_) == 0x000248, "Member 'UMsgProcWindow_Select_Mind::ReadInactiveMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadAddBaseMat_) == 0x000250, "Member 'UMsgProcWindow_Select_Mind::ReadAddBaseMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadBaseMat_) == 0x000258, "Member 'UMsgProcWindow_Select_Mind::ReadBaseMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadlineMat_) == 0x000260, "Member 'UMsgProcWindow_Select_Mind::ReadlineMat_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadInactiveMatInst_) == 0x000268, "Member 'UMsgProcWindow_Select_Mind::ReadInactiveMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadAddBaseMatInst_) == 0x000270, "Member 'UMsgProcWindow_Select_Mind::ReadAddBaseMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadBaseMatInst_) == 0x000278, "Member 'UMsgProcWindow_Select_Mind::ReadBaseMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadlineMatInst_) == 0x000280, "Member 'UMsgProcWindow_Select_Mind::ReadlineMatInst_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Mind, ReadLineUnderMatInst_) == 0x000288, "Member 'UMsgProcWindow_Select_Mind::ReadLineUnderMatInst_' has a wrong offset!");

// Class xrd777.MsgProcWindow_Select_Simple
// 0x00C0 (0x01D0 - 0x0110)
class UMsgProcWindow_Select_Simple final : public UMsgProcWindow_Select
{
public:
	uint8                                         Pad_110[0x80];                                     // 0x0110(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UBustupObject*                          BustupObject_;                                     // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              MsgSpr_;                                           // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              MsgPlg_;                                           // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x20];                                     // 0x01B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Select_Simple">();
	}
	static class UMsgProcWindow_Select_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Select_Simple>();
	}
};
static_assert(alignof(UMsgProcWindow_Select_Simple) == 0x000008, "Wrong alignment on UMsgProcWindow_Select_Simple");
static_assert(sizeof(UMsgProcWindow_Select_Simple) == 0x0001D0, "Wrong size on UMsgProcWindow_Select_Simple");
static_assert(offsetof(UMsgProcWindow_Select_Simple, BustupObject_) == 0x000190, "Member 'UMsgProcWindow_Select_Simple::BustupObject_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Simple, MsgSpr_) == 0x000198, "Member 'UMsgProcWindow_Select_Simple::MsgSpr_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Simple, MsgPlg_) == 0x0001A0, "Member 'UMsgProcWindow_Select_Simple::MsgPlg_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Select_Simple, LayoutDataTable) == 0x0001A8, "Member 'UMsgProcWindow_Select_Simple::LayoutDataTable' has a wrong offset!");

// Class xrd777.MovieSceneEvtDialogueTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtDialogueTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtDialogueTrack">();
	}
	static class UMovieSceneEvtDialogueTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtDialogueTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtDialogueTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtDialogueTrack");
static_assert(sizeof(UMovieSceneEvtDialogueTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtDialogueTrack");
static_assert(offsetof(UMovieSceneEvtDialogueTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtDialogueTrack::Sections' has a wrong offset!");

// Class xrd777.MsgProcWindow_Simple
// 0x00B0 (0x01B8 - 0x0108)
class UMsgProcWindow_Simple final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           Loader_;                                           // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              MsgSpr_;                                           // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              MsgPlg_;                                           // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x90];                                     // 0x0120(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Simple">();
	}
	static class UMsgProcWindow_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Simple>();
	}
};
static_assert(alignof(UMsgProcWindow_Simple) == 0x000008, "Wrong alignment on UMsgProcWindow_Simple");
static_assert(sizeof(UMsgProcWindow_Simple) == 0x0001B8, "Wrong size on UMsgProcWindow_Simple");
static_assert(offsetof(UMsgProcWindow_Simple, Loader_) == 0x000108, "Member 'UMsgProcWindow_Simple::Loader_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Simple, MsgSpr_) == 0x000110, "Member 'UMsgProcWindow_Simple::MsgSpr_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Simple, MsgPlg_) == 0x000118, "Member 'UMsgProcWindow_Simple::MsgPlg_' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Simple, LayoutDataTable) == 0x0001B0, "Member 'UMsgProcWindow_Simple::LayoutDataTable' has a wrong offset!");

// Class xrd777.MsgProcWindow_System
// 0x0050 (0x0158 - 0x0108)
class UMsgProcWindow_System final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           M_pSystemLoader;                                   // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItfMsgProgWindow_TUTRIALDraw> SystemDrawClass;                                   // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItfMsgProgWindow_TUTRIALDraw*          PSystemDraw;                                       // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextColDataTable;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextColLayoutDataTable;                            // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextLayoutData;                                  // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextMaskLayoutData;                              // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_System">();
	}
	static class UMsgProcWindow_System* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_System>();
	}
};
static_assert(alignof(UMsgProcWindow_System) == 0x000008, "Wrong alignment on UMsgProcWindow_System");
static_assert(sizeof(UMsgProcWindow_System) == 0x000158, "Wrong size on UMsgProcWindow_System");
static_assert(offsetof(UMsgProcWindow_System, M_pSystemLoader) == 0x000108, "Member 'UMsgProcWindow_System::M_pSystemLoader' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, SystemDrawClass) == 0x000110, "Member 'UMsgProcWindow_System::SystemDrawClass' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, PSystemDraw) == 0x000118, "Member 'UMsgProcWindow_System::PSystemDraw' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, TextColDataTable) == 0x000120, "Member 'UMsgProcWindow_System::TextColDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, TextColLayoutDataTable) == 0x000128, "Member 'UMsgProcWindow_System::TextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, OkNextLayoutData) == 0x000130, "Member 'UMsgProcWindow_System::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, OkNextLayoutDataTable) == 0x000138, "Member 'UMsgProcWindow_System::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, OkNextMaskLayoutData) == 0x000140, "Member 'UMsgProcWindow_System::OkNextMaskLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_System, OkNextMaskLayoutDataTable) == 0x000148, "Member 'UMsgProcWindow_System::OkNextMaskLayoutDataTable' has a wrong offset!");

// Class xrd777.MsgProcWindow_Tutorial
// 0x0050 (0x0158 - 0x0108)
class UMsgProcWindow_Tutorial final : public UMsgProcWindowBase
{
public:
	class UAssetLoader*                           M_pTutrialLoader;                                  // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItfMsgProgWindow_TUTRIALDraw> TutrialDrawClass;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItfMsgProgWindow_TUTRIALDraw*          PTutrialDraw;                                      // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextColDataTable;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextColLayoutDataTable;                            // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextLayoutData;                                  // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextMaskLayoutData;                              // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgProcWindow_Tutorial">();
	}
	static class UMsgProcWindow_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgProcWindow_Tutorial>();
	}
};
static_assert(alignof(UMsgProcWindow_Tutorial) == 0x000008, "Wrong alignment on UMsgProcWindow_Tutorial");
static_assert(sizeof(UMsgProcWindow_Tutorial) == 0x000158, "Wrong size on UMsgProcWindow_Tutorial");
static_assert(offsetof(UMsgProcWindow_Tutorial, M_pTutrialLoader) == 0x000108, "Member 'UMsgProcWindow_Tutorial::M_pTutrialLoader' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, TutrialDrawClass) == 0x000110, "Member 'UMsgProcWindow_Tutorial::TutrialDrawClass' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, PTutrialDraw) == 0x000118, "Member 'UMsgProcWindow_Tutorial::PTutrialDraw' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, TextColDataTable) == 0x000120, "Member 'UMsgProcWindow_Tutorial::TextColDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, TextColLayoutDataTable) == 0x000128, "Member 'UMsgProcWindow_Tutorial::TextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, OkNextLayoutData) == 0x000130, "Member 'UMsgProcWindow_Tutorial::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, OkNextLayoutDataTable) == 0x000138, "Member 'UMsgProcWindow_Tutorial::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, OkNextMaskLayoutData) == 0x000140, "Member 'UMsgProcWindow_Tutorial::OkNextMaskLayoutData' has a wrong offset!");
static_assert(offsetof(UMsgProcWindow_Tutorial, OkNextMaskLayoutDataTable) == 0x000148, "Member 'UMsgProcWindow_Tutorial::OkNextMaskLayoutDataTable' has a wrong offset!");

// Class xrd777.itfMsgProgWindow_TUTRIALDraw
// 0x0270 (0x0528 - 0x02B8)
class AItfMsgProgWindow_TUTRIALDraw final : public AUIDrawBaseActor
{
public:
	float                                         FadeInNonThumbnailMovePosFrame;                    // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitNonThumbnailMovePosFrame;                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutNonThumbnailMovePosFrame;                   // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitNonThumbnailMovePosFrame;               // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInNonThumbnailAlphaFrame;                      // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitNonThumbnailAlphaFrame;                  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutNonThumbnailAlphaFrame;                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitNonThumbnailAlphaFrame;                 // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInThumbnailMovePosFrame;                       // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitThumbnailMovePosFrame;                   // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutThumbnailMovePosFrame;                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitThumbnailMovePosFrame;                  // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInThumbnailAlphaFrame;                         // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitThumbnailAlphaFrame;                     // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutThumbnailAlphaFrame;                        // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitThumbnailAlphaFrame;                    // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInThumbnailAngleFrame;                         // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitThumbnailAngleFrame;                     // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutThumbnailAngleFrame;                        // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitThumbnailAngleFrame;                    // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixThumbnailAngle;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixThumbnailPosX;                                  // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixThumbnailPosY;                                  // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixThumbnailPlusAngle;                             // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInGroundAlphaFrame;                            // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInWaitGroundAlphaFrame;                        // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutGroundAlphaFrame;                           // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutWaitGroundAlphaFrame;                       // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 NavyColor;                                         // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 GradationColor;                                    // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 UnderShadowColor;                                  // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BackColor;                                         // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutButtonFrame;                                // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutWaitButtonFrame;                            // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInButtonFrame;                                 // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInWaitButtonFrame;                             // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutTextFrame;                                  // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutWaitTextFrame;                              // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInTextFrame;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInWaitTextFrame;                               // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutTextAlphaFrame;                             // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutWaitTextAlphaFrame;                         // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInTextAlphaFrame;                              // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInWaitTextAlphaFrame;                          // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutThumbnailFrame;                             // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageOutWaitThumbnailFrame;                         // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInThumbnailFrame;                              // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageInWaitThumbnailFrame;                          // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InWaitThumbnailShadowFrame;                        // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InThumbnailShadowFrame;                            // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopWaitFrameFirst;                            // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopWaitFrameSecond;                           // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopWaitFrameThird;                            // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopMoveFrameFirst;                            // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopMoveFrameSecond;                           // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskLoopMoveFrameThird;                            // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleWaitFrameFirst;                         // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleWaitFrameSecond;                        // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleWaitFrameThird;                         // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleMoveFrameFirst;                         // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleMoveFrameSecond;                        // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ButtonScaleMoveFrameThird;                         // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Icon_Animation_Start_Delay;                   // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Icon_Angle_Frame;                             // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Icon_Angle_Delay;                             // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Icon_Scale_1Loop_Frame;                       // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x168];                                    // 0x03C0(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"itfMsgProgWindow_TUTRIALDraw">();
	}
	static class AItfMsgProgWindow_TUTRIALDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItfMsgProgWindow_TUTRIALDraw>();
	}
};
static_assert(alignof(AItfMsgProgWindow_TUTRIALDraw) == 0x000008, "Wrong alignment on AItfMsgProgWindow_TUTRIALDraw");
static_assert(sizeof(AItfMsgProgWindow_TUTRIALDraw) == 0x000528, "Wrong size on AItfMsgProgWindow_TUTRIALDraw");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInNonThumbnailMovePosFrame) == 0x0002B8, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInNonThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitNonThumbnailMovePosFrame) == 0x0002BC, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitNonThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutNonThumbnailMovePosFrame) == 0x0002C0, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutNonThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitNonThumbnailMovePosFrame) == 0x0002C4, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitNonThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInNonThumbnailAlphaFrame) == 0x0002C8, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInNonThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitNonThumbnailAlphaFrame) == 0x0002CC, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitNonThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutNonThumbnailAlphaFrame) == 0x0002D0, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutNonThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitNonThumbnailAlphaFrame) == 0x0002D4, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitNonThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInThumbnailMovePosFrame) == 0x0002D8, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitThumbnailMovePosFrame) == 0x0002DC, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutThumbnailMovePosFrame) == 0x0002E0, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitThumbnailMovePosFrame) == 0x0002E4, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitThumbnailMovePosFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInThumbnailAlphaFrame) == 0x0002E8, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitThumbnailAlphaFrame) == 0x0002EC, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutThumbnailAlphaFrame) == 0x0002F0, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitThumbnailAlphaFrame) == 0x0002F4, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitThumbnailAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInThumbnailAngleFrame) == 0x0002F8, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInThumbnailAngleFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitThumbnailAngleFrame) == 0x0002FC, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitThumbnailAngleFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutThumbnailAngleFrame) == 0x000300, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutThumbnailAngleFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitThumbnailAngleFrame) == 0x000304, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitThumbnailAngleFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FixThumbnailAngle) == 0x000308, "Member 'AItfMsgProgWindow_TUTRIALDraw::FixThumbnailAngle' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FixThumbnailPosX) == 0x00030C, "Member 'AItfMsgProgWindow_TUTRIALDraw::FixThumbnailPosX' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FixThumbnailPosY) == 0x000310, "Member 'AItfMsgProgWindow_TUTRIALDraw::FixThumbnailPosY' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FixThumbnailPlusAngle) == 0x000314, "Member 'AItfMsgProgWindow_TUTRIALDraw::FixThumbnailPlusAngle' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInGroundAlphaFrame) == 0x000318, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInGroundAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeInWaitGroundAlphaFrame) == 0x00031C, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeInWaitGroundAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutGroundAlphaFrame) == 0x000320, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutGroundAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, FadeOutWaitGroundAlphaFrame) == 0x000324, "Member 'AItfMsgProgWindow_TUTRIALDraw::FadeOutWaitGroundAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, NavyColor) == 0x000328, "Member 'AItfMsgProgWindow_TUTRIALDraw::NavyColor' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, GradationColor) == 0x00032C, "Member 'AItfMsgProgWindow_TUTRIALDraw::GradationColor' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, UnderShadowColor) == 0x000330, "Member 'AItfMsgProgWindow_TUTRIALDraw::UnderShadowColor' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, BackColor) == 0x000334, "Member 'AItfMsgProgWindow_TUTRIALDraw::BackColor' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutButtonFrame) == 0x000338, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutButtonFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutWaitButtonFrame) == 0x00033C, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutWaitButtonFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInButtonFrame) == 0x000340, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInButtonFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInWaitButtonFrame) == 0x000344, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInWaitButtonFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutTextFrame) == 0x000348, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutTextFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutWaitTextFrame) == 0x00034C, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutWaitTextFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInTextFrame) == 0x000350, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInTextFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInWaitTextFrame) == 0x000354, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInWaitTextFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutTextAlphaFrame) == 0x000358, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutTextAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutWaitTextAlphaFrame) == 0x00035C, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutWaitTextAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInTextAlphaFrame) == 0x000360, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInTextAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInWaitTextAlphaFrame) == 0x000364, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInWaitTextAlphaFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutThumbnailFrame) == 0x000368, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutThumbnailFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageOutWaitThumbnailFrame) == 0x00036C, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageOutWaitThumbnailFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInThumbnailFrame) == 0x000370, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInThumbnailFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, PageInWaitThumbnailFrame) == 0x000374, "Member 'AItfMsgProgWindow_TUTRIALDraw::PageInWaitThumbnailFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, InWaitThumbnailShadowFrame) == 0x000378, "Member 'AItfMsgProgWindow_TUTRIALDraw::InWaitThumbnailShadowFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, InThumbnailShadowFrame) == 0x00037C, "Member 'AItfMsgProgWindow_TUTRIALDraw::InThumbnailShadowFrame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopWaitFrameFirst) == 0x000380, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopWaitFrameFirst' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopWaitFrameSecond) == 0x000384, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopWaitFrameSecond' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopWaitFrameThird) == 0x000388, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopWaitFrameThird' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopMoveFrameFirst) == 0x00038C, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopMoveFrameFirst' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopMoveFrameSecond) == 0x000390, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopMoveFrameSecond' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, MaskLoopMoveFrameThird) == 0x000394, "Member 'AItfMsgProgWindow_TUTRIALDraw::MaskLoopMoveFrameThird' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleWaitFrameFirst) == 0x000398, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleWaitFrameFirst' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleWaitFrameSecond) == 0x00039C, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleWaitFrameSecond' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleWaitFrameThird) == 0x0003A0, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleWaitFrameThird' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleMoveFrameFirst) == 0x0003A4, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleMoveFrameFirst' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleMoveFrameSecond) == 0x0003A8, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleMoveFrameSecond' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, ButtonScaleMoveFrameThird) == 0x0003AC, "Member 'AItfMsgProgWindow_TUTRIALDraw::ButtonScaleMoveFrameThird' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, Edit_Icon_Animation_Start_Delay) == 0x0003B0, "Member 'AItfMsgProgWindow_TUTRIALDraw::Edit_Icon_Animation_Start_Delay' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, Edit_Icon_Angle_Frame) == 0x0003B4, "Member 'AItfMsgProgWindow_TUTRIALDraw::Edit_Icon_Angle_Frame' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, Edit_Icon_Angle_Delay) == 0x0003B8, "Member 'AItfMsgProgWindow_TUTRIALDraw::Edit_Icon_Angle_Delay' has a wrong offset!");
static_assert(offsetof(AItfMsgProgWindow_TUTRIALDraw, Edit_Icon_Scale_1Loop_Frame) == 0x0003BC, "Member 'AItfMsgProgWindow_TUTRIALDraw::Edit_Icon_Scale_1Loop_Frame' has a wrong offset!");

// Class xrd777.MovieSceneEvtFieldAnimationTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtFieldAnimationTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtFieldAnimationTrack">();
	}
	static class UMovieSceneEvtFieldAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtFieldAnimationTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtFieldAnimationTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtFieldAnimationTrack");
static_assert(sizeof(UMovieSceneEvtFieldAnimationTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtFieldAnimationTrack");
static_assert(offsetof(UMovieSceneEvtFieldAnimationTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtFieldAnimationTrack::Sections' has a wrong offset!");

// Class xrd777.MsgWork
// 0x0020 (0x0048 - 0x0028)
class UMsgWork final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMsgManager*                            PMsgManager;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialManager*                       PTutorialManager;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgWork">();
	}
	static class UMsgWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgWork>();
	}
};
static_assert(alignof(UMsgWork) == 0x000008, "Wrong alignment on UMsgWork");
static_assert(sizeof(UMsgWork) == 0x000048, "Wrong size on UMsgWork");
static_assert(offsetof(UMsgWork, PMsgManager) == 0x000038, "Member 'UMsgWork::PMsgManager' has a wrong offset!");
static_assert(offsetof(UMsgWork, PTutorialManager) == 0x000040, "Member 'UMsgWork::PTutorialManager' has a wrong offset!");

// Class xrd777.MsgPerformance
// 0x0030 (0x00E0 - 0x00B0)
class UMsgPerformance final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgPerformance">();
	}
	static class UMsgPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgPerformance>();
	}
};
static_assert(alignof(UMsgPerformance) == 0x000008, "Wrong alignment on UMsgPerformance");
static_assert(sizeof(UMsgPerformance) == 0x0000E0, "Wrong size on UMsgPerformance");

// Class xrd777.SelAEventTypeB
// 0x00C8 (0x0178 - 0x00B0)
class USelAEventTypeB final : public USelItem
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              PSprAsset;                                         // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               PTexture;                                          // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCineCameraComponent*                   PCineCamera;                                       // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x28];                                     // 0x0150(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelAEventTypeB">();
	}
	static class USelAEventTypeB* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelAEventTypeB>();
	}
};
static_assert(alignof(USelAEventTypeB) == 0x000008, "Wrong alignment on USelAEventTypeB");
static_assert(sizeof(USelAEventTypeB) == 0x000178, "Wrong size on USelAEventTypeB");
static_assert(offsetof(USelAEventTypeB, PSprAsset) == 0x000120, "Member 'USelAEventTypeB::PSprAsset' has a wrong offset!");
static_assert(offsetof(USelAEventTypeB, PTexture) == 0x000128, "Member 'USelAEventTypeB::PTexture' has a wrong offset!");
static_assert(offsetof(USelAEventTypeB, PAssetLoader) == 0x000130, "Member 'USelAEventTypeB::PAssetLoader' has a wrong offset!");
static_assert(offsetof(USelAEventTypeB, PCineCamera) == 0x000138, "Member 'USelAEventTypeB::PCineCamera' has a wrong offset!");
static_assert(offsetof(USelAEventTypeB, PParamLayoutData) == 0x000140, "Member 'USelAEventTypeB::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(USelAEventTypeB, PLayoutDataTable) == 0x000148, "Member 'USelAEventTypeB::PLayoutDataTable' has a wrong offset!");

// Class xrd777.SelFukaSuport
// 0x0000 (0x00B0 - 0x00B0)
class USelFukaSuport final : public USelItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelFukaSuport">();
	}
	static class USelFukaSuport* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelFukaSuport>();
	}
};
static_assert(alignof(USelFukaSuport) == 0x000008, "Wrong alignment on USelFukaSuport");
static_assert(sizeof(USelFukaSuport) == 0x0000B0, "Wrong size on USelFukaSuport");

// Class xrd777.SelMessage
// 0x0000 (0x00B0 - 0x00B0)
class USelMessage final : public USelItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelMessage">();
	}
	static class USelMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelMessage>();
	}
};
static_assert(alignof(USelMessage) == 0x000008, "Wrong alignment on USelMessage");
static_assert(sizeof(USelMessage) == 0x0000B0, "Wrong size on USelMessage");

// Class xrd777.SelMind
// 0x0000 (0x00B0 - 0x00B0)
class USelMind final : public USelItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelMind">();
	}
	static class USelMind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelMind>();
	}
};
static_assert(alignof(USelMind) == 0x000008, "Wrong alignment on USelMind");
static_assert(sizeof(USelMind) == 0x0000B0, "Wrong size on USelMind");

// Class xrd777.TestNishidaGameMode
// 0x0010 (0x02D0 - 0x02C0)
class ATestNishidaGameMode final : public AGameModeBase
{
public:
	TSubclassOf<class UTestNishidaResource>       M_pTestNishidaResource;                            // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATestNishidaResourceActor>  M_pTestNishidaResourceActor;                       // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestNishidaGameMode">();
	}
	static class ATestNishidaGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestNishidaGameMode>();
	}
};
static_assert(alignof(ATestNishidaGameMode) == 0x000008, "Wrong alignment on ATestNishidaGameMode");
static_assert(sizeof(ATestNishidaGameMode) == 0x0002D0, "Wrong size on ATestNishidaGameMode");
static_assert(offsetof(ATestNishidaGameMode, M_pTestNishidaResource) == 0x0002C0, "Member 'ATestNishidaGameMode::M_pTestNishidaResource' has a wrong offset!");
static_assert(offsetof(ATestNishidaGameMode, M_pTestNishidaResourceActor) == 0x0002C8, "Member 'ATestNishidaGameMode::M_pTestNishidaResourceActor' has a wrong offset!");

// Class xrd777.MsgSubtitles
// 0x0020 (0x00D0 - 0x00B0)
class UMsgSubtitles final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgSubtitles">();
	}
	static class UMsgSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgSubtitles>();
	}
};
static_assert(alignof(UMsgSubtitles) == 0x000008, "Wrong alignment on UMsgSubtitles");
static_assert(sizeof(UMsgSubtitles) == 0x0000D0, "Wrong size on UMsgSubtitles");

// Class xrd777.MsgSystem
// 0x0038 (0x00E8 - 0x00B0)
class UMsgSystem final : public UMsgItem
{
public:
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MsgSystem">();
	}
	static class UMsgSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMsgSystem>();
	}
};
static_assert(alignof(UMsgSystem) == 0x000008, "Wrong alignment on UMsgSystem");
static_assert(sizeof(UMsgSystem) == 0x0000E8, "Wrong size on UMsgSystem");

// Class xrd777.KernelResource
// 0x0048 (0x0078 - 0x0030)
class UKernelResource final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFont*>                          _Font;                                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFont*                                  _DevelopmentFont;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextureRenderTarget2D*>         _RenderTarget;                                     // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           _LoadHandle;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KernelResource">();
	}
	static class UKernelResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKernelResource>();
	}
};
static_assert(alignof(UKernelResource) == 0x000008, "Wrong alignment on UKernelResource");
static_assert(sizeof(UKernelResource) == 0x000078, "Wrong size on UKernelResource");
static_assert(offsetof(UKernelResource, _Font) == 0x000040, "Member 'UKernelResource::_Font' has a wrong offset!");
static_assert(offsetof(UKernelResource, _DevelopmentFont) == 0x000050, "Member 'UKernelResource::_DevelopmentFont' has a wrong offset!");
static_assert(offsetof(UKernelResource, _RenderTarget) == 0x000058, "Member 'UKernelResource::_RenderTarget' has a wrong offset!");
static_assert(offsetof(UKernelResource, _LoadHandle) == 0x000068, "Member 'UKernelResource::_LoadHandle' has a wrong offset!");

// Class xrd777.BuildModeLibrary
// 0x0000 (0x0028 - 0x0028)
class UBuildModeLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsDebug();
	static bool IsShipping();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildModeLibrary">();
	}
	static class UBuildModeLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildModeLibrary>();
	}
};
static_assert(alignof(UBuildModeLibrary) == 0x000008, "Wrong alignment on UBuildModeLibrary");
static_assert(sizeof(UBuildModeLibrary) == 0x000028, "Wrong size on UBuildModeLibrary");

// Class xrd777.KernelWidget
// 0x0000 (0x0260 - 0x0260)
class UKernelWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KernelWidget">();
	}
	static class UKernelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKernelWidget>();
	}
};
static_assert(alignof(UKernelWidget) == 0x000008, "Wrong alignment on UKernelWidget");
static_assert(sizeof(UKernelWidget) == 0x000260, "Wrong size on UKernelWidget");

// Class xrd777.KernelActor
// 0x0080 (0x02A0 - 0x0220)
class AKernelActor final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           _DebugCamera;                                      // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _OldCamera;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UKernelWidget*                          _KernelWidget;                                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             MpDebugMenu;                                       // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MpChildActor;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x30];                                     // 0x0270(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KernelActor">();
	}
	static class AKernelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKernelActor>();
	}
};
static_assert(alignof(AKernelActor) == 0x000008, "Wrong alignment on AKernelActor");
static_assert(sizeof(AKernelActor) == 0x0002A0, "Wrong size on AKernelActor");
static_assert(offsetof(AKernelActor, _DebugCamera) == 0x000228, "Member 'AKernelActor::_DebugCamera' has a wrong offset!");
static_assert(offsetof(AKernelActor, _OldCamera) == 0x000238, "Member 'AKernelActor::_OldCamera' has a wrong offset!");
static_assert(offsetof(AKernelActor, _KernelWidget) == 0x000258, "Member 'AKernelActor::_KernelWidget' has a wrong offset!");
static_assert(offsetof(AKernelActor, MpDebugMenu) == 0x000260, "Member 'AKernelActor::MpDebugMenu' has a wrong offset!");
static_assert(offsetof(AKernelActor, MpChildActor) == 0x000268, "Member 'AKernelActor::MpChildActor' has a wrong offset!");

// Class xrd777.TitleActor
// 0x04C0 (0x0738 - 0x0278)
class ATitleActor : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTitleStateBase*                        CurrentTitleState;                                 // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ETitleState, class UTitleStateBase*>     TitleStates;                                       // 0x0288(0x0050)(NativeAccessSpecifierPrivate)
	class AActor*                                 DefaultCamera;                                     // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 TitleCamera;                                       // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIDrawGamerTag*                        M_GamerTagWidget;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                M_GamerTagWidgetClass;                             // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x78];                                     // 0x02F8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           TitleAssetLoader;                                  // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TitleDataTable;                                    // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TitleSelectDataTable;                              // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AddAstreaMsgSimpleTimerHandle;                     // 0x03A0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATitleLogoActor*                        LogoActor;                                         // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATitleLogoActor*                        LogoActorAstrea;                                   // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATitleLogoActor>            LogoActorSC;                                       // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATitleLogoActor>            LogoActorSC_Astrea;                                // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  CurvePressAnyButtonBlueRect;                       // 0x03D0(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  CurvePressAnyButtonAnim;                           // 0x0400(0x0030)(NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutDataTable;                                   // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     UILayoutLayoutDataTable;                           // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              TitleSpr;                                          // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              TitleSprAstrea;                                    // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               CautionTex;                                        // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               PhotosensitiveCautionTex;                          // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x1B0];                                    // 0x0460(0x01B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMcaAsset*                              McaCameraAsset;                                    // 0x0610(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMcaAsset*                              McaCameraAssetAstrea;                              // 0x0618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMcaAsset*                              McaCameraAfterAssetAstrea;                         // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           MainCamera;                                        // 0x0628(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 OldCamera;                                         // 0x0630(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x30];                                     // 0x0638(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              PressAnyButtonMat;                                 // 0x0668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PressAnyButtonMID;                                 // 0x0670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0xC0];                                     // 0x0678(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoaded();
	void OpenAddAstreaMsgSimple();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleActor">();
	}
	static class ATitleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATitleActor>();
	}
};
static_assert(alignof(ATitleActor) == 0x000008, "Wrong alignment on ATitleActor");
static_assert(sizeof(ATitleActor) == 0x000738, "Wrong size on ATitleActor");
static_assert(offsetof(ATitleActor, CurrentTitleState) == 0x000280, "Member 'ATitleActor::CurrentTitleState' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleStates) == 0x000288, "Member 'ATitleActor::TitleStates' has a wrong offset!");
static_assert(offsetof(ATitleActor, DefaultCamera) == 0x0002D8, "Member 'ATitleActor::DefaultCamera' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleCamera) == 0x0002E0, "Member 'ATitleActor::TitleCamera' has a wrong offset!");
static_assert(offsetof(ATitleActor, M_GamerTagWidget) == 0x0002E8, "Member 'ATitleActor::M_GamerTagWidget' has a wrong offset!");
static_assert(offsetof(ATitleActor, M_GamerTagWidgetClass) == 0x0002F0, "Member 'ATitleActor::M_GamerTagWidgetClass' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleAssetLoader) == 0x000370, "Member 'ATitleActor::TitleAssetLoader' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleDataTable) == 0x000378, "Member 'ATitleActor::TitleDataTable' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleSelectDataTable) == 0x000380, "Member 'ATitleActor::TitleSelectDataTable' has a wrong offset!");
static_assert(offsetof(ATitleActor, AddAstreaMsgSimpleTimerHandle) == 0x0003A0, "Member 'ATitleActor::AddAstreaMsgSimpleTimerHandle' has a wrong offset!");
static_assert(offsetof(ATitleActor, LogoActor) == 0x0003B0, "Member 'ATitleActor::LogoActor' has a wrong offset!");
static_assert(offsetof(ATitleActor, LogoActorAstrea) == 0x0003B8, "Member 'ATitleActor::LogoActorAstrea' has a wrong offset!");
static_assert(offsetof(ATitleActor, LogoActorSC) == 0x0003C0, "Member 'ATitleActor::LogoActorSC' has a wrong offset!");
static_assert(offsetof(ATitleActor, LogoActorSC_Astrea) == 0x0003C8, "Member 'ATitleActor::LogoActorSC_Astrea' has a wrong offset!");
static_assert(offsetof(ATitleActor, CurvePressAnyButtonBlueRect) == 0x0003D0, "Member 'ATitleActor::CurvePressAnyButtonBlueRect' has a wrong offset!");
static_assert(offsetof(ATitleActor, CurvePressAnyButtonAnim) == 0x000400, "Member 'ATitleActor::CurvePressAnyButtonAnim' has a wrong offset!");
static_assert(offsetof(ATitleActor, LayoutDataTable) == 0x000430, "Member 'ATitleActor::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(ATitleActor, UILayoutLayoutDataTable) == 0x000438, "Member 'ATitleActor::UILayoutLayoutDataTable' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleSpr) == 0x000440, "Member 'ATitleActor::TitleSpr' has a wrong offset!");
static_assert(offsetof(ATitleActor, TitleSprAstrea) == 0x000448, "Member 'ATitleActor::TitleSprAstrea' has a wrong offset!");
static_assert(offsetof(ATitleActor, CautionTex) == 0x000450, "Member 'ATitleActor::CautionTex' has a wrong offset!");
static_assert(offsetof(ATitleActor, PhotosensitiveCautionTex) == 0x000458, "Member 'ATitleActor::PhotosensitiveCautionTex' has a wrong offset!");
static_assert(offsetof(ATitleActor, McaCameraAsset) == 0x000610, "Member 'ATitleActor::McaCameraAsset' has a wrong offset!");
static_assert(offsetof(ATitleActor, McaCameraAssetAstrea) == 0x000618, "Member 'ATitleActor::McaCameraAssetAstrea' has a wrong offset!");
static_assert(offsetof(ATitleActor, McaCameraAfterAssetAstrea) == 0x000620, "Member 'ATitleActor::McaCameraAfterAssetAstrea' has a wrong offset!");
static_assert(offsetof(ATitleActor, MainCamera) == 0x000628, "Member 'ATitleActor::MainCamera' has a wrong offset!");
static_assert(offsetof(ATitleActor, OldCamera) == 0x000630, "Member 'ATitleActor::OldCamera' has a wrong offset!");
static_assert(offsetof(ATitleActor, PressAnyButtonMat) == 0x000668, "Member 'ATitleActor::PressAnyButtonMat' has a wrong offset!");
static_assert(offsetof(ATitleActor, PressAnyButtonMID) == 0x000670, "Member 'ATitleActor::PressAnyButtonMID' has a wrong offset!");

// Class xrd777.KernelBpLib
// 0x0000 (0x0028 - 0x0028)
class UKernelBpLib final : public UBlueprintFunctionLibrary
{
public:
	static bool IsInEditor();
	static void SetTestCharacter(const class UObject* WorldContextObject, TSubclassOf<class ACharacter> In, const struct FTransform& Location);
	static void SetTestMap(const class UObject* WorldContextObject, const struct FTransform& Location);
	static void StartBf(const class UObject* WorldContextObject, TSoftObjectPtr<class UBfAsset> InAsset, int32 ProcNo, bool PlayerStop, bool BmdSearchOff, const struct FLatentActionInfo& LatentInfo, int32* Result);
	static void StartBfEx(const class UObject* WorldContextObject, TSoftObjectPtr<class UBfAsset> InBfAsset, TSoftObjectPtr<class UBmdAsset> InBmdAsset, int32 ProcNo, bool PlayerStop, bool BmdSearchOff, const struct FLatentActionInfo& LatentInfo, int32* Result);
	static void StartBfPath(const class UObject* WorldContextObject, const class FString& BfAssetPath, const class FString& BmdAssetPath, int32 ProcNo, const struct FLatentActionInfo& LatentInfo, int32* Result);
	static void StartLoadingScreen(const class UObject* WorldContextObject, bool bPlayUntilStopped, float PlayTime);
	static void StopLoadingScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KernelBpLib">();
	}
	static class UKernelBpLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKernelBpLib>();
	}
};
static_assert(alignof(UKernelBpLib) == 0x000008, "Wrong alignment on UKernelBpLib");
static_assert(sizeof(UKernelBpLib) == 0x000028, "Wrong size on UKernelBpLib");

// Class xrd777.DebugMenu
// 0x0000 (0x00F8 - 0x00F8)
class UDebugMenu final : public UDebugMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugMenu">();
	}
	static class UDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugMenu>();
	}
};
static_assert(alignof(UDebugMenu) == 0x000008, "Wrong alignment on UDebugMenu");
static_assert(sizeof(UDebugMenu) == 0x0000F8, "Wrong size on UDebugMenu");

// Class xrd777.kitadeTestEditManager
// 0x0000 (0x0290 - 0x0290)
class AKitadeTestEditManager final : public ADebugViewer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"kitadeTestEditManager">();
	}
	static class AKitadeTestEditManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKitadeTestEditManager>();
	}
};
static_assert(alignof(AKitadeTestEditManager) == 0x000008, "Wrong alignment on AKitadeTestEditManager");
static_assert(sizeof(AKitadeTestEditManager) == 0x000290, "Wrong size on AKitadeTestEditManager");

// Class xrd777.LaunchActivityActor
// 0x0010 (0x0288 - 0x0278)
class ALaunchActivityActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaunchActivityActor">();
	}
	static class ALaunchActivityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALaunchActivityActor>();
	}
};
static_assert(alignof(ALaunchActivityActor) == 0x000008, "Wrong alignment on ALaunchActivityActor");
static_assert(sizeof(ALaunchActivityActor) == 0x000288, "Wrong size on ALaunchActivityActor");

// Class xrd777.LeaderBoardManager
// 0x01D0 (0x01F8 - 0x0028)
class ULeaderBoardManager final : public UObject
{
public:
	uint8                                         Pad_28[0x1D0];                                     // 0x0028(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaderBoardManager">();
	}
	static class ULeaderBoardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaderBoardManager>();
	}
};
static_assert(alignof(ULeaderBoardManager) == 0x000008, "Wrong alignment on ULeaderBoardManager");
static_assert(sizeof(ULeaderBoardManager) == 0x0001F8, "Wrong size on ULeaderBoardManager");

// Class xrd777.LipsyncAppObserverSubsystem
// 0x0068 (0x0098 - 0x0030)
class ULipsyncAppObserverSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             LipsyncAppObserveDelegate;                         // 0x0030(0x0010)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, struct FLipsyncAppListener>      SpeakCharacterMap;                                 // 0x0040(0x0050)(Protected, NativeAccessSpecifierProtected)
	class ULipsyncAppObserverSpeakWatcher*        SpeakWatcher;                                      // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishSpeakCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID);
	void FinishSpeakCharacterFromSoundID(int32 SoundMajorID, int32 SoundMinorID);
	struct FCriLipsMorphTargetBlendAmountAsJapanese GetLipsyncLiveInfo(int32 SoundMajorID, int32 SoundMinorID);
	bool IsSpeakingCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID);
	void StartSpeakCharacter(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID, int32 SoundMajorID, int32 SoundMinorID, bool bOverride);
	void StopAllSpeakCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LipsyncAppObserverSubsystem">();
	}
	static class ULipsyncAppObserverSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULipsyncAppObserverSubsystem>();
	}
};
static_assert(alignof(ULipsyncAppObserverSubsystem) == 0x000008, "Wrong alignment on ULipsyncAppObserverSubsystem");
static_assert(sizeof(ULipsyncAppObserverSubsystem) == 0x000098, "Wrong size on ULipsyncAppObserverSubsystem");
static_assert(offsetof(ULipsyncAppObserverSubsystem, LipsyncAppObserveDelegate) == 0x000030, "Member 'ULipsyncAppObserverSubsystem::LipsyncAppObserveDelegate' has a wrong offset!");
static_assert(offsetof(ULipsyncAppObserverSubsystem, SpeakCharacterMap) == 0x000040, "Member 'ULipsyncAppObserverSubsystem::SpeakCharacterMap' has a wrong offset!");
static_assert(offsetof(ULipsyncAppObserverSubsystem, SpeakWatcher) == 0x000090, "Member 'ULipsyncAppObserverSubsystem::SpeakWatcher' has a wrong offset!");

// Class xrd777.MiniMapIconListTable
// 0x0010 (0x0040 - 0x0030)
class UMiniMapIconListTable final : public UAppDataAsset
{
public:
	TArray<struct FMiniMapIconList>               Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapIconListTable">();
	}
	static class UMiniMapIconListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapIconListTable>();
	}
};
static_assert(alignof(UMiniMapIconListTable) == 0x000008, "Wrong alignment on UMiniMapIconListTable");
static_assert(sizeof(UMiniMapIconListTable) == 0x000040, "Wrong size on UMiniMapIconListTable");
static_assert(offsetof(UMiniMapIconListTable, Data) == 0x000030, "Member 'UMiniMapIconListTable::Data' has a wrong offset!");

// Class xrd777.LipsyncAppObserverSpeakWatcher
// 0x0010 (0x0038 - 0x0028)
class ULipsyncAppObserverSpeakWatcher final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULipsyncAppObserverSubsystem> LipsyncAppObserverSubsystem;                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LipsyncAppObserverSpeakWatcher">();
	}
	static class ULipsyncAppObserverSpeakWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULipsyncAppObserverSpeakWatcher>();
	}
};
static_assert(alignof(ULipsyncAppObserverSpeakWatcher) == 0x000008, "Wrong alignment on ULipsyncAppObserverSpeakWatcher");
static_assert(sizeof(ULipsyncAppObserverSpeakWatcher) == 0x000038, "Wrong size on ULipsyncAppObserverSpeakWatcher");
static_assert(offsetof(ULipsyncAppObserverSpeakWatcher, LipsyncAppObserverSubsystem) == 0x000030, "Member 'ULipsyncAppObserverSpeakWatcher::LipsyncAppObserverSubsystem' has a wrong offset!");

// Class xrd777.LoaderActor
// 0x0020 (0x0298 - 0x0278)
class ALoaderActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomCueSheetLoaderComponent*           Loader;                                            // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnLoadCompleted();
	void OnLoadFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoaderActor">();
	}
	static class ALoaderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoaderActor>();
	}
};
static_assert(alignof(ALoaderActor) == 0x000008, "Wrong alignment on ALoaderActor");
static_assert(sizeof(ALoaderActor) == 0x000298, "Wrong size on ALoaderActor");
static_assert(offsetof(ALoaderActor, Loader) == 0x000290, "Member 'ALoaderActor::Loader' has a wrong offset!");

// Class xrd777.LocalizationTest
// 0x0040 (0x02F8 - 0x02B8)
class ALocalizationTest final : public AUIDrawBaseActor
{
public:
	EUI_DRAW_POINT                                DrawPoint;                                         // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LinesNum;                                          // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x02C0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x02CC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           Loader;                                            // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PDataTable;                                        // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationTest">();
	}
	static class ALocalizationTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocalizationTest>();
	}
};
static_assert(alignof(ALocalizationTest) == 0x000008, "Wrong alignment on ALocalizationTest");
static_assert(sizeof(ALocalizationTest) == 0x0002F8, "Wrong size on ALocalizationTest");
static_assert(offsetof(ALocalizationTest, DrawPoint) == 0x0002B8, "Member 'ALocalizationTest::DrawPoint' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, LinesNum) == 0x0002BC, "Member 'ALocalizationTest::LinesNum' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, Position) == 0x0002C0, "Member 'ALocalizationTest::Position' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, Offset) == 0x0002CC, "Member 'ALocalizationTest::Offset' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, Angle) == 0x0002D8, "Member 'ALocalizationTest::Angle' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, Scale) == 0x0002DC, "Member 'ALocalizationTest::Scale' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, DebugMenu) == 0x0002E0, "Member 'ALocalizationTest::DebugMenu' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, Loader) == 0x0002E8, "Member 'ALocalizationTest::Loader' has a wrong offset!");
static_assert(offsetof(ALocalizationTest, PDataTable) == 0x0002F0, "Member 'ALocalizationTest::PDataTable' has a wrong offset!");

// Class xrd777.TextureData
// 0x0020 (0x0298 - 0x0278)
class ATextureData final : public AAppActor
{
public:
	class UTexture*                               Texture;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              Sprite;                                            // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureData">();
	}
	static class ATextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATextureData>();
	}
};
static_assert(alignof(ATextureData) == 0x000008, "Wrong alignment on ATextureData");
static_assert(sizeof(ATextureData) == 0x000298, "Wrong size on ATextureData");
static_assert(offsetof(ATextureData, Texture) == 0x000278, "Member 'ATextureData::Texture' has a wrong offset!");
static_assert(offsetof(ATextureData, Sprite) == 0x000280, "Member 'ATextureData::Sprite' has a wrong offset!");

// Class xrd777.LocalizeStaffRoll
// 0x00D0 (0x0348 - 0x0278)
class ALocalizeStaffRoll final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  M_StaffRollFont;                                   // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0xA8];                                     // 0x02A0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizeStaffRoll">();
	}
	static class ALocalizeStaffRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocalizeStaffRoll>();
	}
};
static_assert(alignof(ALocalizeStaffRoll) == 0x000008, "Wrong alignment on ALocalizeStaffRoll");
static_assert(sizeof(ALocalizeStaffRoll) == 0x000348, "Wrong size on ALocalizeStaffRoll");
static_assert(offsetof(ALocalizeStaffRoll, M_pLoader) == 0x000288, "Member 'ALocalizeStaffRoll::M_pLoader' has a wrong offset!");
static_assert(offsetof(ALocalizeStaffRoll, M_StaffRollFont) == 0x000298, "Member 'ALocalizeStaffRoll::M_StaffRollFont' has a wrong offset!");

// Class xrd777.LocalizeStaffRollDraw
// 0x0058 (0x0310 - 0x02B8)
class ALocalizeStaffRollDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x58];                                     // 0x02B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizeStaffRollDraw">();
	}
	static class ALocalizeStaffRollDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocalizeStaffRollDraw>();
	}
};
static_assert(alignof(ALocalizeStaffRollDraw) == 0x000008, "Wrong alignment on ALocalizeStaffRollDraw");
static_assert(sizeof(ALocalizeStaffRollDraw) == 0x000310, "Wrong size on ALocalizeStaffRollDraw");

// Class xrd777.BustupExistDataAsset
// 0x0050 (0x0080 - 0x0030)
class UBustupExistDataAsset final : public UAppMultiDataAsset
{
public:
	TMap<int32, struct FBustupFace>               Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BustupExistDataAsset">();
	}
	static class UBustupExistDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBustupExistDataAsset>();
	}
};
static_assert(alignof(UBustupExistDataAsset) == 0x000008, "Wrong alignment on UBustupExistDataAsset");
static_assert(sizeof(UBustupExistDataAsset) == 0x000080, "Wrong size on UBustupExistDataAsset");
static_assert(offsetof(UBustupExistDataAsset, Data) == 0x000030, "Member 'UBustupExistDataAsset::Data' has a wrong offset!");

// Class xrd777.MailActor
// 0x0188 (0x0428 - 0x02A0)
class AMailActor final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UBmdAsset*>         BmdAssets_;                                        // 0x02B0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, class UBfAsset*>          BfAssets_;                                         // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              ScrActor_;                                         // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AMailDraw>                  MailDrawActorSC;                                   // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMailDraw*                              MailDrawActor;                                     // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x40];                                     // 0x0378(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextData;                                          // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x60];                                     // 0x03C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailActor">();
	}
	static class AMailActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMailActor>();
	}
};
static_assert(alignof(AMailActor) == 0x000008, "Wrong alignment on AMailActor");
static_assert(sizeof(AMailActor) == 0x000428, "Wrong size on AMailActor");
static_assert(offsetof(AMailActor, Loader_) == 0x0002A8, "Member 'AMailActor::Loader_' has a wrong offset!");
static_assert(offsetof(AMailActor, BmdAssets_) == 0x0002B0, "Member 'AMailActor::BmdAssets_' has a wrong offset!");
static_assert(offsetof(AMailActor, BfAssets_) == 0x000300, "Member 'AMailActor::BfAssets_' has a wrong offset!");
static_assert(offsetof(AMailActor, ScrActor_) == 0x000360, "Member 'AMailActor::ScrActor_' has a wrong offset!");
static_assert(offsetof(AMailActor, MailDrawActorSC) == 0x000368, "Member 'AMailActor::MailDrawActorSC' has a wrong offset!");
static_assert(offsetof(AMailActor, MailDrawActor) == 0x000370, "Member 'AMailActor::MailDrawActor' has a wrong offset!");
static_assert(offsetof(AMailActor, LayoutData) == 0x0003B8, "Member 'AMailActor::LayoutData' has a wrong offset!");
static_assert(offsetof(AMailActor, TextData) == 0x0003C0, "Member 'AMailActor::TextData' has a wrong offset!");

// Class xrd777.MailDraw
// 0x00C8 (0x0380 - 0x02B8)
class AMailDraw final : public AUIDrawBaseActor
{
public:
	bool                                          bIsDirectOpen;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFlipToMainAnim;                                 // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFlipToListAnim;                                 // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartInAnim;                                    // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishInAnim;                                   // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartListAnim;                                  // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishListAnim;                                 // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartMailAnim;                                  // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishMailAnim;                                 // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStartOutAnim;                                   // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishOutAnim;                                  // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsShowMsg;                                        // 0x02C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCloseMsg;                                       // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishShowMsgAnim;                              // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFinishCloseMsgAnim;                             // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHaveScript;                                       // 0x02C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectedIndex;                                     // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DrawIndex;                                         // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ScrollIndex;                                       // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MailScrollLine;                                    // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MailRowCount;                                      // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MailRowMax;                                        // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MailScrollMax;                                     // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIMailListItem>                MailListItems;                                     // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTexture2D*                             MailMainBustupTexture;                             // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x28];                                     // 0x0308(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UTexture2D* TextureObject)> OnLoadedBustupEvent;                               // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextData;                                          // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextDataTable;                                     // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ConvFrameToTime(int32 InFrame);
	void DrawListMailSenderText(int32 InIndex, const struct FVector2D& InPos, const struct FColor& InColor, float InScale);
	void DrawListMailTitleText(int32 InIndex, const struct FVector2D& InPos, const struct FColor& InColor, float InScale);
	void DrawMailMainText(const struct FVector2D& InPos, const struct FColor& InColor, float InScale);
	void DrawMailSenderText(const struct FVector2D& InPos, const struct FColor& InColor, float InScale);
	void DrawMailTitleText(const struct FVector2D& InPos, const struct FColor& InColor, float InScale);
	void DrawSprForUIResources(const struct FVector2D& InPos, const struct FColor& InColor, int32 SprID, const struct FVector2D& Scale, float Angle, EUICommonResource ResourceType, EUI_DRAW_POINT DrawPoint);
	struct FVector2D GetAdjustedLayoutPosition(EMailLayout InLayoutId, const struct FVector2D& InDefaultPos);
	bool GetListIsNew(int32 InIndex);
	bool GetListIsRead(int32 InIndex);
	int32 GetListSenderID(int32 InIndex);
	int32 GetMailSenderID();
	bool InitDraw_IN();
	bool InitDraw_List();
	bool InitDraw_Mail();
	bool InitDraw_Out();
	bool IsIsDeterminedByCross();
	void OneTimeLockInput();
	void SetMailListIsNew(int32 InIndex, bool InIsNew);
	void SetScrollBarBaseCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 ScrollPos, int32 DrawListNum, int32 MaxListNum, EUI_DRAW_POINT DrawPoint);
	void SetScrollBarSliderCollision(float X, float Y, float Width, float Height, float ScrollRange, int32 ScrollPos, int32 DrawListNum, int32 MaxListNum, EUI_DRAW_POINT DrawPoint);
	void SetTouchCollision(int32 Index_0, float X, float Y, float Width, float Height, EUI_DRAW_POINT DrawPoint, bool OnList);
	bool StateDraw_BG();
	bool StateDraw_Frame();
	bool StateDraw_IN();
	bool StateDraw_List();
	bool StateDraw_Mail();
	bool StateDraw_Out();
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailDraw">();
	}
	static class AMailDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMailDraw>();
	}
};
static_assert(alignof(AMailDraw) == 0x000008, "Wrong alignment on AMailDraw");
static_assert(sizeof(AMailDraw) == 0x000380, "Wrong size on AMailDraw");
static_assert(offsetof(AMailDraw, bIsDirectOpen) == 0x0002B8, "Member 'AMailDraw::bIsDirectOpen' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFlipToMainAnim) == 0x0002B9, "Member 'AMailDraw::bIsFlipToMainAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFlipToListAnim) == 0x0002BA, "Member 'AMailDraw::bIsFlipToListAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsStartInAnim) == 0x0002BB, "Member 'AMailDraw::bIsStartInAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishInAnim) == 0x0002BC, "Member 'AMailDraw::bIsFinishInAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsStartListAnim) == 0x0002BD, "Member 'AMailDraw::bIsStartListAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishListAnim) == 0x0002BE, "Member 'AMailDraw::bIsFinishListAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsStartMailAnim) == 0x0002BF, "Member 'AMailDraw::bIsStartMailAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishMailAnim) == 0x0002C0, "Member 'AMailDraw::bIsFinishMailAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsStartOutAnim) == 0x0002C1, "Member 'AMailDraw::bIsStartOutAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishOutAnim) == 0x0002C2, "Member 'AMailDraw::bIsFinishOutAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsShowMsg) == 0x0002C3, "Member 'AMailDraw::bIsShowMsg' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsCloseMsg) == 0x0002C4, "Member 'AMailDraw::bIsCloseMsg' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishShowMsgAnim) == 0x0002C5, "Member 'AMailDraw::bIsFinishShowMsgAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bIsFinishCloseMsgAnim) == 0x0002C6, "Member 'AMailDraw::bIsFinishCloseMsgAnim' has a wrong offset!");
static_assert(offsetof(AMailDraw, bHaveScript) == 0x0002C7, "Member 'AMailDraw::bHaveScript' has a wrong offset!");
static_assert(offsetof(AMailDraw, SelectedIndex) == 0x0002C8, "Member 'AMailDraw::SelectedIndex' has a wrong offset!");
static_assert(offsetof(AMailDraw, DrawIndex) == 0x0002CC, "Member 'AMailDraw::DrawIndex' has a wrong offset!");
static_assert(offsetof(AMailDraw, ScrollIndex) == 0x0002D0, "Member 'AMailDraw::ScrollIndex' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailScrollLine) == 0x0002D4, "Member 'AMailDraw::MailScrollLine' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailRowCount) == 0x0002D8, "Member 'AMailDraw::MailRowCount' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailRowMax) == 0x0002DC, "Member 'AMailDraw::MailRowMax' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailScrollMax) == 0x0002E0, "Member 'AMailDraw::MailScrollMax' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailListItems) == 0x0002E8, "Member 'AMailDraw::MailListItems' has a wrong offset!");
static_assert(offsetof(AMailDraw, MailMainBustupTexture) == 0x0002F8, "Member 'AMailDraw::MailMainBustupTexture' has a wrong offset!");
static_assert(offsetof(AMailDraw, Loader) == 0x000300, "Member 'AMailDraw::Loader' has a wrong offset!");
static_assert(offsetof(AMailDraw, OnLoadedBustupEvent) == 0x000330, "Member 'AMailDraw::OnLoadedBustupEvent' has a wrong offset!");
static_assert(offsetof(AMailDraw, LayoutData) == 0x000358, "Member 'AMailDraw::LayoutData' has a wrong offset!");
static_assert(offsetof(AMailDraw, LayoutDataTable) == 0x000360, "Member 'AMailDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AMailDraw, TextData) == 0x000368, "Member 'AMailDraw::TextData' has a wrong offset!");
static_assert(offsetof(AMailDraw, TextDataTable) == 0x000370, "Member 'AMailDraw::TextDataTable' has a wrong offset!");

// Class xrd777.MiyamuraTestManager
// 0x0000 (0x0278 - 0x0278)
class AMiyamuraTestManager final : public AAppActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiyamuraTestManager">();
	}
	static class AMiyamuraTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMiyamuraTestManager>();
	}
};
static_assert(alignof(AMiyamuraTestManager) == 0x000008, "Wrong alignment on AMiyamuraTestManager");
static_assert(sizeof(AMiyamuraTestManager) == 0x000278, "Wrong size on AMiyamuraTestManager");

// Class xrd777.TitleStateSelect_Astrea
// 0x0058 (0x0090 - 0x0038)
class UTitleStateSelect_Astrea final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIKeyHelpDraw*                         KeyHelpUI;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateSelect_Astrea">();
	}
	static class UTitleStateSelect_Astrea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateSelect_Astrea>();
	}
};
static_assert(alignof(UTitleStateSelect_Astrea) == 0x000008, "Wrong alignment on UTitleStateSelect_Astrea");
static_assert(sizeof(UTitleStateSelect_Astrea) == 0x000090, "Wrong size on UTitleStateSelect_Astrea");
static_assert(offsetof(UTitleStateSelect_Astrea, KeyHelpUI) == 0x000040, "Member 'UTitleStateSelect_Astrea::KeyHelpUI' has a wrong offset!");

// Class xrd777.MiyamuraLoadTest
// 0x0070 (0x02E8 - 0x0278)
class AMiyamuraLoadTest final : public AAppActor
{
public:
	class UBtlGuiDrawObjectImage*                 Image;                                             // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureCup;                                        // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureCoin;                                       // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureSword;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureWand;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TexturePersona;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureFool;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureMagician;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureEmpress;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureEmperor;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TextureHighPrietess;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture*>                       TextureArray;                                      // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAssetLoader*                           LoaderAlpha;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiyamuraLoadTest">();
	}
	static class AMiyamuraLoadTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMiyamuraLoadTest>();
	}
};
static_assert(alignof(AMiyamuraLoadTest) == 0x000008, "Wrong alignment on AMiyamuraLoadTest");
static_assert(sizeof(AMiyamuraLoadTest) == 0x0002E8, "Wrong size on AMiyamuraLoadTest");
static_assert(offsetof(AMiyamuraLoadTest, Image) == 0x000278, "Member 'AMiyamuraLoadTest::Image' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureCup) == 0x000280, "Member 'AMiyamuraLoadTest::TextureCup' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureCoin) == 0x000288, "Member 'AMiyamuraLoadTest::TextureCoin' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureSword) == 0x000290, "Member 'AMiyamuraLoadTest::TextureSword' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureWand) == 0x000298, "Member 'AMiyamuraLoadTest::TextureWand' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TexturePersona) == 0x0002A0, "Member 'AMiyamuraLoadTest::TexturePersona' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureFool) == 0x0002A8, "Member 'AMiyamuraLoadTest::TextureFool' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureMagician) == 0x0002B0, "Member 'AMiyamuraLoadTest::TextureMagician' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureEmpress) == 0x0002B8, "Member 'AMiyamuraLoadTest::TextureEmpress' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureEmperor) == 0x0002C0, "Member 'AMiyamuraLoadTest::TextureEmperor' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureHighPrietess) == 0x0002C8, "Member 'AMiyamuraLoadTest::TextureHighPrietess' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, TextureArray) == 0x0002D0, "Member 'AMiyamuraLoadTest::TextureArray' has a wrong offset!");
static_assert(offsetof(AMiyamuraLoadTest, LoaderAlpha) == 0x0002E0, "Member 'AMiyamuraLoadTest::LoaderAlpha' has a wrong offset!");

// Class xrd777.TestCharacter3
// 0x0010 (0x04D0 - 0x04C0)
class ATestCharacter3 final : public ACharacter
{
public:
	class USkeletalMeshComponent*                 Mesh2;                                             // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh3;                                             // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestCharacter3">();
	}
	static class ATestCharacter3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestCharacter3>();
	}
};
static_assert(alignof(ATestCharacter3) == 0x000010, "Wrong alignment on ATestCharacter3");
static_assert(sizeof(ATestCharacter3) == 0x0004D0, "Wrong size on ATestCharacter3");
static_assert(offsetof(ATestCharacter3, Mesh2) == 0x0004B8, "Member 'ATestCharacter3::Mesh2' has a wrong offset!");
static_assert(offsetof(ATestCharacter3, Mesh3) == 0x0004C0, "Member 'ATestCharacter3::Mesh3' has a wrong offset!");

// Class xrd777.TestSplineCollision
// 0x0008 (0x0228 - 0x0220)
class ATestSplineCollision final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestSplineCollision">();
	}
	static class ATestSplineCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestSplineCollision>();
	}
};
static_assert(alignof(ATestSplineCollision) == 0x000008, "Wrong alignment on ATestSplineCollision");
static_assert(sizeof(ATestSplineCollision) == 0x000228, "Wrong size on ATestSplineCollision");
static_assert(offsetof(ATestSplineCollision, SplineComponent) == 0x000220, "Member 'ATestSplineCollision::SplineComponent' has a wrong offset!");

// Class xrd777.TestBoxCollision
// 0x0008 (0x0228 - 0x0220)
class ATestBoxCollision final : public AActor
{
public:
	class UBoxComponent*                          CollisionComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestBoxCollision">();
	}
	static class ATestBoxCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestBoxCollision>();
	}
};
static_assert(alignof(ATestBoxCollision) == 0x000008, "Wrong alignment on ATestBoxCollision");
static_assert(sizeof(ATestBoxCollision) == 0x000228, "Wrong size on ATestBoxCollision");
static_assert(offsetof(ATestBoxCollision, CollisionComponent) == 0x000220, "Member 'ATestBoxCollision::CollisionComponent' has a wrong offset!");

// Class xrd777.TutorialViewer
// 0x0010 (0x02A0 - 0x0290)
class ATutorialViewer final : public ADebugViewer
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialViewer">();
	}
	static class ATutorialViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialViewer>();
	}
};
static_assert(alignof(ATutorialViewer) == 0x000008, "Wrong alignment on ATutorialViewer");
static_assert(sizeof(ATutorialViewer) == 0x0002A0, "Wrong size on ATutorialViewer");

// Class xrd777.TestTriggerBox
// 0x0010 (0x0230 - 0x0220)
class ATestTriggerBox final : public AActor
{
public:
	class UBillboardComponent*                    Icon;                                              // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CollisionComponent;                                // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnComponentOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTriggerBox">();
	}
	static class ATestTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestTriggerBox>();
	}
};
static_assert(alignof(ATestTriggerBox) == 0x000008, "Wrong alignment on ATestTriggerBox");
static_assert(sizeof(ATestTriggerBox) == 0x000230, "Wrong size on ATestTriggerBox");
static_assert(offsetof(ATestTriggerBox, Icon) == 0x000220, "Member 'ATestTriggerBox::Icon' has a wrong offset!");
static_assert(offsetof(ATestTriggerBox, CollisionComponent) == 0x000228, "Member 'ATestTriggerBox::CollisionComponent' has a wrong offset!");

// Class xrd777.TestActorComponent
// 0x0020 (0x00D0 - 0x00B0)
class UTestActorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTestEventDispatcher;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTestEventDispatcher2;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestActorComponent">();
	}
	static class UTestActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestActorComponent>();
	}
};
static_assert(alignof(UTestActorComponent) == 0x000008, "Wrong alignment on UTestActorComponent");
static_assert(sizeof(UTestActorComponent) == 0x0000D0, "Wrong size on UTestActorComponent");
static_assert(offsetof(UTestActorComponent, OnTestEventDispatcher) == 0x0000B0, "Member 'UTestActorComponent::OnTestEventDispatcher' has a wrong offset!");
static_assert(offsetof(UTestActorComponent, OnTestEventDispatcher2) == 0x0000C0, "Member 'UTestActorComponent::OnTestEventDispatcher2' has a wrong offset!");

// Class xrd777.TestAnimInst
// 0x0020 (0x02E0 - 0x02C0)
class UTestAnimInst final : public UAnimInstance
{
public:
	struct FVector                                LookatPosition2;                                   // 0x02B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookatAlpha2;                                      // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpressionTrig;                                    // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSeq0;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq1;                                          // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AnimChange(int32 Type, int32 Param);
	void TestFunction(int32 Type, int32 Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAnimInst">();
	}
	static class UTestAnimInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestAnimInst>();
	}
};
static_assert(alignof(UTestAnimInst) == 0x000010, "Wrong alignment on UTestAnimInst");
static_assert(sizeof(UTestAnimInst) == 0x0002E0, "Wrong size on UTestAnimInst");
static_assert(offsetof(UTestAnimInst, LookatPosition2) == 0x0002B8, "Member 'UTestAnimInst::LookatPosition2' has a wrong offset!");
static_assert(offsetof(UTestAnimInst, LookatAlpha2) == 0x0002C4, "Member 'UTestAnimInst::LookatAlpha2' has a wrong offset!");
static_assert(offsetof(UTestAnimInst, ExpressionTrig) == 0x0002C8, "Member 'UTestAnimInst::ExpressionTrig' has a wrong offset!");
static_assert(offsetof(UTestAnimInst, AnimSeq0) == 0x0002D0, "Member 'UTestAnimInst::AnimSeq0' has a wrong offset!");
static_assert(offsetof(UTestAnimInst, AnimSeq1) == 0x0002D8, "Member 'UTestAnimInst::AnimSeq1' has a wrong offset!");

// Class xrd777.CollisionActor
// 0x0008 (0x00B8 - 0x00B0)
class UCollisionActor final : public UActorComponent
{
public:
	class USphereComponent*                       MpSphere;                                          // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBeginOverlapSphere(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapSphere(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionActor">();
	}
	static class UCollisionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionActor>();
	}
};
static_assert(alignof(UCollisionActor) == 0x000008, "Wrong alignment on UCollisionActor");
static_assert(sizeof(UCollisionActor) == 0x0000B8, "Wrong size on UCollisionActor");
static_assert(offsetof(UCollisionActor, MpSphere) == 0x0000B0, "Member 'UCollisionActor::MpSphere' has a wrong offset!");

// Class xrd777.UIAssist
// 0x01F8 (0x0220 - 0x0028)
class UUIAssist final : public UObject
{
public:
	class UBmdAsset*                              MessageData_;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAssistSpriteItem                      Sprites_[0xB];                                     // 0x0058(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAssist">();
	}
	static class UUIAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAssist>();
	}
};
static_assert(alignof(UUIAssist) == 0x000008, "Wrong alignment on UUIAssist");
static_assert(sizeof(UUIAssist) == 0x000220, "Wrong size on UUIAssist");
static_assert(offsetof(UUIAssist, MessageData_) == 0x000028, "Member 'UUIAssist::MessageData_' has a wrong offset!");
static_assert(offsetof(UUIAssist, Sprites_) == 0x000058, "Member 'UUIAssist::Sprites_' has a wrong offset!");
static_assert(offsetof(UUIAssist, Loader_) == 0x000218, "Member 'UUIAssist::Loader_' has a wrong offset!");

// Class xrd777.ModelTestComp
// 0x0170 (0x0220 - 0x00B0)
class alignas(0x10) UModelTestComp final : public UActorComponent
{
public:
	class UDebugMenu*                             MpDebugMenu;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacter>                 MCharClass;                                        // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              MpTestSpr;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              MpTestMaterial;                                    // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MpTestMID;                                         // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             MMatPushPopArray;                                  // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MMatArray;                                         // 0x0100(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimController*                        MpAnimController;                                  // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             MpTestSpawnCharacter;                              // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  MTestAnimSeqArray;                                 // 0x0130(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x30];                                     // 0x0140(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     MAiCharArray;                                      // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ACineCameraActor*                       MpCamera;                                          // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               MpSceneCaptureComp;                                // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCollisionActor*                        MpCollisionActor;                                  // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       MpAttachTestSphere;                                // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MpMeshComp;                                        // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APointLight*                            MpLight;                                           // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           MpAssetLoader;                                     // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     MpPostProcessVolume;                               // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MpCaptureDrawMat;                                  // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      MTestMatArray;                                     // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MTestMidArray;                                     // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USprAsset*                              MpDrawTestSpr;                                     // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTestActorComponent*                    MTestComponent;                                    // 0x0210(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InputActivate;                                     // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelTestComp">();
	}
	static class UModelTestComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelTestComp>();
	}
};
static_assert(alignof(UModelTestComp) == 0x000010, "Wrong alignment on UModelTestComp");
static_assert(sizeof(UModelTestComp) == 0x000220, "Wrong size on UModelTestComp");
static_assert(offsetof(UModelTestComp, MpDebugMenu) == 0x0000B0, "Member 'UModelTestComp::MpDebugMenu' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MCharClass) == 0x0000C0, "Member 'UModelTestComp::MCharClass' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpTestSpr) == 0x0000D8, "Member 'UModelTestComp::MpTestSpr' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpTestMaterial) == 0x0000E0, "Member 'UModelTestComp::MpTestMaterial' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpTestMID) == 0x0000E8, "Member 'UModelTestComp::MpTestMID' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MMatPushPopArray) == 0x0000F0, "Member 'UModelTestComp::MMatPushPopArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MMatArray) == 0x000100, "Member 'UModelTestComp::MMatArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpAnimController) == 0x000120, "Member 'UModelTestComp::MpAnimController' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpTestSpawnCharacter) == 0x000128, "Member 'UModelTestComp::MpTestSpawnCharacter' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MTestAnimSeqArray) == 0x000130, "Member 'UModelTestComp::MTestAnimSeqArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MAiCharArray) == 0x000170, "Member 'UModelTestComp::MAiCharArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpCamera) == 0x000180, "Member 'UModelTestComp::MpCamera' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpSceneCaptureComp) == 0x000188, "Member 'UModelTestComp::MpSceneCaptureComp' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpCollisionActor) == 0x000190, "Member 'UModelTestComp::MpCollisionActor' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpAttachTestSphere) == 0x000198, "Member 'UModelTestComp::MpAttachTestSphere' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpMeshComp) == 0x0001A8, "Member 'UModelTestComp::MpMeshComp' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpLight) == 0x0001B0, "Member 'UModelTestComp::MpLight' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpAssetLoader) == 0x0001B8, "Member 'UModelTestComp::MpAssetLoader' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpPostProcessVolume) == 0x0001D0, "Member 'UModelTestComp::MpPostProcessVolume' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpCaptureDrawMat) == 0x0001D8, "Member 'UModelTestComp::MpCaptureDrawMat' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MTestMatArray) == 0x0001E0, "Member 'UModelTestComp::MTestMatArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MTestMidArray) == 0x0001F0, "Member 'UModelTestComp::MTestMidArray' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MpDrawTestSpr) == 0x000200, "Member 'UModelTestComp::MpDrawTestSpr' has a wrong offset!");
static_assert(offsetof(UModelTestComp, MTestComponent) == 0x000210, "Member 'UModelTestComp::MTestComponent' has a wrong offset!");
static_assert(offsetof(UModelTestComp, InputActivate) == 0x000218, "Member 'UModelTestComp::InputActivate' has a wrong offset!");

// Class xrd777.ModelTest
// 0x0008 (0x0228 - 0x0220)
class AModelTest final : public AActor
{
public:
	class UModelTestComp*                         MpModelTestComp;                                   // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelTest">();
	}
	static class AModelTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModelTest>();
	}
};
static_assert(alignof(AModelTest) == 0x000008, "Wrong alignment on AModelTest");
static_assert(sizeof(AModelTest) == 0x000228, "Wrong size on AModelTest");
static_assert(offsetof(AModelTest, MpModelTestComp) == 0x000220, "Member 'AModelTest::MpModelTestComp' has a wrong offset!");

// Class xrd777.MovieCuePointFunction
// 0x0000 (0x0028 - 0x0028)
class UMovieCuePointFunction final : public UBlueprintFunctionLibrary
{
public:
	static void MovieBindCuePointFunction(class UManaComponent* ManaComponent);
	static int32 MovieCheckTrackId(class UManaComponent* ManaComponent, int32 TrackId);
	static int32 MovieGetLanguageTrack();
	static bool MovieIsLoadedAssetForCuePoint();
	static void MovieLoadAssetForCuePoint(class UManaComponent* ManaComponent);
	static void MovieLoadAssetStart();
	static void MovieSetMetaDataWorkAllocator(class UManaComponent* ManaComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieCuePointFunction">();
	}
	static class UMovieCuePointFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieCuePointFunction>();
	}
};
static_assert(alignof(UMovieCuePointFunction) == 0x000008, "Wrong alignment on UMovieCuePointFunction");
static_assert(sizeof(UMovieCuePointFunction) == 0x000028, "Wrong size on UMovieCuePointFunction");

// Class xrd777.MovieCuePointManager
// 0x0028 (0x0050 - 0x0028)
class UMovieCuePointManager final : public UObject
{
public:
	class UAssetLoader*                           AssetLoader;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieCuePointManager">();
	}
	static class UMovieCuePointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieCuePointManager>();
	}
};
static_assert(alignof(UMovieCuePointManager) == 0x000008, "Wrong alignment on UMovieCuePointManager");
static_assert(sizeof(UMovieCuePointManager) == 0x000050, "Wrong size on UMovieCuePointManager");
static_assert(offsetof(UMovieCuePointManager, AssetLoader) == 0x000028, "Member 'UMovieCuePointManager::AssetLoader' has a wrong offset!");
static_assert(offsetof(UMovieCuePointManager, BmdAsset) == 0x000030, "Member 'UMovieCuePointManager::BmdAsset' has a wrong offset!");

// Class xrd777.UICalc
// 0x0000 (0x0028 - 0x0028)
class UUICalc final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICalc">();
	}
	static class UUICalc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICalc>();
	}
};
static_assert(alignof(UUICalc) == 0x000008, "Wrong alignment on UUICalc");
static_assert(sizeof(UUICalc) == 0x000028, "Wrong size on UUICalc");

// Class xrd777.MoviePanel
// 0x0018 (0x00C8 - 0x00B0)
class UMoviePanel final : public UActorComponent
{
public:
	class UMaterialInterface*                     MovieMaterial;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OTType;                                            // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOT(int32 OT);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePanel">();
	}
	static class UMoviePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoviePanel>();
	}
};
static_assert(alignof(UMoviePanel) == 0x000008, "Wrong alignment on UMoviePanel");
static_assert(sizeof(UMoviePanel) == 0x0000C8, "Wrong size on UMoviePanel");
static_assert(offsetof(UMoviePanel, MovieMaterial) == 0x0000B0, "Member 'UMoviePanel::MovieMaterial' has a wrong offset!");
static_assert(offsetof(UMoviePanel, bEnable) == 0x0000B8, "Member 'UMoviePanel::bEnable' has a wrong offset!");
static_assert(offsetof(UMoviePanel, OTType) == 0x0000BC, "Member 'UMoviePanel::OTType' has a wrong offset!");

// Class xrd777.MoviePlayActorBase
// 0x0038 (0x02B0 - 0x0278)
class AMoviePlayActorBase : public AAppActor
{
public:
	TArray<int32>                                 MovieIDList;                                       // 0x0278(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableAutoFlg;                                     // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayBgmOnMovieEnd;                               // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMoviePlayActorBase*                    MainActor;                                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMoviePlayActorBase>        SubClass;                                          // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UManaComponent*                         ManaComponent;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CallOpenSourceForBP();
	void Close(bool ForceClose);
	void MovieEnd();
	void MoviePlay(const class FString& OpenedUrl);
	void Remove();
	void RequestMovie(int32 ID);
	void SetManaComponent(class UManaComponent* InManaComponent);
	void Start();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePlayActorBase">();
	}
	static class AMoviePlayActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoviePlayActorBase>();
	}
};
static_assert(alignof(AMoviePlayActorBase) == 0x000008, "Wrong alignment on AMoviePlayActorBase");
static_assert(sizeof(AMoviePlayActorBase) == 0x0002B0, "Wrong size on AMoviePlayActorBase");
static_assert(offsetof(AMoviePlayActorBase, MovieIDList) == 0x000278, "Member 'AMoviePlayActorBase::MovieIDList' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, EnableAutoFlg) == 0x000288, "Member 'AMoviePlayActorBase::EnableAutoFlg' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, IsPlayBgmOnMovieEnd) == 0x000289, "Member 'AMoviePlayActorBase::IsPlayBgmOnMovieEnd' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, Loader) == 0x000290, "Member 'AMoviePlayActorBase::Loader' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, MainActor) == 0x000298, "Member 'AMoviePlayActorBase::MainActor' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, SubClass) == 0x0002A0, "Member 'AMoviePlayActorBase::SubClass' has a wrong offset!");
static_assert(offsetof(AMoviePlayActorBase, ManaComponent) == 0x0002A8, "Member 'AMoviePlayActorBase::ManaComponent' has a wrong offset!");

// Class xrd777.MoviePlayActor
// 0x0028 (0x02D8 - 0x02B0)
class AMoviePlayActor final : public AMoviePlayActorBase
{
public:
	bool                                          IsMaterialMovie;                                   // 0x02B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0xF];                                      // 0x02B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieCuePointManager*                  CuePointManager;                                   // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckInstance();
	static void CreateInstance();
	static class AMoviePlayActor* GetInstance();
	static bool SyncInstance();

	bool CanDestroy();
	bool GetBGMFlg();
	bool IsBattleWipe();
	bool IsPause();
	bool IsReserveDestroy();
	void Pause(bool IsPause);
	void ReserveDestroy();
	void VisibleKeyHelp(bool bIsVisible);

	bool GetPlayBgmOnMovieEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePlayActor">();
	}
	static class AMoviePlayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoviePlayActor>();
	}
};
static_assert(alignof(AMoviePlayActor) == 0x000008, "Wrong alignment on AMoviePlayActor");
static_assert(sizeof(AMoviePlayActor) == 0x0002D8, "Wrong size on AMoviePlayActor");
static_assert(offsetof(AMoviePlayActor, IsMaterialMovie) == 0x0002B0, "Member 'AMoviePlayActor::IsMaterialMovie' has a wrong offset!");
static_assert(offsetof(AMoviePlayActor, CuePointManager) == 0x0002C0, "Member 'AMoviePlayActor::CuePointManager' has a wrong offset!");

// Class xrd777.MoviePlayActorBattle
// 0x0000 (0x02B0 - 0x02B0)
class AMoviePlayActorBattle final : public AMoviePlayActorBase
{
public:
	static bool CheckBattleMovieInstance();
	static void CreateBattleMovieInstance();
	static class AMoviePlayActorBattle* GetBattleMovieInstance();
	static bool SyncBattleMovieInstance();

	bool CheckPrepareForBP();
	void MaterialStartForBP();
	void RequestRemoveMaterialsForBP();
	void RequestStopperForBP(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePlayActorBattle">();
	}
	static class AMoviePlayActorBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoviePlayActorBattle>();
	}
};
static_assert(alignof(AMoviePlayActorBattle) == 0x000008, "Wrong alignment on AMoviePlayActorBattle");
static_assert(sizeof(AMoviePlayActorBattle) == 0x0002B0, "Wrong size on AMoviePlayActorBattle");

// Class xrd777.SoundMonitoring
// 0x0028 (0x02A0 - 0x0278)
class ASoundMonitoring final : public AAppActor
{
public:
	uint8                                         Pad_278[0x28];                                     // 0x0278(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckReadBank(int32 ReadBank);
	static bool CheckReadyPlayer(int32 PlayerId);
	static bool CheckReadySoundMonitor();
	static bool CreatePlayer(int32 PlayerId, EsoundPlayerType Type);
	static bool FadeInBGMCategorySoundMonitor(int32 FadeInTime, float FadeInVolume);
	static bool FadeOutBGMCategorySoundMonitor(int32 FadeOutTime, float FadeOutVolume);
	static int32 PlayCueID(int32 PlayerId, int32 CueId);
	static void SetReadBankToPlayer(int32 PlayerId, int32 ReadBank);
	static int32 StartFreeAcb(int32 bankID);
	static int32 StartFreePlayer(int32 PlayerId);
	static int32 StartReadAcb(const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMonitoring">();
	}
	static class ASoundMonitoring* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundMonitoring>();
	}
};
static_assert(alignof(ASoundMonitoring) == 0x000008, "Wrong alignment on ASoundMonitoring");
static_assert(sizeof(ASoundMonitoring) == 0x0002A0, "Wrong size on ASoundMonitoring");

// Class xrd777.MoviePlayActorEventSequenceTrack
// 0x0020 (0x02D0 - 0x02B0)
class AMoviePlayActorEventSequenceTrack final : public AMoviePlayActorBase
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMovieCuePointManager*                  CuePointManager;                                   // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckInstance();
	static void CreateInstance();
	static class AMoviePlayActorEventSequenceTrack* GetInstance();
	static bool SyncInstance();

	bool IsPause_Main220040();
	void OnBeginPlay(class UManaComponent* InManaComponent);
	void OnSeekCompleted(int32 InFrameNumber, class UManaComponent* InManaComponent);
	void OnSequenceUpdate(const struct FQualifiedFrameTime& InCurrentTime, const struct FQualifiedFrameTime& InPreviousTime);
	void OnTextureUpdated(int32 InFrameNumber, class UManaComponent* InManaComponent);
	void SetPause_Main220040(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePlayActorEventSequenceTrack">();
	}
	static class AMoviePlayActorEventSequenceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoviePlayActorEventSequenceTrack>();
	}
};
static_assert(alignof(AMoviePlayActorEventSequenceTrack) == 0x000008, "Wrong alignment on AMoviePlayActorEventSequenceTrack");
static_assert(sizeof(AMoviePlayActorEventSequenceTrack) == 0x0002D0, "Wrong size on AMoviePlayActorEventSequenceTrack");
static_assert(offsetof(AMoviePlayActorEventSequenceTrack, CuePointManager) == 0x0002C0, "Member 'AMoviePlayActorEventSequenceTrack::CuePointManager' has a wrong offset!");

// Class xrd777.MoviePlayTest
// 0x05B0 (0x07D0 - 0x0220)
class AMoviePlayTest final : public AActor
{
public:
	uint8                                         Pad_220[0x5A0];                                    // 0x0220(0x05A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AMoviePlayActor*                        MovieActor;                                        // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MMovieInhibitActor;                                // 0x07C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoviePlayTest">();
	}
	static class AMoviePlayTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoviePlayTest>();
	}
};
static_assert(alignof(AMoviePlayTest) == 0x000008, "Wrong alignment on AMoviePlayTest");
static_assert(sizeof(AMoviePlayTest) == 0x0007D0, "Wrong size on AMoviePlayTest");
static_assert(offsetof(AMoviePlayTest, MovieActor) == 0x0007C0, "Member 'AMoviePlayTest::MovieActor' has a wrong offset!");
static_assert(offsetof(AMoviePlayTest, MMovieInhibitActor) == 0x0007C8, "Member 'AMoviePlayTest::MMovieInhibitActor' has a wrong offset!");

// Class xrd777.MovieSceneEvtAdxSoundFadeSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtAdxSoundFadeSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtAdxSoundFadeSectionData  EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundFadeSection">();
	}
	static class UMovieSceneEvtAdxSoundFadeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundFadeSection>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundFadeSection) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundFadeSection");
static_assert(sizeof(UMovieSceneEvtAdxSoundFadeSection) == 0x000170, "Wrong size on UMovieSceneEvtAdxSoundFadeSection");
static_assert(offsetof(UMovieSceneEvtAdxSoundFadeSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtAdxSoundFadeSection::EventData' has a wrong offset!");

// Class xrd777.SoundTableTypes
// 0x0000 (0x0028 - 0x0028)
class USoundTableTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundTableTypes">();
	}
	static class USoundTableTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundTableTypes>();
	}
};
static_assert(alignof(USoundTableTypes) == 0x000008, "Wrong alignment on USoundTableTypes");
static_assert(sizeof(USoundTableTypes) == 0x000028, "Wrong size on USoundTableTypes");

// Class xrd777.MovieSceneEvtAdxSoundFadeTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtAdxSoundFadeTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundFadeTrack">();
	}
	static class UMovieSceneEvtAdxSoundFadeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundFadeTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundFadeTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundFadeTrack");
static_assert(sizeof(UMovieSceneEvtAdxSoundFadeTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtAdxSoundFadeTrack");
static_assert(offsetof(UMovieSceneEvtAdxSoundFadeTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtAdxSoundFadeTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtAdxSoundManageSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtAdxSoundManageSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtAdxSoundManageSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundManageSection">();
	}
	static class UMovieSceneEvtAdxSoundManageSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundManageSection>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundManageSection) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundManageSection");
static_assert(sizeof(UMovieSceneEvtAdxSoundManageSection) == 0x000170, "Wrong size on UMovieSceneEvtAdxSoundManageSection");
static_assert(offsetof(UMovieSceneEvtAdxSoundManageSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtAdxSoundManageSection::EventData' has a wrong offset!");

// Class xrd777.MovieSceneEvtAdxSoundManageTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtAdxSoundManageTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundManageTrack">();
	}
	static class UMovieSceneEvtAdxSoundManageTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundManageTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundManageTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundManageTrack");
static_assert(sizeof(UMovieSceneEvtAdxSoundManageTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtAdxSoundManageTrack");
static_assert(offsetof(UMovieSceneEvtAdxSoundManageTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtAdxSoundManageTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtAdxSoundSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtAdxSoundSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtAdxSoundSectionData      EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundSection">();
	}
	static class UMovieSceneEvtAdxSoundSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundSection>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundSection) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundSection");
static_assert(sizeof(UMovieSceneEvtAdxSoundSection) == 0x000170, "Wrong size on UMovieSceneEvtAdxSoundSection");
static_assert(offsetof(UMovieSceneEvtAdxSoundSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtAdxSoundSection::EventData' has a wrong offset!");

// Class xrd777.StaffRollDataAsset
// 0x0020 (0x0050 - 0x0030)
class UStaffRollDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FStaffRollTableData>            Data;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaffRollDataAsset">();
	}
	static class UStaffRollDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaffRollDataAsset>();
	}
};
static_assert(alignof(UStaffRollDataAsset) == 0x000008, "Wrong alignment on UStaffRollDataAsset");
static_assert(sizeof(UStaffRollDataAsset) == 0x000050, "Wrong size on UStaffRollDataAsset");
static_assert(offsetof(UStaffRollDataAsset, Data) == 0x000030, "Member 'UStaffRollDataAsset::Data' has a wrong offset!");

// Class xrd777.MovieSceneEvtAdxSoundTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtAdxSoundTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtAdxSoundTrack">();
	}
	static class UMovieSceneEvtAdxSoundTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtAdxSoundTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtAdxSoundTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtAdxSoundTrack");
static_assert(sizeof(UMovieSceneEvtAdxSoundTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtAdxSoundTrack");
static_assert(offsetof(UMovieSceneEvtAdxSoundTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtAdxSoundTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaAnimationSection
// 0x0100 (0x01E8 - 0x00E8)
class UMovieSceneEvtCharaAnimationSection final : public UMovieSceneSection
{
public:
	struct FNameCurve                             Events;                                            // 0x00E8(0x0078)(Deprecated, NativeAccessSpecifierPrivate)
	struct FMovieSceneEvtCharaAnimationSectionData EventData;                                         // 0x0160(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaAnimationSection">();
	}
	static class UMovieSceneEvtCharaAnimationSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaAnimationSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaAnimationSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaAnimationSection");
static_assert(sizeof(UMovieSceneEvtCharaAnimationSection) == 0x0001E8, "Wrong size on UMovieSceneEvtCharaAnimationSection");
static_assert(offsetof(UMovieSceneEvtCharaAnimationSection, Events) == 0x0000E8, "Member 'UMovieSceneEvtCharaAnimationSection::Events' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaAnimationSection, EventData) == 0x000160, "Member 'UMovieSceneEvtCharaAnimationSection::EventData' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaAnimationTrack
// 0x0030 (0x00E8 - 0x00B8)
class UMovieSceneEvtCharaAnimationTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAtlCharaAnimFireEventsAtPosition             EventPosition;                                     // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaAnimationTrack">();
	}
	static class UMovieSceneEvtCharaAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaAnimationTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaAnimationTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaAnimationTrack");
static_assert(sizeof(UMovieSceneEvtCharaAnimationTrack) == 0x0000E8, "Wrong size on UMovieSceneEvtCharaAnimationTrack");
static_assert(offsetof(UMovieSceneEvtCharaAnimationTrack, EventPosition) == 0x0000C4, "Member 'UMovieSceneEvtCharaAnimationTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaAnimationTrack, EventReceivers) == 0x0000C8, "Member 'UMovieSceneEvtCharaAnimationTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaAnimationTrack, Sections) == 0x0000D8, "Member 'UMovieSceneEvtCharaAnimationTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaHandwritingSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtCharaHandwritingSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtCharaHandwritingSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaHandwritingSection">();
	}
	static class UMovieSceneEvtCharaHandwritingSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaHandwritingSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaHandwritingSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaHandwritingSection");
static_assert(sizeof(UMovieSceneEvtCharaHandwritingSection) == 0x000170, "Wrong size on UMovieSceneEvtCharaHandwritingSection");
static_assert(offsetof(UMovieSceneEvtCharaHandwritingSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtCharaHandwritingSection::EventData' has a wrong offset!");

// Class xrd777.SuzukiDrawTest
// 0x0018 (0x0290 - 0x0278)
class ASuzukiDrawTest final : public AAppActor
{
public:
	class UAssetLoader*                           PAssetLoader;                                      // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ASuzukiDrawTestDraw>        SuzukiDrawTestDrawClass;                           // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASuzukiDrawTestDraw*                    PSuzukiDrawTestDraw;                               // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuzukiDrawTest">();
	}
	static class ASuzukiDrawTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuzukiDrawTest>();
	}
};
static_assert(alignof(ASuzukiDrawTest) == 0x000008, "Wrong alignment on ASuzukiDrawTest");
static_assert(sizeof(ASuzukiDrawTest) == 0x000290, "Wrong size on ASuzukiDrawTest");
static_assert(offsetof(ASuzukiDrawTest, PAssetLoader) == 0x000278, "Member 'ASuzukiDrawTest::PAssetLoader' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTest, SuzukiDrawTestDrawClass) == 0x000280, "Member 'ASuzukiDrawTest::SuzukiDrawTestDrawClass' has a wrong offset!");
static_assert(offsetof(ASuzukiDrawTest, PSuzukiDrawTestDraw) == 0x000288, "Member 'ASuzukiDrawTest::PSuzukiDrawTestDraw' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaHandwritingTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtCharaHandwritingTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaHandwritingTrack">();
	}
	static class UMovieSceneEvtCharaHandwritingTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaHandwritingTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaHandwritingTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaHandwritingTrack");
static_assert(sizeof(UMovieSceneEvtCharaHandwritingTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtCharaHandwritingTrack");
static_assert(offsetof(UMovieSceneEvtCharaHandwritingTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtCharaHandwritingTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaOperationControllerSection
// 0x0088 (0x0170 - 0x00E8)
class UMovieSceneEvtCharaOperationControllerSection final : public UMovieSceneSection
{
public:
	struct FMovieSceneEvtCharaOperationControllerSectionData EventData;                                         // 0x00E8(0x0088)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaOperationControllerSection">();
	}
	static class UMovieSceneEvtCharaOperationControllerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaOperationControllerSection>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaOperationControllerSection) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaOperationControllerSection");
static_assert(sizeof(UMovieSceneEvtCharaOperationControllerSection) == 0x000170, "Wrong size on UMovieSceneEvtCharaOperationControllerSection");
static_assert(offsetof(UMovieSceneEvtCharaOperationControllerSection, EventData) == 0x0000E8, "Member 'UMovieSceneEvtCharaOperationControllerSection::EventData' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaOperationControllerTrack
// 0x0030 (0x00E8 - 0x00B8)
class UMovieSceneEvtCharaOperationControllerTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaOperationControllerTrack">();
	}
	static class UMovieSceneEvtCharaOperationControllerTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaOperationControllerTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaOperationControllerTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaOperationControllerTrack");
static_assert(sizeof(UMovieSceneEvtCharaOperationControllerTrack) == 0x0000E8, "Wrong size on UMovieSceneEvtCharaOperationControllerTrack");
static_assert(offsetof(UMovieSceneEvtCharaOperationControllerTrack, EventReceivers) == 0x0000C8, "Member 'UMovieSceneEvtCharaOperationControllerTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaOperationControllerTrack, Sections) == 0x0000D8, "Member 'UMovieSceneEvtCharaOperationControllerTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtCharaPackFaceAnimationTrack
// 0x0030 (0x00E8 - 0x00B8)
class UMovieSceneEvtCharaPackFaceAnimationTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAtlCharaFaceAnimFireEventsAtPosition         EventPosition;                                     // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtCharaPackFaceAnimationTrack">();
	}
	static class UMovieSceneEvtCharaPackFaceAnimationTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtCharaPackFaceAnimationTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtCharaPackFaceAnimationTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtCharaPackFaceAnimationTrack");
static_assert(sizeof(UMovieSceneEvtCharaPackFaceAnimationTrack) == 0x0000E8, "Wrong size on UMovieSceneEvtCharaPackFaceAnimationTrack");
static_assert(offsetof(UMovieSceneEvtCharaPackFaceAnimationTrack, EventPosition) == 0x0000C4, "Member 'UMovieSceneEvtCharaPackFaceAnimationTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaPackFaceAnimationTrack, EventReceivers) == 0x0000C8, "Member 'UMovieSceneEvtCharaPackFaceAnimationTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtCharaPackFaceAnimationTrack, Sections) == 0x0000D8, "Member 'UMovieSceneEvtCharaPackFaceAnimationTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtDialogueOptionsTrack
// 0x0030 (0x00C0 - 0x0090)
class UMovieSceneEvtDialogueOptionsTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFireEventsAtPositionggg                      EventPosition;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtDialogueOptionsTrack">();
	}
	static class UMovieSceneEvtDialogueOptionsTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtDialogueOptionsTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtDialogueOptionsTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtDialogueOptionsTrack");
static_assert(sizeof(UMovieSceneEvtDialogueOptionsTrack) == 0x0000C0, "Wrong size on UMovieSceneEvtDialogueOptionsTrack");
static_assert(offsetof(UMovieSceneEvtDialogueOptionsTrack, EventPosition) == 0x00009C, "Member 'UMovieSceneEvtDialogueOptionsTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtDialogueOptionsTrack, EventReceivers) == 0x0000A0, "Member 'UMovieSceneEvtDialogueOptionsTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtDialogueOptionsTrack, Sections) == 0x0000B0, "Member 'UMovieSceneEvtDialogueOptionsTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtFadeScreenTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtFadeScreenTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtFadeScreenTrack">();
	}
	static class UMovieSceneEvtFadeScreenTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtFadeScreenTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtFadeScreenTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtFadeScreenTrack");
static_assert(sizeof(UMovieSceneEvtFadeScreenTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtFadeScreenTrack");
static_assert(offsetof(UMovieSceneEvtFadeScreenTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtFadeScreenTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtMessageSubtitleTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtMessageSubtitleTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtMessageSubtitleTrack">();
	}
	static class UMovieSceneEvtMessageSubtitleTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtMessageSubtitleTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtMessageSubtitleTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtMessageSubtitleTrack");
static_assert(sizeof(UMovieSceneEvtMessageSubtitleTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtMessageSubtitleTrack");
static_assert(offsetof(UMovieSceneEvtMessageSubtitleTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtMessageSubtitleTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtScriptTrack
// 0x0020 (0x00D8 - 0x00B8)
class UMovieSceneEvtScriptTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtScriptTrack">();
	}
	static class UMovieSceneEvtScriptTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtScriptTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtScriptTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtScriptTrack");
static_assert(sizeof(UMovieSceneEvtScriptTrack) == 0x0000D8, "Wrong size on UMovieSceneEvtScriptTrack");
static_assert(offsetof(UMovieSceneEvtScriptTrack, Sections) == 0x0000C8, "Member 'UMovieSceneEvtScriptTrack::Sections' has a wrong offset!");

// Class xrd777.MovieSceneEvtSeqTimeJumpControllerTrack
// 0x0030 (0x00E8 - 0x00B8)
class UMovieSceneEvtSeqTimeJumpControllerTrack final : public UMovieSceneEvtConditionalBranchTrack
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieSceneObjectBindingID>     EventReceivers;                                    // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneEvtSeqTimeJumpControllerTrack">();
	}
	static class UMovieSceneEvtSeqTimeJumpControllerTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneEvtSeqTimeJumpControllerTrack>();
	}
};
static_assert(alignof(UMovieSceneEvtSeqTimeJumpControllerTrack) == 0x000008, "Wrong alignment on UMovieSceneEvtSeqTimeJumpControllerTrack");
static_assert(sizeof(UMovieSceneEvtSeqTimeJumpControllerTrack) == 0x0000E8, "Wrong size on UMovieSceneEvtSeqTimeJumpControllerTrack");
static_assert(offsetof(UMovieSceneEvtSeqTimeJumpControllerTrack, EventReceivers) == 0x0000C8, "Member 'UMovieSceneEvtSeqTimeJumpControllerTrack::EventReceivers' has a wrong offset!");
static_assert(offsetof(UMovieSceneEvtSeqTimeJumpControllerTrack, Sections) == 0x0000D8, "Member 'UMovieSceneEvtSeqTimeJumpControllerTrack::Sections' has a wrong offset!");

// Class xrd777.NiagaraCameraAttachComponent
// 0x0050 (0x0250 - 0x0200)
class UNiagaraCameraAttachComponent final : public USceneComponent
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          NiagaraSystem;                                     // 0x01F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0220(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsyncSystemLoad;                                  // 0x022D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E[0x2];                                      // 0x022E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         SpawnNiagaraSystem;                                // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoAttachCam;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutPlay;                                        // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ParticleComponent;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetParticleComponent();
	bool IsAssetLoaded();
	bool IsCallDestroy();
	void OnComplete(class UNiagaraComponent* PSystem);
	void OnLoadSystem();
	void PlayEffect();
	void SetAttachCam(class USceneComponent* Parent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraCameraAttachComponent">();
	}
	static class UNiagaraCameraAttachComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraCameraAttachComponent>();
	}
};
static_assert(alignof(UNiagaraCameraAttachComponent) == 0x000010, "Wrong alignment on UNiagaraCameraAttachComponent");
static_assert(sizeof(UNiagaraCameraAttachComponent) == 0x000250, "Wrong size on UNiagaraCameraAttachComponent");
static_assert(offsetof(UNiagaraCameraAttachComponent, NiagaraSystem) == 0x0001F8, "Member 'UNiagaraCameraAttachComponent::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, SpawnLocation) == 0x000220, "Member 'UNiagaraCameraAttachComponent::SpawnLocation' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, bAutoDestroy) == 0x00022C, "Member 'UNiagaraCameraAttachComponent::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, bAsyncSystemLoad) == 0x00022D, "Member 'UNiagaraCameraAttachComponent::bAsyncSystemLoad' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, SpawnNiagaraSystem) == 0x000230, "Member 'UNiagaraCameraAttachComponent::SpawnNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, bIsAutoAttachCam) == 0x000238, "Member 'UNiagaraCameraAttachComponent::bIsAutoAttachCam' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, bIsAutPlay) == 0x000239, "Member 'UNiagaraCameraAttachComponent::bIsAutPlay' has a wrong offset!");
static_assert(offsetof(UNiagaraCameraAttachComponent, ParticleComponent) == 0x000240, "Member 'UNiagaraCameraAttachComponent::ParticleComponent' has a wrong offset!");

// Class xrd777.OkadaTestMenu
// 0x0010 (0x0288 - 0x0278)
class AOkadaTestMenu final : public AAppActor
{
public:
	class AActor*                                 Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OkadaTestMenu">();
	}
	static class AOkadaTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOkadaTestMenu>();
	}
};
static_assert(alignof(AOkadaTestMenu) == 0x000008, "Wrong alignment on AOkadaTestMenu");
static_assert(sizeof(AOkadaTestMenu) == 0x000288, "Wrong size on AOkadaTestMenu");
static_assert(offsetof(AOkadaTestMenu, Actor_) == 0x000278, "Member 'AOkadaTestMenu::Actor_' has a wrong offset!");
static_assert(offsetof(AOkadaTestMenu, DebugMenu_) == 0x000280, "Member 'AOkadaTestMenu::DebugMenu_' has a wrong offset!");

// Class xrd777.PadRumbleSequencer
// 0x0000 (0x0278 - 0x0278)
class APadRumbleSequencer final : public AAppActor
{
public:
	void RumbleStartAsset(class UForceFeedbackEffect* PRumble, bool IsLoop);
	void RumbleStartLarge(int32 Power, int32 Frame, int32 WaitFrame, int32 Num, int32 TotalFram);
	void RumbleStartSmall(int32 Frame, int32 WaitFrame, int32 Num, int32 TotalFram);
	void RumbleStopAsset();
	void RumbleStopLarge();
	void RumbleStopSmall();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PadRumbleSequencer">();
	}
	static class APadRumbleSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<APadRumbleSequencer>();
	}
};
static_assert(alignof(APadRumbleSequencer) == 0x000008, "Wrong alignment on APadRumbleSequencer");
static_assert(sizeof(APadRumbleSequencer) == 0x000278, "Wrong size on APadRumbleSequencer");

// Class xrd777.PersonaStatusTest
// 0x0020 (0x0298 - 0x0278)
class APersonaStatusTest final : public AAppActor
{
public:
	class APersonaStatus*                         Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICombineCalc*                         CombineCalc_;                                      // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusTest">();
	}
	static class APersonaStatusTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaStatusTest>();
	}
};
static_assert(alignof(APersonaStatusTest) == 0x000008, "Wrong alignment on APersonaStatusTest");
static_assert(sizeof(APersonaStatusTest) == 0x000298, "Wrong size on APersonaStatusTest");
static_assert(offsetof(APersonaStatusTest, Actor_) == 0x000278, "Member 'APersonaStatusTest::Actor_' has a wrong offset!");
static_assert(offsetof(APersonaStatusTest, CombineCalc_) == 0x000288, "Member 'APersonaStatusTest::CombineCalc_' has a wrong offset!");
static_assert(offsetof(APersonaStatusTest, DebugMenu_) == 0x000290, "Member 'APersonaStatusTest::DebugMenu_' has a wrong offset!");

// Class xrd777.PrgssCmnDataActor
// 0x0018 (0x0290 - 0x0278)
class APrgssCmnDataActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MAssetLoader_;                                     // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrgssCmnDataActor">();
	}
	static class APrgssCmnDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrgssCmnDataActor>();
	}
};
static_assert(alignof(APrgssCmnDataActor) == 0x000008, "Wrong alignment on APrgssCmnDataActor");
static_assert(sizeof(APrgssCmnDataActor) == 0x000290, "Wrong size on APrgssCmnDataActor");
static_assert(offsetof(APrgssCmnDataActor, MAssetLoader_) == 0x000288, "Member 'APrgssCmnDataActor::MAssetLoader_' has a wrong offset!");

// Class xrd777.QuestElizRequest
// 0x0050 (0x0090 - 0x0040)
class UQuestElizRequest final : public UUIScene
{
public:
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmpQuest*                            Context_;                                          // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestElizMessage*                      ElizMessage_;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestElizRequest">();
	}
	static class UQuestElizRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestElizRequest>();
	}
};
static_assert(alignof(UQuestElizRequest) == 0x000008, "Wrong alignment on UQuestElizRequest");
static_assert(sizeof(UQuestElizRequest) == 0x000090, "Wrong size on UQuestElizRequest");
static_assert(offsetof(UQuestElizRequest, Context_) == 0x000080, "Member 'UQuestElizRequest::Context_' has a wrong offset!");
static_assert(offsetof(UQuestElizRequest, ElizMessage_) == 0x000088, "Member 'UQuestElizRequest::ElizMessage_' has a wrong offset!");

// Class xrd777.RightsNotationDraw
// 0x0138 (0x03F0 - 0x02B8)
class ARightsNotationDraw final : public AUIDrawBaseActor
{
public:
	struct FColor                                 BlackBoardColor;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 GladationBoardColor;                               // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BlueBoardColor;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BlackBoardCoverColor;                              // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 BlackBoardMoveSpeed;                               // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardMoveSpeed;                                // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardRollSpeed;                                // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 MainTextMoveSpeed;                                 // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 ScrollBarMoveSpeed;                                // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlackBoardAlphaSpeed;                              // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardAlphaSpeed;                               // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 GradationAlphaSpeed;                               // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 MainTextAlphaSpeed;                                // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 ScrollBarAlphaSpeed;                               // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         FadeOutAnimFinishTime;                             // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TEXT_BASE_POS_X;                                   // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TEXT_BASE_POS_Y;                                   // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkipScrollMoveRate;                                // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxDrawRowCount;                                   // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x44];                                     // 0x037C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               PCaptureTex;                                       // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    PCaptureBackGround;                                // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RightsNotationDraw">();
	}
	static class ARightsNotationDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARightsNotationDraw>();
	}
};
static_assert(alignof(ARightsNotationDraw) == 0x000008, "Wrong alignment on ARightsNotationDraw");
static_assert(sizeof(ARightsNotationDraw) == 0x0003F0, "Wrong size on ARightsNotationDraw");
static_assert(offsetof(ARightsNotationDraw, BlackBoardColor) == 0x0002B8, "Member 'ARightsNotationDraw::BlackBoardColor' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, GladationBoardColor) == 0x0002BC, "Member 'ARightsNotationDraw::GladationBoardColor' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlueBoardColor) == 0x0002C0, "Member 'ARightsNotationDraw::BlueBoardColor' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlackBoardCoverColor) == 0x0002C4, "Member 'ARightsNotationDraw::BlackBoardCoverColor' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlackBoardMoveSpeed) == 0x0002C8, "Member 'ARightsNotationDraw::BlackBoardMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlueBoardMoveSpeed) == 0x0002D8, "Member 'ARightsNotationDraw::BlueBoardMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlueBoardRollSpeed) == 0x0002E8, "Member 'ARightsNotationDraw::BlueBoardRollSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, MainTextMoveSpeed) == 0x0002F8, "Member 'ARightsNotationDraw::MainTextMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, ScrollBarMoveSpeed) == 0x000308, "Member 'ARightsNotationDraw::ScrollBarMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlackBoardAlphaSpeed) == 0x000318, "Member 'ARightsNotationDraw::BlackBoardAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, BlueBoardAlphaSpeed) == 0x000328, "Member 'ARightsNotationDraw::BlueBoardAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, GradationAlphaSpeed) == 0x000338, "Member 'ARightsNotationDraw::GradationAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, MainTextAlphaSpeed) == 0x000348, "Member 'ARightsNotationDraw::MainTextAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, ScrollBarAlphaSpeed) == 0x000358, "Member 'ARightsNotationDraw::ScrollBarAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, FadeOutAnimFinishTime) == 0x000368, "Member 'ARightsNotationDraw::FadeOutAnimFinishTime' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, TEXT_BASE_POS_X) == 0x00036C, "Member 'ARightsNotationDraw::TEXT_BASE_POS_X' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, TEXT_BASE_POS_Y) == 0x000370, "Member 'ARightsNotationDraw::TEXT_BASE_POS_Y' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, SkipScrollMoveRate) == 0x000374, "Member 'ARightsNotationDraw::SkipScrollMoveRate' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, MaxDrawRowCount) == 0x000378, "Member 'ARightsNotationDraw::MaxDrawRowCount' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, PCaptureTex) == 0x0003C0, "Member 'ARightsNotationDraw::PCaptureTex' has a wrong offset!");
static_assert(offsetof(ARightsNotationDraw, PCaptureBackGround) == 0x0003C8, "Member 'ARightsNotationDraw::PCaptureBackGround' has a wrong offset!");

// Class xrd777.ScrActor
// 0x0068 (0x0288 - 0x0220)
class AScrActor final : public AActor
{
public:
	class UBfAsset*                               MpBfAsset;                                         // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBmdAsset*                              MpBmdAsset;                                        // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x40];                                     // 0x0230(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           MpAssetLoader;                                     // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScrActorFinishedDelegate;                        // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ForcedStopScr();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrActor">();
	}
	static class AScrActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScrActor>();
	}
};
static_assert(alignof(AScrActor) == 0x000008, "Wrong alignment on AScrActor");
static_assert(sizeof(AScrActor) == 0x000288, "Wrong size on AScrActor");
static_assert(offsetof(AScrActor, MpBfAsset) == 0x000220, "Member 'AScrActor::MpBfAsset' has a wrong offset!");
static_assert(offsetof(AScrActor, MpBmdAsset) == 0x000228, "Member 'AScrActor::MpBmdAsset' has a wrong offset!");
static_assert(offsetof(AScrActor, MpAssetLoader) == 0x000270, "Member 'AScrActor::MpAssetLoader' has a wrong offset!");
static_assert(offsetof(AScrActor, OnScrActorFinishedDelegate) == 0x000278, "Member 'AScrActor::OnScrActorFinishedDelegate' has a wrong offset!");

// Class xrd777.SignedInDialog
// 0x0030 (0x0058 - 0x0028)
class USignedInDialog final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignedInDialog">();
	}
	static class USignedInDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignedInDialog>();
	}
};
static_assert(alignof(USignedInDialog) == 0x000008, "Wrong alignment on USignedInDialog");
static_assert(sizeof(USignedInDialog) == 0x000058, "Wrong size on USignedInDialog");

// Class xrd777.SoundApp
// 0x0000 (0x0028 - 0x0028)
class USoundApp final : public UObject
{
public:
	static void ApplyDspBusSnapshot(const class FString& SnapshotName, int32 Millisecond);
	static void AttachDspBusSetting(const class FString& SettingName);
	static bool CheckPauseEventVoice(int32 BankNum);
	static void DetachDspBusSetting();
	static void FadeInBGM(int32 FadeOutFrame);
	static void FadeInCategoryBGM(int32 FadeInFrame, float FadeOutVolume);
	static void FadeoutBGM(int32 FadeOutFrame);
	static void FadeOutCategoryBGM(int32 FadeOutFrame, float FadeOutVolume);
	static void FadeOutComSE(int32 FadeOutFrame);
	static class FString GetCurrentAppliedSnapshot();
	static float GetLength(int32 MajorId, int32 MinorId, int32 CueId);
	static struct FCriLipsMorphTargetBlendAmountAsJapanese GetLipsyncLiveInfo(int32 BankNum);
	static int32 GetNowPlayBGMQueID();
	static float GetTime(int32 MajorId, int32 MinorId);
	static void Init();
	static bool IsActiveBackLogVoiceData(int32 BankNum);
	static bool IsActiveBattleEventVoiceData(int32 BankNum);
	static bool IsActiveEventVoiceData(int32 BankNum);
	static bool IsActiveFacilityVoiceData(int32 BankNum);
	static bool IsPlayingBackLogVoice(int32 BankNum);
	static bool IsPlayingBattleEventVoice(int32 BankNum);
	static bool IsPlayingComSE(int32 BankNum);
	static bool IsPlayingEventVoice(int32 BankNum);
	static bool IsPlayingFacilityVoice(bool UseAttenuator, int32 BankNum);
	static bool IsPlayingSingleVoice(int32 BankNum);
	static bool IsSetupEndBackLogVoiceData(int32 BankNum);
	static bool IsSetupEndBattleEventVoiceData(int32 BankNum);
	static bool IsSetupEndEventVoiceData(int32 BankNum);
	static bool IsSetupEndFacilityVoiceData(int32 BankNum);
	static void PauseEventVoice(int32 BankNum, bool bPause);
	static void PlayBackLogVoice(int32 CueId, int32 BankNum);
	static void PlayBattleBGM(int32 CueId);
	static void PlayBattleEventVoice(int32 CueId, int32 BankNum);
	static void PlayBattleEventVoiceWithLipsync(EAppCharCategoryType CategoryType, int32 CharaIndexID, int32 CueId, int32 BankNum);
	static void PlayBGM(int32 CueId, bool IsForcePlay);
	static void PlayComSE(int32 CueId);
	static void PlayEventSE(int32 CueId, int32 BankNum);
	static void PlayEventVoice(int32 CueId, int32 BankNum);
	static void PlayEventVoiceWithLipsync(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID, int32 CueId, int32 BankNum);
	static void PlayEventVoiceWithSimpleLipCustomParam(const struct FCharacterSimpleLipsAnimAppParam& SimpleLipsParam, int32 CueId, int32 BankNum);
	static void PlayFacilityVoice(int32 CueId, int32 CharaIndexID, bool UseAttenuator, int32 BankNum, bool UseLips);
	static void PlaySingleVoice(int32 CueId);
	static void PlayVoiceWithLipsync(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID, int32 CueId, int32 SoundMajorID, int32 BankNum);
	static void PlayVoiceWithSimpleLipCustomParam(const struct FCharacterSimpleLipsAnimAppParam& SimpleLipsParam, int32 CueId, int32 SoundMajorID, int32 BankNum);
	static bool ReleaseBackLogVoiceData(class UGameInstance* GameInst, int32 BankNum);
	static bool ReleaseBattleEventVoiceData(class UGameInstance* GameInst, int32 BankNum);
	static bool ReleaseEventVoiceData(class UGameInstance* GameInst, int32 BankNum);
	static bool ReleaseFacilityVoiceData(class UGameInstance* GameInst, int32 BankNum);
	static bool ReqReadBackLogVoiceData(const class FString& Filename, int32 BankNum);
	static bool ReqReadBattleEventVoiceData(const class FString& Filename, int32 BankNum, bool UseLipsync);
	static bool ReqReadEventVoiceData(const class FString& Filename, int32 BankNum);
	static bool ReqReadFacilityVoiceData(const class FString& Filename, int32 BankNum);
	static void ResetSelectorLabel(int32 PlayerMajorID, int32 PlayerMinorID);
	static void SetAisacByNameBGM(float ControlValue);
	static void SetAisacByNameSE(float ControlValue);
	static void SetAisacByNameVOICE(float ControlValue);
	static void SetPausePlayer(int32 MajorId, int32 MinorId, bool bPause);
	static void SetPausePlayerAll(bool bPause);
	static void SetSelectorLabel(int32 PlayerMajorID, int32 PlayerMinorID, const class FString& Selector, const class FString& Label);
	static void SetSystemPausePlayerAll(bool bPause);
	static void StopBackLogVoice(int32 BankNum);
	static void StopBattleEventVoice(int32 BankNum);
	static void StopBGM();
	static void StopBGM_IMD();
	static void StopComSE(int32 CueId);
	static void StopEventSE(int32 CueId, int32 BankNum);
	static void StopEventVoice(int32 BankNum);
	static void StopEventVoiceWithLipSync(EAppCharCategoryType CharcterCategoryType, int32 CharaIndexID, int32 BankNum);
	static void StopFacilityVoice(int32 CharaIndexID, bool UseAttenuator, int32 BankNum);
	static void StopSingleVoice(int32 CueId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundApp">();
	}
	static class USoundApp* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundApp>();
	}
};
static_assert(alignof(USoundApp) == 0x000008, "Wrong alignment on USoundApp");
static_assert(sizeof(USoundApp) == 0x000028, "Wrong size on USoundApp");

// Class xrd777.SoundMonitorReadyAsyncFunction
// 0x0018 (0x0048 - 0x0030)
class USoundMonitorReadyAsyncFunction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundMonitorReadyAsyncFunction* SoundMonitorReadyAsyncFunction(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMonitorReadyAsyncFunction">();
	}
	static class USoundMonitorReadyAsyncFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundMonitorReadyAsyncFunction>();
	}
};
static_assert(alignof(USoundMonitorReadyAsyncFunction) == 0x000008, "Wrong alignment on USoundMonitorReadyAsyncFunction");
static_assert(sizeof(USoundMonitorReadyAsyncFunction) == 0x000048, "Wrong size on USoundMonitorReadyAsyncFunction");
static_assert(offsetof(USoundMonitorReadyAsyncFunction, Completed) == 0x000030, "Member 'USoundMonitorReadyAsyncFunction::Completed' has a wrong offset!");

// Class xrd777.SoundMonitorACBReadAsyncFunction
// 0x0020 (0x0050 - 0x0030)
class USoundMonitorACBReadAsyncFunction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundMonitorACBReadAsyncFunction* SoundMonitorACBReadAsyncFunction(class UObject* WorldContextObject, int32 AcbBankID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMonitorACBReadAsyncFunction">();
	}
	static class USoundMonitorACBReadAsyncFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundMonitorACBReadAsyncFunction>();
	}
};
static_assert(alignof(USoundMonitorACBReadAsyncFunction) == 0x000008, "Wrong alignment on USoundMonitorACBReadAsyncFunction");
static_assert(sizeof(USoundMonitorACBReadAsyncFunction) == 0x000050, "Wrong size on USoundMonitorACBReadAsyncFunction");
static_assert(offsetof(USoundMonitorACBReadAsyncFunction, Completed) == 0x000030, "Member 'USoundMonitorACBReadAsyncFunction::Completed' has a wrong offset!");

// Class xrd777.soundTestGameInstance
// 0x0010 (0x01B8 - 0x01A8)
class USoundTestGameInstance final : public UGameInstance
{
public:
	class UPlayAdxControl*                        M_PlayAdxControl;                                  // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPakFileManagerControl* GetFileManagerControl();
	class UPlayAdxControl* GetPlayAdxControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"soundTestGameInstance">();
	}
	static class USoundTestGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundTestGameInstance>();
	}
};
static_assert(alignof(USoundTestGameInstance) == 0x000008, "Wrong alignment on USoundTestGameInstance");
static_assert(sizeof(USoundTestGameInstance) == 0x0001B8, "Wrong size on USoundTestGameInstance");
static_assert(offsetof(USoundTestGameInstance, M_PlayAdxControl) == 0x0001A8, "Member 'USoundTestGameInstance::M_PlayAdxControl' has a wrong offset!");

// Class xrd777.StaffRoll
// 0x0118 (0x03D0 - 0x02B8)
class AStaffRoll final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pStaffRollDrawLoader;                            // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AStaffRollDraw>             StaffRollDrawClass;                                // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AStaffRollDraw*                         PStaffRollDraw;                                    // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaffRollDataAsset*                    PStaffRollDataList;                                // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMoviePlayActor*                        PStaffRollMovie;                                   // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFont*                                  PStaffRollFont;                                    // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGetUIParameter                        UIP_StaffRoll;                                     // 0x0308(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x50];                                     // 0x0380(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Draw();
	bool Start(int16 Type, bool RoundFlg);
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaffRoll">();
	}
	static class AStaffRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaffRoll>();
	}
};
static_assert(alignof(AStaffRoll) == 0x000008, "Wrong alignment on AStaffRoll");
static_assert(sizeof(AStaffRoll) == 0x0003D0, "Wrong size on AStaffRoll");
static_assert(offsetof(AStaffRoll, M_pStaffRollDrawLoader) == 0x0002D8, "Member 'AStaffRoll::M_pStaffRollDrawLoader' has a wrong offset!");
static_assert(offsetof(AStaffRoll, StaffRollDrawClass) == 0x0002E0, "Member 'AStaffRoll::StaffRollDrawClass' has a wrong offset!");
static_assert(offsetof(AStaffRoll, PStaffRollDraw) == 0x0002E8, "Member 'AStaffRoll::PStaffRollDraw' has a wrong offset!");
static_assert(offsetof(AStaffRoll, PStaffRollDataList) == 0x0002F0, "Member 'AStaffRoll::PStaffRollDataList' has a wrong offset!");
static_assert(offsetof(AStaffRoll, PStaffRollMovie) == 0x0002F8, "Member 'AStaffRoll::PStaffRollMovie' has a wrong offset!");
static_assert(offsetof(AStaffRoll, PStaffRollFont) == 0x000300, "Member 'AStaffRoll::PStaffRollFont' has a wrong offset!");
static_assert(offsetof(AStaffRoll, UIP_StaffRoll) == 0x000308, "Member 'AStaffRoll::UIP_StaffRoll' has a wrong offset!");

// Class xrd777.StaffRollDebugViewer
// 0x0048 (0x02D8 - 0x0290)
class AStaffRollDebugViewer final : public ADebugViewer
{
public:
	class UBfAsset*                               MpBfAsset;                                         // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetLoader*                           Loader_;                                           // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AScrActor*                              MpActor;                                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsBFAsset;                                         // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartScript;                                      // 0x02B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B2[0x1E];                                     // 0x02B2(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class AStaffRoll*                             PStaffRollSys;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaffRollDebugViewer">();
	}
	static class AStaffRollDebugViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaffRollDebugViewer>();
	}
};
static_assert(alignof(AStaffRollDebugViewer) == 0x000008, "Wrong alignment on AStaffRollDebugViewer");
static_assert(sizeof(AStaffRollDebugViewer) == 0x0002D8, "Wrong size on AStaffRollDebugViewer");
static_assert(offsetof(AStaffRollDebugViewer, MpBfAsset) == 0x000290, "Member 'AStaffRollDebugViewer::MpBfAsset' has a wrong offset!");
static_assert(offsetof(AStaffRollDebugViewer, Loader_) == 0x000298, "Member 'AStaffRollDebugViewer::Loader_' has a wrong offset!");
static_assert(offsetof(AStaffRollDebugViewer, MpActor) == 0x0002A0, "Member 'AStaffRollDebugViewer::MpActor' has a wrong offset!");
static_assert(offsetof(AStaffRollDebugViewer, IsBFAsset) == 0x0002B0, "Member 'AStaffRollDebugViewer::IsBFAsset' has a wrong offset!");
static_assert(offsetof(AStaffRollDebugViewer, bStartScript) == 0x0002B1, "Member 'AStaffRollDebugViewer::bStartScript' has a wrong offset!");
static_assert(offsetof(AStaffRollDebugViewer, PStaffRollSys) == 0x0002D0, "Member 'AStaffRollDebugViewer::PStaffRollSys' has a wrong offset!");

// Class xrd777.StaffRollDraw
// 0x3A490 (0x3A748 - 0x02B8)
class AStaffRollDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PictOutWaitFrame;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PictOutMoveFrame;                                  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PictInWaitFrame;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PictInMoveFrame;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SceneAnimOutWaitFrame;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SceneAnimOutMoveFrame;                             // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SceneAnimInWaitFrame;                              // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SceneAnimInMoveFrame;                              // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundSwitchWaitSec;                                // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SoundFadeFrame;                                    // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaffRollDataAsset*                    DataList;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              SprData;                                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              SprDataAstrea;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x3A440];                                  // 0x0308(0x3A440)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Draw();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaffRollDraw">();
	}
	static class AStaffRollDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaffRollDraw>();
	}
};
static_assert(alignof(AStaffRollDraw) == 0x000008, "Wrong alignment on AStaffRollDraw");
static_assert(sizeof(AStaffRollDraw) == 0x03A748, "Wrong size on AStaffRollDraw");
static_assert(offsetof(AStaffRollDraw, PictOutWaitFrame) == 0x0002C8, "Member 'AStaffRollDraw::PictOutWaitFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, PictOutMoveFrame) == 0x0002CC, "Member 'AStaffRollDraw::PictOutMoveFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, PictInWaitFrame) == 0x0002D0, "Member 'AStaffRollDraw::PictInWaitFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, PictInMoveFrame) == 0x0002D4, "Member 'AStaffRollDraw::PictInMoveFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SceneAnimOutWaitFrame) == 0x0002D8, "Member 'AStaffRollDraw::SceneAnimOutWaitFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SceneAnimOutMoveFrame) == 0x0002DC, "Member 'AStaffRollDraw::SceneAnimOutMoveFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SceneAnimInWaitFrame) == 0x0002E0, "Member 'AStaffRollDraw::SceneAnimInWaitFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SceneAnimInMoveFrame) == 0x0002E4, "Member 'AStaffRollDraw::SceneAnimInMoveFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SoundSwitchWaitSec) == 0x0002E8, "Member 'AStaffRollDraw::SoundSwitchWaitSec' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SoundFadeFrame) == 0x0002EC, "Member 'AStaffRollDraw::SoundFadeFrame' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, DataList) == 0x0002F0, "Member 'AStaffRollDraw::DataList' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SprData) == 0x0002F8, "Member 'AStaffRollDraw::SprData' has a wrong offset!");
static_assert(offsetof(AStaffRollDraw, SprDataAstrea) == 0x000300, "Member 'AStaffRollDraw::SprDataAstrea' has a wrong offset!");

// Class xrd777.suzukiTestMenu
// 0x0010 (0x0288 - 0x0278)
class ASuzukiTestMenu final : public AAppActor
{
public:
	class AActor*                                 Actor_;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugMenu*                             DebugMenu_;                                        // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"suzukiTestMenu">();
	}
	static class ASuzukiTestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuzukiTestMenu>();
	}
};
static_assert(alignof(ASuzukiTestMenu) == 0x000008, "Wrong alignment on ASuzukiTestMenu");
static_assert(sizeof(ASuzukiTestMenu) == 0x000288, "Wrong size on ASuzukiTestMenu");
static_assert(offsetof(ASuzukiTestMenu, Actor_) == 0x000278, "Member 'ASuzukiTestMenu::Actor_' has a wrong offset!");
static_assert(offsetof(ASuzukiTestMenu, DebugMenu_) == 0x000280, "Member 'ASuzukiTestMenu::DebugMenu_' has a wrong offset!");

// Class xrd777.TCSSaveData
// 0x3298 (0x32C0 - 0x0028)
class UTCSSaveData final : public UObject
{
public:
	uint8                                         Pad_28[0x3298];                                    // 0x0028(0x3298)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TCSSaveData">();
	}
	static class UTCSSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTCSSaveData>();
	}
};
static_assert(alignof(UTCSSaveData) == 0x000008, "Wrong alignment on UTCSSaveData");
static_assert(sizeof(UTCSSaveData) == 0x0032C0, "Wrong size on UTCSSaveData");

// Class xrd777.TestIguchiFuncLib
// 0x0000 (0x0028 - 0x0028)
class UTestIguchiFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void StartReplaceCostumeID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestIguchiFuncLib">();
	}
	static class UTestIguchiFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestIguchiFuncLib>();
	}
};
static_assert(alignof(UTestIguchiFuncLib) == 0x000008, "Wrong alignment on UTestIguchiFuncLib");
static_assert(sizeof(UTestIguchiFuncLib) == 0x000028, "Wrong size on UTestIguchiFuncLib");

// Class xrd777.TestSprAppActor
// 0x0020 (0x0298 - 0x0278)
class ATestSprAppActor final : public AAppActor
{
public:
	class USprAsset*                              MpTestSpr;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestSprAppActor">();
	}
	static class ATestSprAppActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestSprAppActor>();
	}
};
static_assert(alignof(ATestSprAppActor) == 0x000008, "Wrong alignment on ATestSprAppActor");
static_assert(sizeof(ATestSprAppActor) == 0x000298, "Wrong size on ATestSprAppActor");
static_assert(offsetof(ATestSprAppActor, MpTestSpr) == 0x000278, "Member 'ATestSprAppActor::MpTestSpr' has a wrong offset!");

// Class xrd777.TheurgiaActor
// 0x0000 (0x02A0 - 0x02A0)
class ATheurgiaActor final : public AUIBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheurgiaActor">();
	}
	static class ATheurgiaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATheurgiaActor>();
	}
};
static_assert(alignof(ATheurgiaActor) == 0x000008, "Wrong alignment on ATheurgiaActor");
static_assert(sizeof(ATheurgiaActor) == 0x0002A0, "Wrong size on ATheurgiaActor");

// Class xrd777.TitleStateConfig
// 0x0010 (0x0048 - 0x0038)
class UTitleStateConfig final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateConfig">();
	}
	static class UTitleStateConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateConfig>();
	}
};
static_assert(alignof(UTitleStateConfig) == 0x000008, "Wrong alignment on UTitleStateConfig");
static_assert(sizeof(UTitleStateConfig) == 0x000048, "Wrong size on UTitleStateConfig");

// Class xrd777.TitleStateLogo
// 0x0130 (0x0168 - 0x0038)
class UTitleStateLogo final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x98];                                      // 0x0038(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           AssetLoader;                                       // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              AtlusLogoMat;                                      // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               AtlusLogoMID;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              P_StudioLogoMat;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               P_StudioLogoMID;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              UE4AndCRILogoMat;                                  // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               UE4AndCRILogoMID;                                  // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveVectorAnimation                  CurveAtlusLogoAnimation;                           // 0x0108(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveLinearColorAnimation             CurveAtlusLogoColorAnimation;                      // 0x0138(0x0030)(NativeAccessSpecifierPrivate)

public:
	void OnLoadedHolder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateLogo">();
	}
	static class UTitleStateLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateLogo>();
	}
};
static_assert(alignof(UTitleStateLogo) == 0x000008, "Wrong alignment on UTitleStateLogo");
static_assert(sizeof(UTitleStateLogo) == 0x000168, "Wrong size on UTitleStateLogo");
static_assert(offsetof(UTitleStateLogo, AssetLoader) == 0x0000D0, "Member 'UTitleStateLogo::AssetLoader' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, AtlusLogoMat) == 0x0000D8, "Member 'UTitleStateLogo::AtlusLogoMat' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, AtlusLogoMID) == 0x0000E0, "Member 'UTitleStateLogo::AtlusLogoMID' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, P_StudioLogoMat) == 0x0000E8, "Member 'UTitleStateLogo::P_StudioLogoMat' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, P_StudioLogoMID) == 0x0000F0, "Member 'UTitleStateLogo::P_StudioLogoMID' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, UE4AndCRILogoMat) == 0x0000F8, "Member 'UTitleStateLogo::UE4AndCRILogoMat' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, UE4AndCRILogoMID) == 0x000100, "Member 'UTitleStateLogo::UE4AndCRILogoMID' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, CurveAtlusLogoAnimation) == 0x000108, "Member 'UTitleStateLogo::CurveAtlusLogoAnimation' has a wrong offset!");
static_assert(offsetof(UTitleStateLogo, CurveAtlusLogoColorAnimation) == 0x000138, "Member 'UTitleStateLogo::CurveAtlusLogoColorAnimation' has a wrong offset!");

// Class xrd777.TitleStateOP_Astrea
// 0x0018 (0x0050 - 0x0038)
class UTitleStateOP_Astrea final : public UTitleStateBase
{
public:
	class AMoviePlayActor*                        MovieActor;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateOP_Astrea">();
	}
	static class UTitleStateOP_Astrea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateOP_Astrea>();
	}
};
static_assert(alignof(UTitleStateOP_Astrea) == 0x000008, "Wrong alignment on UTitleStateOP_Astrea");
static_assert(sizeof(UTitleStateOP_Astrea) == 0x000050, "Wrong size on UTitleStateOP_Astrea");
static_assert(offsetof(UTitleStateOP_Astrea, MovieActor) == 0x000038, "Member 'UTitleStateOP_Astrea::MovieActor' has a wrong offset!");

// Class xrd777.TitleStatePressWait
// 0x0020 (0x0058 - 0x0038)
class UTitleStatePressWait final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStatePressWait">();
	}
	static class UTitleStatePressWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStatePressWait>();
	}
};
static_assert(alignof(UTitleStatePressWait) == 0x000008, "Wrong alignment on UTitleStatePressWait");
static_assert(sizeof(UTitleStatePressWait) == 0x000058, "Wrong size on UTitleStatePressWait");

// Class xrd777.TitleStateResidentReload
// 0x0018 (0x0050 - 0x0038)
class UTitleStateResidentReload final : public UTitleStateBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAstreaAssetLoader;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleStateResidentReload">();
	}
	static class UTitleStateResidentReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleStateResidentReload>();
	}
};
static_assert(alignof(UTitleStateResidentReload) == 0x000008, "Wrong alignment on UTitleStateResidentReload");
static_assert(sizeof(UTitleStateResidentReload) == 0x000050, "Wrong size on UTitleStateResidentReload");
static_assert(offsetof(UTitleStateResidentReload, PAstreaAssetLoader) == 0x000040, "Member 'UTitleStateResidentReload::PAstreaAssetLoader' has a wrong offset!");

// Class xrd777.TrophyManager
// 0x0188 (0x01B0 - 0x0028)
class UTrophyManager final : public UObject
{
public:
	uint8                                         Pad_28[0x188];                                     // 0x0028(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrophyManager">();
	}
	static class UTrophyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrophyManager>();
	}
};
static_assert(alignof(UTrophyManager) == 0x000008, "Wrong alignment on UTrophyManager");
static_assert(sizeof(UTrophyManager) == 0x0001B0, "Wrong size on UTrophyManager");

// Class xrd777.UIActionSuggestionDraw
// 0x0510 (0x07B0 - 0x02A0)
class AUIActionSuggestionDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pTextColDataTable;                               // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pTextColLayoutDataTable;                         // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pGuidanceSpr;                                    // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x4C8];                                    // 0x02E8(0x04C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIActionSuggestionDraw">();
	}
	static class AUIActionSuggestionDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIActionSuggestionDraw>();
	}
};
static_assert(alignof(AUIActionSuggestionDraw) == 0x000008, "Wrong alignment on AUIActionSuggestionDraw");
static_assert(sizeof(AUIActionSuggestionDraw) == 0x0007B0, "Wrong size on AUIActionSuggestionDraw");
static_assert(offsetof(AUIActionSuggestionDraw, M_pTextColDataTable) == 0x0002D0, "Member 'AUIActionSuggestionDraw::M_pTextColDataTable' has a wrong offset!");
static_assert(offsetof(AUIActionSuggestionDraw, M_pTextColLayoutDataTable) == 0x0002D8, "Member 'AUIActionSuggestionDraw::M_pTextColLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIActionSuggestionDraw, M_pGuidanceSpr) == 0x0002E0, "Member 'AUIActionSuggestionDraw::M_pGuidanceSpr' has a wrong offset!");

// Class xrd777.UIBackLogDraw
// 0x07B0 (0x0A68 - 0x02B8)
class AUIBackLogDraw final : public AUIDrawBaseActor
{
public:
	float                                         CursorMoveSpeed;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CursorPosFix;                                      // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         IconWaveMoveSpeed;                                 // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 IconWaveSmallWaitFrameList;                        // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 IconWaveMediumWaitFrameList;                       // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 IconWaveLargeWaitFrameList;                        // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 IconWaitAngleFrame;                                // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 IconMoveAngleFrame;                                // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FColor>                         IconWaveSelColorList;                              // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FColor>                         IconWaveNonSelColorList;                           // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FColor>                         IconColor;                                         // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 BlackBoardColor;                                   // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 GladationBoardColor;                               // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BlueBoardColor;                                    // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BlackBoardCoverColor;                              // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 CursorWaitMoveSlideFrame;                          // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 CursorMoveSlideFrame;                              // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlackBoardMoveSpeed;                               // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardMoveSpeed;                                // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardRollSpeed;                                // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DayMoveSpeed;                                      // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 ScrollBarMoveSpeed;                                // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 LogMoveSpeed;                                      // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 IconMoveSpeed;                                     // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 NoneMoveSpeed;                                     // 0x03F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DecoMoveSpeed;                                     // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlackBoardAlphaSpeed;                              // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 BlueBoardAlphaSpeed;                               // 0x0428(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 GradationAlphaSpeed;                               // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DayAlphaSpeed;                                     // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 ScrollBarAlphaSpeed;                               // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 LogAlphaSpeed;                                     // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 IconAlphaSpeed;                                    // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 NoneAlphaSpeed;                                    // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DecoAlphaSpeed;                                    // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 CursorWhiteMoveSpeed;                              // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 CursorWhiteAlphaSpeed;                             // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 CursorBlueMoveSpeed;                               // 0x04C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 CursorBlueAlphaSpeed;                              // 0x04D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         AnimFinishTime;                                    // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelMsgInterval;                                    // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MingMsgInterval;                                   // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundPlusPosX;                                     // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundPlusPosY;                                     // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0xC4];                                     // 0x04FC(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Tex;                                               // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFrameBufferCapture*                    CaptureBackGround;                                 // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x488];                                    // 0x05D0(0x0488)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0A58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTableAstrea;                            // 0x0A60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackLogDraw">();
	}
	static class AUIBackLogDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackLogDraw>();
	}
};
static_assert(alignof(AUIBackLogDraw) == 0x000008, "Wrong alignment on AUIBackLogDraw");
static_assert(sizeof(AUIBackLogDraw) == 0x000A68, "Wrong size on AUIBackLogDraw");
static_assert(offsetof(AUIBackLogDraw, CursorMoveSpeed) == 0x0002B8, "Member 'AUIBackLogDraw::CursorMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorPosFix) == 0x0002C0, "Member 'AUIBackLogDraw::CursorPosFix' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveMoveSpeed) == 0x0002D0, "Member 'AUIBackLogDraw::IconWaveMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveSmallWaitFrameList) == 0x0002D8, "Member 'AUIBackLogDraw::IconWaveSmallWaitFrameList' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveMediumWaitFrameList) == 0x0002E8, "Member 'AUIBackLogDraw::IconWaveMediumWaitFrameList' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveLargeWaitFrameList) == 0x0002F8, "Member 'AUIBackLogDraw::IconWaveLargeWaitFrameList' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaitAngleFrame) == 0x000308, "Member 'AUIBackLogDraw::IconWaitAngleFrame' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconMoveAngleFrame) == 0x000318, "Member 'AUIBackLogDraw::IconMoveAngleFrame' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveSelColorList) == 0x000328, "Member 'AUIBackLogDraw::IconWaveSelColorList' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconWaveNonSelColorList) == 0x000338, "Member 'AUIBackLogDraw::IconWaveNonSelColorList' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconColor) == 0x000348, "Member 'AUIBackLogDraw::IconColor' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlackBoardColor) == 0x000358, "Member 'AUIBackLogDraw::BlackBoardColor' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, GladationBoardColor) == 0x00035C, "Member 'AUIBackLogDraw::GladationBoardColor' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlueBoardColor) == 0x000360, "Member 'AUIBackLogDraw::BlueBoardColor' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlackBoardCoverColor) == 0x000364, "Member 'AUIBackLogDraw::BlackBoardCoverColor' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorWaitMoveSlideFrame) == 0x000368, "Member 'AUIBackLogDraw::CursorWaitMoveSlideFrame' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorMoveSlideFrame) == 0x000378, "Member 'AUIBackLogDraw::CursorMoveSlideFrame' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlackBoardMoveSpeed) == 0x000388, "Member 'AUIBackLogDraw::BlackBoardMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlueBoardMoveSpeed) == 0x000398, "Member 'AUIBackLogDraw::BlueBoardMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlueBoardRollSpeed) == 0x0003A8, "Member 'AUIBackLogDraw::BlueBoardRollSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, DayMoveSpeed) == 0x0003B8, "Member 'AUIBackLogDraw::DayMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, ScrollBarMoveSpeed) == 0x0003C8, "Member 'AUIBackLogDraw::ScrollBarMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, LogMoveSpeed) == 0x0003D8, "Member 'AUIBackLogDraw::LogMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconMoveSpeed) == 0x0003E8, "Member 'AUIBackLogDraw::IconMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, NoneMoveSpeed) == 0x0003F8, "Member 'AUIBackLogDraw::NoneMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, DecoMoveSpeed) == 0x000408, "Member 'AUIBackLogDraw::DecoMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlackBoardAlphaSpeed) == 0x000418, "Member 'AUIBackLogDraw::BlackBoardAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, BlueBoardAlphaSpeed) == 0x000428, "Member 'AUIBackLogDraw::BlueBoardAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, GradationAlphaSpeed) == 0x000438, "Member 'AUIBackLogDraw::GradationAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, DayAlphaSpeed) == 0x000448, "Member 'AUIBackLogDraw::DayAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, ScrollBarAlphaSpeed) == 0x000458, "Member 'AUIBackLogDraw::ScrollBarAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, LogAlphaSpeed) == 0x000468, "Member 'AUIBackLogDraw::LogAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, IconAlphaSpeed) == 0x000478, "Member 'AUIBackLogDraw::IconAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, NoneAlphaSpeed) == 0x000488, "Member 'AUIBackLogDraw::NoneAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, DecoAlphaSpeed) == 0x000498, "Member 'AUIBackLogDraw::DecoAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorWhiteMoveSpeed) == 0x0004A8, "Member 'AUIBackLogDraw::CursorWhiteMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorWhiteAlphaSpeed) == 0x0004B8, "Member 'AUIBackLogDraw::CursorWhiteAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorBlueMoveSpeed) == 0x0004C8, "Member 'AUIBackLogDraw::CursorBlueMoveSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CursorBlueAlphaSpeed) == 0x0004D8, "Member 'AUIBackLogDraw::CursorBlueAlphaSpeed' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, AnimFinishTime) == 0x0004E8, "Member 'AUIBackLogDraw::AnimFinishTime' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, SelMsgInterval) == 0x0004EC, "Member 'AUIBackLogDraw::SelMsgInterval' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, MingMsgInterval) == 0x0004F0, "Member 'AUIBackLogDraw::MingMsgInterval' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, SoundPlusPosX) == 0x0004F4, "Member 'AUIBackLogDraw::SoundPlusPosX' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, SoundPlusPosY) == 0x0004F8, "Member 'AUIBackLogDraw::SoundPlusPosY' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, Tex) == 0x0005C0, "Member 'AUIBackLogDraw::Tex' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, CaptureBackGround) == 0x0005C8, "Member 'AUIBackLogDraw::CaptureBackGround' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, PLayoutDataTable) == 0x000A58, "Member 'AUIBackLogDraw::PLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIBackLogDraw, PLayoutDataTableAstrea) == 0x000A60, "Member 'AUIBackLogDraw::PLayoutDataTableAstrea' has a wrong offset!");

// Class xrd777.UIClearSaveActor
// 0x0010 (0x0288 - 0x0278)
class AUIClearSaveActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallStatePatternEndDelicate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIClearSaveActor">();
	}
	static class AUIClearSaveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIClearSaveActor>();
	}
};
static_assert(alignof(AUIClearSaveActor) == 0x000008, "Wrong alignment on AUIClearSaveActor");
static_assert(sizeof(AUIClearSaveActor) == 0x000288, "Wrong size on AUIClearSaveActor");

// Class xrd777.UICmmRankUpBG
// 0x0050 (0x0308 - 0x02B8)
class AUICmmRankUpBG final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x5];                                      // 0x02B8(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	EUIBlendFactor                                SrcColor;                                          // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBlendFactor                                DstColor;                                          // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBlendFactor                                SrcAlpha;                                          // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIBlendFactor                                DstAlpha;                                          // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureBG;                                        // 0x02C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PBGMaterial;                                       // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsAlreadySetBGMaterial;                            // 0x02D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x27];                                     // 0x02D1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitSettingMaterialBG(class UMaterialInstance* Material);
	void StartAnimePoemBG1In();
	bool UICmmBGCapture();
	void UICmmDrawBG_1(const struct FColor& Top, const struct FColor& Bottom);
	void UICmmDrawBG_2(const struct FColor& Top, const struct FColor& Bottom);
	void UICmmDrawBG_3(const struct FColor& Top, const struct FColor& Bottom);
	void UICmmDrawBG_4(const struct FColor& Color);
	void UICmmDrawBG_5();
	void UICmmDrawBG_Red();
	void Update(const float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmmRankUpBG">();
	}
	static class AUICmmRankUpBG* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICmmRankUpBG>();
	}
};
static_assert(alignof(AUICmmRankUpBG) == 0x000008, "Wrong alignment on AUICmmRankUpBG");
static_assert(sizeof(AUICmmRankUpBG) == 0x000308, "Wrong size on AUICmmRankUpBG");
static_assert(offsetof(AUICmmRankUpBG, SrcColor) == 0x0002BD, "Member 'AUICmmRankUpBG::SrcColor' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, DstColor) == 0x0002BE, "Member 'AUICmmRankUpBG::DstColor' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, SrcAlpha) == 0x0002BF, "Member 'AUICmmRankUpBG::SrcAlpha' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, DstAlpha) == 0x0002C0, "Member 'AUICmmRankUpBG::DstAlpha' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, bCaptureBG) == 0x0002C1, "Member 'AUICmmRankUpBG::bCaptureBG' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, PBGMaterial) == 0x0002C8, "Member 'AUICmmRankUpBG::PBGMaterial' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, IsAlreadySetBGMaterial) == 0x0002D0, "Member 'AUICmmRankUpBG::IsAlreadySetBGMaterial' has a wrong offset!");
static_assert(offsetof(AUICmmRankUpBG, AnimManager) == 0x0002F8, "Member 'AUICmmRankUpBG::AnimManager' has a wrong offset!");

// Class xrd777.UICmpCalendarDraw
// 0x03E8 (0x0410 - 0x0028)
class UUICmpCalendarDraw final : public UObject
{
public:
	uint8                                         Pad_28[0x3A0];                                     // 0x0028(0x03A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      PBackgroundMaterialInstance;                       // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PBackgroundMaterialDaynamic;                       // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PEditParameterDataTable;                           // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PMonthTable;                                       // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PDayTable;                                         // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PWeekTable;                                        // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpCalendarDraw">();
	}
	static class UUICmpCalendarDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICmpCalendarDraw>();
	}
};
static_assert(alignof(UUICmpCalendarDraw) == 0x000008, "Wrong alignment on UUICmpCalendarDraw");
static_assert(sizeof(UUICmpCalendarDraw) == 0x000410, "Wrong size on UUICmpCalendarDraw");
static_assert(offsetof(UUICmpCalendarDraw, PBackgroundMaterialInstance) == 0x0003C8, "Member 'UUICmpCalendarDraw::PBackgroundMaterialInstance' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PBackgroundMaterialDaynamic) == 0x0003D0, "Member 'UUICmpCalendarDraw::PBackgroundMaterialDaynamic' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PEditParameterDataTable) == 0x0003D8, "Member 'UUICmpCalendarDraw::PEditParameterDataTable' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PMonthTable) == 0x0003E0, "Member 'UUICmpCalendarDraw::PMonthTable' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PDayTable) == 0x0003E8, "Member 'UUICmpCalendarDraw::PDayTable' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PWeekTable) == 0x0003F0, "Member 'UUICmpCalendarDraw::PWeekTable' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PAssetLoader) == 0x0003F8, "Member 'UUICmpCalendarDraw::PAssetLoader' has a wrong offset!");
static_assert(offsetof(UUICmpCalendarDraw, PMainActor) == 0x000400, "Member 'UUICmpCalendarDraw::PMainActor' has a wrong offset!");

// Class xrd777.UICmpStatus
// 0x0320 (0x0348 - 0x0028)
class UUICmpStatus final : public UObject
{
public:
	uint8                                         Pad_28[0x288];                                     // 0x0028(0x0288)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISceneFSM*                            SceneFSM_;                                         // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UUIScene*>                  Scenes_;                                           // 0x02B8(0x0050)(NativeAccessSpecifierPrivate)
	class APersonaStatus*                         PSStatusActor_;                                    // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIDialogSingle*                        SingleDialog_;                                     // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpStatusCharacterListDraw*            CharaListDraw_;                                    // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpCharacterStatusDraw*                CharaStatusDraw_;                                  // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCmpStatus*                             PParent;                                           // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICmpStatus">();
	}
	static class UUICmpStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICmpStatus>();
	}
};
static_assert(alignof(UUICmpStatus) == 0x000008, "Wrong alignment on UUICmpStatus");
static_assert(sizeof(UUICmpStatus) == 0x000348, "Wrong size on UUICmpStatus");
static_assert(offsetof(UUICmpStatus, SceneFSM_) == 0x0002B0, "Member 'UUICmpStatus::SceneFSM_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, Scenes_) == 0x0002B8, "Member 'UUICmpStatus::Scenes_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, PSStatusActor_) == 0x000308, "Member 'UUICmpStatus::PSStatusActor_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, SingleDialog_) == 0x000310, "Member 'UUICmpStatus::SingleDialog_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, CharaListDraw_) == 0x000318, "Member 'UUICmpStatus::CharaListDraw_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, CharaStatusDraw_) == 0x000320, "Member 'UUICmpStatus::CharaStatusDraw_' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, PMainActor) == 0x000330, "Member 'UUICmpStatus::PMainActor' has a wrong offset!");
static_assert(offsetof(UUICmpStatus, PParent) == 0x000338, "Member 'UUICmpStatus::PParent' has a wrong offset!");

// Class xrd777.UICompleteBook
// 0x0118 (0x0140 - 0x0028)
class UUICompleteBook final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIVelvetRoomOwner*                     M_pOwner;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xF8];                                      // 0x0048(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICompleteBook">();
	}
	static class UUICompleteBook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICompleteBook>();
	}
};
static_assert(alignof(UUICompleteBook) == 0x000008, "Wrong alignment on UUICompleteBook");
static_assert(sizeof(UUICompleteBook) == 0x000140, "Wrong size on UUICompleteBook");
static_assert(offsetof(UUICompleteBook, M_pOwner) == 0x000040, "Member 'UUICompleteBook::M_pOwner' has a wrong offset!");

// Class xrd777.UIContactManager
// 0x01A8 (0x01D8 - 0x0030)
class UUIContactManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAppActor*>                      M_pUIActorList;                                    // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x190];                                     // 0x0048(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContactManager">();
	}
	static class UUIContactManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContactManager>();
	}
};
static_assert(alignof(UUIContactManager) == 0x000008, "Wrong alignment on UUIContactManager");
static_assert(sizeof(UUIContactManager) == 0x0001D8, "Wrong size on UUIContactManager");
static_assert(offsetof(UUIContactManager, M_pUIActorList) == 0x000038, "Member 'UUIContactManager::M_pUIActorList' has a wrong offset!");

// Class xrd777.ShoesItemListTable
// 0x0010 (0x0040 - 0x0030)
class UShoesItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FShoesItemList>                 Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShoesItemListTable">();
	}
	static class UShoesItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShoesItemListTable>();
	}
};
static_assert(alignof(UShoesItemListTable) == 0x000008, "Wrong alignment on UShoesItemListTable");
static_assert(sizeof(UShoesItemListTable) == 0x000040, "Wrong size on UShoesItemListTable");
static_assert(offsetof(UShoesItemListTable, Data) == 0x000030, "Member 'UShoesItemListTable::Data' has a wrong offset!");

// Class xrd777.MaterialItemListTable
// 0x0010 (0x0040 - 0x0030)
class UMaterialItemListTable final : public UAppDataAsset
{
public:
	TArray<struct FMaterialItemList>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialItemListTable">();
	}
	static class UMaterialItemListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialItemListTable>();
	}
};
static_assert(alignof(UMaterialItemListTable) == 0x000008, "Wrong alignment on UMaterialItemListTable");
static_assert(sizeof(UMaterialItemListTable) == 0x000040, "Wrong size on UMaterialItemListTable");
static_assert(offsetof(UMaterialItemListTable, Data) == 0x000030, "Member 'UMaterialItemListTable::Data' has a wrong offset!");

// Class xrd777.ItemShopLineUpListTable
// 0x0010 (0x0040 - 0x0030)
class UItemShopLineUpListTable final : public UAppDataAsset
{
public:
	TArray<struct FItemShopLineUpList>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemShopLineUpListTable">();
	}
	static class UItemShopLineUpListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemShopLineUpListTable>();
	}
};
static_assert(alignof(UItemShopLineUpListTable) == 0x000008, "Wrong alignment on UItemShopLineUpListTable");
static_assert(sizeof(UItemShopLineUpListTable) == 0x000040, "Wrong size on UItemShopLineUpListTable");
static_assert(offsetof(UItemShopLineUpListTable, Data) == 0x000030, "Member 'UItemShopLineUpListTable::Data' has a wrong offset!");

// Class xrd777.FontAdjustmentListTable
// 0x0050 (0x0080 - 0x0030)
class UFontAdjustmentListTable final : public UAppDataAsset
{
public:
	TMap<int32, struct FFontAdjustmentList>       Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FontAdjustmentListTable">();
	}
	static class UFontAdjustmentListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFontAdjustmentListTable>();
	}
};
static_assert(alignof(UFontAdjustmentListTable) == 0x000008, "Wrong alignment on UFontAdjustmentListTable");
static_assert(sizeof(UFontAdjustmentListTable) == 0x000080, "Wrong size on UFontAdjustmentListTable");
static_assert(offsetof(UFontAdjustmentListTable, Data) == 0x000030, "Member 'UFontAdjustmentListTable::Data' has a wrong offset!");

// Class xrd777.SuggestionListTable
// 0x0010 (0x0040 - 0x0030)
class USuggestionListTable final : public UAppDataAsset
{
public:
	TArray<struct FSuggestionList>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuggestionListTable">();
	}
	static class USuggestionListTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuggestionListTable>();
	}
};
static_assert(alignof(USuggestionListTable) == 0x000008, "Wrong alignment on USuggestionListTable");
static_assert(sizeof(USuggestionListTable) == 0x000040, "Wrong size on USuggestionListTable");
static_assert(offsetof(USuggestionListTable, Data) == 0x000030, "Member 'USuggestionListTable::Data' has a wrong offset!");

// Class xrd777.TownMapDetailTextDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTownMapDetailTextDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTownMapDetailTextTable>        Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownMapDetailTextDataAsset">();
	}
	static class UTownMapDetailTextDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTownMapDetailTextDataAsset>();
	}
};
static_assert(alignof(UTownMapDetailTextDataAsset) == 0x000008, "Wrong alignment on UTownMapDetailTextDataAsset");
static_assert(sizeof(UTownMapDetailTextDataAsset) == 0x000040, "Wrong size on UTownMapDetailTextDataAsset");
static_assert(offsetof(UTownMapDetailTextDataAsset, Data) == 0x000030, "Member 'UTownMapDetailTextDataAsset::Data' has a wrong offset!");

// Class xrd777.MiniMapOffsetDataAsset
// 0x0010 (0x0040 - 0x0030)
class UMiniMapOffsetDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FMiniMapOffsetTable>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapOffsetDataAsset">();
	}
	static class UMiniMapOffsetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapOffsetDataAsset>();
	}
};
static_assert(alignof(UMiniMapOffsetDataAsset) == 0x000008, "Wrong alignment on UMiniMapOffsetDataAsset");
static_assert(sizeof(UMiniMapOffsetDataAsset) == 0x000040, "Wrong size on UMiniMapOffsetDataAsset");
static_assert(offsetof(UMiniMapOffsetDataAsset, Data) == 0x000030, "Member 'UMiniMapOffsetDataAsset::Data' has a wrong offset!");

// Class xrd777.MailIncomingDataAsset
// 0x0050 (0x0080 - 0x0030)
class UMailIncomingDataAsset final : public UAppMultiDataAsset
{
public:
	TMap<int32, struct FMailIncomingItem>         Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailIncomingDataAsset">();
	}
	static class UMailIncomingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailIncomingDataAsset>();
	}
};
static_assert(alignof(UMailIncomingDataAsset) == 0x000008, "Wrong alignment on UMailIncomingDataAsset");
static_assert(sizeof(UMailIncomingDataAsset) == 0x000080, "Wrong size on UMailIncomingDataAsset");
static_assert(offsetof(UMailIncomingDataAsset, Data) == 0x000030, "Member 'UMailIncomingDataAsset::Data' has a wrong offset!");

// Class xrd777.DisappearDataAsset
// 0x0050 (0x0080 - 0x0030)
class UDisappearDataAsset final : public UAppDataAsset
{
public:
	TMap<uint16, struct FDisappearItem>           Data;                                              // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisappearDataAsset">();
	}
	static class UDisappearDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisappearDataAsset>();
	}
};
static_assert(alignof(UDisappearDataAsset) == 0x000008, "Wrong alignment on UDisappearDataAsset");
static_assert(sizeof(UDisappearDataAsset) == 0x000080, "Wrong size on UDisappearDataAsset");
static_assert(offsetof(UDisappearDataAsset, Data) == 0x000030, "Member 'UDisappearDataAsset::Data' has a wrong offset!");

// Class xrd777.NormalSpreadDataAsset
// 0x0010 (0x0040 - 0x0030)
class UNormalSpreadDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FNormalSpreadItem>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NormalSpreadDataAsset">();
	}
	static class UNormalSpreadDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNormalSpreadDataAsset>();
	}
};
static_assert(alignof(UNormalSpreadDataAsset) == 0x000008, "Wrong alignment on UNormalSpreadDataAsset");
static_assert(sizeof(UNormalSpreadDataAsset) == 0x000040, "Wrong size on UNormalSpreadDataAsset");
static_assert(offsetof(UNormalSpreadDataAsset, Data) == 0x000030, "Member 'UNormalSpreadDataAsset::Data' has a wrong offset!");

// Class xrd777.SpecialSpreadDataAsset
// 0x0010 (0x0040 - 0x0030)
class USpecialSpreadDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSpecialSpreadItem>             Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialSpreadDataAsset">();
	}
	static class USpecialSpreadDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialSpreadDataAsset>();
	}
};
static_assert(alignof(USpecialSpreadDataAsset) == 0x000008, "Wrong alignment on USpecialSpreadDataAsset");
static_assert(sizeof(USpecialSpreadDataAsset) == 0x000040, "Wrong size on USpecialSpreadDataAsset");
static_assert(offsetof(USpecialSpreadDataAsset, Data) == 0x000030, "Member 'USpecialSpreadDataAsset::Data' has a wrong offset!");

// Class xrd777.SkillLimitDataAsset
// 0x0010 (0x0040 - 0x0030)
class USkillLimitDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSkillLimitItem>                Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillLimitDataAsset">();
	}
	static class USkillLimitDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillLimitDataAsset>();
	}
};
static_assert(alignof(USkillLimitDataAsset) == 0x000008, "Wrong alignment on USkillLimitDataAsset");
static_assert(sizeof(USkillLimitDataAsset) == 0x000040, "Wrong size on USkillLimitDataAsset");
static_assert(offsetof(USkillLimitDataAsset, Data) == 0x000030, "Member 'USkillLimitDataAsset::Data' has a wrong offset!");

// Class xrd777.PersonaConfigDataAsset
// 0x0010 (0x0040 - 0x0030)
class UPersonaConfigDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FPersonaConfigItem>             Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaConfigDataAsset">();
	}
	static class UPersonaConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaConfigDataAsset>();
	}
};
static_assert(alignof(UPersonaConfigDataAsset) == 0x000008, "Wrong alignment on UPersonaConfigDataAsset");
static_assert(sizeof(UPersonaConfigDataAsset) == 0x000040, "Wrong size on UPersonaConfigDataAsset");
static_assert(offsetof(UPersonaConfigDataAsset, Data) == 0x000030, "Member 'UPersonaConfigDataAsset::Data' has a wrong offset!");

// Class xrd777.CombineCounterDataAsset
// 0x0010 (0x0040 - 0x0030)
class UCombineCounterDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FCombineCounterItem>            Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombineCounterDataAsset">();
	}
	static class UCombineCounterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombineCounterDataAsset>();
	}
};
static_assert(alignof(UCombineCounterDataAsset) == 0x000008, "Wrong alignment on UCombineCounterDataAsset");
static_assert(sizeof(UCombineCounterDataAsset) == 0x000040, "Wrong size on UCombineCounterDataAsset");
static_assert(offsetof(UCombineCounterDataAsset, Data) == 0x000030, "Member 'UCombineCounterDataAsset::Data' has a wrong offset!");

// Class xrd777.SkillChangeDataAsset
// 0x0010 (0x0040 - 0x0030)
class USkillChangeDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSkillChangeItem>               Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChangeDataAsset">();
	}
	static class USkillChangeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillChangeDataAsset>();
	}
};
static_assert(alignof(USkillChangeDataAsset) == 0x000008, "Wrong alignment on USkillChangeDataAsset");
static_assert(sizeof(USkillChangeDataAsset) == 0x000040, "Wrong size on USkillChangeDataAsset");
static_assert(offsetof(USkillChangeDataAsset, Data) == 0x000030, "Member 'USkillChangeDataAsset::Data' has a wrong offset!");

// Class xrd777.VelvetRoomQuestDataAsset
// 0x0010 (0x0040 - 0x0030)
class UVelvetRoomQuestDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FVelvetRoomQuestItem>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelvetRoomQuestDataAsset">();
	}
	static class UVelvetRoomQuestDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelvetRoomQuestDataAsset>();
	}
};
static_assert(alignof(UVelvetRoomQuestDataAsset) == 0x000008, "Wrong alignment on UVelvetRoomQuestDataAsset");
static_assert(sizeof(UVelvetRoomQuestDataAsset) == 0x000040, "Wrong size on UVelvetRoomQuestDataAsset");
static_assert(offsetof(UVelvetRoomQuestDataAsset, Data) == 0x000030, "Member 'UVelvetRoomQuestDataAsset::Data' has a wrong offset!");

// Class xrd777.GenSelItemLineupDataAsset
// 0x0010 (0x0040 - 0x0030)
class UGenSelItemLineupDataAsset final : public UAppMultiDataAsset
{
public:
	TArray<struct FGenSelItemLineup>              Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenSelItemLineupDataAsset">();
	}
	static class UGenSelItemLineupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenSelItemLineupDataAsset>();
	}
};
static_assert(alignof(UGenSelItemLineupDataAsset) == 0x000008, "Wrong alignment on UGenSelItemLineupDataAsset");
static_assert(sizeof(UGenSelItemLineupDataAsset) == 0x000040, "Wrong size on UGenSelItemLineupDataAsset");
static_assert(offsetof(UGenSelItemLineupDataAsset, Data) == 0x000030, "Member 'UGenSelItemLineupDataAsset::Data' has a wrong offset!");

// Class xrd777.DLCPersonaCombineBirthDataAsset
// 0x0010 (0x0040 - 0x0030)
class UDLCPersonaCombineBirthDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FDLCPersonaCombineBirthTable>   Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCPersonaCombineBirthDataAsset">();
	}
	static class UDLCPersonaCombineBirthDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCPersonaCombineBirthDataAsset>();
	}
};
static_assert(alignof(UDLCPersonaCombineBirthDataAsset) == 0x000008, "Wrong alignment on UDLCPersonaCombineBirthDataAsset");
static_assert(sizeof(UDLCPersonaCombineBirthDataAsset) == 0x000040, "Wrong size on UDLCPersonaCombineBirthDataAsset");
static_assert(offsetof(UDLCPersonaCombineBirthDataAsset, Data) == 0x000030, "Member 'UDLCPersonaCombineBirthDataAsset::Data' has a wrong offset!");

// Class xrd777.AddContentNameDispTableDataAsset
// 0x0010 (0x0040 - 0x0030)
class UAddContentNameDispTableDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FAddContentsNameDispTable>      Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentNameDispTableDataAsset">();
	}
	static class UAddContentNameDispTableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentNameDispTableDataAsset>();
	}
};
static_assert(alignof(UAddContentNameDispTableDataAsset) == 0x000008, "Wrong alignment on UAddContentNameDispTableDataAsset");
static_assert(sizeof(UAddContentNameDispTableDataAsset) == 0x000040, "Wrong size on UAddContentNameDispTableDataAsset");
static_assert(offsetof(UAddContentNameDispTableDataAsset, Data) == 0x000030, "Member 'UAddContentNameDispTableDataAsset::Data' has a wrong offset!");

// Class xrd777.SeedLotteryDataAsset
// 0x0010 (0x0040 - 0x0030)
class USeedLotteryDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FSeedLotteryTableItem>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeedLotteryDataAsset">();
	}
	static class USeedLotteryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeedLotteryDataAsset>();
	}
};
static_assert(alignof(USeedLotteryDataAsset) == 0x000008, "Wrong alignment on USeedLotteryDataAsset");
static_assert(sizeof(USeedLotteryDataAsset) == 0x000040, "Wrong size on USeedLotteryDataAsset");
static_assert(offsetof(USeedLotteryDataAsset, Data) == 0x000030, "Member 'USeedLotteryDataAsset::Data' has a wrong offset!");

// Class xrd777.UIDebugDraw
// 0x0420 (0x0698 - 0x0278)
class AUIDebugDraw final : public AAppActor
{
public:
	uint8                                         Pad_278[0x1A8];                                    // 0x0278(0x01A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pMapLoader;                                      // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSprAsset;                                       // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              M_pMaterial;                                       // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pTexture;                                        // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               M_pMID;                                            // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APersonaStatus*                         M_pPersonaStatus;                                  // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pNotePlg;                                        // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_uip;                                             // 0x0458(0x0078)(NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_uipB;                                            // 0x04D0(0x0078)(NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_uipC;                                            // 0x0548(0x0078)(NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_uipD;                                            // 0x05C0(0x0078)(NativeAccessSpecifierPublic)
	struct FCurveFloatAnimation                   M_curve;                                           // 0x0638(0x0030)(NativeAccessSpecifierPublic)
	TArray<struct FTestDebugNishida>              M_aTestDebugNishidaList;                           // 0x0668(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AScrActor*                              M_pScrActor;                                       // 0x0680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBfAsset*                               M_pBfAsset;                                        // 0x0688(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              M_pBmdAsset;                                       // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnFinishedScrDebug(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDebugDraw">();
	}
	static class AUIDebugDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDebugDraw>();
	}
};
static_assert(alignof(AUIDebugDraw) == 0x000008, "Wrong alignment on AUIDebugDraw");
static_assert(sizeof(AUIDebugDraw) == 0x000698, "Wrong size on AUIDebugDraw");
static_assert(offsetof(AUIDebugDraw, M_pMapLoader) == 0x000420, "Member 'AUIDebugDraw::M_pMapLoader' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pSprAsset) == 0x000428, "Member 'AUIDebugDraw::M_pSprAsset' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pMaterial) == 0x000430, "Member 'AUIDebugDraw::M_pMaterial' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pTexture) == 0x000438, "Member 'AUIDebugDraw::M_pTexture' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pMID) == 0x000440, "Member 'AUIDebugDraw::M_pMID' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pPersonaStatus) == 0x000448, "Member 'AUIDebugDraw::M_pPersonaStatus' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pNotePlg) == 0x000450, "Member 'AUIDebugDraw::M_pNotePlg' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_uip) == 0x000458, "Member 'AUIDebugDraw::M_uip' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_uipB) == 0x0004D0, "Member 'AUIDebugDraw::M_uipB' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_uipC) == 0x000548, "Member 'AUIDebugDraw::M_uipC' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_uipD) == 0x0005C0, "Member 'AUIDebugDraw::M_uipD' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_curve) == 0x000638, "Member 'AUIDebugDraw::M_curve' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_aTestDebugNishidaList) == 0x000668, "Member 'AUIDebugDraw::M_aTestDebugNishidaList' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pScrActor) == 0x000680, "Member 'AUIDebugDraw::M_pScrActor' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pBfAsset) == 0x000688, "Member 'AUIDebugDraw::M_pBfAsset' has a wrong offset!");
static_assert(offsetof(AUIDebugDraw, M_pBmdAsset) == 0x000690, "Member 'AUIDebugDraw::M_pBmdAsset' has a wrong offset!");

// Class xrd777.UIDictionary
// 0x00E0 (0x0358 - 0x0278)
class AUIDictionary final : public AAppActor
{
public:
	class UAssetLoader*                           Loader;                                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableAsset;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             NameTableAsset;                                    // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x60];                                     // 0x0290(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUITutorialDraw*                        PTutorialDraw;                                     // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUITutorialDraw>            PTutorialDrawClass;                                // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x50];                                     // 0x0308(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDictionary">();
	}
	static class AUIDictionary* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIDictionary>();
	}
};
static_assert(alignof(AUIDictionary) == 0x000008, "Wrong alignment on AUIDictionary");
static_assert(sizeof(AUIDictionary) == 0x000358, "Wrong size on AUIDictionary");
static_assert(offsetof(AUIDictionary, Loader) == 0x000278, "Member 'AUIDictionary::Loader' has a wrong offset!");
static_assert(offsetof(AUIDictionary, DataTableAsset) == 0x000280, "Member 'AUIDictionary::DataTableAsset' has a wrong offset!");
static_assert(offsetof(AUIDictionary, NameTableAsset) == 0x000288, "Member 'AUIDictionary::NameTableAsset' has a wrong offset!");
static_assert(offsetof(AUIDictionary, PMainActor) == 0x0002F0, "Member 'AUIDictionary::PMainActor' has a wrong offset!");
static_assert(offsetof(AUIDictionary, PTutorialDraw) == 0x0002F8, "Member 'AUIDictionary::PTutorialDraw' has a wrong offset!");
static_assert(offsetof(AUIDictionary, PTutorialDrawClass) == 0x000300, "Member 'AUIDictionary::PTutorialDrawClass' has a wrong offset!");

// Class xrd777.UIDataAsset
// 0x0010 (0x0040 - 0x0030)
class UUIDataAsset final : public UAppDataAsset
{
public:
	TArray<class UObject*>                        Assets;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDataAsset">();
	}
	static class UUIDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDataAsset>();
	}
};
static_assert(alignof(UUIDataAsset) == 0x000008, "Wrong alignment on UUIDataAsset");
static_assert(sizeof(UUIDataAsset) == 0x000040, "Wrong size on UUIDataAsset");
static_assert(offsetof(UUIDataAsset, Assets) == 0x000030, "Member 'UUIDataAsset::Assets' has a wrong offset!");

// Class xrd777.UIDungeonTransferData
// 0x0560 (0x0588 - 0x0028)
class UUIDungeonTransferData final : public UObject
{
public:
	int32                                         ContentNum;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListPosWhen2_4;                               // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListPosWhen5_8;                               // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListScale;                                    // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorListInterval;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListColorV0;                                  // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListColorV1;                                  // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListColorV2;                                  // 0x006C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListColorV3;                                  // 0x0078(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListLightPosDif;                              // 0x0084(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListLightScale;                               // 0x0090(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListLightColor;                               // 0x009C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScrollBarPosDif;                                   // 0x00A8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollBarEnableY;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScrollBarMinmamSize;                               // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TarminalIconPosDif;                                // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ListHeadPosDif;                                    // 0x00D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FMarkPosDif;                                       // 0x00DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListSelectedColor;                            // 0x00E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorListNotSelectedColor;                         // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNumWhen1PosDif;                               // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNumDigit1PosDif;                              // 0x010C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNumDigit2PosDif;                              // 0x0118(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNumDigit3PosDif;                              // 0x0124(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorEntrancePosDif;                               // 0x0130(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentIconPosDif;                                 // 0x013C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentIconSelectedColor;                          // 0x0148(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentIconNotSelectedColor;                       // 0x0154(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DoorIconPosDif;                                    // 0x0160(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HorizonPosDif;                                     // 0x016C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HorizonScale;                                      // 0x0178(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonAlpha;                                      // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WhiteCursorPosDif;                                 // 0x0188(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WhiteCursorScale;                                  // 0x0194(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WhiteCursorColor;                                  // 0x01A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GreenCursorPosDif;                                 // 0x01AC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GreenCursorScale;                                  // 0x01B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GreenCursorColor;                                  // 0x01C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoPlatePos;                                      // 0x01D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoPlateScale;                                    // 0x01DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoPlateScaleWhenEntrance;                        // 0x01E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoPlateColor;                                    // 0x01F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNamePosDiff;                              // 0x0200(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockHeadPosDiff;                              // 0x020C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfoBlockHeadAlpha;                                // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNumPosDiff;                               // 0x021C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNumColorDarkColor;                        // 0x0228(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNumColorLightColor;                       // 0x0234(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfoBlockNumColorLightAlpha;                       // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNumMaskPosDiff;                           // 0x0244(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoBlockNumMaskScale;                             // 0x0250(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameEntrancePosDiff;                           // 0x025C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor1PosDiff;                             // 0x0268(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor2PosDiff;                             // 0x0274(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor3PosDiff;                             // 0x0280(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor4PosDiff;                             // 0x028C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor5PosDiff;                             // 0x0298(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameFloor6PosDiff;                             // 0x02A4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameColorDark;                                 // 0x02B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoNameColorLight;                                // 0x02BC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoMissHeadPos;                                   // 0x02C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoMissUnitPosDiff;                               // 0x02D4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoMissNumPosDiff;                                // 0x02E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoMiss0Color;                                    // 0x02EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoTrianglePosDiff;                               // 0x02F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfoTriangleAlpha;                                 // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoTriangleOutPosDiff;                            // 0x0308(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfoTriangleOutAlpha;                              // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InfoExclamationPosDiff;                            // 0x0318(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CursorInAnimeMove;                                 // 0x0324(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CursorInAnimeFrame;                                // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNameAnimeMoveUp;                              // 0x0334(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorNameAnimeMoveDown;                            // 0x0340(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FloorNameAnimeFrame;                               // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfoMissTriangleRotationSecond;                    // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorNameFadeInFrame;                              // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorNameFadeOutFrame;                             // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BackGroundPos;                                     // 0x0360(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BackGroundSelectUpY;                               // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackGroundSelectDownY;                             // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackGroundNotSelectUpY;                            // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackGroundNotSelectDownY;                          // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistantviewFrontSpeed;                             // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistantviewBackSpeed;                              // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistantviewInterval;                               // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistantviewLoopXFront;                             // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistantviewLoopXBack;                              // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 DistantviewPos;                                    // 0x0398(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        MoonPos;                                           // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 MoonScale;                                         // 0x03B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ColorMoonCloud;                                    // 0x03C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerDownPos;                                      // 0x03D4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerMidPos;                                       // 0x03E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerUpPos;                                        // 0x03EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerTownPos;                                      // 0x03F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerColorDark;                                    // 0x0404(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TowerColorLight;                                   // 0x0410(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TowerTownMoveRation;                               // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        WindowPos;                                         // 0x0420(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WomdowAlpha;                                       // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor1;                                       // 0x0438(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor2;                                       // 0x0448(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor3;                                       // 0x0458(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor4;                                       // 0x0468(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor5;                                       // 0x0478(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUIDungeonTransferCloudParam>   CloudFloor6;                                       // 0x0488(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CloudLoopDistance;                                 // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDungeonTransferHazeParam>    HazeParam;                                         // 0x04A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HazeFadeInSecond;                                  // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeAppearSecond;                                  // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeWaitSecond;                                    // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeVanishSecondMin;                               // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeVanishSecondMax;                               // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeAppearSecondMin;                               // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeAppearSecondMax;                               // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeAllRotationMin;                                // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeAllRotationMax;                                // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeInitRMax;                                      // 0x04D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeMoveMin;                                       // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeMoveMax;                                       // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeInitScaleMin;                                  // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeInitScaleMax;                                  // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeInitAlphaMin;                                  // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeInitAlphaMax;                                  // 0x04EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeHiddenPosUpY;                                  // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HazeHiddenPosDownY;                                // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        RedHazePos;                                        // 0x04F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RedHazeWholeTime;                                  // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeSprMin;                                     // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeSprMax;                                     // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeNumMin;                                     // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeNumMax;                                     // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeInitRMax;                                   // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeInitScaleMin;                               // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeInitScaleMax;                               // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeAddNumMin;                                  // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedHazeAddNumMax;                                  // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeAddInitRMax;                                // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeAddInitScaleMin;                            // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedHazeAddInitScaleMax;                            // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RedHazeAddInitRationStart;                         // 0x0540(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RedHazeAddInitRationEnd;                           // 0x0550(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RedHazeFadeSecond;                                 // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGAnimChangeWholeFrame;                            // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGAnimChangeDistantviewFrame;                      // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGAnimChangeMoonFrame;                             // 0x056C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGAnimChangeCloudFadeOutFrame;                     // 0x0570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGAnimChangeCloudFadeInFrame;                      // 0x0574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenFadeInFrame;                                 // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenFadeOutFrame;                                // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenFadeOutCancelFrame;                          // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDungeonTransferData">();
	}
	static class UUIDungeonTransferData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDungeonTransferData>();
	}
};
static_assert(alignof(UUIDungeonTransferData) == 0x000008, "Wrong alignment on UUIDungeonTransferData");
static_assert(sizeof(UUIDungeonTransferData) == 0x000588, "Wrong size on UUIDungeonTransferData");
static_assert(offsetof(UUIDungeonTransferData, ContentNum) == 0x000028, "Member 'UUIDungeonTransferData::ContentNum' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListPosWhen2_4) == 0x00002C, "Member 'UUIDungeonTransferData::FloorListPosWhen2_4' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListPosWhen5_8) == 0x000038, "Member 'UUIDungeonTransferData::FloorListPosWhen5_8' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListScale) == 0x000044, "Member 'UUIDungeonTransferData::FloorListScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListInterval) == 0x000050, "Member 'UUIDungeonTransferData::FloorListInterval' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListColorV0) == 0x000054, "Member 'UUIDungeonTransferData::FloorListColorV0' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListColorV1) == 0x000060, "Member 'UUIDungeonTransferData::FloorListColorV1' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListColorV2) == 0x00006C, "Member 'UUIDungeonTransferData::FloorListColorV2' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListColorV3) == 0x000078, "Member 'UUIDungeonTransferData::FloorListColorV3' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListLightPosDif) == 0x000084, "Member 'UUIDungeonTransferData::FloorListLightPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListLightScale) == 0x000090, "Member 'UUIDungeonTransferData::FloorListLightScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListLightColor) == 0x00009C, "Member 'UUIDungeonTransferData::FloorListLightColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScrollBarPosDif) == 0x0000A8, "Member 'UUIDungeonTransferData::ScrollBarPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScrollBarEnableY) == 0x0000B4, "Member 'UUIDungeonTransferData::ScrollBarEnableY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScrollBarMinmamSize) == 0x0000B8, "Member 'UUIDungeonTransferData::ScrollBarMinmamSize' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TarminalIconPosDif) == 0x0000C4, "Member 'UUIDungeonTransferData::TarminalIconPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ListHeadPosDif) == 0x0000D0, "Member 'UUIDungeonTransferData::ListHeadPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FMarkPosDif) == 0x0000DC, "Member 'UUIDungeonTransferData::FMarkPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListSelectedColor) == 0x0000E8, "Member 'UUIDungeonTransferData::FloorListSelectedColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorListNotSelectedColor) == 0x0000F4, "Member 'UUIDungeonTransferData::FloorListNotSelectedColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNumWhen1PosDif) == 0x000100, "Member 'UUIDungeonTransferData::FloorNumWhen1PosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNumDigit1PosDif) == 0x00010C, "Member 'UUIDungeonTransferData::FloorNumDigit1PosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNumDigit2PosDif) == 0x000118, "Member 'UUIDungeonTransferData::FloorNumDigit2PosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNumDigit3PosDif) == 0x000124, "Member 'UUIDungeonTransferData::FloorNumDigit3PosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorEntrancePosDif) == 0x000130, "Member 'UUIDungeonTransferData::FloorEntrancePosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CurrentIconPosDif) == 0x00013C, "Member 'UUIDungeonTransferData::CurrentIconPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CurrentIconSelectedColor) == 0x000148, "Member 'UUIDungeonTransferData::CurrentIconSelectedColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CurrentIconNotSelectedColor) == 0x000154, "Member 'UUIDungeonTransferData::CurrentIconNotSelectedColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DoorIconPosDif) == 0x000160, "Member 'UUIDungeonTransferData::DoorIconPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HorizonPosDif) == 0x00016C, "Member 'UUIDungeonTransferData::HorizonPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HorizonScale) == 0x000178, "Member 'UUIDungeonTransferData::HorizonScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HorizonAlpha) == 0x000184, "Member 'UUIDungeonTransferData::HorizonAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, WhiteCursorPosDif) == 0x000188, "Member 'UUIDungeonTransferData::WhiteCursorPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, WhiteCursorScale) == 0x000194, "Member 'UUIDungeonTransferData::WhiteCursorScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, WhiteCursorColor) == 0x0001A0, "Member 'UUIDungeonTransferData::WhiteCursorColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, GreenCursorPosDif) == 0x0001AC, "Member 'UUIDungeonTransferData::GreenCursorPosDif' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, GreenCursorScale) == 0x0001B8, "Member 'UUIDungeonTransferData::GreenCursorScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, GreenCursorColor) == 0x0001C4, "Member 'UUIDungeonTransferData::GreenCursorColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoPlatePos) == 0x0001D0, "Member 'UUIDungeonTransferData::InfoPlatePos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoPlateScale) == 0x0001DC, "Member 'UUIDungeonTransferData::InfoPlateScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoPlateScaleWhenEntrance) == 0x0001E8, "Member 'UUIDungeonTransferData::InfoPlateScaleWhenEntrance' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoPlateColor) == 0x0001F4, "Member 'UUIDungeonTransferData::InfoPlateColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNamePosDiff) == 0x000200, "Member 'UUIDungeonTransferData::InfoBlockNamePosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockHeadPosDiff) == 0x00020C, "Member 'UUIDungeonTransferData::InfoBlockHeadPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockHeadAlpha) == 0x000218, "Member 'UUIDungeonTransferData::InfoBlockHeadAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumPosDiff) == 0x00021C, "Member 'UUIDungeonTransferData::InfoBlockNumPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumColorDarkColor) == 0x000228, "Member 'UUIDungeonTransferData::InfoBlockNumColorDarkColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumColorLightColor) == 0x000234, "Member 'UUIDungeonTransferData::InfoBlockNumColorLightColor' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumColorLightAlpha) == 0x000240, "Member 'UUIDungeonTransferData::InfoBlockNumColorLightAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumMaskPosDiff) == 0x000244, "Member 'UUIDungeonTransferData::InfoBlockNumMaskPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoBlockNumMaskScale) == 0x000250, "Member 'UUIDungeonTransferData::InfoBlockNumMaskScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameEntrancePosDiff) == 0x00025C, "Member 'UUIDungeonTransferData::InfoNameEntrancePosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor1PosDiff) == 0x000268, "Member 'UUIDungeonTransferData::InfoNameFloor1PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor2PosDiff) == 0x000274, "Member 'UUIDungeonTransferData::InfoNameFloor2PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor3PosDiff) == 0x000280, "Member 'UUIDungeonTransferData::InfoNameFloor3PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor4PosDiff) == 0x00028C, "Member 'UUIDungeonTransferData::InfoNameFloor4PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor5PosDiff) == 0x000298, "Member 'UUIDungeonTransferData::InfoNameFloor5PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameFloor6PosDiff) == 0x0002A4, "Member 'UUIDungeonTransferData::InfoNameFloor6PosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameColorDark) == 0x0002B0, "Member 'UUIDungeonTransferData::InfoNameColorDark' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoNameColorLight) == 0x0002BC, "Member 'UUIDungeonTransferData::InfoNameColorLight' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoMissHeadPos) == 0x0002C8, "Member 'UUIDungeonTransferData::InfoMissHeadPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoMissUnitPosDiff) == 0x0002D4, "Member 'UUIDungeonTransferData::InfoMissUnitPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoMissNumPosDiff) == 0x0002E0, "Member 'UUIDungeonTransferData::InfoMissNumPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoMiss0Color) == 0x0002EC, "Member 'UUIDungeonTransferData::InfoMiss0Color' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoTrianglePosDiff) == 0x0002F8, "Member 'UUIDungeonTransferData::InfoTrianglePosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoTriangleAlpha) == 0x000304, "Member 'UUIDungeonTransferData::InfoTriangleAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoTriangleOutPosDiff) == 0x000308, "Member 'UUIDungeonTransferData::InfoTriangleOutPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoTriangleOutAlpha) == 0x000314, "Member 'UUIDungeonTransferData::InfoTriangleOutAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoExclamationPosDiff) == 0x000318, "Member 'UUIDungeonTransferData::InfoExclamationPosDiff' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CursorInAnimeMove) == 0x000324, "Member 'UUIDungeonTransferData::CursorInAnimeMove' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CursorInAnimeFrame) == 0x000330, "Member 'UUIDungeonTransferData::CursorInAnimeFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNameAnimeMoveUp) == 0x000334, "Member 'UUIDungeonTransferData::FloorNameAnimeMoveUp' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNameAnimeMoveDown) == 0x000340, "Member 'UUIDungeonTransferData::FloorNameAnimeMoveDown' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNameAnimeFrame) == 0x00034C, "Member 'UUIDungeonTransferData::FloorNameAnimeFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, InfoMissTriangleRotationSecond) == 0x000350, "Member 'UUIDungeonTransferData::InfoMissTriangleRotationSecond' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNameFadeInFrame) == 0x000354, "Member 'UUIDungeonTransferData::FloorNameFadeInFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, FloorNameFadeOutFrame) == 0x000358, "Member 'UUIDungeonTransferData::FloorNameFadeOutFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BackGroundPos) == 0x000360, "Member 'UUIDungeonTransferData::BackGroundPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BackGroundSelectUpY) == 0x000370, "Member 'UUIDungeonTransferData::BackGroundSelectUpY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BackGroundSelectDownY) == 0x000374, "Member 'UUIDungeonTransferData::BackGroundSelectDownY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BackGroundNotSelectUpY) == 0x000378, "Member 'UUIDungeonTransferData::BackGroundNotSelectUpY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BackGroundNotSelectDownY) == 0x00037C, "Member 'UUIDungeonTransferData::BackGroundNotSelectDownY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewFrontSpeed) == 0x000380, "Member 'UUIDungeonTransferData::DistantviewFrontSpeed' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewBackSpeed) == 0x000384, "Member 'UUIDungeonTransferData::DistantviewBackSpeed' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewInterval) == 0x000388, "Member 'UUIDungeonTransferData::DistantviewInterval' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewLoopXFront) == 0x00038C, "Member 'UUIDungeonTransferData::DistantviewLoopXFront' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewLoopXBack) == 0x000390, "Member 'UUIDungeonTransferData::DistantviewLoopXBack' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, DistantviewPos) == 0x000398, "Member 'UUIDungeonTransferData::DistantviewPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, MoonPos) == 0x0003A8, "Member 'UUIDungeonTransferData::MoonPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, MoonScale) == 0x0003B8, "Member 'UUIDungeonTransferData::MoonScale' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ColorMoonCloud) == 0x0003C8, "Member 'UUIDungeonTransferData::ColorMoonCloud' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerDownPos) == 0x0003D4, "Member 'UUIDungeonTransferData::TowerDownPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerMidPos) == 0x0003E0, "Member 'UUIDungeonTransferData::TowerMidPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerUpPos) == 0x0003EC, "Member 'UUIDungeonTransferData::TowerUpPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerTownPos) == 0x0003F8, "Member 'UUIDungeonTransferData::TowerTownPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerColorDark) == 0x000404, "Member 'UUIDungeonTransferData::TowerColorDark' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerColorLight) == 0x000410, "Member 'UUIDungeonTransferData::TowerColorLight' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, TowerTownMoveRation) == 0x00041C, "Member 'UUIDungeonTransferData::TowerTownMoveRation' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, WindowPos) == 0x000420, "Member 'UUIDungeonTransferData::WindowPos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, WomdowAlpha) == 0x000430, "Member 'UUIDungeonTransferData::WomdowAlpha' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor1) == 0x000438, "Member 'UUIDungeonTransferData::CloudFloor1' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor2) == 0x000448, "Member 'UUIDungeonTransferData::CloudFloor2' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor3) == 0x000458, "Member 'UUIDungeonTransferData::CloudFloor3' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor4) == 0x000468, "Member 'UUIDungeonTransferData::CloudFloor4' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor5) == 0x000478, "Member 'UUIDungeonTransferData::CloudFloor5' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudFloor6) == 0x000488, "Member 'UUIDungeonTransferData::CloudFloor6' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, CloudLoopDistance) == 0x000498, "Member 'UUIDungeonTransferData::CloudLoopDistance' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeParam) == 0x0004A0, "Member 'UUIDungeonTransferData::HazeParam' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeFadeInSecond) == 0x0004B0, "Member 'UUIDungeonTransferData::HazeFadeInSecond' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeAppearSecond) == 0x0004B4, "Member 'UUIDungeonTransferData::HazeAppearSecond' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeWaitSecond) == 0x0004B8, "Member 'UUIDungeonTransferData::HazeWaitSecond' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeVanishSecondMin) == 0x0004BC, "Member 'UUIDungeonTransferData::HazeVanishSecondMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeVanishSecondMax) == 0x0004C0, "Member 'UUIDungeonTransferData::HazeVanishSecondMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeAppearSecondMin) == 0x0004C4, "Member 'UUIDungeonTransferData::HazeAppearSecondMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeAppearSecondMax) == 0x0004C8, "Member 'UUIDungeonTransferData::HazeAppearSecondMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeAllRotationMin) == 0x0004CC, "Member 'UUIDungeonTransferData::HazeAllRotationMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeAllRotationMax) == 0x0004D0, "Member 'UUIDungeonTransferData::HazeAllRotationMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeInitRMax) == 0x0004D4, "Member 'UUIDungeonTransferData::HazeInitRMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeMoveMin) == 0x0004D8, "Member 'UUIDungeonTransferData::HazeMoveMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeMoveMax) == 0x0004DC, "Member 'UUIDungeonTransferData::HazeMoveMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeInitScaleMin) == 0x0004E0, "Member 'UUIDungeonTransferData::HazeInitScaleMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeInitScaleMax) == 0x0004E4, "Member 'UUIDungeonTransferData::HazeInitScaleMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeInitAlphaMin) == 0x0004E8, "Member 'UUIDungeonTransferData::HazeInitAlphaMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeInitAlphaMax) == 0x0004EC, "Member 'UUIDungeonTransferData::HazeInitAlphaMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeHiddenPosUpY) == 0x0004F0, "Member 'UUIDungeonTransferData::HazeHiddenPosUpY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, HazeHiddenPosDownY) == 0x0004F4, "Member 'UUIDungeonTransferData::HazeHiddenPosDownY' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazePos) == 0x0004F8, "Member 'UUIDungeonTransferData::RedHazePos' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeWholeTime) == 0x000508, "Member 'UUIDungeonTransferData::RedHazeWholeTime' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeSprMin) == 0x00050C, "Member 'UUIDungeonTransferData::RedHazeSprMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeSprMax) == 0x000510, "Member 'UUIDungeonTransferData::RedHazeSprMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeNumMin) == 0x000514, "Member 'UUIDungeonTransferData::RedHazeNumMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeNumMax) == 0x000518, "Member 'UUIDungeonTransferData::RedHazeNumMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeInitRMax) == 0x00051C, "Member 'UUIDungeonTransferData::RedHazeInitRMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeInitScaleMin) == 0x000520, "Member 'UUIDungeonTransferData::RedHazeInitScaleMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeInitScaleMax) == 0x000524, "Member 'UUIDungeonTransferData::RedHazeInitScaleMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddNumMin) == 0x000528, "Member 'UUIDungeonTransferData::RedHazeAddNumMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddNumMax) == 0x00052C, "Member 'UUIDungeonTransferData::RedHazeAddNumMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddInitRMax) == 0x000530, "Member 'UUIDungeonTransferData::RedHazeAddInitRMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddInitScaleMin) == 0x000534, "Member 'UUIDungeonTransferData::RedHazeAddInitScaleMin' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddInitScaleMax) == 0x000538, "Member 'UUIDungeonTransferData::RedHazeAddInitScaleMax' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddInitRationStart) == 0x000540, "Member 'UUIDungeonTransferData::RedHazeAddInitRationStart' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeAddInitRationEnd) == 0x000550, "Member 'UUIDungeonTransferData::RedHazeAddInitRationEnd' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, RedHazeFadeSecond) == 0x000560, "Member 'UUIDungeonTransferData::RedHazeFadeSecond' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BGAnimChangeWholeFrame) == 0x000564, "Member 'UUIDungeonTransferData::BGAnimChangeWholeFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BGAnimChangeDistantviewFrame) == 0x000568, "Member 'UUIDungeonTransferData::BGAnimChangeDistantviewFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BGAnimChangeMoonFrame) == 0x00056C, "Member 'UUIDungeonTransferData::BGAnimChangeMoonFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BGAnimChangeCloudFadeOutFrame) == 0x000570, "Member 'UUIDungeonTransferData::BGAnimChangeCloudFadeOutFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, BGAnimChangeCloudFadeInFrame) == 0x000574, "Member 'UUIDungeonTransferData::BGAnimChangeCloudFadeInFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScreenFadeInFrame) == 0x000578, "Member 'UUIDungeonTransferData::ScreenFadeInFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScreenFadeOutFrame) == 0x00057C, "Member 'UUIDungeonTransferData::ScreenFadeOutFrame' has a wrong offset!");
static_assert(offsetof(UUIDungeonTransferData, ScreenFadeOutCancelFrame) == 0x000580, "Member 'UUIDungeonTransferData::ScreenFadeOutCancelFrame' has a wrong offset!");

// Class xrd777.UIGenericSelect
// 0x00E0 (0x0380 - 0x02A0)
class AUIGenericSelect final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x58];                                     // 0x02A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UGenericSelectSystemBase*               System_;                                           // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUIGenericSelectDraw>       PDrawClass;                                        // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIGenericSelectDraw*                   PDrawActor;                                        // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutData;                                        // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LayoutDataAstreaGarden;                            // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTableAstreaGarden;                       // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x48];                                     // 0x0338(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGenericSelect">();
	}
	static class AUIGenericSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIGenericSelect>();
	}
};
static_assert(alignof(AUIGenericSelect) == 0x000008, "Wrong alignment on AUIGenericSelect");
static_assert(sizeof(AUIGenericSelect) == 0x000380, "Wrong size on AUIGenericSelect");
static_assert(offsetof(AUIGenericSelect, System_) == 0x0002F8, "Member 'AUIGenericSelect::System_' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, PAssetLoader) == 0x000300, "Member 'AUIGenericSelect::PAssetLoader' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, PDrawClass) == 0x000308, "Member 'AUIGenericSelect::PDrawClass' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, PDrawActor) == 0x000310, "Member 'AUIGenericSelect::PDrawActor' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, LayoutData) == 0x000318, "Member 'AUIGenericSelect::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, LayoutDataTable) == 0x000320, "Member 'AUIGenericSelect::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, LayoutDataAstreaGarden) == 0x000328, "Member 'AUIGenericSelect::LayoutDataAstreaGarden' has a wrong offset!");
static_assert(offsetof(AUIGenericSelect, LayoutDataTableAstreaGarden) == 0x000330, "Member 'AUIGenericSelect::LayoutDataTableAstreaGarden' has a wrong offset!");

// Class xrd777.UIGetCommunityPointDraw
// 0x24C8 (0x2768 - 0x02A0)
class AUIGetCommunityPointDraw final : public AUIBaseActor
{
public:
	class USprAsset*                              M_pSpr;                                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlgAsset*                              M_pNotePlg;                                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         M_pRankUpEffect;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         M_pRankUpFinishEffect;                             // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      M_pRankUpEffectComponent;                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           M_pLoader;                                         // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_tagGetUIP;                                       // 0x02D0(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x2420];                                   // 0x0348(0x2420)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGetCommunityPointDraw">();
	}
	static class AUIGetCommunityPointDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIGetCommunityPointDraw>();
	}
};
static_assert(alignof(AUIGetCommunityPointDraw) == 0x000008, "Wrong alignment on AUIGetCommunityPointDraw");
static_assert(sizeof(AUIGetCommunityPointDraw) == 0x002768, "Wrong size on AUIGetCommunityPointDraw");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pSpr) == 0x0002A0, "Member 'AUIGetCommunityPointDraw::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pNotePlg) == 0x0002A8, "Member 'AUIGetCommunityPointDraw::M_pNotePlg' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pRankUpEffect) == 0x0002B0, "Member 'AUIGetCommunityPointDraw::M_pRankUpEffect' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pRankUpFinishEffect) == 0x0002B8, "Member 'AUIGetCommunityPointDraw::M_pRankUpFinishEffect' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pRankUpEffectComponent) == 0x0002C0, "Member 'AUIGetCommunityPointDraw::M_pRankUpEffectComponent' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_pLoader) == 0x0002C8, "Member 'AUIGetCommunityPointDraw::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIGetCommunityPointDraw, M_tagGetUIP) == 0x0002D0, "Member 'AUIGetCommunityPointDraw::M_tagGetUIP' has a wrong offset!");

// Class xrd777.UIKeyHelpDraw
// 0x0240 (0x04E0 - 0x02A0)
class AUIKeyHelpDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x240];                                    // 0x02A0(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyHelpDraw">();
	}
	static class AUIKeyHelpDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIKeyHelpDraw>();
	}
};
static_assert(alignof(AUIKeyHelpDraw) == 0x000008, "Wrong alignment on AUIKeyHelpDraw");
static_assert(sizeof(AUIKeyHelpDraw) == 0x0004E0, "Wrong size on AUIKeyHelpDraw");

// Class xrd777.UILayoutDataTable
// 0x0018 (0x0040 - 0x0028)
class UUILayoutDataTable final : public UObject
{
public:
	class UDataTable*                             LayoutTable;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutDataTable">();
	}
	static class UUILayoutDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutDataTable>();
	}
};
static_assert(alignof(UUILayoutDataTable) == 0x000008, "Wrong alignment on UUILayoutDataTable");
static_assert(sizeof(UUILayoutDataTable) == 0x000040, "Wrong size on UUILayoutDataTable");
static_assert(offsetof(UUILayoutDataTable, LayoutTable) == 0x000028, "Member 'UUILayoutDataTable::LayoutTable' has a wrong offset!");

// Class xrd777.UILocationSelect
// 0x0330 (0x0358 - 0x0028)
class UUILocationSelect final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pMiniMapSpr;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAssetLoader*                           M_pLoader;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_tagUip;                                          // 0x0058(0x0078)(NativeAccessSpecifierPublic)
	TArray<struct FShortcutItem>                  M_aShortcutList;                                   // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x228];                                     // 0x00E0(0x0228)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pLayoutData;                                     // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     M_pLayoutDataTable;                                // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pLayoutData2;                                    // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     M_pLayoutDataTable2;                               // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILocationSelect">();
	}
	static class UUILocationSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILocationSelect>();
	}
};
static_assert(alignof(UUILocationSelect) == 0x000008, "Wrong alignment on UUILocationSelect");
static_assert(sizeof(UUILocationSelect) == 0x000358, "Wrong size on UUILocationSelect");
static_assert(offsetof(UUILocationSelect, M_pMiniMapSpr) == 0x000048, "Member 'UUILocationSelect::M_pMiniMapSpr' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_pLoader) == 0x000050, "Member 'UUILocationSelect::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_tagUip) == 0x000058, "Member 'UUILocationSelect::M_tagUip' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_aShortcutList) == 0x0000D0, "Member 'UUILocationSelect::M_aShortcutList' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_pLayoutData) == 0x000308, "Member 'UUILocationSelect::M_pLayoutData' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_pLayoutDataTable) == 0x000310, "Member 'UUILocationSelect::M_pLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_pLayoutData2) == 0x000318, "Member 'UUILocationSelect::M_pLayoutData2' has a wrong offset!");
static_assert(offsetof(UUILocationSelect, M_pLayoutDataTable2) == 0x000320, "Member 'UUILocationSelect::M_pLayoutDataTable2' has a wrong offset!");

// Class xrd777.UIMiscCheckDraw
// 0x0F20 (0x11C0 - 0x02A0)
class alignas(0x10) AUIMiscCheckDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pAlphaSpr;                                       // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pKeySpr;                                         // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           M_pLoader;                                         // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveLinearColorAnimation             M_tagMaxColorWave;                                 // 0x02D0(0x0030)(NativeAccessSpecifierPrivate)
	struct FGetUIParameter                        M_uip;                                             // 0x0300(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0xE20];                                    // 0x0378(0x0E20)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutData;                                        // 0x1198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TextLayoutData;                                    // 0x11A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x11A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextLayoutDataTable;                               // 0x11B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B8[0x8];                                     // 0x11B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscCheckDraw">();
	}
	static class AUIMiscCheckDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscCheckDraw>();
	}
};
static_assert(alignof(AUIMiscCheckDraw) == 0x000010, "Wrong alignment on AUIMiscCheckDraw");
static_assert(sizeof(AUIMiscCheckDraw) == 0x0011C0, "Wrong size on AUIMiscCheckDraw");
static_assert(offsetof(AUIMiscCheckDraw, M_pAlphaSpr) == 0x0002B8, "Member 'AUIMiscCheckDraw::M_pAlphaSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, M_pKeySpr) == 0x0002C0, "Member 'AUIMiscCheckDraw::M_pKeySpr' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, M_pLoader) == 0x0002C8, "Member 'AUIMiscCheckDraw::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, M_tagMaxColorWave) == 0x0002D0, "Member 'AUIMiscCheckDraw::M_tagMaxColorWave' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, M_uip) == 0x000300, "Member 'AUIMiscCheckDraw::M_uip' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, LayoutData) == 0x001198, "Member 'AUIMiscCheckDraw::LayoutData' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, TextLayoutData) == 0x0011A0, "Member 'AUIMiscCheckDraw::TextLayoutData' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, LayoutDataTable) == 0x0011A8, "Member 'AUIMiscCheckDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIMiscCheckDraw, TextLayoutDataTable) == 0x0011B0, "Member 'AUIMiscCheckDraw::TextLayoutDataTable' has a wrong offset!");

// Class xrd777.UIMiscGetItemDraw
// 0x0C30 (0x0ED0 - 0x02A0)
class AUIMiscGetItemDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x68];                                     // 0x02A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pGetItemSpr;                                     // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              M_pGetPlg;                                         // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pItemGetDT;                                      // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pSpecialKeyHelpSpr;                              // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pSpecialKeyHelpTextSpr;                          // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pLayoutTextColDT;                                // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pLayoutOkNextDT;                                 // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pLayoutOkNextMaskDT;                             // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pLayoutTextCol;                                  // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pLayoutOkNext;                                   // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pLayoutOkNextMask;                               // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0xAC8];                                    // 0x0360(0x0AC8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGetUIParameter                        M_ArcanaGetMsgAndTutorialParameter;                // 0x0E28(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA0[0x30];                                     // 0x0EA0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateMajorArcanaGetMessage();
	void UpdateMajorArcanaTutorial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscGetItemDraw">();
	}
	static class AUIMiscGetItemDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscGetItemDraw>();
	}
};
static_assert(alignof(AUIMiscGetItemDraw) == 0x000008, "Wrong alignment on AUIMiscGetItemDraw");
static_assert(sizeof(AUIMiscGetItemDraw) == 0x000ED0, "Wrong size on AUIMiscGetItemDraw");
static_assert(offsetof(AUIMiscGetItemDraw, M_pGetItemSpr) == 0x000308, "Member 'AUIMiscGetItemDraw::M_pGetItemSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pGetPlg) == 0x000310, "Member 'AUIMiscGetItemDraw::M_pGetPlg' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pItemGetDT) == 0x000318, "Member 'AUIMiscGetItemDraw::M_pItemGetDT' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pSpecialKeyHelpSpr) == 0x000320, "Member 'AUIMiscGetItemDraw::M_pSpecialKeyHelpSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pSpecialKeyHelpTextSpr) == 0x000328, "Member 'AUIMiscGetItemDraw::M_pSpecialKeyHelpTextSpr' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutTextColDT) == 0x000330, "Member 'AUIMiscGetItemDraw::M_pLayoutTextColDT' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutOkNextDT) == 0x000338, "Member 'AUIMiscGetItemDraw::M_pLayoutOkNextDT' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutOkNextMaskDT) == 0x000340, "Member 'AUIMiscGetItemDraw::M_pLayoutOkNextMaskDT' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutTextCol) == 0x000348, "Member 'AUIMiscGetItemDraw::M_pLayoutTextCol' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutOkNext) == 0x000350, "Member 'AUIMiscGetItemDraw::M_pLayoutOkNext' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_pLayoutOkNextMask) == 0x000358, "Member 'AUIMiscGetItemDraw::M_pLayoutOkNextMask' has a wrong offset!");
static_assert(offsetof(AUIMiscGetItemDraw, M_ArcanaGetMsgAndTutorialParameter) == 0x000E28, "Member 'AUIMiscGetItemDraw::M_ArcanaGetMsgAndTutorialParameter' has a wrong offset!");

// Class xrd777.UIMiscMoneyDraw
// 0x05B8 (0x0858 - 0x02A0)
class AUIMiscMoneyDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x38];                                     // 0x02A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              M_pMoneySpr;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x578];                                    // 0x02E0(0x0578)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiscMoneyDraw">();
	}
	static class AUIMiscMoneyDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMiscMoneyDraw>();
	}
};
static_assert(alignof(AUIMiscMoneyDraw) == 0x000008, "Wrong alignment on AUIMiscMoneyDraw");
static_assert(sizeof(AUIMiscMoneyDraw) == 0x000858, "Wrong size on AUIMiscMoneyDraw");
static_assert(offsetof(AUIMiscMoneyDraw, M_pMoneySpr) == 0x0002D8, "Member 'AUIMiscMoneyDraw::M_pMoneySpr' has a wrong offset!");

// Class xrd777.UIMissingPerson
// 0x0BD0 (0x0BF8 - 0x0028)
class UUIMissingPerson final : public UObject
{
public:
	uint8                                         Pad_28[0x3E0];                                     // 0x0028(0x03E0)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              PSpr_;                                             // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PLoader_;                                          // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     M_pBGMat;                                          // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pBGMatInst;                                      // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pDT;                                             // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMissingParamTableRow                  ParamDT;                                           // 0x0430(0x00F8)(NativeAccessSpecifierPrivate)
	class UWorld*                                 PRefWorld_;                                        // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x630];                                    // 0x0530(0x0630)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutData;                                        // 0x0B60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextColLayoutData;                                 // 0x0B68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextPosLayoutData;                                 // 0x0B70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     DateLayoutData;                                    // 0x0B78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B80[0x78];                                     // 0x0B80(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMissingPerson">();
	}
	static class UUIMissingPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMissingPerson>();
	}
};
static_assert(alignof(UUIMissingPerson) == 0x000008, "Wrong alignment on UUIMissingPerson");
static_assert(sizeof(UUIMissingPerson) == 0x000BF8, "Wrong size on UUIMissingPerson");
static_assert(offsetof(UUIMissingPerson, PSpr_) == 0x000408, "Member 'UUIMissingPerson::PSpr_' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, PLoader_) == 0x000410, "Member 'UUIMissingPerson::PLoader_' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, M_pBGMat) == 0x000418, "Member 'UUIMissingPerson::M_pBGMat' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, M_pBGMatInst) == 0x000420, "Member 'UUIMissingPerson::M_pBGMatInst' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, M_pDT) == 0x000428, "Member 'UUIMissingPerson::M_pDT' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, ParamDT) == 0x000430, "Member 'UUIMissingPerson::ParamDT' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, PRefWorld_) == 0x000528, "Member 'UUIMissingPerson::PRefWorld_' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, LayoutData) == 0x000B60, "Member 'UUIMissingPerson::LayoutData' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, TextColLayoutData) == 0x000B68, "Member 'UUIMissingPerson::TextColLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, TextPosLayoutData) == 0x000B70, "Member 'UUIMissingPerson::TextPosLayoutData' has a wrong offset!");
static_assert(offsetof(UUIMissingPerson, DateLayoutData) == 0x000B78, "Member 'UUIMissingPerson::DateLayoutData' has a wrong offset!");

// Class xrd777.UIMorphTestActor
// 0x00C8 (0x02E8 - 0x0220)
class AUIMorphTestActor final : public AActor
{
public:
	class UUimAsset*                              M_pUimMain;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              MpUimSubAry[0x5];                                  // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              M_pUimCross;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              M_pUimColor;                                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              M_pUimUV;                                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              M_pUimPoly;                                        // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUimAsset*                              M_pUimUVCol;                                       // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               M_TexMain;                                         // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               M_TexSubAry[0x5];                                  // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               M_TexMask;                                         // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pSpr;                                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           PMayaCamera;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMorphTestActor">();
	}
	static class AUIMorphTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMorphTestActor>();
	}
};
static_assert(alignof(AUIMorphTestActor) == 0x000008, "Wrong alignment on AUIMorphTestActor");
static_assert(sizeof(AUIMorphTestActor) == 0x0002E8, "Wrong size on AUIMorphTestActor");
static_assert(offsetof(AUIMorphTestActor, M_pUimMain) == 0x000220, "Member 'AUIMorphTestActor::M_pUimMain' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, MpUimSubAry) == 0x000228, "Member 'AUIMorphTestActor::MpUimSubAry' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pUimCross) == 0x000250, "Member 'AUIMorphTestActor::M_pUimCross' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pUimColor) == 0x000258, "Member 'AUIMorphTestActor::M_pUimColor' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pUimUV) == 0x000260, "Member 'AUIMorphTestActor::M_pUimUV' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pUimPoly) == 0x000268, "Member 'AUIMorphTestActor::M_pUimPoly' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pUimUVCol) == 0x000270, "Member 'AUIMorphTestActor::M_pUimUVCol' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_TexMain) == 0x000278, "Member 'AUIMorphTestActor::M_TexMain' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_TexSubAry) == 0x000280, "Member 'AUIMorphTestActor::M_TexSubAry' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_TexMask) == 0x0002A8, "Member 'AUIMorphTestActor::M_TexMask' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, M_pSpr) == 0x0002B0, "Member 'AUIMorphTestActor::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUIMorphTestActor, PMayaCamera) == 0x0002D8, "Member 'AUIMorphTestActor::PMayaCamera' has a wrong offset!");

// Class xrd777.NameEntry
// 0x00E8 (0x0388 - 0x02A0)
class ANameEntry final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x48];                                     // 0x02A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AScrActor*                              ScrActor_;                                         // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset_;                                         // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               BfAsset_;                                          // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNameEntryCnvCharDataAsset*             CnvCharDataAsset_;                                 // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUINameEntryDraw>           NameEntryDrawSubClass;                             // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUINameEntryDraw*                       PNameEntryDrawActor;                               // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PParamLayoutData;                                  // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PLayoutDataTable;                                  // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x30];                                     // 0x0358(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NameEntry">();
	}
	static class ANameEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANameEntry>();
	}
};
static_assert(alignof(ANameEntry) == 0x000008, "Wrong alignment on ANameEntry");
static_assert(sizeof(ANameEntry) == 0x000388, "Wrong size on ANameEntry");
static_assert(offsetof(ANameEntry, Loader_) == 0x0002E8, "Member 'ANameEntry::Loader_' has a wrong offset!");
static_assert(offsetof(ANameEntry, ScrActor_) == 0x0002F0, "Member 'ANameEntry::ScrActor_' has a wrong offset!");
static_assert(offsetof(ANameEntry, BmdAsset_) == 0x0002F8, "Member 'ANameEntry::BmdAsset_' has a wrong offset!");
static_assert(offsetof(ANameEntry, BfAsset_) == 0x000300, "Member 'ANameEntry::BfAsset_' has a wrong offset!");
static_assert(offsetof(ANameEntry, CnvCharDataAsset_) == 0x000308, "Member 'ANameEntry::CnvCharDataAsset_' has a wrong offset!");
static_assert(offsetof(ANameEntry, NameEntryDrawSubClass) == 0x000320, "Member 'ANameEntry::NameEntryDrawSubClass' has a wrong offset!");
static_assert(offsetof(ANameEntry, PNameEntryDrawActor) == 0x000328, "Member 'ANameEntry::PNameEntryDrawActor' has a wrong offset!");
static_assert(offsetof(ANameEntry, PParamLayoutData) == 0x000348, "Member 'ANameEntry::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(ANameEntry, PLayoutDataTable) == 0x000350, "Member 'ANameEntry::PLayoutDataTable' has a wrong offset!");

// Class xrd777.UIParameterAsset
// 0x0018 (0x0040 - 0x0028)
class UUIParameterAsset final : public UObject
{
public:
	TArray<struct FUIParameter>                   UIParameters;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIParameterAsset">();
	}
	static class UUIParameterAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIParameterAsset>();
	}
};
static_assert(alignof(UUIParameterAsset) == 0x000008, "Wrong alignment on UUIParameterAsset");
static_assert(sizeof(UUIParameterAsset) == 0x000040, "Wrong size on UUIParameterAsset");
static_assert(offsetof(UUIParameterAsset, UIParameters) == 0x000028, "Member 'UUIParameterAsset::UIParameters' has a wrong offset!");

// Class xrd777.UIPersonaModelActor
// 0x0000 (0x0280 - 0x0280)
class AUIPersonaModelActor final : public APawn
{
public:
	class USkeletalMeshComponent* GetSkeletalMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPersonaModelActor">();
	}
	static class AUIPersonaModelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPersonaModelActor>();
	}
};
static_assert(alignof(AUIPersonaModelActor) == 0x000008, "Wrong alignment on AUIPersonaModelActor");
static_assert(sizeof(AUIPersonaModelActor) == 0x000280, "Wrong size on AUIPersonaModelActor");

// Class xrd777.PersonaPreviewWorldUpdater
// 0x0010 (0x0340 - 0x0330)
class APersonaPreviewWorldUpdater final : public APreviewWorldUpdater
{
public:
	bool                                          IsPlaying;                                         // 0x0330(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0xF];                                      // 0x0331(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckPlayAnimation(class AActor* Actor);
	void RequestAnimation(class AActor* Actor, EPersonaStatusModelAnim Anim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaPreviewWorldUpdater">();
	}
	static class APersonaPreviewWorldUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaPreviewWorldUpdater>();
	}
};
static_assert(alignof(APersonaPreviewWorldUpdater) == 0x000010, "Wrong alignment on APersonaPreviewWorldUpdater");
static_assert(sizeof(APersonaPreviewWorldUpdater) == 0x000340, "Wrong size on APersonaPreviewWorldUpdater");
static_assert(offsetof(APersonaPreviewWorldUpdater, IsPlaying) == 0x000330, "Member 'APersonaPreviewWorldUpdater::IsPlaying' has a wrong offset!");

// Class xrd777.PersonaModelCaptureUpdater
// 0x00D0 (0x0388 - 0x02B8)
class APersonaModelCaptureUpdater final : public AModelCaptureUpdater
{
public:
	TArray<class UModelCaptureLayoutDataAsset*>   DataAssets_;                                       // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0xC0];                                     // 0x02C8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaModelCaptureUpdater">();
	}
	static class APersonaModelCaptureUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaModelCaptureUpdater>();
	}
};
static_assert(alignof(APersonaModelCaptureUpdater) == 0x000008, "Wrong alignment on APersonaModelCaptureUpdater");
static_assert(sizeof(APersonaModelCaptureUpdater) == 0x000388, "Wrong size on APersonaModelCaptureUpdater");
static_assert(offsetof(APersonaModelCaptureUpdater, DataAssets_) == 0x0002B8, "Member 'APersonaModelCaptureUpdater::DataAssets_' has a wrong offset!");

// Class xrd777.PersonaStatusDraw
// 0x0648 (0x0900 - 0x02B8)
class APersonaStatusDraw : public AUIDrawBaseActor
{
public:
	bool                                          IsMemoryCheckPersonaModel;                         // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x1F];                                     // 0x02B9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_L1R1_Loop_Animation_Frame;                    // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_L1R1_Push_Animation_Frame;                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Flickering_Loop_Frame;                        // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Persona_Change_SlideIn_Frame;                 // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_Persona_Change_Slide_Value;                   // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPERSONA_STATUS_DRAW_SCENE                    Scene;                                             // 0x02EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PBackgroundMaterial;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0xB0];                                     // 0x02F8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class APersonaModelCaptureUpdater*            ModelCaptureUpdater;                               // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Edit_Background_FadeIn_Frame;                      // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Caustics_SlideIn_Delay;                       // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Caustics_SlideIn_Frame;                       // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Caustics_RectMask_ScaleUp_Delay;              // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Caustics_RectMask_ScaleUp_Frame;              // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_PersonaInfo_SlideIn_Delay;                    // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_PersonaInfo_SlideIn_Frame;                    // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Attribute_Effect_Frame;                       // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillList_SlideIn_Delay;                      // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillList_SlideIn_Frame;                      // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Parameter_SlideIn_Delay;                      // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Parameter_SlideIn_Frame;                      // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Persona_SlideIn_Delay;                        // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Persona_SlideIn_Frame;                        // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetBackgroundAlphaEvent;                           // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetCausticsSlideEvent;                             // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SetCausticsRectMaskScaleEvent;                     // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x14];                                     // 0x0418(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Parameter_Gage_Animation_Frame;               // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Parameter_Gage_Animation_Delay;               // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Parameter_UpGage_Animation_Frame;             // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Parameter_Incense_Value_FadeIn_Frame;         // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x48];                                     // 0x043C(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_LevelUp_SlideIn_Frame;                        // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_LevelUp_Plate_FadeOut_Frame;                  // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x114];                                    // 0x048C(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SkillAdd_Next_Skill_Start_Delay;              // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Wait;    // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Time;    // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillAdd_Next_Skill_Move_Frame;               // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillAdd_Next_Skill_In_Frame;                 // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillAdd_Next_Skill_New_Slide_In_Frame;       // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillAdd_Next_Skill_New_Fade_In_Frame;        // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x2C];                                     // 0x05BC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Conception_Level3_LoopAnimation_Frame;        // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_Level1_LoopAnimation_Frame;        // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_GetEffect_Scale_Frame;             // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_GetEffect_FadeOut_Delay;           // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_GetEffect_FadeOut_Frame;           // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_Icon_Get_FadeOut_Delay;            // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Conception_Icon_Get_FadeOut_Frame;            // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_604[0x10];                                     // 0x0604(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SkillCard_FadeIn_Frame;                       // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_SlideIn_Frame;                      // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_Used_FadeOut_Frame;                 // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_Used_SlideeOut_Frame;               // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_Used_Plate_AddEffect_Frame;         // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_Used_Plate_LoopAnimation_Frame;     // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillCard_Used_GetIcon_SlideIn_Frame;         // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x18];                                     // 0x0630(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_ChangeSkill_Skill_Name_Color_LoopAnimation_Frame; // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_1Effect_Delay;                    // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_BluePlate_SlideIn_Frame;          // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_BluePlate_Slide_Wait_Frame;       // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_BluePlate_SlideOut_Frame;         // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_SlideIn_Delay;        // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_SlideIn_Frame;        // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_Slide_Wait_Frame;     // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_SlideOut_Frame;       // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_FadeIn_Delay;         // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_FadeIn_Frame;         // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_Fade_Wait_Frame;      // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_Change_Font_FadeOut_Frame;        // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_ChangeIcon_FadeIn_Frame;          // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_ChangeSkill_ChangeIcon_SlideIn_Frame;         // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x24];                                     // 0x0684(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SkillInfo_SlideIn_Frame;                      // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_FadeIn_Frame;                       // 0x06AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_SlideOut_Frame;                     // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_FadeOut_Frame;                      // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_Cursor_FadeIn_Frame;                // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_Cursor_FadeOut_Frame;               // 0x06BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_Cursor_Frame;                       // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillInfo_SubCursor_Frame;                    // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SkillSelectListEvent;                              // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D8[0x54];                                     // 0x06D8(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_AffinityCheck_Icon_Move_Frame;                // 0x072C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Icon_1_Move_Delay;              // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Font_Delay;                     // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Font_Move_Frame;                // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Font_1_Move_Delay;              // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Font_FadeIn_Frame;              // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_AffinityCheck_Font_1_FadeIn_Delay;            // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_SkillSelectList_SlideIn_Delay;                // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_SlideIn_Frame;                // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_FadeIn_Delay;                 // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_FadeIn_Frame;                 // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_SlideOut_Delay;               // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_SlideOut_Frame;               // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_FadeOut_Delay;                // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_FadeOut_Frame;                // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_RectScale_Delay;              // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_RectScale_Frame;              // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Cursor_FadeIn_Delay;          // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Cursor_FadeIn_Frame;          // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Cursor_SlideIn_Delay;         // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Cursor_SlideIn_Frame;         // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_SubCursor_SlideIn_Frame;      // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Cursor_Frame;                 // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_SubCursor_Frame;              // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Info_SlideIn_Frame;           // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Info_FadeIn_Frame;            // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Info_ChangeSlideIn_Frame;     // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_SkillSelectList_Info_ChangeFadeIn_Frame;      // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Selected_Succession_Skill_SlideIn_Delay;      // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Selected_Succession_Skill_SlideIn_Frame;      // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Selected_Succession_Skill_FadeIn_Delay;       // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Selected_Succession_Skill_FadeIn_Frame;       // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B4[0x34];                                     // 0x07B4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Commentary_FadeIn_Frame;                      // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_SlideIn_Frame;                     // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Persona_Slide_Delay;               // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Persona_Slide_Frame;               // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Info_FadeOut_Delay;                // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Info_FadeOut_Frame;                // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_SkillList_Move_Delay;              // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_SkillList_Move_Frame;              // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Paramter_Move_Delay;               // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Paramter_Move_Frame;               // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Affinity_FadeOut_Delay;            // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Affinity_FadeOut_Frame;            // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Affinity_SlideOut_Delay;           // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Affinity_SlideOut_Frame;           // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Rect_ScaleUp_Delay;                // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Rect_ScaleUp_Frame;                // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Commentary_Font_Change_Frame;                 // 0x0828(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_82C[0x8];                                      // 0x082C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Combine_CommuBonus_SlideIn_Frame;             // 0x0834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_CommuBonus_Plate_FadeOut_Frame;       // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_CommuBonus_Font_FadeOut_Frame;        // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame1; // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame2; // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_CommuBonus_ColorChange_Frame;         // 0x0848(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_BonusExp_SlideIn_Delay;               // 0x084C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_BonusExp_SlideIn_Frame;               // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Combine_BonusExp_Fade_Frame;                  // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x18];                                     // 0x0858(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Registry_LockIcon_InAnimation_Delay;          // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_LockIcon_InAnimation_Frame;          // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_SlideOut_Delay;       // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_SlideOut_Frame;       // 0x087C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_FadeOut_Delay;        // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_FadeOut_Frame;        // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_SlideIn_Delay;        // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_SlideIn_Frame;        // 0x088C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_FadeIn_Delay;         // 0x0890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Heading_FadeIn_Frame;         // 0x0894(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Registry_Switch_Mark_Rotate_Animation_Frame;  // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89C[0x14];                                     // 0x089C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LayoutTable;                                       // 0x08B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextLayoutTable;                                   // 0x08B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TextPosRowLayoutTable;                             // 0x08C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x08C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextLayoutDataTable;                               // 0x08D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     TextPosRowLayoutDataTable;                         // 0x08D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E0[0x20];                                     // 0x08E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawAttribute(float X, float Y, float Angle);
	void DrawBackground();
	void DrawCombinePersona(float X, float Y, float Angle);
	void DrawCombinePersonaInfo(float X, float Y, float Angle);
	void DrawCommuBonus(float X, float Y, float Angle);
	void DrawConceptionInfo(float X, float Y, float Angle);
	void DrawDefalutConception(float X, float Y, float Angle);
	void DrawDefalutSkillList(float X, float Y, float Angle);
	void DrawDefaultCommentary(float X, float Y, float Angle);
	void DrawDefaultPersona(float X, float Y, float Angle);
	void DrawDefaultPersonaInfo(float X, float Y, float Angle);
	void DrawDefaultPersonaInfoBackground(float X, float Y, float Angle);
	void DrawDefaultStatusParameter(float X, float Y, float Angle);
	void DrawDrawerConception(float X, float Y, float Angle);
	void DrawDrawerConceptionInfo(float X, float Y, float Angle);
	void DrawDrawerPersona(float X, float Y, float Angle);
	void DrawExpBonus(float X, float Y, float Angle);
	void DrawLevelUp(float X, float Y, float Angle);
	void DrawLevelUpConception(float X, float Y, float Angle);
	void DrawOutAnimation();
	void DrawRegistryCommentary(float X, float Y, float Angle);
	void DrawRegistryPersona(float X, float Y, float Angle);
	void DrawRegistryPersonaInfo(float X, float Y, float Angle);
	void DrawRegistrySkillList(float X, float Y, float Angle);
	void DrawSkillCard(float X, float Y, float Angle);
	void DrawSkillInfo(float X, float Y, float Angle);
	void DrawSkillSelectList(float X, float Y, float Angle);
	class UTexture* GetCaptureRenderTarget();
	void SetupOutAnimation();
	void Update(const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusDraw">();
	}
	static class APersonaStatusDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaStatusDraw>();
	}
};
static_assert(alignof(APersonaStatusDraw) == 0x000008, "Wrong alignment on APersonaStatusDraw");
static_assert(sizeof(APersonaStatusDraw) == 0x000900, "Wrong size on APersonaStatusDraw");
static_assert(offsetof(APersonaStatusDraw, IsMemoryCheckPersonaModel) == 0x0002B8, "Member 'APersonaStatusDraw::IsMemoryCheckPersonaModel' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_L1R1_Loop_Animation_Frame) == 0x0002D8, "Member 'APersonaStatusDraw::Edit_L1R1_Loop_Animation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_L1R1_Push_Animation_Frame) == 0x0002DC, "Member 'APersonaStatusDraw::Edit_L1R1_Push_Animation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Flickering_Loop_Frame) == 0x0002E0, "Member 'APersonaStatusDraw::Edit_Flickering_Loop_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Persona_Change_SlideIn_Frame) == 0x0002E4, "Member 'APersonaStatusDraw::Edit_Persona_Change_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Persona_Change_Slide_Value) == 0x0002E8, "Member 'APersonaStatusDraw::Edit_Persona_Change_Slide_Value' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Scene) == 0x0002EC, "Member 'APersonaStatusDraw::Scene' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, PBackgroundMaterial) == 0x0002F0, "Member 'APersonaStatusDraw::PBackgroundMaterial' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, ModelCaptureUpdater) == 0x0003A8, "Member 'APersonaStatusDraw::ModelCaptureUpdater' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Background_FadeIn_Frame) == 0x0003B0, "Member 'APersonaStatusDraw::Edit_Background_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Caustics_SlideIn_Delay) == 0x0003B4, "Member 'APersonaStatusDraw::Edit_Caustics_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Caustics_SlideIn_Frame) == 0x0003B8, "Member 'APersonaStatusDraw::Edit_Caustics_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Caustics_RectMask_ScaleUp_Delay) == 0x0003BC, "Member 'APersonaStatusDraw::Edit_Caustics_RectMask_ScaleUp_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Caustics_RectMask_ScaleUp_Frame) == 0x0003C0, "Member 'APersonaStatusDraw::Edit_Caustics_RectMask_ScaleUp_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_PersonaInfo_SlideIn_Delay) == 0x0003C4, "Member 'APersonaStatusDraw::Edit_PersonaInfo_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_PersonaInfo_SlideIn_Frame) == 0x0003C8, "Member 'APersonaStatusDraw::Edit_PersonaInfo_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Attribute_Effect_Frame) == 0x0003CC, "Member 'APersonaStatusDraw::Edit_Attribute_Effect_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillList_SlideIn_Delay) == 0x0003D0, "Member 'APersonaStatusDraw::Edit_SkillList_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillList_SlideIn_Frame) == 0x0003D4, "Member 'APersonaStatusDraw::Edit_SkillList_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_SlideIn_Delay) == 0x0003D8, "Member 'APersonaStatusDraw::Edit_Parameter_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_SlideIn_Frame) == 0x0003DC, "Member 'APersonaStatusDraw::Edit_Parameter_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Persona_SlideIn_Delay) == 0x0003E0, "Member 'APersonaStatusDraw::Edit_Persona_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Persona_SlideIn_Frame) == 0x0003E4, "Member 'APersonaStatusDraw::Edit_Persona_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, SetBackgroundAlphaEvent) == 0x0003E8, "Member 'APersonaStatusDraw::SetBackgroundAlphaEvent' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, SetCausticsSlideEvent) == 0x0003F8, "Member 'APersonaStatusDraw::SetCausticsSlideEvent' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, SetCausticsRectMaskScaleEvent) == 0x000408, "Member 'APersonaStatusDraw::SetCausticsRectMaskScaleEvent' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_Gage_Animation_Frame) == 0x00042C, "Member 'APersonaStatusDraw::Edit_Parameter_Gage_Animation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_Gage_Animation_Delay) == 0x000430, "Member 'APersonaStatusDraw::Edit_Parameter_Gage_Animation_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_UpGage_Animation_Frame) == 0x000434, "Member 'APersonaStatusDraw::Edit_Parameter_UpGage_Animation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Parameter_Incense_Value_FadeIn_Frame) == 0x000438, "Member 'APersonaStatusDraw::Edit_Parameter_Incense_Value_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_LevelUp_SlideIn_Frame) == 0x000484, "Member 'APersonaStatusDraw::Edit_LevelUp_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_LevelUp_Plate_FadeOut_Frame) == 0x000488, "Member 'APersonaStatusDraw::Edit_LevelUp_Plate_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_Start_Delay) == 0x0005A0, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_Start_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Wait) == 0x0005A4, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Wait' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Time) == 0x0005A8, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_Plate_Color_Fade_Time' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_Move_Frame) == 0x0005AC, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_Move_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_In_Frame) == 0x0005B0, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_In_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_New_Slide_In_Frame) == 0x0005B4, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_New_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillAdd_Next_Skill_New_Fade_In_Frame) == 0x0005B8, "Member 'APersonaStatusDraw::Edit_SkillAdd_Next_Skill_New_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_Level3_LoopAnimation_Frame) == 0x0005E8, "Member 'APersonaStatusDraw::Edit_Conception_Level3_LoopAnimation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_Level1_LoopAnimation_Frame) == 0x0005EC, "Member 'APersonaStatusDraw::Edit_Conception_Level1_LoopAnimation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_GetEffect_Scale_Frame) == 0x0005F0, "Member 'APersonaStatusDraw::Edit_Conception_GetEffect_Scale_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_GetEffect_FadeOut_Delay) == 0x0005F4, "Member 'APersonaStatusDraw::Edit_Conception_GetEffect_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_GetEffect_FadeOut_Frame) == 0x0005F8, "Member 'APersonaStatusDraw::Edit_Conception_GetEffect_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_Icon_Get_FadeOut_Delay) == 0x0005FC, "Member 'APersonaStatusDraw::Edit_Conception_Icon_Get_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Conception_Icon_Get_FadeOut_Frame) == 0x000600, "Member 'APersonaStatusDraw::Edit_Conception_Icon_Get_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_FadeIn_Frame) == 0x000614, "Member 'APersonaStatusDraw::Edit_SkillCard_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_SlideIn_Frame) == 0x000618, "Member 'APersonaStatusDraw::Edit_SkillCard_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_Used_FadeOut_Frame) == 0x00061C, "Member 'APersonaStatusDraw::Edit_SkillCard_Used_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_Used_SlideeOut_Frame) == 0x000620, "Member 'APersonaStatusDraw::Edit_SkillCard_Used_SlideeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_Used_Plate_AddEffect_Frame) == 0x000624, "Member 'APersonaStatusDraw::Edit_SkillCard_Used_Plate_AddEffect_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_Used_Plate_LoopAnimation_Frame) == 0x000628, "Member 'APersonaStatusDraw::Edit_SkillCard_Used_Plate_LoopAnimation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillCard_Used_GetIcon_SlideIn_Frame) == 0x00062C, "Member 'APersonaStatusDraw::Edit_SkillCard_Used_GetIcon_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Skill_Name_Color_LoopAnimation_Frame) == 0x000648, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Skill_Name_Color_LoopAnimation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_1Effect_Delay) == 0x00064C, "Member 'APersonaStatusDraw::Edit_ChangeSkill_1Effect_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_BluePlate_SlideIn_Frame) == 0x000650, "Member 'APersonaStatusDraw::Edit_ChangeSkill_BluePlate_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_BluePlate_Slide_Wait_Frame) == 0x000654, "Member 'APersonaStatusDraw::Edit_ChangeSkill_BluePlate_Slide_Wait_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_BluePlate_SlideOut_Frame) == 0x000658, "Member 'APersonaStatusDraw::Edit_ChangeSkill_BluePlate_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_SlideIn_Delay) == 0x00065C, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_SlideIn_Frame) == 0x000660, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_Slide_Wait_Frame) == 0x000664, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_Slide_Wait_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_SlideOut_Frame) == 0x000668, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_FadeIn_Delay) == 0x00066C, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_FadeIn_Frame) == 0x000670, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_Fade_Wait_Frame) == 0x000674, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_Fade_Wait_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_Change_Font_FadeOut_Frame) == 0x000678, "Member 'APersonaStatusDraw::Edit_ChangeSkill_Change_Font_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_ChangeIcon_FadeIn_Frame) == 0x00067C, "Member 'APersonaStatusDraw::Edit_ChangeSkill_ChangeIcon_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_ChangeSkill_ChangeIcon_SlideIn_Frame) == 0x000680, "Member 'APersonaStatusDraw::Edit_ChangeSkill_ChangeIcon_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_SlideIn_Frame) == 0x0006A8, "Member 'APersonaStatusDraw::Edit_SkillInfo_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_FadeIn_Frame) == 0x0006AC, "Member 'APersonaStatusDraw::Edit_SkillInfo_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_SlideOut_Frame) == 0x0006B0, "Member 'APersonaStatusDraw::Edit_SkillInfo_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_FadeOut_Frame) == 0x0006B4, "Member 'APersonaStatusDraw::Edit_SkillInfo_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_Cursor_FadeIn_Frame) == 0x0006B8, "Member 'APersonaStatusDraw::Edit_SkillInfo_Cursor_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_Cursor_FadeOut_Frame) == 0x0006BC, "Member 'APersonaStatusDraw::Edit_SkillInfo_Cursor_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_Cursor_Frame) == 0x0006C0, "Member 'APersonaStatusDraw::Edit_SkillInfo_Cursor_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillInfo_SubCursor_Frame) == 0x0006C4, "Member 'APersonaStatusDraw::Edit_SkillInfo_SubCursor_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, SkillSelectListEvent) == 0x0006C8, "Member 'APersonaStatusDraw::SkillSelectListEvent' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Icon_Move_Frame) == 0x00072C, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Icon_Move_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Icon_1_Move_Delay) == 0x000730, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Icon_1_Move_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Font_Delay) == 0x000734, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Font_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Font_Move_Frame) == 0x000738, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Font_Move_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Font_1_Move_Delay) == 0x00073C, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Font_1_Move_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Font_FadeIn_Frame) == 0x000740, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Font_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_AffinityCheck_Font_1_FadeIn_Delay) == 0x000744, "Member 'APersonaStatusDraw::Edit_AffinityCheck_Font_1_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SlideIn_Delay) == 0x000750, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SlideIn_Frame) == 0x000754, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_FadeIn_Delay) == 0x000758, "Member 'APersonaStatusDraw::Edit_SkillSelectList_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_FadeIn_Frame) == 0x00075C, "Member 'APersonaStatusDraw::Edit_SkillSelectList_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SlideOut_Delay) == 0x000760, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SlideOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SlideOut_Frame) == 0x000764, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_FadeOut_Delay) == 0x000768, "Member 'APersonaStatusDraw::Edit_SkillSelectList_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_FadeOut_Frame) == 0x00076C, "Member 'APersonaStatusDraw::Edit_SkillSelectList_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_RectScale_Delay) == 0x000770, "Member 'APersonaStatusDraw::Edit_SkillSelectList_RectScale_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_RectScale_Frame) == 0x000774, "Member 'APersonaStatusDraw::Edit_SkillSelectList_RectScale_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Cursor_FadeIn_Delay) == 0x000778, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Cursor_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Cursor_FadeIn_Frame) == 0x00077C, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Cursor_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Cursor_SlideIn_Delay) == 0x000780, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Cursor_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Cursor_SlideIn_Frame) == 0x000784, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Cursor_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SubCursor_SlideIn_Frame) == 0x000788, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SubCursor_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Cursor_Frame) == 0x00078C, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Cursor_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_SubCursor_Frame) == 0x000790, "Member 'APersonaStatusDraw::Edit_SkillSelectList_SubCursor_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Info_SlideIn_Frame) == 0x000794, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Info_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Info_FadeIn_Frame) == 0x000798, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Info_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Info_ChangeSlideIn_Frame) == 0x00079C, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Info_ChangeSlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_SkillSelectList_Info_ChangeFadeIn_Frame) == 0x0007A0, "Member 'APersonaStatusDraw::Edit_SkillSelectList_Info_ChangeFadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Selected_Succession_Skill_SlideIn_Delay) == 0x0007A4, "Member 'APersonaStatusDraw::Edit_Selected_Succession_Skill_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Selected_Succession_Skill_SlideIn_Frame) == 0x0007A8, "Member 'APersonaStatusDraw::Edit_Selected_Succession_Skill_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Selected_Succession_Skill_FadeIn_Delay) == 0x0007AC, "Member 'APersonaStatusDraw::Edit_Selected_Succession_Skill_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Selected_Succession_Skill_FadeIn_Frame) == 0x0007B0, "Member 'APersonaStatusDraw::Edit_Selected_Succession_Skill_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_FadeIn_Frame) == 0x0007E8, "Member 'APersonaStatusDraw::Edit_Commentary_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_SlideIn_Frame) == 0x0007EC, "Member 'APersonaStatusDraw::Edit_Commentary_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Persona_Slide_Delay) == 0x0007F0, "Member 'APersonaStatusDraw::Edit_Commentary_Persona_Slide_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Persona_Slide_Frame) == 0x0007F4, "Member 'APersonaStatusDraw::Edit_Commentary_Persona_Slide_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Info_FadeOut_Delay) == 0x0007F8, "Member 'APersonaStatusDraw::Edit_Commentary_Info_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Info_FadeOut_Frame) == 0x0007FC, "Member 'APersonaStatusDraw::Edit_Commentary_Info_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_SkillList_Move_Delay) == 0x000800, "Member 'APersonaStatusDraw::Edit_Commentary_SkillList_Move_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_SkillList_Move_Frame) == 0x000804, "Member 'APersonaStatusDraw::Edit_Commentary_SkillList_Move_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Paramter_Move_Delay) == 0x000808, "Member 'APersonaStatusDraw::Edit_Commentary_Paramter_Move_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Paramter_Move_Frame) == 0x00080C, "Member 'APersonaStatusDraw::Edit_Commentary_Paramter_Move_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Affinity_FadeOut_Delay) == 0x000810, "Member 'APersonaStatusDraw::Edit_Commentary_Affinity_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Affinity_FadeOut_Frame) == 0x000814, "Member 'APersonaStatusDraw::Edit_Commentary_Affinity_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Affinity_SlideOut_Delay) == 0x000818, "Member 'APersonaStatusDraw::Edit_Commentary_Affinity_SlideOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Affinity_SlideOut_Frame) == 0x00081C, "Member 'APersonaStatusDraw::Edit_Commentary_Affinity_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Rect_ScaleUp_Delay) == 0x000820, "Member 'APersonaStatusDraw::Edit_Commentary_Rect_ScaleUp_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Rect_ScaleUp_Frame) == 0x000824, "Member 'APersonaStatusDraw::Edit_Commentary_Rect_ScaleUp_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Commentary_Font_Change_Frame) == 0x000828, "Member 'APersonaStatusDraw::Edit_Commentary_Font_Change_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_SlideIn_Frame) == 0x000834, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_Plate_FadeOut_Frame) == 0x000838, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_Plate_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_Font_FadeOut_Frame) == 0x00083C, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_Font_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame1) == 0x000840, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame1' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame2) == 0x000844, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_Fix_Point_ColorChange_Frame2' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_CommuBonus_ColorChange_Frame) == 0x000848, "Member 'APersonaStatusDraw::Edit_Combine_CommuBonus_ColorChange_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_BonusExp_SlideIn_Delay) == 0x00084C, "Member 'APersonaStatusDraw::Edit_Combine_BonusExp_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_BonusExp_SlideIn_Frame) == 0x000850, "Member 'APersonaStatusDraw::Edit_Combine_BonusExp_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Combine_BonusExp_Fade_Frame) == 0x000854, "Member 'APersonaStatusDraw::Edit_Combine_BonusExp_Fade_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_LockIcon_InAnimation_Delay) == 0x000870, "Member 'APersonaStatusDraw::Edit_Registry_LockIcon_InAnimation_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_LockIcon_InAnimation_Frame) == 0x000874, "Member 'APersonaStatusDraw::Edit_Registry_LockIcon_InAnimation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_SlideOut_Delay) == 0x000878, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_SlideOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_SlideOut_Frame) == 0x00087C, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_SlideOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_FadeOut_Delay) == 0x000880, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_FadeOut_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_FadeOut_Frame) == 0x000884, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_FadeOut_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_SlideIn_Delay) == 0x000888, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_SlideIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_SlideIn_Frame) == 0x00088C, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_SlideIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_FadeIn_Delay) == 0x000890, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_FadeIn_Delay' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Heading_FadeIn_Frame) == 0x000894, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Heading_FadeIn_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, Edit_Registry_Switch_Mark_Rotate_Animation_Frame) == 0x000898, "Member 'APersonaStatusDraw::Edit_Registry_Switch_Mark_Rotate_Animation_Frame' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, LayoutTable) == 0x0008B0, "Member 'APersonaStatusDraw::LayoutTable' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, TextLayoutTable) == 0x0008B8, "Member 'APersonaStatusDraw::TextLayoutTable' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, TextPosRowLayoutTable) == 0x0008C0, "Member 'APersonaStatusDraw::TextPosRowLayoutTable' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, LayoutDataTable) == 0x0008C8, "Member 'APersonaStatusDraw::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, TextLayoutDataTable) == 0x0008D0, "Member 'APersonaStatusDraw::TextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(APersonaStatusDraw, TextPosRowLayoutDataTable) == 0x0008D8, "Member 'APersonaStatusDraw::TextPosRowLayoutDataTable' has a wrong offset!");

// Class xrd777.PersonaStatusSkillHelpSeq
// 0x0008 (0x0038 - 0x0030)
class UPersonaStatusSkillHelpSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSkillHelpSeq">();
	}
	static class UPersonaStatusSkillHelpSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSkillHelpSeq>();
	}
};
static_assert(alignof(UPersonaStatusSkillHelpSeq) == 0x000008, "Wrong alignment on UPersonaStatusSkillHelpSeq");
static_assert(sizeof(UPersonaStatusSkillHelpSeq) == 0x000038, "Wrong size on UPersonaStatusSkillHelpSeq");

// Class xrd777.PersonaStatusChangeSkillSeq
// 0x0028 (0x0058 - 0x0030)
class UPersonaStatusChangeSkillSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersonaStatusSkillHelpSeq*             SkillHelpSequence_;                                // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusChangeSkillSeq">();
	}
	static class UPersonaStatusChangeSkillSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusChangeSkillSeq>();
	}
};
static_assert(alignof(UPersonaStatusChangeSkillSeq) == 0x000008, "Wrong alignment on UPersonaStatusChangeSkillSeq");
static_assert(sizeof(UPersonaStatusChangeSkillSeq) == 0x000058, "Wrong size on UPersonaStatusChangeSkillSeq");
static_assert(offsetof(UPersonaStatusChangeSkillSeq, SkillHelpSequence_) == 0x000050, "Member 'UPersonaStatusChangeSkillSeq::SkillHelpSequence_' has a wrong offset!");

// Class xrd777.PersonaStatusLvUpSeq
// 0x01C8 (0x01F8 - 0x0030)
class UPersonaStatusLvUpSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x130];                                     // 0x0030(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersonaStatusSkillHelpSeq*             SkillHelpSequence_;                                // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonaStatusSelectSkillSeq*           SelectSkillSequence_;                              // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonaStatusChangeSkillSeq*           ChangeSkillSequence_;                              // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICombineCalc*                         CombineCalc_;                                      // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x78];                                     // 0x0180(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusLvUpSeq">();
	}
	static class UPersonaStatusLvUpSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusLvUpSeq>();
	}
};
static_assert(alignof(UPersonaStatusLvUpSeq) == 0x000008, "Wrong alignment on UPersonaStatusLvUpSeq");
static_assert(sizeof(UPersonaStatusLvUpSeq) == 0x0001F8, "Wrong size on UPersonaStatusLvUpSeq");
static_assert(offsetof(UPersonaStatusLvUpSeq, SkillHelpSequence_) == 0x000160, "Member 'UPersonaStatusLvUpSeq::SkillHelpSequence_' has a wrong offset!");
static_assert(offsetof(UPersonaStatusLvUpSeq, SelectSkillSequence_) == 0x000168, "Member 'UPersonaStatusLvUpSeq::SelectSkillSequence_' has a wrong offset!");
static_assert(offsetof(UPersonaStatusLvUpSeq, ChangeSkillSequence_) == 0x000170, "Member 'UPersonaStatusLvUpSeq::ChangeSkillSequence_' has a wrong offset!");
static_assert(offsetof(UPersonaStatusLvUpSeq, CombineCalc_) == 0x000178, "Member 'UPersonaStatusLvUpSeq::CombineCalc_' has a wrong offset!");

// Class xrd777.PersonaStatusSkillCardSeq
// 0x0020 (0x0050 - 0x0030)
class UPersonaStatusSkillCardSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersonaStatusSkillHelpSeq*             SkillHelpSequence_;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonaStatusSelectSkillSeq*           SelectSkillSequence_;                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSkillCardSeq">();
	}
	static class UPersonaStatusSkillCardSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSkillCardSeq>();
	}
};
static_assert(alignof(UPersonaStatusSkillCardSeq) == 0x000008, "Wrong alignment on UPersonaStatusSkillCardSeq");
static_assert(sizeof(UPersonaStatusSkillCardSeq) == 0x000050, "Wrong size on UPersonaStatusSkillCardSeq");
static_assert(offsetof(UPersonaStatusSkillCardSeq, SkillHelpSequence_) == 0x000040, "Member 'UPersonaStatusSkillCardSeq::SkillHelpSequence_' has a wrong offset!");
static_assert(offsetof(UPersonaStatusSkillCardSeq, SelectSkillSequence_) == 0x000048, "Member 'UPersonaStatusSkillCardSeq::SelectSkillSequence_' has a wrong offset!");

// Class xrd777.PersonaStatusRememberSkillSeq
// 0x0010 (0x0040 - 0x0030)
class UPersonaStatusRememberSkillSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusRememberSkillSeq">();
	}
	static class UPersonaStatusRememberSkillSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusRememberSkillSeq>();
	}
};
static_assert(alignof(UPersonaStatusRememberSkillSeq) == 0x000008, "Wrong alignment on UPersonaStatusRememberSkillSeq");
static_assert(sizeof(UPersonaStatusRememberSkillSeq) == 0x000040, "Wrong size on UPersonaStatusRememberSkillSeq");

// Class xrd777.PersonaStatusSkillInfoSeq
// 0x0010 (0x0040 - 0x0030)
class UPersonaStatusSkillInfoSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusSkillInfoSeq">();
	}
	static class UPersonaStatusSkillInfoSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusSkillInfoSeq>();
	}
};
static_assert(alignof(UPersonaStatusSkillInfoSeq) == 0x000008, "Wrong alignment on UPersonaStatusSkillInfoSeq");
static_assert(sizeof(UPersonaStatusSkillInfoSeq) == 0x000040, "Wrong size on UPersonaStatusSkillInfoSeq");

// Class xrd777.PersonaStatusParamUpSeq
// 0x0020 (0x0050 - 0x0030)
class UPersonaStatusParamUpSeq final : public UPersonaStatusSeq
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersonaStatusSkillHelpSeq*             SkillHelpSequence_;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaStatusParamUpSeq">();
	}
	static class UPersonaStatusParamUpSeq* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonaStatusParamUpSeq>();
	}
};
static_assert(alignof(UPersonaStatusParamUpSeq) == 0x000008, "Wrong alignment on UPersonaStatusParamUpSeq");
static_assert(sizeof(UPersonaStatusParamUpSeq) == 0x000050, "Wrong size on UPersonaStatusParamUpSeq");
static_assert(offsetof(UPersonaStatusParamUpSeq, SkillHelpSequence_) == 0x000048, "Member 'UPersonaStatusParamUpSeq::SkillHelpSequence_' has a wrong offset!");

// Class xrd777.UIPoetryActor
// 0x0048 (0x02C0 - 0x0278)
class AUIPoetryActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPoetryDataAsset*                     PoetryData_;                                       // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPoetryRippleDataAsset*               PoetryRippleData_;                                 // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           PAssetLoader;                                      // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUIPoetryDraw>              UIPoetryDrawClass;                                 // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIPoetryDraw*                          PUIPoetryDraw;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPoetryActor">();
	}
	static class AUIPoetryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPoetryActor>();
	}
};
static_assert(alignof(AUIPoetryActor) == 0x000008, "Wrong alignment on AUIPoetryActor");
static_assert(sizeof(AUIPoetryActor) == 0x0002C0, "Wrong size on AUIPoetryActor");
static_assert(offsetof(AUIPoetryActor, PoetryData_) == 0x000280, "Member 'AUIPoetryActor::PoetryData_' has a wrong offset!");
static_assert(offsetof(AUIPoetryActor, PoetryRippleData_) == 0x000288, "Member 'AUIPoetryActor::PoetryRippleData_' has a wrong offset!");
static_assert(offsetof(AUIPoetryActor, AnimManager) == 0x000290, "Member 'AUIPoetryActor::AnimManager' has a wrong offset!");
static_assert(offsetof(AUIPoetryActor, PAssetLoader) == 0x0002A8, "Member 'AUIPoetryActor::PAssetLoader' has a wrong offset!");
static_assert(offsetof(AUIPoetryActor, UIPoetryDrawClass) == 0x0002B0, "Member 'AUIPoetryActor::UIPoetryDrawClass' has a wrong offset!");
static_assert(offsetof(AUIPoetryActor, PUIPoetryDraw) == 0x0002B8, "Member 'AUIPoetryActor::PUIPoetryDraw' has a wrong offset!");

// Class xrd777.UIPoetryDraw
// 0x06A0 (0x0958 - 0x02B8)
class AUIPoetryDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ArcanaID;                                          // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ModeID;                                            // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIPoetryDataAsset*                     Data_;                                             // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIPoetryRippleDataAsset*               RippleData_;                                       // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_BlurTexPath[0x7];                                // 0x02D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_pEfTexPath[0x7];                                 // 0x0348(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_pNormalTexPath[0x7];                             // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               M_pBlurTex[0x7];                                   // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pEfTex[0x7];                                     // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pNormalTex[0x7];                                 // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_ArcanaTex;                                       // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_ArcanaTexBlur;                                   // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_ArcanaTexEf;                                     // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      PMaterial;                                         // 0x04F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      PRippleMat;                                        // 0x04F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Line1[0x3];                                   // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Line2[0x3];                                   // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Line3[0x3];                                   // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Line4[0x3];                                   // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Line5[0x3];                                   // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PMat_Ripples[0x8];                                 // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EfBaseAlpha;                                       // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineStartTime_1;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineStartTime_2;                                   // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineStartTime_3;                                   // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineStartTime_4;                                   // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineStartTime_5;                                   // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OkKeyPushStartTimeMax;                             // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OkKeyPushEndTimeMax;                               // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OkKeyFadeOutAnimTime;                              // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OkKeyFadeOutMovePos;                               // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveFloatAnimation                   CrvFadeWidthAnim;                                  // 0x05F0(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveFloatAnimation                   CrvFadeHeightAnim;                                 // 0x0620(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveFloatAnimation                   CrvFadeLineAnim;                                   // 0x0650(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveFloatAnimation                   CrvFadeLineEfAnim;                                 // 0x0680(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveFloatAnimation                   CrvFadeRippleAlpha;                                // 0x06B0(0x0030)(NativeAccessSpecifierPrivate)
	struct FCurveFloatAnimation                   CrvFadeRippleScale;                                // 0x06E0(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_710[0x8];                                      // 0x0710(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUICmmRankUPAnimManager*                AnimManager;                                       // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_720[0x188];                                    // 0x0720(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PoetyLayoutData;                                   // 0x08A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     PoetyLayoutDataTable;                              // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RippleLayoutData;                                  // 0x08B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     RippleLayoutDataTable;                             // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RippleTimeData;                                    // 0x08C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     RippleTimeDataTable;                               // 0x08D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextLayoutData;                                  // 0x08D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextLayoutDataTable;                             // 0x08E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextMaskLayoutData;                              // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     OkNextMaskLayoutDataTable;                         // 0x08F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F8[0x60];                                     // 0x08F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAdjustedLayoutRippleTiming(EUIRippleTimeLayout InLayoutId, float InDefaultTiming);
	void UIPoetryCreateMaterial();
	void UIPoetryDrawAllPoetry();
	void UIPoetryDrawLine1();
	void UIPoetryDrawLine2();
	void UIPoetryDrawMaxLine1();
	void UIPoetryDrawMaxLine2();
	void UIPoetryDrawMaxLine3();
	void UIPoetryDrawOkKey();
	void UIPoetryDrawRippleMax(float DeltaTime, float Ripple1, float Ripple2, float Ripple3, float Ripple4, float Ripple5, float Ripple6, float Ripple7, float Ripple8);
	void UIPoetryDrawRippleOpen(float DeltaTime, float Ripple1, float Ripple2, float Ripple3, float Ripple4, float Ripple5);
	void UIPoetryGetParam(float EfBaseAlpha_);
	bool UIPoetryIsRankMaxPoetry();
	void Update(const float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPoetryDraw">();
	}
	static class AUIPoetryDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPoetryDraw>();
	}
};
static_assert(alignof(AUIPoetryDraw) == 0x000008, "Wrong alignment on AUIPoetryDraw");
static_assert(sizeof(AUIPoetryDraw) == 0x000958, "Wrong size on AUIPoetryDraw");
static_assert(offsetof(AUIPoetryDraw, ArcanaID) == 0x0002C0, "Member 'AUIPoetryDraw::ArcanaID' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, ModeID) == 0x0002C4, "Member 'AUIPoetryDraw::ModeID' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, Data_) == 0x0002C8, "Member 'AUIPoetryDraw::Data_' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, RippleData_) == 0x0002D0, "Member 'AUIPoetryDraw::RippleData_' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_BlurTexPath) == 0x0002D8, "Member 'AUIPoetryDraw::M_BlurTexPath' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_pEfTexPath) == 0x000348, "Member 'AUIPoetryDraw::M_pEfTexPath' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_pNormalTexPath) == 0x0003B8, "Member 'AUIPoetryDraw::M_pNormalTexPath' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_pBlurTex) == 0x000430, "Member 'AUIPoetryDraw::M_pBlurTex' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_pEfTex) == 0x000468, "Member 'AUIPoetryDraw::M_pEfTex' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_pNormalTex) == 0x0004A0, "Member 'AUIPoetryDraw::M_pNormalTex' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_ArcanaTex) == 0x0004D8, "Member 'AUIPoetryDraw::M_ArcanaTex' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_ArcanaTexBlur) == 0x0004E0, "Member 'AUIPoetryDraw::M_ArcanaTexBlur' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, M_ArcanaTexEf) == 0x0004E8, "Member 'AUIPoetryDraw::M_ArcanaTexEf' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMaterial) == 0x0004F0, "Member 'AUIPoetryDraw::PMaterial' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PRippleMat) == 0x0004F8, "Member 'AUIPoetryDraw::PRippleMat' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Line1) == 0x000500, "Member 'AUIPoetryDraw::PMat_Line1' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Line2) == 0x000518, "Member 'AUIPoetryDraw::PMat_Line2' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Line3) == 0x000530, "Member 'AUIPoetryDraw::PMat_Line3' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Line4) == 0x000548, "Member 'AUIPoetryDraw::PMat_Line4' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Line5) == 0x000560, "Member 'AUIPoetryDraw::PMat_Line5' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PMat_Ripples) == 0x000578, "Member 'AUIPoetryDraw::PMat_Ripples' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, EfBaseAlpha) == 0x0005B8, "Member 'AUIPoetryDraw::EfBaseAlpha' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, LineStartTime_1) == 0x0005BC, "Member 'AUIPoetryDraw::LineStartTime_1' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, LineStartTime_2) == 0x0005C0, "Member 'AUIPoetryDraw::LineStartTime_2' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, LineStartTime_3) == 0x0005C4, "Member 'AUIPoetryDraw::LineStartTime_3' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, LineStartTime_4) == 0x0005C8, "Member 'AUIPoetryDraw::LineStartTime_4' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, LineStartTime_5) == 0x0005CC, "Member 'AUIPoetryDraw::LineStartTime_5' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkKeyPushStartTimeMax) == 0x0005D0, "Member 'AUIPoetryDraw::OkKeyPushStartTimeMax' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkKeyPushEndTimeMax) == 0x0005D4, "Member 'AUIPoetryDraw::OkKeyPushEndTimeMax' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkKeyFadeOutAnimTime) == 0x0005D8, "Member 'AUIPoetryDraw::OkKeyFadeOutAnimTime' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkKeyFadeOutMovePos) == 0x0005DC, "Member 'AUIPoetryDraw::OkKeyFadeOutMovePos' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeWidthAnim) == 0x0005F0, "Member 'AUIPoetryDraw::CrvFadeWidthAnim' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeHeightAnim) == 0x000620, "Member 'AUIPoetryDraw::CrvFadeHeightAnim' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeLineAnim) == 0x000650, "Member 'AUIPoetryDraw::CrvFadeLineAnim' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeLineEfAnim) == 0x000680, "Member 'AUIPoetryDraw::CrvFadeLineEfAnim' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeRippleAlpha) == 0x0006B0, "Member 'AUIPoetryDraw::CrvFadeRippleAlpha' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, CrvFadeRippleScale) == 0x0006E0, "Member 'AUIPoetryDraw::CrvFadeRippleScale' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, AnimManager) == 0x000718, "Member 'AUIPoetryDraw::AnimManager' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PoetyLayoutData) == 0x0008A8, "Member 'AUIPoetryDraw::PoetyLayoutData' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, PoetyLayoutDataTable) == 0x0008B0, "Member 'AUIPoetryDraw::PoetyLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, RippleLayoutData) == 0x0008B8, "Member 'AUIPoetryDraw::RippleLayoutData' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, RippleLayoutDataTable) == 0x0008C0, "Member 'AUIPoetryDraw::RippleLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, RippleTimeData) == 0x0008C8, "Member 'AUIPoetryDraw::RippleTimeData' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, RippleTimeDataTable) == 0x0008D0, "Member 'AUIPoetryDraw::RippleTimeDataTable' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkNextLayoutData) == 0x0008D8, "Member 'AUIPoetryDraw::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkNextLayoutDataTable) == 0x0008E0, "Member 'AUIPoetryDraw::OkNextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkNextMaskLayoutData) == 0x0008E8, "Member 'AUIPoetryDraw::OkNextMaskLayoutData' has a wrong offset!");
static_assert(offsetof(AUIPoetryDraw, OkNextMaskLayoutDataTable) == 0x0008F0, "Member 'AUIPoetryDraw::OkNextMaskLayoutDataTable' has a wrong offset!");

// Class xrd777.UIPreviewWorldUpdater
// 0x0038 (0x0258 - 0x0220)
class AUIPreviewWorldUpdater final : public AActor
{
public:
	TSoftObjectPtr<class UWorld>                  PreviewWorld;                                      // 0x0220(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPreviewWorldUpdater">();
	}
	static class AUIPreviewWorldUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPreviewWorldUpdater>();
	}
};
static_assert(alignof(AUIPreviewWorldUpdater) == 0x000008, "Wrong alignment on AUIPreviewWorldUpdater");
static_assert(sizeof(AUIPreviewWorldUpdater) == 0x000258, "Wrong size on AUIPreviewWorldUpdater");
static_assert(offsetof(AUIPreviewWorldUpdater, PreviewWorld) == 0x000220, "Member 'AUIPreviewWorldUpdater::PreviewWorld' has a wrong offset!");

// Class xrd777.UIRankUpDraw
// 0x0090 (0x0330 - 0x02A0)
class AUIRankUpDraw final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIPoetryActor*                         PoetryActor;                                       // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIArcanaCardCapture*                   UIACCaptureActor;                                  // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIGameOverPoem*                        UIGameOverPoem;                                    // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           PAssetLoader;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUICmmRankUpBG>             UIBGActorClass;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUpBG*                         PUIBGActor;                                        // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUICmmRankUpDraw>           UICmmRankUpDrawClass;                              // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUpDraw*                       PUICmmRankUpDraw;                                  // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUICmmRankUPAnimManager>    RankUpAnimManagerClass;                            // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUICmmRankUPAnimManager*                PRankUpAnimManager;                                // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      PMaterialBGGameover;                               // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             OkNextLayoutData;                                  // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OkNextMaskLayoutData;                              // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CmmRankUpLayoutData;                               // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRankUpDraw">();
	}
	static class AUIRankUpDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIRankUpDraw>();
	}
};
static_assert(alignof(AUIRankUpDraw) == 0x000008, "Wrong alignment on AUIRankUpDraw");
static_assert(sizeof(AUIRankUpDraw) == 0x000330, "Wrong size on AUIRankUpDraw");
static_assert(offsetof(AUIRankUpDraw, PoetryActor) == 0x0002B8, "Member 'AUIRankUpDraw::PoetryActor' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, UIACCaptureActor) == 0x0002C0, "Member 'AUIRankUpDraw::UIACCaptureActor' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, UIGameOverPoem) == 0x0002C8, "Member 'AUIRankUpDraw::UIGameOverPoem' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, PAssetLoader) == 0x0002D0, "Member 'AUIRankUpDraw::PAssetLoader' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, UIBGActorClass) == 0x0002D8, "Member 'AUIRankUpDraw::UIBGActorClass' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, PUIBGActor) == 0x0002E0, "Member 'AUIRankUpDraw::PUIBGActor' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, UICmmRankUpDrawClass) == 0x0002E8, "Member 'AUIRankUpDraw::UICmmRankUpDrawClass' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, PUICmmRankUpDraw) == 0x0002F0, "Member 'AUIRankUpDraw::PUICmmRankUpDraw' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, RankUpAnimManagerClass) == 0x0002F8, "Member 'AUIRankUpDraw::RankUpAnimManagerClass' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, PRankUpAnimManager) == 0x000300, "Member 'AUIRankUpDraw::PRankUpAnimManager' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, PMaterialBGGameover) == 0x000308, "Member 'AUIRankUpDraw::PMaterialBGGameover' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, OkNextLayoutData) == 0x000318, "Member 'AUIRankUpDraw::OkNextLayoutData' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, OkNextMaskLayoutData) == 0x000320, "Member 'AUIRankUpDraw::OkNextMaskLayoutData' has a wrong offset!");
static_assert(offsetof(AUIRankUpDraw, CmmRankUpLayoutData) == 0x000328, "Member 'AUIRankUpDraw::CmmRankUpLayoutData' has a wrong offset!");

// Class xrd777.UIRenderWidget
// 0x0030 (0x00F8 - 0x00C8)
class UUIRenderWidget final : public UAppActorComponent
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            RenderWidget;                                      // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawToRenderTarget();
	bool Initialize(class UTextureRenderTarget2D* InRenderTarget, class UUserWidget* InRenderWidget, const struct FVector2D& DrawSize, bool InUseGamma, bool InClearTarget, ETextureFilter InFilter);
	bool IsPause();
	void SetPause(bool InPause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenderWidget">();
	}
	static class UUIRenderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenderWidget>();
	}
};
static_assert(alignof(UUIRenderWidget) == 0x000008, "Wrong alignment on UUIRenderWidget");
static_assert(sizeof(UUIRenderWidget) == 0x0000F8, "Wrong size on UUIRenderWidget");
static_assert(offsetof(UUIRenderWidget, RenderTarget) == 0x0000C8, "Member 'UUIRenderWidget::RenderTarget' has a wrong offset!");
static_assert(offsetof(UUIRenderWidget, RenderWidget) == 0x0000D0, "Member 'UUIRenderWidget::RenderWidget' has a wrong offset!");

// Class xrd777.UIRequest
// 0x0DE8 (0x0E10 - 0x0028)
class UUIRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AScrActor*                              M_pScrActor;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBfAsset*                               M_pBfAsset;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              M_pBmdAsset;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 M_pRefWorld;                                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USprAsset*                              M_pCampSpr;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlgAsset*                              M_pCampPlg;                                        // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     M_pBGMat;                                          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pBGMatInst;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pRequestDT;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0xCC0];                                     // 0x00A8(0x0CC0)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     LayoutData;                                        // 0x0D68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextColLayoutData;                                 // 0x0D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextPosLayoutData;                                 // 0x0D78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextPosLayoutDataAstrea;                           // 0x0D80(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     TextColLayoutDataAstrea;                           // 0x0D88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUILayoutDataTable*                     DateLayoutData;                                    // 0x0D90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D98[0x78];                                     // 0x0D98(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRequest">();
	}
	static class UUIRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRequest>();
	}
};
static_assert(alignof(UUIRequest) == 0x000008, "Wrong alignment on UUIRequest");
static_assert(sizeof(UUIRequest) == 0x000E10, "Wrong size on UUIRequest");
static_assert(offsetof(UUIRequest, M_pLoader) == 0x000058, "Member 'UUIRequest::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pScrActor) == 0x000060, "Member 'UUIRequest::M_pScrActor' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pBfAsset) == 0x000068, "Member 'UUIRequest::M_pBfAsset' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pBmdAsset) == 0x000070, "Member 'UUIRequest::M_pBmdAsset' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pRefWorld) == 0x000078, "Member 'UUIRequest::M_pRefWorld' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pCampSpr) == 0x000080, "Member 'UUIRequest::M_pCampSpr' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pCampPlg) == 0x000088, "Member 'UUIRequest::M_pCampPlg' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pBGMat) == 0x000090, "Member 'UUIRequest::M_pBGMat' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pBGMatInst) == 0x000098, "Member 'UUIRequest::M_pBGMatInst' has a wrong offset!");
static_assert(offsetof(UUIRequest, M_pRequestDT) == 0x0000A0, "Member 'UUIRequest::M_pRequestDT' has a wrong offset!");
static_assert(offsetof(UUIRequest, LayoutData) == 0x000D68, "Member 'UUIRequest::LayoutData' has a wrong offset!");
static_assert(offsetof(UUIRequest, TextColLayoutData) == 0x000D70, "Member 'UUIRequest::TextColLayoutData' has a wrong offset!");
static_assert(offsetof(UUIRequest, TextPosLayoutData) == 0x000D78, "Member 'UUIRequest::TextPosLayoutData' has a wrong offset!");
static_assert(offsetof(UUIRequest, TextPosLayoutDataAstrea) == 0x000D80, "Member 'UUIRequest::TextPosLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(UUIRequest, TextColLayoutDataAstrea) == 0x000D88, "Member 'UUIRequest::TextColLayoutDataAstrea' has a wrong offset!");
static_assert(offsetof(UUIRequest, DateLayoutData) == 0x000D90, "Member 'UUIRequest::DateLayoutData' has a wrong offset!");

// Class xrd777.UIRestore
// 0x00F8 (0x0370 - 0x0278)
class AUIRestore final : public AAppActor
{
public:
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     SaveLoadLayoutDataTable;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadLayoutDataTable2;                          // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SaveLoadDateLayoutDataTable;                       // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData2;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamDateLayoutData;                              // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetLoader*                           Loader;                                            // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ASaveLoadDraw>              DrawActorSC;                                       // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASaveLoadDraw*                          DrawActor;                                         // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAddContent*                            AddContentCheck;                                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x78];                                     // 0x02F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedCloseAnim();
	void OnFinishedInAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRestore">();
	}
	static class AUIRestore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIRestore>();
	}
};
static_assert(alignof(AUIRestore) == 0x000008, "Wrong alignment on AUIRestore");
static_assert(sizeof(AUIRestore) == 0x000370, "Wrong size on AUIRestore");
static_assert(offsetof(AUIRestore, SaveLoadLayoutDataTable) == 0x0002A8, "Member 'AUIRestore::SaveLoadLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIRestore, SaveLoadLayoutDataTable2) == 0x0002B0, "Member 'AUIRestore::SaveLoadLayoutDataTable2' has a wrong offset!");
static_assert(offsetof(AUIRestore, SaveLoadDateLayoutDataTable) == 0x0002B8, "Member 'AUIRestore::SaveLoadDateLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIRestore, PParamLayoutData) == 0x0002C0, "Member 'AUIRestore::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUIRestore, PParamLayoutData2) == 0x0002C8, "Member 'AUIRestore::PParamLayoutData2' has a wrong offset!");
static_assert(offsetof(AUIRestore, PParamDateLayoutData) == 0x0002D0, "Member 'AUIRestore::PParamDateLayoutData' has a wrong offset!");
static_assert(offsetof(AUIRestore, Loader) == 0x0002D8, "Member 'AUIRestore::Loader' has a wrong offset!");
static_assert(offsetof(AUIRestore, DrawActorSC) == 0x0002E0, "Member 'AUIRestore::DrawActorSC' has a wrong offset!");
static_assert(offsetof(AUIRestore, DrawActor) == 0x0002E8, "Member 'AUIRestore::DrawActor' has a wrong offset!");
static_assert(offsetof(AUIRestore, AddContentCheck) == 0x0002F0, "Member 'AUIRestore::AddContentCheck' has a wrong offset!");

// Class xrd777.UISaveDialog
// 0x0008 (0x03D8 - 0x03D0)
class AUISaveDialog final : public AUISaveLoad
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveDialog">();
	}
	static class AUISaveDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISaveDialog>();
	}
};
static_assert(alignof(AUISaveDialog) == 0x000008, "Wrong alignment on AUISaveDialog");
static_assert(sizeof(AUISaveDialog) == 0x0003D8, "Wrong size on AUISaveDialog");

// Class xrd777.UISceneCapture
// 0x0000 (0x0238 - 0x0238)
class AUISceneCapture final : public ASceneCapture2D
{
public:
	void InAnimationStart();
	void LoopAnimationStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISceneCapture">();
	}
	static class AUISceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISceneCapture>();
	}
};
static_assert(alignof(AUISceneCapture) == 0x000008, "Wrong alignment on AUISceneCapture");
static_assert(sizeof(AUISceneCapture) == 0x000238, "Wrong size on AUISceneCapture");

// Class xrd777.UISoundManager
// 0x0000 (0x0030 - 0x0030)
class UUISoundManager final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISoundManager">();
	}
	static class UUISoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISoundManager>();
	}
};
static_assert(alignof(UUISoundManager) == 0x000008, "Wrong alignment on UUISoundManager");
static_assert(sizeof(UUISoundManager) == 0x000030, "Wrong size on UUISoundManager");

// Class xrd777.UISubsystem
// 0x0050 (0x0080 - 0x0030)
class UUISubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShopActor_;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  TempActor_;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAssist*                              Assist_;                                           // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFadePlayer*                            FadePlayer_;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyLevelLoadedShop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISubsystem">();
	}
	static class UUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISubsystem>();
	}
};
static_assert(alignof(UUISubsystem) == 0x000008, "Wrong alignment on UUISubsystem");
static_assert(sizeof(UUISubsystem) == 0x000080, "Wrong size on UUISubsystem");
static_assert(offsetof(UUISubsystem, ShopActor_) == 0x000048, "Member 'UUISubsystem::ShopActor_' has a wrong offset!");
static_assert(offsetof(UUISubsystem, TempActor_) == 0x000050, "Member 'UUISubsystem::TempActor_' has a wrong offset!");
static_assert(offsetof(UUISubsystem, Assist_) == 0x000058, "Member 'UUISubsystem::Assist_' has a wrong offset!");
static_assert(offsetof(UUISubsystem, FadePlayer_) == 0x000060, "Member 'UUISubsystem::FadePlayer_' has a wrong offset!");

// Class xrd777.UISystemMsgActor
// 0x0040 (0x02B8 - 0x0278)
class AUISystemMsgActor final : public AAppActor
{
public:
	uint8                                         Pad_278[0x40];                                     // 0x0278(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISystemMsgActor">();
	}
	static class AUISystemMsgActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISystemMsgActor>();
	}
};
static_assert(alignof(AUISystemMsgActor) == 0x000008, "Wrong alignment on AUISystemMsgActor");
static_assert(sizeof(AUISystemMsgActor) == 0x0002B8, "Wrong size on AUISystemMsgActor");

// Class xrd777.TestNishidaDataAsset
// 0x0010 (0x0040 - 0x0030)
class UTestNishidaDataAsset final : public UAppDataAsset
{
public:
	TArray<struct FTestNishidaDataTable>          Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestNishidaDataAsset">();
	}
	static class UTestNishidaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestNishidaDataAsset>();
	}
};
static_assert(alignof(UTestNishidaDataAsset) == 0x000008, "Wrong alignment on UTestNishidaDataAsset");
static_assert(sizeof(UTestNishidaDataAsset) == 0x000040, "Wrong size on UTestNishidaDataAsset");
static_assert(offsetof(UTestNishidaDataAsset, Data) == 0x000030, "Member 'UTestNishidaDataAsset::Data' has a wrong offset!");

// Class xrd777.UITest1Actor
// 0x07C0 (0x09E0 - 0x0220)
class alignas(0x10) AUITest1Actor final : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               M_pMenuTexture;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pIconSpr;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              M_pPostMaterial;                                   // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 M_pRenderTarget1;                                  // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x658];                                    // 0x0250(0x0658)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              M_loadMaterial;                                    // 0x08A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               M_loadMaterialInstanceDynamic;                     // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               M_loadTex;                                         // 0x08B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pCurveFloat;                                     // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveFloatAnimation                   M_tagCurveFloatAnimation;                          // 0x08C8(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_tagCurveVectorAnimation;                         // 0x08F8(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveLinearColorAnimation             M_tagCurveColorAnimation;                          // 0x0928(0x0030)(Protected, NativeAccessSpecifierProtected)
	class UTestNishidaDataAsset*                  M_pTestNishidaTableData;                           // 0x0958(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGetUIParameter                        M_tagGetUIP;                                       // 0x0960(0x0078)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITest1Actor">();
	}
	static class AUITest1Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITest1Actor>();
	}
};
static_assert(alignof(AUITest1Actor) == 0x000010, "Wrong alignment on AUITest1Actor");
static_assert(sizeof(AUITest1Actor) == 0x0009E0, "Wrong size on AUITest1Actor");
static_assert(offsetof(AUITest1Actor, M_pMenuTexture) == 0x000230, "Member 'AUITest1Actor::M_pMenuTexture' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_pIconSpr) == 0x000238, "Member 'AUITest1Actor::M_pIconSpr' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_pPostMaterial) == 0x000240, "Member 'AUITest1Actor::M_pPostMaterial' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_pRenderTarget1) == 0x000248, "Member 'AUITest1Actor::M_pRenderTarget1' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_loadMaterial) == 0x0008A8, "Member 'AUITest1Actor::M_loadMaterial' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_loadMaterialInstanceDynamic) == 0x0008B0, "Member 'AUITest1Actor::M_loadMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_loadTex) == 0x0008B8, "Member 'AUITest1Actor::M_loadTex' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_pCurveFloat) == 0x0008C0, "Member 'AUITest1Actor::M_pCurveFloat' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_tagCurveFloatAnimation) == 0x0008C8, "Member 'AUITest1Actor::M_tagCurveFloatAnimation' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_tagCurveVectorAnimation) == 0x0008F8, "Member 'AUITest1Actor::M_tagCurveVectorAnimation' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_tagCurveColorAnimation) == 0x000928, "Member 'AUITest1Actor::M_tagCurveColorAnimation' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_pTestNishidaTableData) == 0x000958, "Member 'AUITest1Actor::M_pTestNishidaTableData' has a wrong offset!");
static_assert(offsetof(AUITest1Actor, M_tagGetUIP) == 0x000960, "Member 'AUITest1Actor::M_tagGetUIP' has a wrong offset!");

// Class xrd777.UITestSpawnActor
// 0x0000 (0x0278 - 0x0278)
class AUITestSpawnActor final : public AAppActor
{
public:
	void AlwayFieldUpdate(float DeltaTime);
	void CommunityUpdate();
	void DungeonUpdate();
	void MoneyUpdate();
	void SpawnAlwayField();
	void SpawnBattle();
	void SpawnCommunity();
	void SpawnDungeon();
	void SpawnMoney();
	void SpawnTownMap();
	void SpawnVelvetRoom();
	void Update(float DeltaTime);
	void VelvetRoomUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITestSpawnActor">();
	}
	static class AUITestSpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITestSpawnActor>();
	}
};
static_assert(alignof(AUITestSpawnActor) == 0x000008, "Wrong alignment on AUITestSpawnActor");
static_assert(sizeof(AUITestSpawnActor) == 0x000278, "Wrong size on AUITestSpawnActor");

// Class xrd777.UITimeChange
// 0x0638 (0x08D8 - 0x02A0)
class AUITimeChange final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           M_pLoader;                                         // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USprAsset*                              M_pSpr;                                            // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAnim1;                                // 0x02C0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAnim2;                                // 0x02F0(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAnim3;                                // 0x0320(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAnim4;                                // 0x0350(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveRotateAnim5;                                // 0x0380(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveVectorAnimation                  M_curveOutAnim;                                    // 0x03B0(0x0030)(NativeAccessSpecifierPublic)
	struct FGetUIParameter                        M_uip;                                             // 0x03E0(0x0078)(NativeAccessSpecifierPublic)
	class UDataTable*                             M_pTimeChangeUIDT;                                 // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_460[0x458];                                    // 0x0460(0x0458)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pTimeChangeDataTable;                            // 0x08B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pTimeChangeLayoutDataTable;                      // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_pTimeChangeMaskDataTable;                        // 0x08C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     M_pTimeChangeMaskLayoutDataTable;                  // 0x08D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITimeChange">();
	}
	static class AUITimeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITimeChange>();
	}
};
static_assert(alignof(AUITimeChange) == 0x000008, "Wrong alignment on AUITimeChange");
static_assert(sizeof(AUITimeChange) == 0x0008D8, "Wrong size on AUITimeChange");
static_assert(offsetof(AUITimeChange, M_pLoader) == 0x0002B0, "Member 'AUITimeChange::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pSpr) == 0x0002B8, "Member 'AUITimeChange::M_pSpr' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveRotateAnim1) == 0x0002C0, "Member 'AUITimeChange::M_curveRotateAnim1' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveRotateAnim2) == 0x0002F0, "Member 'AUITimeChange::M_curveRotateAnim2' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveRotateAnim3) == 0x000320, "Member 'AUITimeChange::M_curveRotateAnim3' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveRotateAnim4) == 0x000350, "Member 'AUITimeChange::M_curveRotateAnim4' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveRotateAnim5) == 0x000380, "Member 'AUITimeChange::M_curveRotateAnim5' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_curveOutAnim) == 0x0003B0, "Member 'AUITimeChange::M_curveOutAnim' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_uip) == 0x0003E0, "Member 'AUITimeChange::M_uip' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pTimeChangeUIDT) == 0x000458, "Member 'AUITimeChange::M_pTimeChangeUIDT' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pTimeChangeDataTable) == 0x0008B8, "Member 'AUITimeChange::M_pTimeChangeDataTable' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pTimeChangeLayoutDataTable) == 0x0008C0, "Member 'AUITimeChange::M_pTimeChangeLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pTimeChangeMaskDataTable) == 0x0008C8, "Member 'AUITimeChange::M_pTimeChangeMaskDataTable' has a wrong offset!");
static_assert(offsetof(AUITimeChange, M_pTimeChangeMaskLayoutDataTable) == 0x0008D0, "Member 'AUITimeChange::M_pTimeChangeMaskLayoutDataTable' has a wrong offset!");

// Class xrd777.UITownMapActor
// 0x3E50 (0x40F0 - 0x02A0)
class AUITownMapActor final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x50];                                     // 0x02A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pTownMapDT;                                      // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pTownMapSpr;                                     // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pMiniMapIcon00Spr;                               // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              M_pMiniMapIcon01Spr;                               // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetLoader*                           M_pLoader;                                         // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGetUIParameter                        M_tagUip;                                          // 0x0318(0x0078)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_curveHeadInAnim;                                 // 0x0390(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_curveBlueDiamondAnim;                            // 0x03C0(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_curveWhiteDiamondAnim;                           // 0x03F0(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_curveInfoInAnim;                                 // 0x0420(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FCurveVectorAnimation                  M_curveIconAnim;                                   // 0x0450(0x0030)(Protected, NativeAccessSpecifierProtected)
	class UUILocationSelect*                      M_pLocationSelect;                                 // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFldAnimObj*                            M_pSymbolRefList[0x6];                             // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkinnedMeshComponent*                  M_pSymbolSkinnedRefList[0x6];                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pFieldCamera;                                    // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pMainCamera;                                     // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pStartCamera;                                    // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pInfoCamera[0x6];                                // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pNameLocator[0x6];                               // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBmdAsset*                              M_pTownMapDetailText;                              // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x3970];                                   // 0x0568(0x3970)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MarginRot;                                         // 0x3ED8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EE4[0x3C];                                    // 0x3EE4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     M_notSelectedLayoutDataTables[0x6];                // 0x3F20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     M_selectedLayoutDataTables[0x6];                   // 0x3F50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     M_infoLayoutDataTable;                             // 0x3F80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutDataTable*                     M_infoLayoutDataTable2;                            // 0x3F88(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_notSelectedParamLayouts[0x6];                    // 0x3F90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_selectedParamLayouts[0x6];                       // 0x3FC0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_infoParamLayout;                                 // 0x3FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_infoParamLayout2;                                // 0x3FF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4000[0xF0];                                    // 0x4000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownMapActor">();
	}
	static class AUITownMapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITownMapActor>();
	}
};
static_assert(alignof(AUITownMapActor) == 0x000008, "Wrong alignment on AUITownMapActor");
static_assert(sizeof(AUITownMapActor) == 0x0040F0, "Wrong size on AUITownMapActor");
static_assert(offsetof(AUITownMapActor, M_pTownMapDT) == 0x0002F0, "Member 'AUITownMapActor::M_pTownMapDT' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pTownMapSpr) == 0x0002F8, "Member 'AUITownMapActor::M_pTownMapSpr' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pMiniMapIcon00Spr) == 0x000300, "Member 'AUITownMapActor::M_pMiniMapIcon00Spr' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pMiniMapIcon01Spr) == 0x000308, "Member 'AUITownMapActor::M_pMiniMapIcon01Spr' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pLoader) == 0x000310, "Member 'AUITownMapActor::M_pLoader' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_tagUip) == 0x000318, "Member 'AUITownMapActor::M_tagUip' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_curveHeadInAnim) == 0x000390, "Member 'AUITownMapActor::M_curveHeadInAnim' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_curveBlueDiamondAnim) == 0x0003C0, "Member 'AUITownMapActor::M_curveBlueDiamondAnim' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_curveWhiteDiamondAnim) == 0x0003F0, "Member 'AUITownMapActor::M_curveWhiteDiamondAnim' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_curveInfoInAnim) == 0x000420, "Member 'AUITownMapActor::M_curveInfoInAnim' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_curveIconAnim) == 0x000450, "Member 'AUITownMapActor::M_curveIconAnim' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pLocationSelect) == 0x000480, "Member 'AUITownMapActor::M_pLocationSelect' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pSymbolRefList) == 0x000488, "Member 'AUITownMapActor::M_pSymbolRefList' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pSymbolSkinnedRefList) == 0x0004B8, "Member 'AUITownMapActor::M_pSymbolSkinnedRefList' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pFieldCamera) == 0x0004E8, "Member 'AUITownMapActor::M_pFieldCamera' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pMainCamera) == 0x0004F0, "Member 'AUITownMapActor::M_pMainCamera' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pStartCamera) == 0x0004F8, "Member 'AUITownMapActor::M_pStartCamera' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pInfoCamera) == 0x000500, "Member 'AUITownMapActor::M_pInfoCamera' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pNameLocator) == 0x000530, "Member 'AUITownMapActor::M_pNameLocator' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_pTownMapDetailText) == 0x000560, "Member 'AUITownMapActor::M_pTownMapDetailText' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, MarginRot) == 0x003ED8, "Member 'AUITownMapActor::MarginRot' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_notSelectedLayoutDataTables) == 0x003F20, "Member 'AUITownMapActor::M_notSelectedLayoutDataTables' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_selectedLayoutDataTables) == 0x003F50, "Member 'AUITownMapActor::M_selectedLayoutDataTables' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_infoLayoutDataTable) == 0x003F80, "Member 'AUITownMapActor::M_infoLayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_infoLayoutDataTable2) == 0x003F88, "Member 'AUITownMapActor::M_infoLayoutDataTable2' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_notSelectedParamLayouts) == 0x003F90, "Member 'AUITownMapActor::M_notSelectedParamLayouts' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_selectedParamLayouts) == 0x003FC0, "Member 'AUITownMapActor::M_selectedParamLayouts' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_infoParamLayout) == 0x003FF0, "Member 'AUITownMapActor::M_infoParamLayout' has a wrong offset!");
static_assert(offsetof(AUITownMapActor, M_infoParamLayout2) == 0x003FF8, "Member 'AUITownMapActor::M_infoParamLayout2' has a wrong offset!");

// Class xrd777.UITownMapCameraActor
// 0x0070 (0x02E8 - 0x0278)
class AUITownMapCameraActor : public AAppActor
{
public:
	class AActor*                                 MainCamera_;                                       // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SchoolCamera_;                                     // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DormitoryCamera_;                                  // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PortislandCamera_;                                 // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PolonianmallCamera_;                               // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 IwatodayCamera_;                                   // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NaganakiCamera_;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SchoolActor_;                                      // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DormitoryActor_;                                   // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PortislandActor_;                                  // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PolonianmallActor_;                                // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 IwatodayActor_;                                    // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NaganakiActor_;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartCamera_;                                      // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(class AActor* MainCamera, class AActor* SchoolCamera, class AActor* DormitoryCamera, class AActor* PortislandCamera, class AActor* PolonianmallCamera, class AActor* IwatodayCamera, class AActor* NaganakiCamera, class AActor* SchoolActor, class AActor* DormitoryActor, class AActor* PortislandActor, class AActor* PolonianmallActor, class AActor* IwatodayActor, class AActor* NaganakiActor, class AActor* StartCamera);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownMapCameraActor">();
	}
	static class AUITownMapCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITownMapCameraActor>();
	}
};
static_assert(alignof(AUITownMapCameraActor) == 0x000008, "Wrong alignment on AUITownMapCameraActor");
static_assert(sizeof(AUITownMapCameraActor) == 0x0002E8, "Wrong size on AUITownMapCameraActor");
static_assert(offsetof(AUITownMapCameraActor, MainCamera_) == 0x000278, "Member 'AUITownMapCameraActor::MainCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, SchoolCamera_) == 0x000280, "Member 'AUITownMapCameraActor::SchoolCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, DormitoryCamera_) == 0x000288, "Member 'AUITownMapCameraActor::DormitoryCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, PortislandCamera_) == 0x000290, "Member 'AUITownMapCameraActor::PortislandCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, PolonianmallCamera_) == 0x000298, "Member 'AUITownMapCameraActor::PolonianmallCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, IwatodayCamera_) == 0x0002A0, "Member 'AUITownMapCameraActor::IwatodayCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, NaganakiCamera_) == 0x0002A8, "Member 'AUITownMapCameraActor::NaganakiCamera_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, SchoolActor_) == 0x0002B0, "Member 'AUITownMapCameraActor::SchoolActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, DormitoryActor_) == 0x0002B8, "Member 'AUITownMapCameraActor::DormitoryActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, PortislandActor_) == 0x0002C0, "Member 'AUITownMapCameraActor::PortislandActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, PolonianmallActor_) == 0x0002C8, "Member 'AUITownMapCameraActor::PolonianmallActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, IwatodayActor_) == 0x0002D0, "Member 'AUITownMapCameraActor::IwatodayActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, NaganakiActor_) == 0x0002D8, "Member 'AUITownMapCameraActor::NaganakiActor_' has a wrong offset!");
static_assert(offsetof(AUITownMapCameraActor, StartCamera_) == 0x0002E0, "Member 'AUITownMapCameraActor::StartCamera_' has a wrong offset!");

// Class xrd777.UITutorial
// 0x01A8 (0x0420 - 0x0278)
class AUITutorial final : public AAppActor
{
public:
	uint8                                         Pad_278[0xD8];                                     // 0x0278(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader;                                            // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BattleDataTableAsset;                              // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BattleNameTableAsset;                              // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DungeonDataTableAsset;                             // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DungeonNameTableAsset;                             // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DailyDataTableAsset;                               // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DailyNameTableAsset;                               // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CombineDataTableAsset;                             // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CombineNameTableAsset;                             // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SystemDataTableAsset;                              // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SystemNameTableAsset;                              // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACmpMainActor*                          PMainActor;                                        // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUITutorialDraw*                        PTutorialDraw;                                     // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AUITutorialDraw>            PTutorialDrawClass;                                // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x60];                                     // 0x03C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorial">();
	}
	static class AUITutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITutorial>();
	}
};
static_assert(alignof(AUITutorial) == 0x000008, "Wrong alignment on AUITutorial");
static_assert(sizeof(AUITutorial) == 0x000420, "Wrong size on AUITutorial");
static_assert(offsetof(AUITutorial, Loader) == 0x000350, "Member 'AUITutorial::Loader' has a wrong offset!");
static_assert(offsetof(AUITutorial, BattleDataTableAsset) == 0x000358, "Member 'AUITutorial::BattleDataTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, BattleNameTableAsset) == 0x000360, "Member 'AUITutorial::BattleNameTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, DungeonDataTableAsset) == 0x000368, "Member 'AUITutorial::DungeonDataTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, DungeonNameTableAsset) == 0x000370, "Member 'AUITutorial::DungeonNameTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, DailyDataTableAsset) == 0x000378, "Member 'AUITutorial::DailyDataTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, DailyNameTableAsset) == 0x000380, "Member 'AUITutorial::DailyNameTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, CombineDataTableAsset) == 0x000388, "Member 'AUITutorial::CombineDataTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, CombineNameTableAsset) == 0x000390, "Member 'AUITutorial::CombineNameTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, SystemDataTableAsset) == 0x000398, "Member 'AUITutorial::SystemDataTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, SystemNameTableAsset) == 0x0003A0, "Member 'AUITutorial::SystemNameTableAsset' has a wrong offset!");
static_assert(offsetof(AUITutorial, PMainActor) == 0x0003A8, "Member 'AUITutorial::PMainActor' has a wrong offset!");
static_assert(offsetof(AUITutorial, PTutorialDraw) == 0x0003B0, "Member 'AUITutorial::PTutorialDraw' has a wrong offset!");
static_assert(offsetof(AUITutorial, PTutorialDrawClass) == 0x0003B8, "Member 'AUITutorial::PTutorialDrawClass' has a wrong offset!");

// Class xrd777.UITutorialDraw
// 0x02F0 (0x05A8 - 0x02B8)
class AUITutorialDraw : public AUIDrawBaseActor
{
public:
	class UMaterialInstanceDynamic*               PBackgroundMaterialDynamicInstance;                // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBmdAsset*                              PBmdAsset;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Title_Logo_Slide_In_Delay;                    // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Title_Logo_Slide_In_Frame;                    // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Navy_Blue_Plate_Slide_In_Delay;               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Navy_Blue_Plate_Slide_In_Frame;               // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Slide_In_Delay;                     // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Slide_In_Frame;                     // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_White_Plate_Slide_In_Delay;                   // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_White_Plate_Slide_In_Frame;                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Tab_Slide_In_Delay;                           // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Tab_Slide_In_Frame;                           // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Tab_Fade_In_Delay;                            // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Tab_Fade_In_Frame;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Slide_In_Delay;                          // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Slide_In_Frame;                          // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Fade_In_Delay;                           // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Fade_In_Frame;                           // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Sub_Cursor_Slide_In_Delay;               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Sub_Cursor_Slide_In_Frame;               // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x4];                                      // 0x0310(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_List_Change_Fade_Out_Delay;                   // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Change_Fade_Out_Frame;                   // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Change_Fade_In_Delay;                    // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Change_Fade_In_Frame;                    // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Change_Slide_In_Delay;                   // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Change_Slide_In_Frame;                   // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Change_Slide_In_Delay;              // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Change_Slide_In_Frame;              // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Change_Cross_Fade_Delay;            // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gradation_Change_Cross_Fade_Frame;            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x64];                                     // 0x033C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Edit_Tab_Cursor_Frame;                             // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Cursor_Frame;                            // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_List_Sub_Cursor_Frame;                        // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Edit_Gray_Out_Frame;                               // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x1D8];                                    // 0x03B0(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	class ACmpMainActor*                          PMainActor;                                        // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x18];                                     // 0x0590(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawBackground(float X, float Y, float Angle);
	void DrawCategorys(float X, float Y, float Angle);
	void DrawCloseWipe();
	void DrawHelp(float X, float Y, float Angle);
	void DrawList(float X, float Y, float Angle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialDraw">();
	}
	static class AUITutorialDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITutorialDraw>();
	}
};
static_assert(alignof(AUITutorialDraw) == 0x000008, "Wrong alignment on AUITutorialDraw");
static_assert(sizeof(AUITutorialDraw) == 0x0005A8, "Wrong size on AUITutorialDraw");
static_assert(offsetof(AUITutorialDraw, PBackgroundMaterialDynamicInstance) == 0x0002B8, "Member 'AUITutorialDraw::PBackgroundMaterialDynamicInstance' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, PBmdAsset) == 0x0002C0, "Member 'AUITutorialDraw::PBmdAsset' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Title_Logo_Slide_In_Delay) == 0x0002C8, "Member 'AUITutorialDraw::Edit_Title_Logo_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Title_Logo_Slide_In_Frame) == 0x0002CC, "Member 'AUITutorialDraw::Edit_Title_Logo_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Navy_Blue_Plate_Slide_In_Delay) == 0x0002D0, "Member 'AUITutorialDraw::Edit_Navy_Blue_Plate_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Navy_Blue_Plate_Slide_In_Frame) == 0x0002D4, "Member 'AUITutorialDraw::Edit_Navy_Blue_Plate_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Slide_In_Delay) == 0x0002D8, "Member 'AUITutorialDraw::Edit_Gradation_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Slide_In_Frame) == 0x0002DC, "Member 'AUITutorialDraw::Edit_Gradation_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_White_Plate_Slide_In_Delay) == 0x0002E0, "Member 'AUITutorialDraw::Edit_White_Plate_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_White_Plate_Slide_In_Frame) == 0x0002E4, "Member 'AUITutorialDraw::Edit_White_Plate_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Tab_Slide_In_Delay) == 0x0002E8, "Member 'AUITutorialDraw::Edit_Tab_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Tab_Slide_In_Frame) == 0x0002EC, "Member 'AUITutorialDraw::Edit_Tab_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Tab_Fade_In_Delay) == 0x0002F0, "Member 'AUITutorialDraw::Edit_Tab_Fade_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Tab_Fade_In_Frame) == 0x0002F4, "Member 'AUITutorialDraw::Edit_Tab_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Slide_In_Delay) == 0x0002F8, "Member 'AUITutorialDraw::Edit_List_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Slide_In_Frame) == 0x0002FC, "Member 'AUITutorialDraw::Edit_List_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Fade_In_Delay) == 0x000300, "Member 'AUITutorialDraw::Edit_List_Fade_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Fade_In_Frame) == 0x000304, "Member 'AUITutorialDraw::Edit_List_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Sub_Cursor_Slide_In_Delay) == 0x000308, "Member 'AUITutorialDraw::Edit_List_Sub_Cursor_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Sub_Cursor_Slide_In_Frame) == 0x00030C, "Member 'AUITutorialDraw::Edit_List_Sub_Cursor_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Fade_Out_Delay) == 0x000314, "Member 'AUITutorialDraw::Edit_List_Change_Fade_Out_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Fade_Out_Frame) == 0x000318, "Member 'AUITutorialDraw::Edit_List_Change_Fade_Out_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Fade_In_Delay) == 0x00031C, "Member 'AUITutorialDraw::Edit_List_Change_Fade_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Fade_In_Frame) == 0x000320, "Member 'AUITutorialDraw::Edit_List_Change_Fade_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Slide_In_Delay) == 0x000324, "Member 'AUITutorialDraw::Edit_List_Change_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Change_Slide_In_Frame) == 0x000328, "Member 'AUITutorialDraw::Edit_List_Change_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Change_Slide_In_Delay) == 0x00032C, "Member 'AUITutorialDraw::Edit_Gradation_Change_Slide_In_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Change_Slide_In_Frame) == 0x000330, "Member 'AUITutorialDraw::Edit_Gradation_Change_Slide_In_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Change_Cross_Fade_Delay) == 0x000334, "Member 'AUITutorialDraw::Edit_Gradation_Change_Cross_Fade_Delay' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gradation_Change_Cross_Fade_Frame) == 0x000338, "Member 'AUITutorialDraw::Edit_Gradation_Change_Cross_Fade_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Tab_Cursor_Frame) == 0x0003A0, "Member 'AUITutorialDraw::Edit_Tab_Cursor_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Cursor_Frame) == 0x0003A4, "Member 'AUITutorialDraw::Edit_List_Cursor_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_List_Sub_Cursor_Frame) == 0x0003A8, "Member 'AUITutorialDraw::Edit_List_Sub_Cursor_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, Edit_Gray_Out_Frame) == 0x0003AC, "Member 'AUITutorialDraw::Edit_Gray_Out_Frame' has a wrong offset!");
static_assert(offsetof(AUITutorialDraw, PMainActor) == 0x000588, "Member 'AUITutorialDraw::PMainActor' has a wrong offset!");

// Class xrd777.UIVelvetRoom
// 0x0258 (0x04F8 - 0x02A0)
class AUIVelvetRoom final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICombine*                             M_pUICombine;                                      // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUICompleteBook*                        M_pUICompleteBook;                                 // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUICompleteBookRegist*                  M_pUICompleteBookRegist;                           // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIVelvetRoomOwner*                     M_pOwner;                                          // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x230];                                    // 0x02C8(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StreamLevelCountDecrement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoom">();
	}
	static class AUIVelvetRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVelvetRoom>();
	}
};
static_assert(alignof(AUIVelvetRoom) == 0x000008, "Wrong alignment on AUIVelvetRoom");
static_assert(sizeof(AUIVelvetRoom) == 0x0004F8, "Wrong size on AUIVelvetRoom");
static_assert(offsetof(AUIVelvetRoom, M_pUICombine) == 0x0002A8, "Member 'AUIVelvetRoom::M_pUICombine' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoom, M_pUICompleteBook) == 0x0002B0, "Member 'AUIVelvetRoom::M_pUICompleteBook' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoom, M_pUICompleteBookRegist) == 0x0002B8, "Member 'AUIVelvetRoom::M_pUICompleteBookRegist' has a wrong offset!");
static_assert(offsetof(AUIVelvetRoom, M_pOwner) == 0x0002C0, "Member 'AUIVelvetRoom::M_pOwner' has a wrong offset!");

// Class xrd777.VelvetRoomMcaDataAsset
// 0x0010 (0x0040 - 0x0030)
class UVelvetRoomMcaDataAsset final : public UAppDataAsset
{
public:
	TArray<class UMcaAsset*>                      Asset;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelvetRoomMcaDataAsset">();
	}
	static class UVelvetRoomMcaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelvetRoomMcaDataAsset>();
	}
};
static_assert(alignof(UVelvetRoomMcaDataAsset) == 0x000008, "Wrong alignment on UVelvetRoomMcaDataAsset");
static_assert(sizeof(UVelvetRoomMcaDataAsset) == 0x000040, "Wrong size on UVelvetRoomMcaDataAsset");
static_assert(offsetof(UVelvetRoomMcaDataAsset, Asset) == 0x000030, "Member 'UVelvetRoomMcaDataAsset::Asset' has a wrong offset!");

// Class xrd777.UIVelvetRoomMca
// 0x0020 (0x0048 - 0x0028)
class UUIVelvetRoomMca final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 PWorld;                                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           PCamera;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomMca">();
	}
	static class UUIVelvetRoomMca* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVelvetRoomMca>();
	}
};
static_assert(alignof(UUIVelvetRoomMca) == 0x000008, "Wrong alignment on UUIVelvetRoomMca");
static_assert(sizeof(UUIVelvetRoomMca) == 0x000048, "Wrong size on UUIVelvetRoomMca");
static_assert(offsetof(UUIVelvetRoomMca, PWorld) == 0x000038, "Member 'UUIVelvetRoomMca::PWorld' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomMca, PCamera) == 0x000040, "Member 'UUIVelvetRoomMca::PCamera' has a wrong offset!");

// Class xrd777.UIVelvetRoomOwner
// 0x00F0 (0x0118 - 0x0028)
class UUIVelvetRoomOwner final : public UObject
{
public:
	class UAssetLoader*                           M_pLoader;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AScrActor*                              M_pScrActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBfAsset*                               M_pBfAsset;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBmdAsset*                              M_pBmdAsset;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APersonaStatus*                         M_pPersonaStatusActor;                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUICombineCalc*                         M_pCombineCalc;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               M_pCombineStateTex;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUIVelvetRoomDraw*                      M_pVelvetRoomDraw;                                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUIVelvetRoomDraw>          M_pVelvetRoomDrawClass;                            // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutDataTable*                     CommonLayoutDataTable;                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CompendiumLayoutDataTable;                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SearchLayoutDataTable;                             // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SpreadLayoutDataTable;                             // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SpecialLayoutDataTable;                            // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     SummonLayoutDataTable;                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     CommonTextLayoutDataTable;                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     HelpLayoutDataTable;                               // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     AstreaLayoutDataTable;                             // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCommon;                            // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCompendium;                        // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSearch;                            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSpread;                            // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSpecial;                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataSummon;                            // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataCommonText;                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataHelp;                              // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutDataAstrea;                            // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinishedScr(int32 ExitType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomOwner">();
	}
	static class UUIVelvetRoomOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVelvetRoomOwner>();
	}
};
static_assert(alignof(UUIVelvetRoomOwner) == 0x000008, "Wrong alignment on UUIVelvetRoomOwner");
static_assert(sizeof(UUIVelvetRoomOwner) == 0x000118, "Wrong size on UUIVelvetRoomOwner");
static_assert(offsetof(UUIVelvetRoomOwner, M_pLoader) == 0x000028, "Member 'UUIVelvetRoomOwner::M_pLoader' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pScrActor) == 0x000030, "Member 'UUIVelvetRoomOwner::M_pScrActor' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pBfAsset) == 0x000038, "Member 'UUIVelvetRoomOwner::M_pBfAsset' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pBmdAsset) == 0x000040, "Member 'UUIVelvetRoomOwner::M_pBmdAsset' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pPersonaStatusActor) == 0x000048, "Member 'UUIVelvetRoomOwner::M_pPersonaStatusActor' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pCombineCalc) == 0x000050, "Member 'UUIVelvetRoomOwner::M_pCombineCalc' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pCombineStateTex) == 0x000058, "Member 'UUIVelvetRoomOwner::M_pCombineStateTex' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pVelvetRoomDraw) == 0x000060, "Member 'UUIVelvetRoomOwner::M_pVelvetRoomDraw' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, M_pVelvetRoomDrawClass) == 0x000078, "Member 'UUIVelvetRoomOwner::M_pVelvetRoomDrawClass' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, CommonLayoutDataTable) == 0x000088, "Member 'UUIVelvetRoomOwner::CommonLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, CompendiumLayoutDataTable) == 0x000090, "Member 'UUIVelvetRoomOwner::CompendiumLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, SearchLayoutDataTable) == 0x000098, "Member 'UUIVelvetRoomOwner::SearchLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, SpreadLayoutDataTable) == 0x0000A0, "Member 'UUIVelvetRoomOwner::SpreadLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, SpecialLayoutDataTable) == 0x0000A8, "Member 'UUIVelvetRoomOwner::SpecialLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, SummonLayoutDataTable) == 0x0000B0, "Member 'UUIVelvetRoomOwner::SummonLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, CommonTextLayoutDataTable) == 0x0000B8, "Member 'UUIVelvetRoomOwner::CommonTextLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, HelpLayoutDataTable) == 0x0000C0, "Member 'UUIVelvetRoomOwner::HelpLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, AstreaLayoutDataTable) == 0x0000C8, "Member 'UUIVelvetRoomOwner::AstreaLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataCommon) == 0x0000D0, "Member 'UUIVelvetRoomOwner::PParamLayoutDataCommon' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataCompendium) == 0x0000D8, "Member 'UUIVelvetRoomOwner::PParamLayoutDataCompendium' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataSearch) == 0x0000E0, "Member 'UUIVelvetRoomOwner::PParamLayoutDataSearch' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataSpread) == 0x0000E8, "Member 'UUIVelvetRoomOwner::PParamLayoutDataSpread' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataSpecial) == 0x0000F0, "Member 'UUIVelvetRoomOwner::PParamLayoutDataSpecial' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataSummon) == 0x0000F8, "Member 'UUIVelvetRoomOwner::PParamLayoutDataSummon' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataCommonText) == 0x000100, "Member 'UUIVelvetRoomOwner::PParamLayoutDataCommonText' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataHelp) == 0x000108, "Member 'UUIVelvetRoomOwner::PParamLayoutDataHelp' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomOwner, PParamLayoutDataAstrea) == 0x000110, "Member 'UUIVelvetRoomOwner::PParamLayoutDataAstrea' has a wrong offset!");

// Class xrd777.UIVelvetRoomRequest
// 0x0000 (0x02A0 - 0x02A0)
class AUIVelvetRoomRequest final : public AUIBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomRequest">();
	}
	static class AUIVelvetRoomRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVelvetRoomRequest>();
	}
};
static_assert(alignof(AUIVelvetRoomRequest) == 0x000008, "Wrong alignment on AUIVelvetRoomRequest");
static_assert(sizeof(AUIVelvetRoomRequest) == 0x0002A0, "Wrong size on AUIVelvetRoomRequest");

// Class xrd777.UIVelvetRoomRequestDraw
// 0x0050 (0x0308 - 0x02B8)
class AUIVelvetRoomRequestDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x50];                                     // 0x02B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseQuestDetails();
	void CloseQuestMenu();
	void DrawQuestDetails(float X, float Y);
	void DrawQuestHelp(float X, float Y);
	void DrawQuestItem(float X, float Y, int32 Index_0);
	void DrawQuestReward(float X, float Y, int32 Index_0);
	int32 GetCursorCurrentIndex();
	int32 GetCursorListTopIndex();
	int32 GetQuestRank();
	void OpenQuestDetails();
	void OpenQuestMenu();

	int32 GetQuestID(int32 Index_0) const;
	int32 GetQuestListMax() const;
	bool GetQuestNewFlag(int32 Index_0) const;
	EQuestListItemState GetQuestState(int32 Index_0) const;
	int32 GetSortType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomRequestDraw">();
	}
	static class AUIVelvetRoomRequestDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVelvetRoomRequestDraw>();
	}
};
static_assert(alignof(AUIVelvetRoomRequestDraw) == 0x000008, "Wrong alignment on AUIVelvetRoomRequestDraw");
static_assert(sizeof(AUIVelvetRoomRequestDraw) == 0x000308, "Wrong size on AUIVelvetRoomRequestDraw");

// Class xrd777.VelvetRoomCardTextureDataAsset
// 0x0010 (0x0040 - 0x0030)
class UVelvetRoomCardTextureDataAsset final : public UAppDataAsset
{
public:
	TArray<class UTexture*>                       Textures;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelvetRoomCardTextureDataAsset">();
	}
	static class UVelvetRoomCardTextureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelvetRoomCardTextureDataAsset>();
	}
};
static_assert(alignof(UVelvetRoomCardTextureDataAsset) == 0x000008, "Wrong alignment on UVelvetRoomCardTextureDataAsset");
static_assert(sizeof(UVelvetRoomCardTextureDataAsset) == 0x000040, "Wrong size on UVelvetRoomCardTextureDataAsset");
static_assert(offsetof(UVelvetRoomCardTextureDataAsset, Textures) == 0x000030, "Member 'UVelvetRoomCardTextureDataAsset::Textures' has a wrong offset!");

// Class xrd777.VelvetRoomCardDataAsset
// 0x0020 (0x0050 - 0x0030)
class UVelvetRoomCardDataAsset final : public UAppDataAsset
{
public:
	TArray<class UVelvetRoomCardTextureDataAsset*> TextureDataAsset;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class UVelvetRoomUnimDataAsset*>       UnimDataAsset;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelvetRoomCardDataAsset">();
	}
	static class UVelvetRoomCardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelvetRoomCardDataAsset>();
	}
};
static_assert(alignof(UVelvetRoomCardDataAsset) == 0x000008, "Wrong alignment on UVelvetRoomCardDataAsset");
static_assert(sizeof(UVelvetRoomCardDataAsset) == 0x000050, "Wrong size on UVelvetRoomCardDataAsset");
static_assert(offsetof(UVelvetRoomCardDataAsset, TextureDataAsset) == 0x000030, "Member 'UVelvetRoomCardDataAsset::TextureDataAsset' has a wrong offset!");
static_assert(offsetof(UVelvetRoomCardDataAsset, UnimDataAsset) == 0x000040, "Member 'UVelvetRoomCardDataAsset::UnimDataAsset' has a wrong offset!");

// Class xrd777.UIVelvetRoomUimCard
// 0x01A8 (0x01D0 - 0x0028)
class UUIVelvetRoomUimCard final : public UObject
{
public:
	uint8                                         Pad_28[0x188];                                     // 0x0028(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 PWorld;                                            // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           PCamera;                                           // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVelvetRoomUimCard">();
	}
	static class UUIVelvetRoomUimCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVelvetRoomUimCard>();
	}
};
static_assert(alignof(UUIVelvetRoomUimCard) == 0x000008, "Wrong alignment on UUIVelvetRoomUimCard");
static_assert(sizeof(UUIVelvetRoomUimCard) == 0x0001D0, "Wrong size on UUIVelvetRoomUimCard");
static_assert(offsetof(UUIVelvetRoomUimCard, PWorld) == 0x0001B0, "Member 'UUIVelvetRoomUimCard::PWorld' has a wrong offset!");
static_assert(offsetof(UUIVelvetRoomUimCard, PCamera) == 0x0001B8, "Member 'UUIVelvetRoomUimCard::PCamera' has a wrong offset!");

// Class xrd777.TextInputWidget
// 0x0018 (0x0278 - 0x0260)
class UTextInputWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcLetterBoxSize(float InTmpScreenSize);
	float CalcScreenScale();
	void ChangeInputTextPositionLeft();
	void ChangeInputTextPositionRight();
	void Decide();
	class FText GetText();
	bool IsChangeScreenSize();
	bool IsDrawLetterBoxDirHeight();
	void SetBaseText(const class FText& InText);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextInputWidget">();
	}
	static class UTextInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextInputWidget>();
	}
};
static_assert(alignof(UTextInputWidget) == 0x000008, "Wrong alignment on UTextInputWidget");
static_assert(sizeof(UTextInputWidget) == 0x000278, "Wrong size on UTextInputWidget");

// Class xrd777.UIVoiceActionDraw
// 0x0128 (0x03E0 - 0x02B8)
class AUIVoiceActionDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x40];                                     // 0x02B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStartInAnim;                                    // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInAnim;                                   // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutAnim;                                   // 0x02FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutAnim;                                  // 0x02FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKeyOutAnim;                                     // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnSceneOptionAnim;                            // 0x02FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartInNetworkIconAnim;                         // 0x02FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInNetworkIconAnim;                        // 0x02FF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutNetworkIconAnim;                        // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutNetworkIconAnim;                       // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartInBlackBoardAnim;                          // 0x0302(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInBlackBoardAnim;                         // 0x0303(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutBlackBoardAnim;                         // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutBlackBoardAnim;                        // 0x0305(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStartGetData;                                    // 0x0306(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGetData;                                         // 0x0307(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USprAsset*                              SprData;                                           // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PlgData;                                           // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OffStartFrame;                                     // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDisp;                                            // 0x031C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31D[0xC3];                                     // 0x031D(0x00C3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ConvFrameToTime(int32 InFrame);
	void DrawActionBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBackBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBlackBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBlueBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawCommunityActionPercent(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawCommunityActionStickyNote(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDailyActionPercent(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDailyActionStickyNote(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDay(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDayOfWeek(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDungeonActionPercent(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDungeonActionStickyNote(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawMonth(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawNetworkIcon(const struct FVector2D& InPos, const struct FColor& InColor, float Angle, float IconAngle);
	void DrawNetworkIconSecond(const struct FVector2D& InPos, const struct FColor& InColor, float Angle, float Scale);
	void DrawStickyNoteAverage(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	bool InitDraw_IN();
	bool InitDraw_Out();
	bool InitDrawBlackBoard_IN();
	bool InitDrawBlackBoard_Out();
	bool InitDrawNetworkIcon_IN();
	bool InitDrawNetworkIcon_Out();
	void InitSetDayTime();
	bool KeyHelpIn();
	bool KeyHelpOut();
	void OneTimeLockInput();
	bool StateDraw_BG();
	bool StateDraw_Frame();
	bool StateDraw_IN();
	bool StateDraw_Network();
	bool StateDraw_Out();
	bool StateDrawBlackBoard_IN();
	bool StateDrawBlackBoard_Out();
	bool StateDrawNetworkIcon_IN();
	bool StateDrawNetworkIcon_Out();
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceActionDraw">();
	}
	static class AUIVoiceActionDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceActionDraw>();
	}
};
static_assert(alignof(AUIVoiceActionDraw) == 0x000008, "Wrong alignment on AUIVoiceActionDraw");
static_assert(sizeof(AUIVoiceActionDraw) == 0x0003E0, "Wrong size on AUIVoiceActionDraw");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartInAnim) == 0x0002F8, "Member 'AUIVoiceActionDraw::bIsStartInAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishInAnim) == 0x0002F9, "Member 'AUIVoiceActionDraw::bIsFinishInAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartOutAnim) == 0x0002FA, "Member 'AUIVoiceActionDraw::bIsStartOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishOutAnim) == 0x0002FB, "Member 'AUIVoiceActionDraw::bIsFinishOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsKeyOutAnim) == 0x0002FC, "Member 'AUIVoiceActionDraw::bIsKeyOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bReturnSceneOptionAnim) == 0x0002FD, "Member 'AUIVoiceActionDraw::bReturnSceneOptionAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartInNetworkIconAnim) == 0x0002FE, "Member 'AUIVoiceActionDraw::bIsStartInNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishInNetworkIconAnim) == 0x0002FF, "Member 'AUIVoiceActionDraw::bIsFinishInNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartOutNetworkIconAnim) == 0x000300, "Member 'AUIVoiceActionDraw::bIsStartOutNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishOutNetworkIconAnim) == 0x000301, "Member 'AUIVoiceActionDraw::bIsFinishOutNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartInBlackBoardAnim) == 0x000302, "Member 'AUIVoiceActionDraw::bIsStartInBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishInBlackBoardAnim) == 0x000303, "Member 'AUIVoiceActionDraw::bIsFinishInBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsStartOutBlackBoardAnim) == 0x000304, "Member 'AUIVoiceActionDraw::bIsStartOutBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, bIsFinishOutBlackBoardAnim) == 0x000305, "Member 'AUIVoiceActionDraw::bIsFinishOutBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, IsStartGetData) == 0x000306, "Member 'AUIVoiceActionDraw::IsStartGetData' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, IsGetData) == 0x000307, "Member 'AUIVoiceActionDraw::IsGetData' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, SprData) == 0x000308, "Member 'AUIVoiceActionDraw::SprData' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, PlgData) == 0x000310, "Member 'AUIVoiceActionDraw::PlgData' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, OffStartFrame) == 0x000318, "Member 'AUIVoiceActionDraw::OffStartFrame' has a wrong offset!");
static_assert(offsetof(AUIVoiceActionDraw, IsDisp) == 0x00031C, "Member 'AUIVoiceActionDraw::IsDisp' has a wrong offset!");

// Class xrd777.UIVoiceAnswer
// 0x00E8 (0x0398 - 0x02B0)
class AUIVoiceAnswer final : public AUIVoiceBase
{
public:
	uint8                                         Pad_2B0[0x60];                                     // 0x02B0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLoader*                           Loader_;                                           // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBmdAsset*                              BmdAsset_;                                         // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x18];                                     // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUIVoiceAnswerDraw>         VoiceAnswerDrawSubClass;                           // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUIVoiceAnswerDraw*                     PVoiceAnswerDrawActor;                             // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutDataTable;                                   // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILayoutDataTable*                     LayoutTextColDataTable;                            // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamLayoutData;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PParamTextColLayoutData;                           // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x30];                                     // 0x0368(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceAnswer">();
	}
	static class AUIVoiceAnswer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceAnswer>();
	}
};
static_assert(alignof(AUIVoiceAnswer) == 0x000008, "Wrong alignment on AUIVoiceAnswer");
static_assert(sizeof(AUIVoiceAnswer) == 0x000398, "Wrong size on AUIVoiceAnswer");
static_assert(offsetof(AUIVoiceAnswer, Loader_) == 0x000310, "Member 'AUIVoiceAnswer::Loader_' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, BmdAsset_) == 0x000318, "Member 'AUIVoiceAnswer::BmdAsset_' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, VoiceAnswerDrawSubClass) == 0x000338, "Member 'AUIVoiceAnswer::VoiceAnswerDrawSubClass' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, PVoiceAnswerDrawActor) == 0x000340, "Member 'AUIVoiceAnswer::PVoiceAnswerDrawActor' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, LayoutDataTable) == 0x000348, "Member 'AUIVoiceAnswer::LayoutDataTable' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, LayoutTextColDataTable) == 0x000350, "Member 'AUIVoiceAnswer::LayoutTextColDataTable' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, PParamLayoutData) == 0x000358, "Member 'AUIVoiceAnswer::PParamLayoutData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswer, PParamTextColLayoutData) == 0x000360, "Member 'AUIVoiceAnswer::PParamTextColLayoutData' has a wrong offset!");

// Class xrd777.UIVoiceAnswerDraw
// 0x0710 (0x09C8 - 0x02B8)
class AUIVoiceAnswerDraw final : public AUIDrawBaseActor
{
public:
	uint8                                         Pad_2B8[0x1];                                      // 0x02B8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStartInAnim;                                    // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInAnim;                                   // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutAnim;                                   // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutAnim;                                  // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKeyOutAnim;                                     // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnSceneOptionAnim;                            // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartInNetworkIconAnim;                         // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInNetworkIconAnim;                        // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutNetworkIconAnim;                        // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutNetworkIconAnim;                       // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartInBlackBoardAnim;                          // 0x02C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishInBlackBoardAnim;                         // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStartOutBlackBoardAnim;                         // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinishOutBlackBoardAnim;                        // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStartGetData;                                    // 0x02C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGetData;                                         // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDisp;                                            // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USprAsset*                              SprData;                                           // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlgAsset*                              PlgData;                                           // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OffStartFrame;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x6E4];                                    // 0x02E4(0x06E4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ConvFrameToTime(int32 InFrame);
	void DrawAnswerBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawAnswerTextA(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawAnswerTextB(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawAnswerTextC(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawAnswerTextD(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBackBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBlackBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawBlueBoard(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDay(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawDayOfWeek(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawLeftBracketsA(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawLeftBracketsB(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawLeftBracketsC(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawLeftBracketsD(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawMonth(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawNetworkIcon(const struct FVector2D& InPos, const struct FColor& InColor, float Angle, float IconAngle);
	void DrawNetworkIconSecond(const struct FVector2D& InPos, const struct FColor& InColor, float Angle, float Scale);
	void DrawRightBracketsA(const struct FVector2D& InPos, const struct FColor& InColor, float Width, float Height, float Angle);
	void DrawRightBracketsB(const struct FVector2D& InPos, const struct FColor& InColor, float Width, float Height, float Angle);
	void DrawRightBracketsC(const struct FVector2D& InPos, const struct FColor& InColor, float Width, float Height, float Angle);
	void DrawRightBracketsD(const struct FVector2D& InPos, const struct FColor& InColor, float Width, float Height, float Angle);
	void DrawStickerA(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawStickerB(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawStickerC(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawStickerD(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawTextureA(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawTextureB(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawTextureC(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	void DrawTextureD(const struct FVector2D& InPos, const struct FColor& InColor, float Angle);
	bool InitDraw_IN();
	bool InitDraw_Out();
	bool InitDrawBlackBoard_IN();
	bool InitDrawBlackBoard_Out();
	bool InitDrawNetworkIcon_IN();
	bool InitDrawNetworkIcon_Out();
	void InitSetDayTime();
	bool IsMaxAnswer();
	bool KeyHelpIn();
	bool KeyHelpOut();
	void OneTimeLockInput();
	bool StateDraw_BG();
	bool StateDraw_Frame();
	bool StateDraw_IN();
	bool StateDraw_Network();
	bool StateDraw_Out();
	bool StateDrawBlackBoard_IN();
	bool StateDrawBlackBoard_Out();
	bool StateDrawNetworkIcon_IN();
	bool StateDrawNetworkIcon_Out();
	bool TimeWithinRangeFrame(float NowTime, int32 StartFrame, int32 EndFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceAnswerDraw">();
	}
	static class AUIVoiceAnswerDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceAnswerDraw>();
	}
};
static_assert(alignof(AUIVoiceAnswerDraw) == 0x000008, "Wrong alignment on AUIVoiceAnswerDraw");
static_assert(sizeof(AUIVoiceAnswerDraw) == 0x0009C8, "Wrong size on AUIVoiceAnswerDraw");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartInAnim) == 0x0002B9, "Member 'AUIVoiceAnswerDraw::bIsStartInAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishInAnim) == 0x0002BA, "Member 'AUIVoiceAnswerDraw::bIsFinishInAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartOutAnim) == 0x0002BB, "Member 'AUIVoiceAnswerDraw::bIsStartOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishOutAnim) == 0x0002BC, "Member 'AUIVoiceAnswerDraw::bIsFinishOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsKeyOutAnim) == 0x0002BD, "Member 'AUIVoiceAnswerDraw::bIsKeyOutAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bReturnSceneOptionAnim) == 0x0002BE, "Member 'AUIVoiceAnswerDraw::bReturnSceneOptionAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartInNetworkIconAnim) == 0x0002BF, "Member 'AUIVoiceAnswerDraw::bIsStartInNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishInNetworkIconAnim) == 0x0002C0, "Member 'AUIVoiceAnswerDraw::bIsFinishInNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartOutNetworkIconAnim) == 0x0002C1, "Member 'AUIVoiceAnswerDraw::bIsStartOutNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishOutNetworkIconAnim) == 0x0002C2, "Member 'AUIVoiceAnswerDraw::bIsFinishOutNetworkIconAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartInBlackBoardAnim) == 0x0002C3, "Member 'AUIVoiceAnswerDraw::bIsStartInBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishInBlackBoardAnim) == 0x0002C4, "Member 'AUIVoiceAnswerDraw::bIsFinishInBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsStartOutBlackBoardAnim) == 0x0002C5, "Member 'AUIVoiceAnswerDraw::bIsStartOutBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, bIsFinishOutBlackBoardAnim) == 0x0002C6, "Member 'AUIVoiceAnswerDraw::bIsFinishOutBlackBoardAnim' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, IsStartGetData) == 0x0002C7, "Member 'AUIVoiceAnswerDraw::IsStartGetData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, IsGetData) == 0x0002C8, "Member 'AUIVoiceAnswerDraw::IsGetData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, IsDisp) == 0x0002C9, "Member 'AUIVoiceAnswerDraw::IsDisp' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, SprData) == 0x0002D0, "Member 'AUIVoiceAnswerDraw::SprData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, PlgData) == 0x0002D8, "Member 'AUIVoiceAnswerDraw::PlgData' has a wrong offset!");
static_assert(offsetof(AUIVoiceAnswerDraw, OffStartFrame) == 0x0002E0, "Member 'AUIVoiceAnswerDraw::OffStartFrame' has a wrong offset!");

// Class xrd777.UIVoiceConnectWatching
// 0x0020 (0x02C0 - 0x02A0)
class AUIVoiceConnectWatching final : public AUIBaseActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVoiceConnectWatching">();
	}
	static class AUIVoiceConnectWatching* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIVoiceConnectWatching>();
	}
};
static_assert(alignof(AUIVoiceConnectWatching) == 0x000008, "Wrong alignment on AUIVoiceConnectWatching");
static_assert(sizeof(AUIVoiceConnectWatching) == 0x0002C0, "Wrong size on AUIVoiceConnectWatching");

// Class xrd777.UmgDebugLogActor
// 0x0048 (0x0268 - 0x0220)
class AUmgDebugLogActor final : public AActor
{
public:
	uint8                                         Pad_220[0x48];                                     // 0x0220(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgDebugLogActor">();
	}
	static class AUmgDebugLogActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUmgDebugLogActor>();
	}
};
static_assert(alignof(AUmgDebugLogActor) == 0x000008, "Wrong alignment on AUmgDebugLogActor");
static_assert(sizeof(AUmgDebugLogActor) == 0x000268, "Wrong size on AUmgDebugLogActor");

// Class xrd777.UmgDebugLogWidget
// 0x0000 (0x0260 - 0x0260)
class UUmgDebugLogWidget final : public UUserWidget
{
public:
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgDebugLogWidget">();
	}
	static class UUmgDebugLogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgDebugLogWidget>();
	}
};
static_assert(alignof(UUmgDebugLogWidget) == 0x000008, "Wrong alignment on UUmgDebugLogWidget");
static_assert(sizeof(UUmgDebugLogWidget) == 0x000260, "Wrong size on UUmgDebugLogWidget");

// Class xrd777.UmgDialogActor
// 0x0030 (0x0250 - 0x0220)
class AUmgDialogActor final : public AActor
{
public:
	uint8                                         Pad_220[0x30];                                     // 0x0220(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgDialogActor">();
	}
	static class AUmgDialogActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUmgDialogActor>();
	}
};
static_assert(alignof(AUmgDialogActor) == 0x000008, "Wrong alignment on AUmgDialogActor");
static_assert(sizeof(AUmgDialogActor) == 0x000250, "Wrong size on AUmgDialogActor");

// Class xrd777.UtlBpObjManager
// 0x0008 (0x0038 - 0x0030)
class UUtlBpObjManager final : public UGameInstanceSubsystem
{
public:
	class UUtlBpObjCore*                          MObject_;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUtlBpObjCore* CreateBluePrint(class UClass* ObjectClass);
	void SetBluePrint(class UUtlBpObjCore* BpObjCore);
	void SetEventEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtlBpObjManager">();
	}
	static class UUtlBpObjManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtlBpObjManager>();
	}
};
static_assert(alignof(UUtlBpObjManager) == 0x000008, "Wrong alignment on UUtlBpObjManager");
static_assert(sizeof(UUtlBpObjManager) == 0x000038, "Wrong size on UUtlBpObjManager");
static_assert(offsetof(UUtlBpObjManager, MObject_) == 0x000030, "Member 'UUtlBpObjManager::MObject_' has a wrong offset!");

// Class xrd777.Xrd777AssetManager
// 0x0000 (0x0478 - 0x0478)
class UXrd777AssetManager final : public UAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Xrd777AssetManager">();
	}
	static class UXrd777AssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXrd777AssetManager>();
	}
};
static_assert(alignof(UXrd777AssetManager) == 0x000008, "Wrong alignment on UXrd777AssetManager");
static_assert(sizeof(UXrd777AssetManager) == 0x000478, "Wrong size on UXrd777AssetManager");

// Class xrd777.AstreaSaveGame
// 0x3806E0 (0x380708 - 0x0028)
class UAstreaSaveGame final : public USaveGame
{
public:
	class FString                                 breakdown;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSaveGameHeadder                       SaveDataHeadder;                                   // 0x0038(0x00D0)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint32                                        SaveDataArea[0xE0180];                             // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AstreaSaveGame">();
	}
	static class UAstreaSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAstreaSaveGame>();
	}
};
static_assert(alignof(UAstreaSaveGame) == 0x000008, "Wrong alignment on UAstreaSaveGame");
static_assert(sizeof(UAstreaSaveGame) == 0x380708, "Wrong size on UAstreaSaveGame");
static_assert(offsetof(UAstreaSaveGame, breakdown) == 0x000028, "Member 'UAstreaSaveGame::breakdown' has a wrong offset!");
static_assert(offsetof(UAstreaSaveGame, SaveDataHeadder) == 0x000038, "Member 'UAstreaSaveGame::SaveDataHeadder' has a wrong offset!");
static_assert(offsetof(UAstreaSaveGame, SaveDataArea) == 0x000108, "Member 'UAstreaSaveGame::SaveDataArea' has a wrong offset!");

}

