#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ABP_CH_MeshBase

#include "Basic.hpp"

#include "ABP_CH_MeshBase_classes.hpp"
#include "ABP_CH_MeshBase_parameters.hpp"


namespace SDK
{

// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ExecuteUbergraph_ABP_CH_MeshBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::ExecuteUbergraph_ABP_CH_MeshBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ExecuteUbergraph_ABP_CH_MeshBase");

	Params::ABP_CH_MeshBase_C_ExecuteUbergraph_ABP_CH_MeshBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_EnterStop
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_EnterStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_EnterStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set No Blink
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Set_No_Blink(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set No Blink");

	Params::ABP_CH_MeshBase_C_Set_No_Blink Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set Saccade
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Set_Saccade(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set Saccade");

	Params::ABP_CH_MeshBase_C_Set_Saccade Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.LinkPhysics
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::LinkPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "LinkPhysics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UnlinkPhysics
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UnlinkPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UnlinkPhysics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_EnterIdle
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_EnterIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_EnterIdle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_EnterMoving
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_EnterMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_EnterMoving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetOverrideLocomotionNotMoveAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAnimSequence*                    InAnimSeq                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetOverrideLocomotionNotMoveAnim(class UAnimSequence* InAnimSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetOverrideLocomotionNotMoveAnim");

	Params::ABP_CH_MeshBase_C_SetOverrideLocomotionNotMoveAnim Parms{};

	Parms.InAnimSeq = InAnimSeq;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BPI_SetOverlayOverrideState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   OverlayOverrideState_0                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::BPI_SetOverlayOverrideState(int32 OverlayOverrideState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BPI_SetOverlayOverrideState");

	Params::ABP_CH_MeshBase_C_BPI_SetOverlayOverrideState Parms{};

	Parms.OverlayOverrideState_0 = OverlayOverrideState_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.PlayDynamicTransition
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReTriggerDelay                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FDynamicMontageParams            Parameters                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::PlayDynamicTransition(float ReTriggerDelay, const struct FDynamicMontageParams& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "PlayDynamicTransition");

	Params::ABP_CH_MeshBase_C_PlayDynamicTransition Parms{};

	Parms.ReTriggerDelay = ReTriggerDelay;
	Parms.Parameters = std::move(Parameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Pivot
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Pivot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Pivot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips RF
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_RF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips RF");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips RB
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_RB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips RB");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips LF
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_LF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips LF");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips LB
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_LB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips LB");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips B
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips B");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Hips F
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Hips_F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Hips F");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Reset-GroundedEntryState
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_ResetMinusGroundedEntryState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Reset-GroundedEntryState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BPI_SetGroundedEntryState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EGroundedEntryState                     GroundedEntryState_0                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::BPI_SetGroundedEntryState(EGroundedEntryState GroundedEntryState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BPI_SetGroundedEntryState");

	Params::ABP_CH_MeshBase_C_BPI_SetGroundedEntryState Parms{};

	Parms.GroundedEntryState_0 = GroundedEntryState_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BPI_Jumped
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::BPI_Jumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BPI_Jumped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_->N QuickStop 
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Minus_N_QuickStop_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_->N QuickStop ");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Land->Idle
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_LandMinus_Idle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Land->Idle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_->N Stop R
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Minus_N_Stop_R()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_->N Stop R");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_->N Stop L
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Minus_N_Stop_L()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_->N Stop L");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_Roll->Idle
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_RollMinus_Idle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_Roll->Idle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.PlayTransition
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDynamicMontageParams            Parameters                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::PlayTransition(const struct FDynamicMontageParams& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "PlayTransition");

	Params::ABP_CH_MeshBase_C_PlayTransition Parms{};

	Parms.Parameters = std::move(Parameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_StopTransition
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_StopTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_StopTransition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimNotify_->CLF Stop
// (BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::AnimNotify_Minus_CLF_Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimNotify_->CLF Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BlueprintUpdateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTimeX_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::BlueprintUpdateAnimation(float DeltaTimeX_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BlueprintUpdateAnimation");

	Params::ABP_CH_MeshBase_C_BlueprintUpdateAnimation Parms{};

	Parms.DeltaTimeX_0 = DeltaTimeX_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetLookAtWorldLocation
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetLookAtWorldLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetLookAtWorldLocation");

	Params::ABP_CH_MeshBase_C_SetLookAtWorldLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetLookAtType
// (Event, Public, BlueprintEvent)
// Parameters:
// uint8                                   LookAtType_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetLookAtType(uint8 LookAtType_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetLookAtType");

	Params::ABP_CH_MeshBase_C_SetLookAtType Parms{};

	Parms.LookAtType_0 = LookAtType_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetLookAtTargetActorBoneName
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetLookAtTargetActorBoneName(const class FString& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetLookAtTargetActorBoneName");

	Params::ABP_CH_MeshBase_C_SetLookAtTargetActorBoneName Parms{};

	Parms.BoneName = std::move(BoneName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetLookAtTargetActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetLookAtTargetActor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetLookAtTargetActor");

	Params::ABP_CH_MeshBase_C_SetLookAtTargetActor Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetSinkingDistance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   SinkingDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::SetSinkingDistance(float SinkingDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetSinkingDistance");

	Params::ABP_CH_MeshBase_C_SetSinkingDistance Parms{};

	Parms.SinkingDistance = SinkingDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.LoadEnd_ABP
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::LoadEnd_ABP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "LoadEnd_ABP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BlueprintBeginPlay
// (Event, Public, BlueprintEvent)

void UABP_CH_MeshBase_C::BlueprintBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BlueprintBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BlueprintInitializeAnimation
// (Event, Public, BlueprintEvent)

void UABP_CH_MeshBase_C::BlueprintInitializeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BlueprintInitializeAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_274CDB9D48BE303F923DF0B7A4356B50
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_274CDB9D48BE303F923DF0B7A4356B50()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_274CDB9D48BE303F923DF0B7A4356B50");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_C1A4EDBA43432B3CB30140BF05AD7C9F
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_C1A4EDBA43432B3CB30140BF05AD7C9F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_C1A4EDBA43432B3CB30140BF05AD7C9F");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_2B6BFB6443D826E14FD2478E86394F45
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_2B6BFB6443D826E14FD2478E86394F45()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_2B6BFB6443D826E14FD2478E86394F45");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_E42C81AB4DF3911DB54AE0A3E1C40185
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_E42C81AB4DF3911DB54AE0A3E1C40185()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_E42C81AB4DF3911DB54AE0A3E1C40185");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4B071AFA4E51734525FBB2A8B721DB85
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4B071AFA4E51734525FBB2A8B721DB85()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4B071AFA4E51734525FBB2A8B721DB85");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_198042894FFE1D3A4634A7A5B6B65C54
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_198042894FFE1D3A4634A7A5B6B65C54()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_198042894FFE1D3A4634A7A5B6B65C54");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_1A54E6ED44EB539483F3169042D1D9C5
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_1A54E6ED44EB539483F3169042D1D9C5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_1A54E6ED44EB539483F3169042D1D9C5");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_7C438D0F457C2E264E238FA09C9F007C
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_7C438D0F457C2E264E238FA09C9F007C()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_7C438D0F457C2E264E238FA09C9F007C");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_9D02FC2E4C91D3CBC27D40BDACC6D51F
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_9D02FC2E4C91D3CBC27D40BDACC6D51F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_9D02FC2E4C91D3CBC27D40BDACC6D51F");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_3419A62A45DEC8A55FED899E00F783E5
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_3419A62A45DEC8A55FED899E00F783E5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_3419A62A45DEC8A55FED899E00F783E5");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_8AC7C0D94B7C5D1ED46FF29A99E1166F
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_8AC7C0D94B7C5D1ED46FF29A99E1166F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_8AC7C0D94B7C5D1ED46FF29A99E1166F");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4079A1634C43683E49A8F8AA15C7B3EB
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4079A1634C43683E49A8F8AA15C7B3EB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_4079A1634C43683E49A8F8AA15C7B3EB");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_072CDE8542978AECEF69879116FAF6C3
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_072CDE8542978AECEF69879116FAF6C3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_072CDE8542978AECEF69879116FAF6C3");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_D6F93A464E6BAB795FC1119394BC8F49
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_D6F93A464E6BAB795FC1119394BC8F49()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_TransitionResult_D6F93A464E6BAB795FC1119394BC8F49");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_E38F8FD54B0425E7972ADFA6FFDEED65
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_E38F8FD54B0425E7972ADFA6FFDEED65()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_E38F8FD54B0425E7972ADFA6FFDEED65");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_DB6122F54E607584944EF994199C8707
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_DB6122F54E607584944EF994199C8707()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_DB6122F54E607584944EF994199C8707");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_27818ADC4EEE691D4D046093B5614F21
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_27818ADC4EEE691D4D046093B5614F21()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_BlendListByInt_27818ADC4EEE691D4D046093B5614F21");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_LookAt_211191D44AE994690710A4851EFEAD22
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_LookAt_211191D44AE994690710A4851EFEAD22()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_LookAt_211191D44AE994690710A4851EFEAD22");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_D230DF334EBA17502293E3A3AE03249E
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_D230DF334EBA17502293E3A3AE03249E()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_D230DF334EBA17502293E3A3AE03249E");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_DCB050404075A6D11CCAF9B7E8DC3039
// (BlueprintEvent)

void UABP_CH_MeshBase_C::EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_DCB050404075A6D11CCAF9B7E8DC3039()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_ABP_CH_MeshBase_AnimGraphNode_ModifyBone_DCB050404075A6D11CCAF9B7E8DC3039");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update Character Info
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_Character_Info()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update Character Info");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdateLayerValues
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdateLayerValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdateLayerValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update Foot IK
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_Foot_IK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update Foot IK");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdateMovementValues
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdateMovementValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdateMovementValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdateRotationValues
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdateRotationValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdateRotationValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdateInAirValues
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdateInAirValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdateInAirValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdateRagdollValues
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdateRagdollValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdateRagdollValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateVelocityBlend
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVelocityBlend                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVelocityBlend UABP_CH_MeshBase_C::CalculateVelocityBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateVelocityBlend");

	Params::ABP_CH_MeshBase_C_CalculateVelocityBlend Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateDiagonalScaleAmount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UABP_CH_MeshBase_C::CalculateDiagonalScaleAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateDiagonalScaleAmount");

	Params::ABP_CH_MeshBase_C_CalculateDiagonalScaleAmount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Calculate Relative Acceleration Amount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UABP_CH_MeshBase_C::Calculate_Relative_Acceleration_Amount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Calculate Relative Acceleration Amount");

	Params::ABP_CH_MeshBase_C_Calculate_Relative_Acceleration_Amount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateWalkRunBlend
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   WalkRunBlend_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateWalkRunBlend(float* WalkRunBlend_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateWalkRunBlend");

	Params::ABP_CH_MeshBase_C_CalculateWalkRunBlend Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WalkRunBlend_0 != nullptr)
		*WalkRunBlend_0 = Parms.WalkRunBlend_0;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateStrideBlend
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UABP_CH_MeshBase_C::CalculateStrideBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateStrideBlend");

	Params::ABP_CH_MeshBase_C_CalculateStrideBlend Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateStandingPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateStandingPlayRate(float* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateStandingPlayRate");

	Params::ABP_CH_MeshBase_C_CalculateStandingPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateCrouchingPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateCrouchingPlayRate(float* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateCrouchingPlayRate");

	Params::ABP_CH_MeshBase_C_CalculateCrouchingPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateMovementDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EMovementDirection                      ReturnValues                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateMovementDirection(EMovementDirection* ReturnValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateMovementDirection");

	Params::ABP_CH_MeshBase_C_CalculateMovementDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ReturnValues != nullptr)
		*ReturnValues = Parms.ReturnValues;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetFootOffsets
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          CurrentLocationL_Target                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CurrentLocationR_Target                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CurrentLocationOffset                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         CurrentRotationOffset                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::SetFootOffsets(struct FVector& CurrentLocationL_Target, struct FVector& CurrentLocationR_Target, struct FVector& CurrentLocationOffset, struct FRotator& CurrentRotationOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetFootOffsets");

	Params::ABP_CH_MeshBase_C_SetFootOffsets Parms{};

	Parms.CurrentLocationL_Target = std::move(CurrentLocationL_Target);
	Parms.CurrentLocationR_Target = std::move(CurrentLocationR_Target);
	Parms.CurrentLocationOffset = std::move(CurrentLocationOffset);
	Parms.CurrentRotationOffset = std::move(CurrentRotationOffset);

	UObject::ProcessEvent(Func, &Parms);

	CurrentLocationL_Target = std::move(Parms.CurrentLocationL_Target);
	CurrentLocationR_Target = std::move(Parms.CurrentLocationR_Target);
	CurrentLocationOffset = std::move(Parms.CurrentLocationOffset);
	CurrentRotationOffset = std::move(Parms.CurrentRotationOffset);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetFootLocking
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Enable_FootIK_Curve                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             FootLockCurve                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             IKFootBone                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CurrentFootLockAlpha                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CurrentFootLockLocation                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         CurrentFootLockRotation                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::SetFootLocking(class FName Enable_FootIK_Curve, class FName FootLockCurve, class FName IKFootBone, float& CurrentFootLockAlpha, struct FVector& CurrentFootLockLocation, struct FRotator& CurrentFootLockRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetFootLocking");

	Params::ABP_CH_MeshBase_C_SetFootLocking Parms{};

	Parms.Enable_FootIK_Curve = Enable_FootIK_Curve;
	Parms.FootLockCurve = FootLockCurve;
	Parms.IKFootBone = IKFootBone;
	Parms.CurrentFootLockAlpha = CurrentFootLockAlpha;
	Parms.CurrentFootLockLocation = std::move(CurrentFootLockLocation);
	Parms.CurrentFootLockRotation = std::move(CurrentFootLockRotation);

	UObject::ProcessEvent(Func, &Parms);

	CurrentFootLockAlpha = Parms.CurrentFootLockAlpha;
	CurrentFootLockLocation = std::move(Parms.CurrentFootLockLocation);
	CurrentFootLockRotation = std::move(Parms.CurrentFootLockRotation);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetFootLockOffsets
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          LocalLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         LocalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::SetFootLockOffsets(struct FVector& LocalLocation, struct FRotator& LocalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetFootLockOffsets");

	Params::ABP_CH_MeshBase_C_SetFootLockOffsets Parms{};

	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);

	UObject::ProcessEvent(Func, &Parms);

	LocalLocation = std::move(Parms.LocalLocation);
	LocalRotation = std::move(Parms.LocalRotation);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ShouldMoveCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::ShouldMoveCheck(bool* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ShouldMoveCheck");

	Params::ABP_CH_MeshBase_C_ShouldMoveCheck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CanTurnInPlace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UABP_CH_MeshBase_C::CanTurnInPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CanTurnInPlace");

	Params::ABP_CH_MeshBase_C_CanTurnInPlace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CanRotateInPlace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UABP_CH_MeshBase_C::CanRotateInPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CanRotateInPlace");

	Params::ABP_CH_MeshBase_C_CanRotateInPlace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CanDynamicTransition
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UABP_CH_MeshBase_C::CanDynamicTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CanDynamicTransition");

	Params::ABP_CH_MeshBase_C_CanDynamicTransition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CanOverlayTransition
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UABP_CH_MeshBase_C::CanOverlayTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CanOverlayTransition");

	Params::ABP_CH_MeshBase_C_CanOverlayTransition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.TurnInPlace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         TargetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   PlayRateScale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OverrideCurrent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::TurnInPlace(const struct FRotator& TargetRotation, float PlayRateScale, float StartTime, bool OverrideCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "TurnInPlace");

	Params::ABP_CH_MeshBase_C_TurnInPlace Parms{};

	Parms.TargetRotation = std::move(TargetRotation);
	Parms.PlayRateScale = PlayRateScale;
	Parms.StartTime = StartTime;
	Parms.OverrideCurrent = OverrideCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.TurnInPlaceCheck
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::TurnInPlaceCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "TurnInPlaceCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateLandPrediction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   LandPrediction_0                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateLandPrediction(float* LandPrediction_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateLandPrediction");

	Params::ABP_CH_MeshBase_C_CalculateLandPrediction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LandPrediction_0 != nullptr)
		*LandPrediction_0 = Parms.LandPrediction_0;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateInAirLeanAmount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FLeanAmount                      LeanAmount_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CalculateInAirLeanAmount(struct FLeanAmount* LeanAmount_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateInAirLeanAmount");

	Params::ABP_CH_MeshBase_C_CalculateInAirLeanAmount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LeanAmount_0 != nullptr)
		*LeanAmount_0 = std::move(Parms.LeanAmount_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.RotateInPlaceCheck
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::RotateInPlaceCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "RotateInPlaceCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.DynamicTransitionCheck
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::DynamicTransitionCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "DynamicTransitionCheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetDebugTraceType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EDrawDebugTrace                         ShowTraceType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDrawDebugTrace                         DebugType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::GetDebugTraceType(EDrawDebugTrace ShowTraceType, EDrawDebugTrace* DebugType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetDebugTraceType");

	Params::ABP_CH_MeshBase_C_GetDebugTraceType Parms{};

	Parms.ShowTraceType = ShowTraceType;

	UObject::ProcessEvent(Func, &Parms);

	if (DebugType != nullptr)
		*DebugType = Parms.DebugType;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.InterpVelocityBlend
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVelocityBlend                   Current                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVelocityBlend                   Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVelocityBlend                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVelocityBlend UABP_CH_MeshBase_C::InterpVelocityBlend(const struct FVelocityBlend& Current, const struct FVelocityBlend& Target, float InterpSpeed, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "InterpVelocityBlend");

	Params::ABP_CH_MeshBase_C_InterpVelocityBlend Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.InterpSpeed = InterpSpeed;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.InterpLeanAmount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FLeanAmount                      Current                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLeanAmount                      Target                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLeanAmount                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FLeanAmount UABP_CH_MeshBase_C::InterpLeanAmount(const struct FLeanAmount& Current, const struct FLeanAmount& Target, float InterpSpeed, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "InterpLeanAmount");

	Params::ABP_CH_MeshBase_C_InterpLeanAmount Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.InterpSpeed = InterpSpeed;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CalculateQuadrant
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EMovementDirection                      Current                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   FRMinusThreshold                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   FLMinusThreshold                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BRMinusThreshold                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BLMinusThreshold                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Buffer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EMovementDirection                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

EMovementDirection UABP_CH_MeshBase_C::CalculateQuadrant(EMovementDirection Current, float FRMinusThreshold, float FLMinusThreshold, float BRMinusThreshold, float BLMinusThreshold, float Buffer, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CalculateQuadrant");

	Params::ABP_CH_MeshBase_C_CalculateQuadrant Parms{};

	Parms.Current = Current;
	Parms.FRMinusThreshold = FRMinusThreshold;
	Parms.FLMinusThreshold = FLMinusThreshold;
	Parms.BRMinusThreshold = BRMinusThreshold;
	Parms.BLMinusThreshold = BLMinusThreshold;
	Parms.Buffer = Buffer;
	Parms.Angle = Angle;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AngleInRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Buffer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IncreaseBuffer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UABP_CH_MeshBase_C::AngleInRange(float Angle, float MinAngle, float MaxAngle, float Buffer, bool IncreaseBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AngleInRange");

	Params::ABP_CH_MeshBase_C_AngleInRange Parms{};

	Parms.Angle = Angle;
	Parms.MinAngle = MinAngle;
	Parms.MaxAngle = MaxAngle;
	Parms.Buffer = Buffer;
	Parms.IncreaseBuffer = IncreaseBuffer;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ResetIKOffsets
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::ResetIKOffsets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ResetIKOffsets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EyeBlink
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::EyeBlink(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EyeBlink");

	Params::ABP_CH_MeshBase_C_EyeBlink Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.EyeSaccade
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::EyeSaccade(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "EyeSaccade");

	Params::ABP_CH_MeshBase_C_EyeSaccade Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Lookat
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_CharacterBase_C*              CharaBP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Lookat(class ABP_CharacterBase_C* CharaBP, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Lookat");

	Params::ABP_CH_MeshBase_C_Lookat Parms{};

	Parms.CharaBP = CharaBP;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ClampLookAtAngle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CurrentAngle                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AngleOverLimitter                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   AngleLimit                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ClampAngle                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::ClampLookAtAngle(float CurrentAngle, bool AngleOverLimitter, float AngleLimit, float* ClampAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ClampLookAtAngle");

	Params::ABP_CH_MeshBase_C_ClampLookAtAngle Parms{};

	Parms.CurrentAngle = CurrentAngle;
	Parms.AngleOverLimitter = AngleOverLimitter;
	Parms.AngleLimit = AngleLimit;

	UObject::ProcessEvent(Func, &Parms);

	if (ClampAngle != nullptr)
		*ClampAngle = Parms.ClampAngle;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.InterpLookAtTo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Lookat_Vertical_                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Lookat_Horizontal_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TargetLookat_Vertical_                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TargetLookat_Horizontal_                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaTime_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSpeed_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Lookat_CurrentVertical                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Lookat_CurrentHorizontal                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::InterpLookAtTo(float Lookat_Vertical_, float Lookat_Horizontal_, float TargetLookat_Vertical_, float TargetLookat_Horizontal_, float DeltaTime_, float InterpSpeed_, float* Lookat_CurrentVertical, float* Lookat_CurrentHorizontal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "InterpLookAtTo");

	Params::ABP_CH_MeshBase_C_InterpLookAtTo Parms{};

	Parms.Lookat_Vertical_ = Lookat_Vertical_;
	Parms.Lookat_Horizontal_ = Lookat_Horizontal_;
	Parms.TargetLookat_Vertical_ = TargetLookat_Vertical_;
	Parms.TargetLookat_Horizontal_ = TargetLookat_Horizontal_;
	Parms.DeltaTime_ = DeltaTime_;
	Parms.InterpSpeed_ = InterpSpeed_;

	UObject::ProcessEvent(Func, &Parms);

	if (Lookat_CurrentVertical != nullptr)
		*Lookat_CurrentVertical = Parms.Lookat_CurrentVertical;

	if (Lookat_CurrentHorizontal != nullptr)
		*Lookat_CurrentHorizontal = Parms.Lookat_CurrentHorizontal;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ClampAllLookatAngle
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::ClampAllLookatAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ClampAllLookatAngle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get Ex Upleg TransX
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             DriveBone                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USceneComponent*                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TransformX                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Get_Ex_Upleg_TransX(class FName DriveBone, class USceneComponent* Target, struct FVector* TransformX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get Ex Upleg TransX");

	Params::ABP_CH_MeshBase_C_Get_Ex_Upleg_TransX Parms{};

	Parms.DriveBone = DriveBone;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (TransformX != nullptr)
		*TransformX = std::move(Parms.TransformX);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetKneeCapTransXY
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             DriveBone                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USceneComponent*                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TransformX                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::GetKneeCapTransXY(class FName DriveBone, class USceneComponent* Target, struct FVector* TransformX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetKneeCapTransXY");

	Params::ABP_CH_MeshBase_C_GetKneeCapTransXY Parms{};

	Parms.DriveBone = DriveBone;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (TransformX != nullptr)
		*TransformX = std::move(Parms.TransformX);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.FaceDeformationAtCamera
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             HeadBoneName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USkeletalMeshComponent*           SKMesh                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APlayerCameraManager*             Camera                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::FaceDeformationAtCamera(class FName HeadBoneName, class USkeletalMeshComponent* SKMesh, class APlayerCameraManager* Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "FaceDeformationAtCamera");

	Params::ABP_CH_MeshBase_C_FaceDeformationAtCamera Parms{};

	Parms.HeadBoneName = HeadBoneName;
	Parms.SKMesh = SKMesh;
	Parms.Camera = Camera;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetLookAtTargetActor
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class AActor* UABP_CH_MeshBase_C::GetLookAtTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetLookAtTargetActor");

	Params::ABP_CH_MeshBase_C_GetLookAtTargetActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetLookAtType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

uint8 UABP_CH_MeshBase_C::GetLookAtType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetLookAtType");

	Params::ABP_CH_MeshBase_C_GetLookAtType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetLookAtWorldLocation
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UABP_CH_MeshBase_C::GetLookAtWorldLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetLookAtWorldLocation");

	Params::ABP_CH_MeshBase_C_GetLookAtWorldLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetLookAtTargetActorBoneName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)

class FString UABP_CH_MeshBase_C::GetLookAtTargetActorBoneName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetLookAtTargetActorBoneName");

	Params::ABP_CH_MeshBase_C_GetLookAtTargetActorBoneName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.ClampAngleToLookat
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BodyLookAt_EnableLimitter_0                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   MinAngleDegrees                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngleDegrees                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LookAtTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LookatOffset                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UABP_CH_MeshBase_C::ClampAngleToLookat(bool BodyLookAt_EnableLimitter_0, float MinAngleDegrees, float MaxAngleDegrees, float LookAtTarget, float LookatOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "ClampAngleToLookat");

	Params::ABP_CH_MeshBase_C_ClampAngleToLookat Parms{};

	Parms.BodyLookAt_EnableLimitter_0 = BodyLookAt_EnableLimitter_0;
	Parms.MinAngleDegrees = MinAngleDegrees;
	Parms.MaxAngleDegrees = MaxAngleDegrees;
	Parms.LookAtTarget = LookAtTarget;
	Parms.LookatOffset = LookatOffset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Foot Trace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TraceLimit                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InActorBottomDistance                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceStartLocation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OutHitResult                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   OutHitDistance                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         OutHitRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Foot_Trace(float TraceLimit, float InActorBottomDistance, const struct FVector& TraceStartLocation, bool* OutHitResult, float* OutHitDistance, struct FRotator* OutHitRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Foot Trace");

	Params::ABP_CH_MeshBase_C_Foot_Trace Parms{};

	Parms.TraceLimit = TraceLimit;
	Parms.InActorBottomDistance = InActorBottomDistance;
	Parms.TraceStartLocation = std::move(TraceStartLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutHitResult != nullptr)
		*OutHitResult = Parms.OutHitResult;

	if (OutHitDistance != nullptr)
		*OutHitDistance = Parms.OutHitDistance;

	if (OutHitRotation != nullptr)
		*OutHitRotation = std::move(Parms.OutHitRotation);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get Foot Offsets
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   InAdjustSinking                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InEnableFootIK_L                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    InEnableFootIK_R                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsUpdate_Foot_L                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsUpdate_Foot_R                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   OutActorSinking                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutFootL_Distance                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutFootR_Distance                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         OutFootL_Rotation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         OutFootR_Rotation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Get_Foot_Offsets(float InAdjustSinking, bool InEnableFootIK_L, bool InEnableFootIK_R, bool IsUpdate_Foot_L, bool IsUpdate_Foot_R, float* OutActorSinking, float* OutFootL_Distance, float* OutFootR_Distance, struct FRotator* OutFootL_Rotation, struct FRotator* OutFootR_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get Foot Offsets");

	Params::ABP_CH_MeshBase_C_Get_Foot_Offsets Parms{};

	Parms.InAdjustSinking = InAdjustSinking;
	Parms.InEnableFootIK_L = InEnableFootIK_L;
	Parms.InEnableFootIK_R = InEnableFootIK_R;
	Parms.IsUpdate_Foot_L = IsUpdate_Foot_L;
	Parms.IsUpdate_Foot_R = IsUpdate_Foot_R;

	UObject::ProcessEvent(Func, &Parms);

	if (OutActorSinking != nullptr)
		*OutActorSinking = Parms.OutActorSinking;

	if (OutFootL_Distance != nullptr)
		*OutFootL_Distance = Parms.OutFootL_Distance;

	if (OutFootR_Distance != nullptr)
		*OutFootR_Distance = Parms.OutFootR_Distance;

	if (OutFootL_Rotation != nullptr)
		*OutFootL_Rotation = std::move(Parms.OutFootL_Rotation);

	if (OutFootR_Rotation != nullptr)
		*OutFootR_Rotation = std::move(Parms.OutFootR_Rotation);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.SetHandIK
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::SetHandIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "SetHandIK");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update IK Values
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_IK_Values()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update IK Values");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetTargetHandIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             InCurveName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             InHandName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InHandTargetVar                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InCurrentHandTargetVar                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       OutHandTargetTransform                                 (Parm, OutParm, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::GetTargetHandIK(class FName InCurveName, class FName InHandName, float& InHandTargetVar, float& InCurrentHandTargetVar, struct FTransform* OutHandTargetTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetTargetHandIK");

	Params::ABP_CH_MeshBase_C_GetTargetHandIK Parms{};

	Parms.InCurveName = InCurveName;
	Parms.InHandName = InHandName;
	Parms.InHandTargetVar = InHandTargetVar;
	Parms.InCurrentHandTargetVar = InCurrentHandTargetVar;

	UObject::ProcessEvent(Func, &Parms);

	InHandTargetVar = Parms.InHandTargetVar;
	InCurrentHandTargetVar = Parms.InCurrentHandTargetVar;

	if (OutHandTargetTransform != nullptr)
		*OutHandTargetTransform = std::move(Parms.OutHandTargetTransform);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.UpdatePhysicsAlpha
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::UpdatePhysicsAlpha()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "UpdatePhysicsAlpha");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update Lock Body
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_Lock_Body()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update Lock Body");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CulcLookatDirection_Euler
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InStartLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          InTargetLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutHorizontalAngle                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutVerticalAngle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CulcLookatDirection_Euler(const struct FVector& InStartLocation, const struct FVector& InTargetLocation, float* OutHorizontalAngle, float* OutVerticalAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CulcLookatDirection_Euler");

	Params::ABP_CH_MeshBase_C_CulcLookatDirection_Euler Parms{};

	Parms.InStartLocation = std::move(InStartLocation);
	Parms.InTargetLocation = std::move(InTargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutHorizontalAngle != nullptr)
		*OutHorizontalAngle = Parms.OutHorizontalAngle;

	if (OutVerticalAngle != nullptr)
		*OutVerticalAngle = Parms.OutVerticalAngle;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CulcLookatDirection_Vector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InStartLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         InStartRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          InTargetLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutHorizontalAngle                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutVerticalAngle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::CulcLookatDirection_Vector(const struct FVector& InStartLocation, const struct FRotator& InStartRotation, const struct FVector& InTargetLocation, float* OutHorizontalAngle, float* OutVerticalAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CulcLookatDirection_Vector");

	Params::ABP_CH_MeshBase_C_CulcLookatDirection_Vector Parms{};

	Parms.InStartLocation = std::move(InStartLocation);
	Parms.InStartRotation = std::move(InStartRotation);
	Parms.InTargetLocation = std::move(InTargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutHorizontalAngle != nullptr)
		*OutHorizontalAngle = Parms.OutHorizontalAngle;

	if (OutVerticalAngle != nullptr)
		*OutVerticalAngle = Parms.OutVerticalAngle;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update Locomotion Values
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_Locomotion_Values()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update Locomotion Values");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Update AddBleath Values
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Update_AddBleath_Values()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Update AddBleath Values");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get Layering Arms Alpha
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ArmL_R_Alpha                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Get_Layering_Arms_Alpha(float* ArmL_R_Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get Layering Arms Alpha");

	Params::ABP_CH_MeshBase_C_Get_Layering_Arms_Alpha Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ArmL_R_Alpha != nullptr)
		*ArmL_R_Alpha = Parms.ArmL_R_Alpha;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.IsLookatUpdate
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::IsLookatUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "IsLookatUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Check_UpdateFootIK
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Check_UpdateFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Check_UpdateFootIK");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set_FootDistance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   In_ActorSinking                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   In_Foot_L_Distance                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   In_Foot_R_Distance                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         In_Foot_L_Rotation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         In_Foot_R_Rotation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Set_FootDistance(float In_ActorSinking, float In_Foot_L_Distance, float In_Foot_R_Distance, const struct FRotator& In_Foot_L_Rotation, const struct FRotator& In_Foot_R_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set_FootDistance");

	Params::ABP_CH_MeshBase_C_Set_FootDistance Parms{};

	Parms.In_ActorSinking = In_ActorSinking;
	Parms.In_Foot_L_Distance = In_Foot_L_Distance;
	Parms.In_Foot_R_Distance = In_Foot_R_Distance;
	Parms.In_Foot_L_Rotation = std::move(In_Foot_L_Rotation);
	Parms.In_Foot_R_Rotation = std::move(In_Foot_R_Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set Actor Bottom Distance
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Set_Actor_Bottom_Distance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set Actor Bottom Distance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set_IsEnableLocomotionSim
// (Public, BlueprintCallable, BlueprintEvent)

void UABP_CH_MeshBase_C::Set_IsEnableLocomotionSim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set_IsEnableLocomotionSim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get Floor State
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_FloorState                         Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Get_Floor_State(Enum_FloorState* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get Floor State");

	Params::ABP_CH_MeshBase_C_Get_Floor_State Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Can Enable Post Process In Event
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Can_Enable_Post_Process_In_Event(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Can Enable Post Process In Event");

	Params::ABP_CH_MeshBase_C_Can_Enable_Post_Process_In_Event Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get_IndexHandIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             InCurveName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InHandTargetVar                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Out_IndexHandTarget                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Is_update                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Get_IndexHandIK(class FName InCurveName, float& InHandTargetVar, float* Out_IndexHandTarget, bool* Is_update)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get_IndexHandIK");

	Params::ABP_CH_MeshBase_C_Get_IndexHandIK Parms{};

	Parms.InCurveName = InCurveName;
	Parms.InHandTargetVar = InHandTargetVar;

	UObject::ProcessEvent(Func, &Parms);

	InHandTargetVar = Parms.InHandTargetVar;

	if (Out_IndexHandTarget != nullptr)
		*Out_IndexHandTarget = Parms.Out_IndexHandTarget;

	if (Is_update != nullptr)
		*Is_update = Parms.Is_update;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AnimGraph
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        AnimGraph_0                                            (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::AnimGraph(struct FPoseLink* AnimGraph_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AnimGraph");

	Params::ABP_CH_MeshBase_C_AnimGraph Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AnimGraph_0 != nullptr)
		*AnimGraph_0 = std::move(Parms.AnimGraph_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.BaseLayer
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        BaseLayer_0                                            (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::BaseLayer(struct FPoseLink* BaseLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "BaseLayer");

	Params::ABP_CH_MeshBase_C_BaseLayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BaseLayer_0 != nullptr)
		*BaseLayer_0 = std::move(Parms.BaseLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.LayerBlending
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        Base_Layer_Input                                       (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        LayerBlending_0                                        (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::LayerBlending(const struct FPoseLink& Base_Layer_Input, struct FPoseLink* LayerBlending_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "LayerBlending");

	Params::ABP_CH_MeshBase_C_LayerBlending Parms{};

	Parms.Base_Layer_Input = std::move(Base_Layer_Input);

	UObject::ProcessEvent(Func, &Parms);

	if (LayerBlending_0 != nullptr)
		*LayerBlending_0 = std::move(Parms.LayerBlending_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Foot IK
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        InPose                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        Foot_IK_0                                              (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::Foot_IK(const struct FPoseLink& InPose, struct FPoseLink* Foot_IK_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Foot IK");

	Params::ABP_CH_MeshBase_C_Foot_IK Parms{};

	Parms.InPose = std::move(InPose);

	UObject::ProcessEvent(Func, &Parms);

	if (Foot_IK_0 != nullptr)
		*Foot_IK_0 = std::move(Parms.Foot_IK_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.AssistanceBone
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        InPose_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        AssistanceBone_0                                       (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::AssistanceBone(const struct FPoseLink& InPose_0, struct FPoseLink* AssistanceBone_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "AssistanceBone");

	Params::ABP_CH_MeshBase_C_AssistanceBone Parms{};

	Parms.InPose_0 = std::move(InPose_0);

	UObject::ProcessEvent(Func, &Parms);

	if (AssistanceBone_0 != nullptr)
		*AssistanceBone_0 = std::move(Parms.AssistanceBone_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Set_AttachHandIK_Bone
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink                        InPose_1                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        Set_AttachHandIK_Bone_0                                (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::Set_AttachHandIK_Bone(const struct FPoseLink& InPose_1, struct FPoseLink* Set_AttachHandIK_Bone_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Set_AttachHandIK_Bone");

	Params::ABP_CH_MeshBase_C_Set_AttachHandIK_Bone Parms{};

	Parms.InPose_1 = std::move(InPose_1);

	UObject::ProcessEvent(Func, &Parms);

	if (Set_AttachHandIK_Bone_0 != nullptr)
		*Set_AttachHandIK_Bone_0 = std::move(Parms.Set_AttachHandIK_Bone_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CostumePhysLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseLink                        InPhysicsPose                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        CostumePhysLayer_0                                     (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::CostumePhysLayer(const struct FPoseLink& InPhysicsPose, struct FPoseLink* CostumePhysLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CostumePhysLayer");

	Params::ABP_CH_MeshBase_C_CostumePhysLayer Parms{};

	Parms.InPhysicsPose = std::move(InPhysicsPose);

	UObject::ProcessEvent(Func, &Parms);

	if (CostumePhysLayer_0 != nullptr)
		*CostumePhysLayer_0 = std::move(Parms.CostumePhysLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CustomAdditiveLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseLink                        InPose                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        CustomAdditiveLayer_0                                  (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::CustomAdditiveLayer(const struct FPoseLink& InPose, struct FPoseLink* CustomAdditiveLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CustomAdditiveLayer");

	Params::ABP_CH_MeshBase_C_CustomAdditiveLayer Parms{};

	Parms.InPose = std::move(InPose);

	UObject::ProcessEvent(Func, &Parms);

	if (CustomAdditiveLayer_0 != nullptr)
		*CustomAdditiveLayer_0 = std::move(Parms.CustomAdditiveLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.CostumeAdjustLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseLink                        InMeshPose                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        CostumeAdjustLayer_0                                   (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::CostumeAdjustLayer(const struct FPoseLink& InMeshPose, struct FPoseLink* CostumeAdjustLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "CostumeAdjustLayer");

	Params::ABP_CH_MeshBase_C_CostumeAdjustLayer Parms{};

	Parms.InMeshPose = std::move(InMeshPose);

	UObject::ProcessEvent(Func, &Parms);

	if (CostumeAdjustLayer_0 != nullptr)
		*CostumeAdjustLayer_0 = std::move(Parms.CostumeAdjustLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.HairAdjustLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseLink                        InMeshPose                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        HairAdjustLayer_0                                      (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::HairAdjustLayer(const struct FPoseLink& InMeshPose, struct FPoseLink* HairAdjustLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "HairAdjustLayer");

	Params::ABP_CH_MeshBase_C_HairAdjustLayer Parms{};

	Parms.InMeshPose = std::move(InMeshPose);

	UObject::ProcessEvent(Func, &Parms);

	if (HairAdjustLayer_0 != nullptr)
		*HairAdjustLayer_0 = std::move(Parms.HairAdjustLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.HairPhysLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseLink                        InPhysPose                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink                        HairPhysLayer_0                                        (Parm, OutParm, NoDestructor)

void UABP_CH_MeshBase_C::HairPhysLayer(const struct FPoseLink& InPhysPose, struct FPoseLink* HairPhysLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "HairPhysLayer");

	Params::ABP_CH_MeshBase_C_HairPhysLayer Parms{};

	Parms.InPhysPose = std::move(InPhysPose);

	UObject::ProcessEvent(Func, &Parms);

	if (HairPhysLayer_0 != nullptr)
		*HairPhysLayer_0 = std::move(Parms.HairPhysLayer_0);
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get_ABP_CH_MeshBaseVariable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   LookAtHorizontal                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LookAtVertical                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Out_Interp_LookatHair_H                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Out_Interp_LookatHair_V                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Out                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Upperbody_Out                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Lowerbody_Out                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Hair_Out                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Jacket_Out                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   PhysicsAlpha_Skirt_Out                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Get_ABP_CH_MeshBaseVariable(float* LookAtHorizontal, float* LookAtVertical, float* Out_Interp_LookatHair_H, float* Out_Interp_LookatHair_V, float* PhysicsAlpha_Out, float* PhysicsAlpha_Upperbody_Out, float* PhysicsAlpha_Lowerbody_Out, float* PhysicsAlpha_Hair_Out, float* PhysicsAlpha_Jacket_Out, float* PhysicsAlpha_Skirt_Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get_ABP_CH_MeshBaseVariable");

	Params::ABP_CH_MeshBase_C_Get_ABP_CH_MeshBaseVariable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LookAtHorizontal != nullptr)
		*LookAtHorizontal = Parms.LookAtHorizontal;

	if (LookAtVertical != nullptr)
		*LookAtVertical = Parms.LookAtVertical;

	if (Out_Interp_LookatHair_H != nullptr)
		*Out_Interp_LookatHair_H = Parms.Out_Interp_LookatHair_H;

	if (Out_Interp_LookatHair_V != nullptr)
		*Out_Interp_LookatHair_V = Parms.Out_Interp_LookatHair_V;

	if (PhysicsAlpha_Out != nullptr)
		*PhysicsAlpha_Out = Parms.PhysicsAlpha_Out;

	if (PhysicsAlpha_Upperbody_Out != nullptr)
		*PhysicsAlpha_Upperbody_Out = Parms.PhysicsAlpha_Upperbody_Out;

	if (PhysicsAlpha_Lowerbody_Out != nullptr)
		*PhysicsAlpha_Lowerbody_Out = Parms.PhysicsAlpha_Lowerbody_Out;

	if (PhysicsAlpha_Hair_Out != nullptr)
		*PhysicsAlpha_Hair_Out = Parms.PhysicsAlpha_Hair_Out;

	if (PhysicsAlpha_Jacket_Out != nullptr)
		*PhysicsAlpha_Jacket_Out = Parms.PhysicsAlpha_Jacket_Out;

	if (PhysicsAlpha_Skirt_Out != nullptr)
		*PhysicsAlpha_Skirt_Out = Parms.PhysicsAlpha_Skirt_Out;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get_AnimBP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimInstance*                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::Get_AnimBP(class UAnimInstance** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get_AnimBP");

	Params::ABP_CH_MeshBase_C_Get_AnimBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.Get_Enable_FootIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Out_foot_r                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Out_foot_l                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UABP_CH_MeshBase_C::Get_Enable_FootIK(bool* Out_foot_r, bool* Out_foot_l)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "Get_Enable_FootIK");

	Params::ABP_CH_MeshBase_C_Get_Enable_FootIK Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Out_foot_r != nullptr)
		*Out_foot_r = Parms.Out_foot_r;

	if (Out_foot_l != nullptr)
		*Out_foot_l = Parms.Out_foot_l;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetWalkRunBlend
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   OutWalkRunBlend                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   OutPreviousWalkRunBlend                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::GetWalkRunBlend(float* OutWalkRunBlend, float* OutPreviousWalkRunBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetWalkRunBlend");

	Params::ABP_CH_MeshBase_C_GetWalkRunBlend Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutWalkRunBlend != nullptr)
		*OutWalkRunBlend = Parms.OutWalkRunBlend;

	if (OutPreviousWalkRunBlend != nullptr)
		*OutPreviousWalkRunBlend = Parms.OutPreviousWalkRunBlend;
}


// Function ABP_CH_MeshBase.ABP_CH_MeshBase_C.GetLocomotionState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_LocomotionState                    OutLocomotionState                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UABP_CH_MeshBase_C::GetLocomotionState(Enum_LocomotionState* OutLocomotionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ABP_CH_MeshBase_C", "GetLocomotionState");

	Params::ABP_CH_MeshBase_C_GetLocomotionState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutLocomotionState != nullptr)
		*OutLocomotionState = Parms.OutLocomotionState;
}

}

