#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AIModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum AIModule.EPathFollowingResult
// NumValues: 0x0007
enum class EPathFollowingResult : uint8
{
	Success                                  = 0,
	Blocked                                  = 1,
	OffPath                                  = 2,
	Aborted                                  = 3,
	Skipped_DEPRECATED                       = 4,
	Invalid                                  = 5,
	EPathFollowingResult_MAX                 = 6,
};

// Enum AIModule.EEnvQueryStatus
// NumValues: 0x0007
enum class EEnvQueryStatus : uint8
{
	Processing                               = 0,
	Success                                  = 1,
	Failed                                   = 2,
	Aborted                                  = 3,
	OwnerLost                                = 4,
	MissingParam                             = 5,
	EEnvQueryStatus_MAX                      = 6,
};

// Enum AIModule.EAISenseNotifyType
// NumValues: 0x0003
enum class EAISenseNotifyType : uint8
{
	OnEveryPerception                        = 0,
	OnPerceptionChange                       = 1,
	EAISenseNotifyType_MAX                   = 2,
};

// Enum AIModule.EAITaskPriority
// NumValues: 0x0006
enum class EAITaskPriority : uint8
{
	Lowest                                   = 0,
	Low                                      = 64,
	AutonomousAI                             = 127,
	High                                     = 192,
	Ultimate                                 = 254,
	EAITaskPriority_MAX                      = 255,
};

// Enum AIModule.EGenericAICheck
// NumValues: 0x0008
enum class EGenericAICheck : uint8
{
	Less                                     = 0,
	LessOrEqual                              = 1,
	Equal                                    = 2,
	NotEqual                                 = 3,
	GreaterOrEqual                           = 4,
	Greater                                  = 5,
	IsTrue                                   = 6,
	MAX                                      = 7,
};

// Enum AIModule.EAILockSource
// NumValues: 0x0005
enum class EAILockSource : uint8
{
	Animation                                = 0,
	Logic                                    = 1,
	Script                                   = 2,
	Gameplay                                 = 3,
	MAX                                      = 4,
};

// Enum AIModule.EAIRequestPriority
// NumValues: 0x0006
enum class EAIRequestPriority : uint8
{
	SoftScript                               = 0,
	Logic                                    = 1,
	HardScript                               = 2,
	Reaction                                 = 3,
	Ultimate                                 = 4,
	MAX                                      = 5,
};

// Enum AIModule.EPawnActionEventType
// NumValues: 0x0007
enum class EPawnActionEventType : uint8
{
	Invalid                                  = 0,
	FailedToStart                            = 1,
	InstantAbort                             = 2,
	FinishedAborting                         = 3,
	FinishedExecution                        = 4,
	Push                                     = 5,
	EPawnActionEventType_MAX                 = 6,
};

// Enum AIModule.EPawnActionResult
// NumValues: 0x0006
enum class EPawnActionResult : uint8
{
	NotStarted                               = 0,
	InProgress                               = 1,
	Success                                  = 2,
	Failed                                   = 3,
	Aborted                                  = 4,
	EPawnActionResult_MAX                    = 5,
};

// Enum AIModule.EPawnActionAbortState
// NumValues: 0x0006
enum class EPawnActionAbortState : uint8
{
	NeverStarted                             = 0,
	NotBeingAborted                          = 1,
	MarkPendingAbort                         = 2,
	LatentAbortInProgress                    = 3,
	AbortDone                                = 4,
	MAX                                      = 5,
};

// Enum AIModule.FAIDistanceType
// NumValues: 0x0004
enum class EFAIDistanceType : uint8
{
	Distance3D                               = 0,
	Distance2D                               = 1,
	DistanceZ                                = 2,
	MAX                                      = 3,
};

// Enum AIModule.EAIOptionFlag
// NumValues: 0x0004
enum class EAIOptionFlag : uint8
{
	Default                                  = 0,
	Enable                                   = 1,
	Disable                                  = 2,
	MAX                                      = 3,
};

// Enum AIModule.EBTFlowAbortMode
// NumValues: 0x0005
enum class EBTFlowAbortMode : uint8
{
	None                                     = 0,
	LowerPriority                            = 1,
	Self                                     = 2,
	Both                                     = 3,
	EBTFlowAbortMode_MAX                     = 4,
};

// Enum AIModule.EBTNodeResult
// NumValues: 0x0005
enum class EBTNodeResult : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	Aborted                                  = 2,
	InProgress                               = 3,
	EBTNodeResult_MAX                        = 4,
};

// Enum AIModule.ETextKeyOperation
// NumValues: 0x0005
enum class ETextKeyOperation : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Contain                                  = 2,
	NotContain                               = 3,
	ETextKeyOperation_MAX                    = 4,
};

// Enum AIModule.EArithmeticKeyOperation
// NumValues: 0x0007
enum class EArithmeticKeyOperation : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Less                                     = 2,
	LessOrEqual                              = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	EArithmeticKeyOperation_MAX              = 6,
};

// Enum AIModule.EBasicKeyOperation
// NumValues: 0x0003
enum class EBasicKeyOperation : uint8
{
	Set                                      = 0,
	NotSet                                   = 1,
	EBasicKeyOperation_MAX                   = 2,
};

// Enum AIModule.EBTParallelMode
// NumValues: 0x0003
enum class EBTParallelMode : uint8
{
	AbortBackground                          = 0,
	WaitForBackground                        = 1,
	EBTParallelMode_MAX                      = 2,
};

// Enum AIModule.EBTDecoratorLogic
// NumValues: 0x0006
enum class EBTDecoratorLogic : uint8
{
	Invalid                                  = 0,
	Test                                     = 1,
	And                                      = 2,
	Or                                       = 3,
	Not                                      = 4,
	EBTDecoratorLogic_MAX                    = 5,
};

// Enum AIModule.EBTChildIndex
// NumValues: 0x0003
enum class EBTChildIndex : uint8
{
	FirstNode                                = 0,
	TaskNode                                 = 1,
	EBTChildIndex_MAX                        = 2,
};

// Enum AIModule.EBTBlackboardRestart
// NumValues: 0x0003
enum class EBTBlackboardRestart : uint8
{
	ValueChange                              = 0,
	ResultChange                             = 1,
	EBTBlackboardRestart_MAX                 = 2,
};

// Enum AIModule.EBlackBoardEntryComparison
// NumValues: 0x0003
enum class EBlackBoardEntryComparison : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	EBlackBoardEntryComparison_MAX           = 2,
};

// Enum AIModule.EPathExistanceQueryType
// NumValues: 0x0004
enum class EPathExistanceQueryType : uint8
{
	NavmeshRaycast2D                         = 0,
	HierarchicalQuery                        = 1,
	RegularPathFinding                       = 2,
	EPathExistanceQueryType_MAX              = 3,
};

// Enum AIModule.EPointOnCircleSpacingMethod
// NumValues: 0x0003
enum class EPointOnCircleSpacingMethod : uint8
{
	BySpaceBetween                           = 0,
	ByNumberOfPoints                         = 1,
	EPointOnCircleSpacingMethod_MAX          = 2,
};

// Enum AIModule.EEQSNormalizationType
// NumValues: 0x0003
enum class EEQSNormalizationType : uint8
{
	Absolute                                 = 0,
	RelativeToScores                         = 1,
	EEQSNormalizationType_MAX                = 2,
};

// Enum AIModule.EEnvTestDistance
// NumValues: 0x0005
enum class EEnvTestDistance : uint8
{
	Distance3D                               = 0,
	Distance2D                               = 1,
	DistanceZ                                = 2,
	DistanceAbsoluteZ                        = 3,
	EEnvTestDistance_MAX                     = 4,
};

// Enum AIModule.EEnvTestDot
// NumValues: 0x0003
enum class EEnvTestDot : uint8
{
	Dot3D                                    = 0,
	Dot2D                                    = 1,
	EEnvTestDot_MAX                          = 2,
};

// Enum AIModule.EEnvTestPathfinding
// NumValues: 0x0004
enum class EEnvTestPathfinding : uint8
{
	PathExist                                = 0,
	PathCost                                 = 1,
	PathLength                               = 2,
	EEnvTestPathfinding_MAX                  = 3,
};

// Enum AIModule.EEnvQueryTestClamping
// NumValues: 0x0004
enum class EEnvQueryTestClamping : uint8
{
	None                                     = 0,
	SpecifiedValue                           = 1,
	FilterThreshold                          = 2,
	EEnvQueryTestClamping_MAX                = 3,
};

// Enum AIModule.EEnvDirection
// NumValues: 0x0003
enum class EEnvDirection : uint8
{
	TwoPoints                                = 0,
	Rotation                                 = 1,
	EEnvDirection_MAX                        = 2,
};

// Enum AIModule.EEnvOverlapShape
// NumValues: 0x0004
enum class EEnvOverlapShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	EEnvOverlapShape_MAX                     = 3,
};

// Enum AIModule.EEnvTraceShape
// NumValues: 0x0005
enum class EEnvTraceShape : uint8
{
	Line                                     = 0,
	Box                                      = 1,
	Sphere                                   = 2,
	Capsule                                  = 3,
	EEnvTraceShape_MAX                       = 4,
};

// Enum AIModule.EEnvQueryTrace
// NumValues: 0x0005
enum class EEnvQueryTrace : uint8
{
	None                                     = 0,
	Navigation                               = 1,
	Geometry                                 = 2,
	NavigationOverLedges                     = 3,
	EEnvQueryTrace_MAX                       = 4,
};

// Enum AIModule.EAIParamType
// NumValues: 0x0004
enum class EAIParamType : uint8
{
	Float                                    = 0,
	Int                                      = 1,
	Bool                                     = 2,
	MAX                                      = 3,
};

// Enum AIModule.EEnvQueryParam
// NumValues: 0x0004
enum class EEnvQueryParam : uint8
{
	Float                                    = 0,
	Int                                      = 1,
	Bool                                     = 2,
	EEnvQueryParam_MAX                       = 3,
};

// Enum AIModule.EEnvQueryRunMode
// NumValues: 0x0005
enum class EEnvQueryRunMode : uint8
{
	SingleResult                             = 0,
	RandomBest5Pct                           = 1,
	RandomBest25Pct                          = 2,
	AllMatching                              = 3,
	EEnvQueryRunMode_MAX                     = 4,
};

// Enum AIModule.EEnvTestScoreOperator
// NumValues: 0x0005
enum class EEnvTestScoreOperator : uint8
{
	AverageScore                             = 0,
	MinScore                                 = 1,
	MaxScore                                 = 2,
	Multiply                                 = 3,
	EEnvTestScoreOperator_MAX                = 4,
};

// Enum AIModule.EEnvTestFilterOperator
// NumValues: 0x0003
enum class EEnvTestFilterOperator : uint8
{
	AllPass                                  = 0,
	AnyPass                                  = 1,
	EEnvTestFilterOperator_MAX               = 2,
};

// Enum AIModule.EEnvTestCost
// NumValues: 0x0004
enum class EEnvTestCost : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	EEnvTestCost_MAX                         = 3,
};

// Enum AIModule.EEnvTestWeight
// NumValues: 0x0007
enum class EEnvTestWeight : uint8
{
	None                                     = 0,
	Square                                   = 1,
	Inverse                                  = 2,
	Unused                                   = 3,
	Constant                                 = 4,
	Skip                                     = 5,
	EEnvTestWeight_MAX                       = 6,
};

// Enum AIModule.EEnvTestScoreEquation
// NumValues: 0x0006
enum class EEnvTestScoreEquation : uint8
{
	Linear                                   = 0,
	Square                                   = 1,
	InverseLinear                            = 2,
	SquareRoot                               = 3,
	Constant                                 = 4,
	EEnvTestScoreEquation_MAX                = 5,
};

// Enum AIModule.EEnvTestFilterType
// NumValues: 0x0005
enum class EEnvTestFilterType : uint8
{
	Minimum                                  = 0,
	Maximum                                  = 1,
	Range                                    = 2,
	Match                                    = 3,
	EEnvTestFilterType_MAX                   = 4,
};

// Enum AIModule.EEnvTestPurpose
// NumValues: 0x0004
enum class EEnvTestPurpose : uint8
{
	Filter                                   = 0,
	Score                                    = 1,
	FilterAndScore                           = 2,
	EEnvTestPurpose_MAX                      = 3,
};

// Enum AIModule.EEnvQueryHightlightMode
// NumValues: 0x0004
enum class EEnvQueryHightlightMode : uint8
{
	All                                      = 0,
	Best5Pct                                 = 1,
	Best25Pct                                = 2,
	EEnvQueryHightlightMode_MAX              = 3,
};

// Enum AIModule.ETeamAttitude
// NumValues: 0x0004
enum class ETeamAttitude : uint8
{
	Friendly                                 = 0,
	Neutral                                  = 1,
	Hostile                                  = 2,
	ETeamAttitude_MAX                        = 3,
};

// Enum AIModule.EPathFollowingRequestResult
// NumValues: 0x0004
enum class EPathFollowingRequestResult : uint8
{
	Failed                                   = 0,
	AlreadyAtGoal                            = 1,
	RequestSuccessful                        = 2,
	EPathFollowingRequestResult_MAX          = 3,
};

// Enum AIModule.EPathFollowingAction
// NumValues: 0x0006
enum class EPathFollowingAction : uint8
{
	Error                                    = 0,
	NoMove                                   = 1,
	DirectMove                               = 2,
	PartialPath                              = 3,
	PathToGoal                               = 4,
	EPathFollowingAction_MAX                 = 5,
};

// Enum AIModule.EPathFollowingStatus
// NumValues: 0x0005
enum class EPathFollowingStatus : uint8
{
	Idle                                     = 0,
	Waiting                                  = 1,
	Paused                                   = 2,
	Moving                                   = 3,
	EPathFollowingStatus_MAX                 = 4,
};

// Enum AIModule.EPawnActionFailHandling
// NumValues: 0x0003
enum class EPawnActionFailHandling : uint8
{
	RequireSuccess                           = 0,
	IgnoreFailure                            = 1,
	EPawnActionFailHandling_MAX              = 2,
};

// Enum AIModule.EPawnSubActionTriggeringPolicy
// NumValues: 0x0003
enum class EPawnSubActionTriggeringPolicy : uint8
{
	CopyBeforeTriggering                     = 0,
	ReuseInstances                           = 1,
	EPawnSubActionTriggeringPolicy_MAX       = 2,
};

// Enum AIModule.EPawnActionMoveMode
// NumValues: 0x0003
enum class EPawnActionMoveMode : uint8
{
	UsePathfinding                           = 0,
	StraightLine                             = 1,
	EPawnActionMoveMode_MAX                  = 2,
};

// ScriptStruct AIModule.AIDataProviderValue
// 0x0020 (0x0020 - 0x0000)
struct FAIDataProviderValue
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIDataProvider*                        DataBinding;                                       // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataField;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDataProviderValue) == 0x000008, "Wrong alignment on FAIDataProviderValue");
static_assert(sizeof(FAIDataProviderValue) == 0x000020, "Wrong size on FAIDataProviderValue");
static_assert(offsetof(FAIDataProviderValue, DataBinding) == 0x000010, "Member 'FAIDataProviderValue::DataBinding' has a wrong offset!");
static_assert(offsetof(FAIDataProviderValue, DataField) == 0x000018, "Member 'FAIDataProviderValue::DataField' has a wrong offset!");

// ScriptStruct AIModule.AIDataProviderTypedValue
// 0x0010 (0x0030 - 0x0020)
struct FAIDataProviderTypedValue : public FAIDataProviderValue
{
public:
	class UClass*                                 PropertyType;                                      // 0x0020(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataProviderTypedValue) == 0x000008, "Wrong alignment on FAIDataProviderTypedValue");
static_assert(sizeof(FAIDataProviderTypedValue) == 0x000030, "Wrong size on FAIDataProviderTypedValue");
static_assert(offsetof(FAIDataProviderTypedValue, PropertyType) == 0x000020, "Member 'FAIDataProviderTypedValue::PropertyType' has a wrong offset!");

// ScriptStruct AIModule.AIDataProviderBoolValue
// 0x0008 (0x0038 - 0x0030)
struct FAIDataProviderBoolValue final : public FAIDataProviderTypedValue
{
public:
	bool                                          DefaultValue;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataProviderBoolValue) == 0x000008, "Wrong alignment on FAIDataProviderBoolValue");
static_assert(sizeof(FAIDataProviderBoolValue) == 0x000038, "Wrong size on FAIDataProviderBoolValue");
static_assert(offsetof(FAIDataProviderBoolValue, DefaultValue) == 0x000030, "Member 'FAIDataProviderBoolValue::DefaultValue' has a wrong offset!");

// ScriptStruct AIModule.AIRequestID
// 0x0004 (0x0004 - 0x0000)
struct FAIRequestID final
{
public:
	uint32                                        RequestID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAIRequestID) == 0x000004, "Wrong alignment on FAIRequestID");
static_assert(sizeof(FAIRequestID) == 0x000004, "Wrong size on FAIRequestID");
static_assert(offsetof(FAIRequestID, RequestID) == 0x000000, "Member 'FAIRequestID::RequestID' has a wrong offset!");

// ScriptStruct AIModule.AIDataProviderFloatValue
// 0x0008 (0x0038 - 0x0030)
struct FAIDataProviderFloatValue final : public FAIDataProviderTypedValue
{
public:
	float                                         DefaultValue;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataProviderFloatValue) == 0x000008, "Wrong alignment on FAIDataProviderFloatValue");
static_assert(sizeof(FAIDataProviderFloatValue) == 0x000038, "Wrong size on FAIDataProviderFloatValue");
static_assert(offsetof(FAIDataProviderFloatValue, DefaultValue) == 0x000030, "Member 'FAIDataProviderFloatValue::DefaultValue' has a wrong offset!");

// ScriptStruct AIModule.AIStimulus
// 0x003C (0x003C - 0x0000)
struct FAIStimulus final
{
public:
	float                                         Age;                                               // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpirationAge;                                     // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StimulusLocation;                                  // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReceiverLocation;                                  // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0024(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_38_0 : 1;                                   // 0x0038(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSuccessfullySensed : 1;                           // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStimulus) == 0x000004, "Wrong alignment on FAIStimulus");
static_assert(sizeof(FAIStimulus) == 0x00003C, "Wrong size on FAIStimulus");
static_assert(offsetof(FAIStimulus, Age) == 0x000000, "Member 'FAIStimulus::Age' has a wrong offset!");
static_assert(offsetof(FAIStimulus, ExpirationAge) == 0x000004, "Member 'FAIStimulus::ExpirationAge' has a wrong offset!");
static_assert(offsetof(FAIStimulus, Strength) == 0x000008, "Member 'FAIStimulus::Strength' has a wrong offset!");
static_assert(offsetof(FAIStimulus, StimulusLocation) == 0x00000C, "Member 'FAIStimulus::StimulusLocation' has a wrong offset!");
static_assert(offsetof(FAIStimulus, ReceiverLocation) == 0x000018, "Member 'FAIStimulus::ReceiverLocation' has a wrong offset!");
static_assert(offsetof(FAIStimulus, Tag) == 0x000024, "Member 'FAIStimulus::Tag' has a wrong offset!");

// ScriptStruct AIModule.ActorPerceptionUpdateInfo
// 0x0048 (0x0048 - 0x0000)
struct FActorPerceptionUpdateInfo final
{
public:
	int32                                         TargetID;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x000C(0x003C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorPerceptionUpdateInfo) == 0x000004, "Wrong alignment on FActorPerceptionUpdateInfo");
static_assert(sizeof(FActorPerceptionUpdateInfo) == 0x000048, "Wrong size on FActorPerceptionUpdateInfo");
static_assert(offsetof(FActorPerceptionUpdateInfo, TargetID) == 0x000000, "Member 'FActorPerceptionUpdateInfo::TargetID' has a wrong offset!");
static_assert(offsetof(FActorPerceptionUpdateInfo, Target) == 0x000004, "Member 'FActorPerceptionUpdateInfo::Target' has a wrong offset!");
static_assert(offsetof(FActorPerceptionUpdateInfo, Stimulus) == 0x00000C, "Member 'FActorPerceptionUpdateInfo::Stimulus' has a wrong offset!");

// ScriptStruct AIModule.AIDataProviderIntValue
// 0x0008 (0x0038 - 0x0030)
struct FAIDataProviderIntValue final : public FAIDataProviderTypedValue
{
public:
	int32                                         DefaultValue;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataProviderIntValue) == 0x000008, "Wrong alignment on FAIDataProviderIntValue");
static_assert(sizeof(FAIDataProviderIntValue) == 0x000038, "Wrong size on FAIDataProviderIntValue");
static_assert(offsetof(FAIDataProviderIntValue, DefaultValue) == 0x000030, "Member 'FAIDataProviderIntValue::DefaultValue' has a wrong offset!");

// ScriptStruct AIModule.AIDataProviderStructValue
// 0x0010 (0x0030 - 0x0020)
struct FAIDataProviderStructValue final : public FAIDataProviderValue
{
public:
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataProviderStructValue) == 0x000008, "Wrong alignment on FAIDataProviderStructValue");
static_assert(sizeof(FAIDataProviderStructValue) == 0x000030, "Wrong size on FAIDataProviderStructValue");

// ScriptStruct AIModule.ActorPerceptionBlueprintInfo
// 0x0020 (0x0020 - 0x0000)
struct FActorPerceptionBlueprintInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIStimulus>                    LastSensedStimuli;                                 // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bIsHostile : 1;                                    // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorPerceptionBlueprintInfo) == 0x000008, "Wrong alignment on FActorPerceptionBlueprintInfo");
static_assert(sizeof(FActorPerceptionBlueprintInfo) == 0x000020, "Wrong size on FActorPerceptionBlueprintInfo");
static_assert(offsetof(FActorPerceptionBlueprintInfo, Target) == 0x000000, "Member 'FActorPerceptionBlueprintInfo::Target' has a wrong offset!");
static_assert(offsetof(FActorPerceptionBlueprintInfo, LastSensedStimuli) == 0x000008, "Member 'FActorPerceptionBlueprintInfo::LastSensedStimuli' has a wrong offset!");

// ScriptStruct AIModule.AISenseAffiliationFilter
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAISenseAffiliationFilter final
{
public:
	uint8                                         bDetectEnemies : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDetectNeutrals : 1;                               // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDetectFriendlies : 1;                             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISenseAffiliationFilter) == 0x000004, "Wrong alignment on FAISenseAffiliationFilter");
static_assert(sizeof(FAISenseAffiliationFilter) == 0x000004, "Wrong size on FAISenseAffiliationFilter");

// ScriptStruct AIModule.AIDamageEvent
// 0x0038 (0x0038 - 0x0000)
struct FAIDamageEvent final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamagedActor;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDamageEvent) == 0x000008, "Wrong alignment on FAIDamageEvent");
static_assert(sizeof(FAIDamageEvent) == 0x000038, "Wrong size on FAIDamageEvent");
static_assert(offsetof(FAIDamageEvent, Amount) == 0x000000, "Member 'FAIDamageEvent::Amount' has a wrong offset!");
static_assert(offsetof(FAIDamageEvent, Location) == 0x000004, "Member 'FAIDamageEvent::Location' has a wrong offset!");
static_assert(offsetof(FAIDamageEvent, HitLocation) == 0x000010, "Member 'FAIDamageEvent::HitLocation' has a wrong offset!");
static_assert(offsetof(FAIDamageEvent, DamagedActor) == 0x000020, "Member 'FAIDamageEvent::DamagedActor' has a wrong offset!");
static_assert(offsetof(FAIDamageEvent, Instigator) == 0x000028, "Member 'FAIDamageEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAIDamageEvent, Tag) == 0x000030, "Member 'FAIDamageEvent::Tag' has a wrong offset!");

// ScriptStruct AIModule.AINoiseEvent
// 0x0030 (0x0030 - 0x0000)
struct FAINoiseEvent final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoiseLocation;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAINoiseEvent) == 0x000008, "Wrong alignment on FAINoiseEvent");
static_assert(sizeof(FAINoiseEvent) == 0x000030, "Wrong size on FAINoiseEvent");
static_assert(offsetof(FAINoiseEvent, NoiseLocation) == 0x000004, "Member 'FAINoiseEvent::NoiseLocation' has a wrong offset!");
static_assert(offsetof(FAINoiseEvent, Loudness) == 0x000010, "Member 'FAINoiseEvent::Loudness' has a wrong offset!");
static_assert(offsetof(FAINoiseEvent, MaxRange) == 0x000014, "Member 'FAINoiseEvent::MaxRange' has a wrong offset!");
static_assert(offsetof(FAINoiseEvent, Instigator) == 0x000018, "Member 'FAINoiseEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAINoiseEvent, Tag) == 0x000020, "Member 'FAINoiseEvent::Tag' has a wrong offset!");

// ScriptStruct AIModule.AIPredictionEvent
// 0x0018 (0x0018 - 0x0000)
struct FAIPredictionEvent final
{
public:
	class AActor*                                 Requestor;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PredictedActor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPredictionEvent) == 0x000008, "Wrong alignment on FAIPredictionEvent");
static_assert(sizeof(FAIPredictionEvent) == 0x000018, "Wrong size on FAIPredictionEvent");
static_assert(offsetof(FAIPredictionEvent, Requestor) == 0x000000, "Member 'FAIPredictionEvent::Requestor' has a wrong offset!");
static_assert(offsetof(FAIPredictionEvent, PredictedActor) == 0x000008, "Member 'FAIPredictionEvent::PredictedActor' has a wrong offset!");

// ScriptStruct AIModule.AISightEvent
// 0x0018 (0x0018 - 0x0000)
struct FAISightEvent final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SeenActor;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Observer;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISightEvent) == 0x000008, "Wrong alignment on FAISightEvent");
static_assert(sizeof(FAISightEvent) == 0x000018, "Wrong size on FAISightEvent");
static_assert(offsetof(FAISightEvent, SeenActor) == 0x000008, "Member 'FAISightEvent::SeenActor' has a wrong offset!");
static_assert(offsetof(FAISightEvent, Observer) == 0x000010, "Member 'FAISightEvent::Observer' has a wrong offset!");

// ScriptStruct AIModule.AITeamStimulusEvent
// 0x0038 (0x0038 - 0x0000)
struct FAITeamStimulusEvent final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Broadcaster;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Enemy;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITeamStimulusEvent) == 0x000008, "Wrong alignment on FAITeamStimulusEvent");
static_assert(sizeof(FAITeamStimulusEvent) == 0x000038, "Wrong size on FAITeamStimulusEvent");
static_assert(offsetof(FAITeamStimulusEvent, Broadcaster) == 0x000028, "Member 'FAITeamStimulusEvent::Broadcaster' has a wrong offset!");
static_assert(offsetof(FAITeamStimulusEvent, Enemy) == 0x000030, "Member 'FAITeamStimulusEvent::Enemy' has a wrong offset!");

// ScriptStruct AIModule.AITouchEvent
// 0x0020 (0x0020 - 0x0000)
struct FAITouchEvent final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TouchReceiver;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITouchEvent) == 0x000008, "Wrong alignment on FAITouchEvent");
static_assert(sizeof(FAITouchEvent) == 0x000020, "Wrong size on FAITouchEvent");
static_assert(offsetof(FAITouchEvent, TouchReceiver) == 0x000010, "Member 'FAITouchEvent::TouchReceiver' has a wrong offset!");
static_assert(offsetof(FAITouchEvent, OtherActor) == 0x000018, "Member 'FAITouchEvent::OtherActor' has a wrong offset!");

// ScriptStruct AIModule.IntervalCountdown
// 0x0008 (0x0008 - 0x0000)
struct FIntervalCountdown final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntervalCountdown) == 0x000004, "Wrong alignment on FIntervalCountdown");
static_assert(sizeof(FIntervalCountdown) == 0x000008, "Wrong size on FIntervalCountdown");
static_assert(offsetof(FIntervalCountdown, Interval) == 0x000000, "Member 'FIntervalCountdown::Interval' has a wrong offset!");

// ScriptStruct AIModule.AIMoveRequest
// 0x0040 (0x0040 - 0x0000)
struct FAIMoveRequest final
{
public:
	class AActor*                                 GoalActor;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIMoveRequest) == 0x000008, "Wrong alignment on FAIMoveRequest");
static_assert(sizeof(FAIMoveRequest) == 0x000040, "Wrong size on FAIMoveRequest");
static_assert(offsetof(FAIMoveRequest, GoalActor) == 0x000000, "Member 'FAIMoveRequest::GoalActor' has a wrong offset!");

// ScriptStruct AIModule.BehaviorTreeTemplateInfo
// 0x0018 (0x0018 - 0x0000)
struct FBehaviorTreeTemplateInfo final
{
public:
	class UBehaviorTree*                          Asset;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBTCompositeNode*                       Template;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBehaviorTreeTemplateInfo) == 0x000008, "Wrong alignment on FBehaviorTreeTemplateInfo");
static_assert(sizeof(FBehaviorTreeTemplateInfo) == 0x000018, "Wrong size on FBehaviorTreeTemplateInfo");
static_assert(offsetof(FBehaviorTreeTemplateInfo, Asset) == 0x000000, "Member 'FBehaviorTreeTemplateInfo::Asset' has a wrong offset!");
static_assert(offsetof(FBehaviorTreeTemplateInfo, Template) == 0x000008, "Member 'FBehaviorTreeTemplateInfo::Template' has a wrong offset!");

// ScriptStruct AIModule.BlackboardKeySelector
// 0x0028 (0x0028 - 0x0000)
struct FBlackboardKeySelector final
{
public:
	TArray<class UBlackboardKeyType*>             AllowedTypes;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FName                                   SelectedKeyName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBlackboardKeyType>         SelectedKeyType;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SelectedKeyID;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bNoneIsAllowedValue : 1;                           // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlackboardKeySelector) == 0x000008, "Wrong alignment on FBlackboardKeySelector");
static_assert(sizeof(FBlackboardKeySelector) == 0x000028, "Wrong size on FBlackboardKeySelector");
static_assert(offsetof(FBlackboardKeySelector, AllowedTypes) == 0x000000, "Member 'FBlackboardKeySelector::AllowedTypes' has a wrong offset!");
static_assert(offsetof(FBlackboardKeySelector, SelectedKeyName) == 0x000010, "Member 'FBlackboardKeySelector::SelectedKeyName' has a wrong offset!");
static_assert(offsetof(FBlackboardKeySelector, SelectedKeyType) == 0x000018, "Member 'FBlackboardKeySelector::SelectedKeyType' has a wrong offset!");
static_assert(offsetof(FBlackboardKeySelector, SelectedKeyID) == 0x000020, "Member 'FBlackboardKeySelector::SelectedKeyID' has a wrong offset!");

// ScriptStruct AIModule.BlackboardEntry
// 0x0018 (0x0018 - 0x0000)
struct FBlackboardEntry final
{
public:
	class FName                                   EntryName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardKeyType*                     KeyType;                                           // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInstanceSynced : 1;                               // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlackboardEntry) == 0x000008, "Wrong alignment on FBlackboardEntry");
static_assert(sizeof(FBlackboardEntry) == 0x000018, "Wrong size on FBlackboardEntry");
static_assert(offsetof(FBlackboardEntry, EntryName) == 0x000000, "Member 'FBlackboardEntry::EntryName' has a wrong offset!");
static_assert(offsetof(FBlackboardEntry, KeyType) == 0x000008, "Member 'FBlackboardEntry::KeyType' has a wrong offset!");

// ScriptStruct AIModule.BTDecoratorLogic
// 0x0004 (0x0004 - 0x0000)
struct FBTDecoratorLogic final
{
public:
	EBTDecoratorLogic                             Operation;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Number;                                            // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBTDecoratorLogic) == 0x000002, "Wrong alignment on FBTDecoratorLogic");
static_assert(sizeof(FBTDecoratorLogic) == 0x000004, "Wrong size on FBTDecoratorLogic");
static_assert(offsetof(FBTDecoratorLogic, Operation) == 0x000000, "Member 'FBTDecoratorLogic::Operation' has a wrong offset!");
static_assert(offsetof(FBTDecoratorLogic, Number) == 0x000002, "Member 'FBTDecoratorLogic::Number' has a wrong offset!");

// ScriptStruct AIModule.BTCompositeChild
// 0x0030 (0x0030 - 0x0000)
struct FBTCompositeChild final
{
public:
	class UBTCompositeNode*                       ChildComposite;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBTTaskNode*                            ChildTask;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBTDecorator*>                   Decorators;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBTDecoratorLogic>              DecoratorOps;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBTCompositeChild) == 0x000008, "Wrong alignment on FBTCompositeChild");
static_assert(sizeof(FBTCompositeChild) == 0x000030, "Wrong size on FBTCompositeChild");
static_assert(offsetof(FBTCompositeChild, ChildComposite) == 0x000000, "Member 'FBTCompositeChild::ChildComposite' has a wrong offset!");
static_assert(offsetof(FBTCompositeChild, ChildTask) == 0x000008, "Member 'FBTCompositeChild::ChildTask' has a wrong offset!");
static_assert(offsetof(FBTCompositeChild, Decorators) == 0x000010, "Member 'FBTCompositeChild::Decorators' has a wrong offset!");
static_assert(offsetof(FBTCompositeChild, DecoratorOps) == 0x000020, "Member 'FBTCompositeChild::DecoratorOps' has a wrong offset!");

// ScriptStruct AIModule.CrowdAvoidanceSamplingPattern
// 0x0020 (0x0020 - 0x0000)
struct FCrowdAvoidanceSamplingPattern final
{
public:
	TArray<float>                                 Angles;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Radii;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrowdAvoidanceSamplingPattern) == 0x000008, "Wrong alignment on FCrowdAvoidanceSamplingPattern");
static_assert(sizeof(FCrowdAvoidanceSamplingPattern) == 0x000020, "Wrong size on FCrowdAvoidanceSamplingPattern");
static_assert(offsetof(FCrowdAvoidanceSamplingPattern, Angles) == 0x000000, "Member 'FCrowdAvoidanceSamplingPattern::Angles' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceSamplingPattern, Radii) == 0x000010, "Member 'FCrowdAvoidanceSamplingPattern::Radii' has a wrong offset!");

// ScriptStruct AIModule.CrowdAvoidanceConfig
// 0x001C (0x001C - 0x0000)
struct FCrowdAvoidanceConfig final
{
public:
	float                                         VelocityBias;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredVelocityWeight;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentVelocityWeight;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideBiasWeight;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactTimeWeight;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactTimeRange;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CustomPatternIdx;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AdaptiveDivisions;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AdaptiveRings;                                     // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AdaptiveDepth;                                     // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrowdAvoidanceConfig) == 0x000004, "Wrong alignment on FCrowdAvoidanceConfig");
static_assert(sizeof(FCrowdAvoidanceConfig) == 0x00001C, "Wrong size on FCrowdAvoidanceConfig");
static_assert(offsetof(FCrowdAvoidanceConfig, VelocityBias) == 0x000000, "Member 'FCrowdAvoidanceConfig::VelocityBias' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, DesiredVelocityWeight) == 0x000004, "Member 'FCrowdAvoidanceConfig::DesiredVelocityWeight' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, CurrentVelocityWeight) == 0x000008, "Member 'FCrowdAvoidanceConfig::CurrentVelocityWeight' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, SideBiasWeight) == 0x00000C, "Member 'FCrowdAvoidanceConfig::SideBiasWeight' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, ImpactTimeWeight) == 0x000010, "Member 'FCrowdAvoidanceConfig::ImpactTimeWeight' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, ImpactTimeRange) == 0x000014, "Member 'FCrowdAvoidanceConfig::ImpactTimeRange' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, CustomPatternIdx) == 0x000018, "Member 'FCrowdAvoidanceConfig::CustomPatternIdx' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, AdaptiveDivisions) == 0x000019, "Member 'FCrowdAvoidanceConfig::AdaptiveDivisions' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, AdaptiveRings) == 0x00001A, "Member 'FCrowdAvoidanceConfig::AdaptiveRings' has a wrong offset!");
static_assert(offsetof(FCrowdAvoidanceConfig, AdaptiveDepth) == 0x00001B, "Member 'FCrowdAvoidanceConfig::AdaptiveDepth' has a wrong offset!");

// ScriptStruct AIModule.EnvQueryInstanceCache
// 0x0178 (0x0178 - 0x0000)
struct FEnvQueryInstanceCache final
{
public:
	class UEnvQuery*                              Template;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x170];                                      // 0x0008(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvQueryInstanceCache) == 0x000008, "Wrong alignment on FEnvQueryInstanceCache");
static_assert(sizeof(FEnvQueryInstanceCache) == 0x000178, "Wrong size on FEnvQueryInstanceCache");
static_assert(offsetof(FEnvQueryInstanceCache, Template) == 0x000000, "Member 'FEnvQueryInstanceCache::Template' has a wrong offset!");

// ScriptStruct AIModule.EnvQueryRequest
// 0x0068 (0x0068 - 0x0000)
struct FEnvQueryRequest final
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                Owner;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x50];                                      // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvQueryRequest) == 0x000008, "Wrong alignment on FEnvQueryRequest");
static_assert(sizeof(FEnvQueryRequest) == 0x000068, "Wrong size on FEnvQueryRequest");
static_assert(offsetof(FEnvQueryRequest, QueryTemplate) == 0x000000, "Member 'FEnvQueryRequest::QueryTemplate' has a wrong offset!");
static_assert(offsetof(FEnvQueryRequest, Owner) == 0x000008, "Member 'FEnvQueryRequest::Owner' has a wrong offset!");
static_assert(offsetof(FEnvQueryRequest, World) == 0x000010, "Member 'FEnvQueryRequest::World' has a wrong offset!");

// ScriptStruct AIModule.AIDynamicParam
// 0x0038 (0x0038 - 0x0000)
struct FAIDynamicParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIParamType                                  ParamType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBKey;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDynamicParam) == 0x000008, "Wrong alignment on FAIDynamicParam");
static_assert(sizeof(FAIDynamicParam) == 0x000038, "Wrong size on FAIDynamicParam");
static_assert(offsetof(FAIDynamicParam, ParamName) == 0x000000, "Member 'FAIDynamicParam::ParamName' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam, ParamType) == 0x000008, "Member 'FAIDynamicParam::ParamType' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam, Value) == 0x00000C, "Member 'FAIDynamicParam::Value' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam, BBKey) == 0x000010, "Member 'FAIDynamicParam::BBKey' has a wrong offset!");

// ScriptStruct AIModule.EQSParametrizedQueryExecutionRequest
// 0x0048 (0x0048 - 0x0000)
struct FEQSParametrizedQueryExecutionRequest final
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIDynamicParam>                QueryConfig;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 EQSQueryBlackboardKey;                             // 0x0018(0x0028)(Edit, NativeAccessSpecifierPublic)
	EEnvQueryRunMode                              RunMode;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseBBKeyForQueryTemplate : 1;                     // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEQSParametrizedQueryExecutionRequest) == 0x000008, "Wrong alignment on FEQSParametrizedQueryExecutionRequest");
static_assert(sizeof(FEQSParametrizedQueryExecutionRequest) == 0x000048, "Wrong size on FEQSParametrizedQueryExecutionRequest");
static_assert(offsetof(FEQSParametrizedQueryExecutionRequest, QueryTemplate) == 0x000000, "Member 'FEQSParametrizedQueryExecutionRequest::QueryTemplate' has a wrong offset!");
static_assert(offsetof(FEQSParametrizedQueryExecutionRequest, QueryConfig) == 0x000008, "Member 'FEQSParametrizedQueryExecutionRequest::QueryConfig' has a wrong offset!");
static_assert(offsetof(FEQSParametrizedQueryExecutionRequest, EQSQueryBlackboardKey) == 0x000018, "Member 'FEQSParametrizedQueryExecutionRequest::EQSQueryBlackboardKey' has a wrong offset!");
static_assert(offsetof(FEQSParametrizedQueryExecutionRequest, RunMode) == 0x000040, "Member 'FEQSParametrizedQueryExecutionRequest::RunMode' has a wrong offset!");

// ScriptStruct AIModule.EnvQueryResult
// 0x0040 (0x0040 - 0x0000)
struct FEnvQueryResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryItemType>          ItemType;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x14];                                      // 0x0018(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OptionIndex;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QueryID;                                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvQueryResult) == 0x000008, "Wrong alignment on FEnvQueryResult");
static_assert(sizeof(FEnvQueryResult) == 0x000040, "Wrong size on FEnvQueryResult");
static_assert(offsetof(FEnvQueryResult, ItemType) == 0x000010, "Member 'FEnvQueryResult::ItemType' has a wrong offset!");
static_assert(offsetof(FEnvQueryResult, OptionIndex) == 0x00002C, "Member 'FEnvQueryResult::OptionIndex' has a wrong offset!");
static_assert(offsetof(FEnvQueryResult, QueryID) == 0x000030, "Member 'FEnvQueryResult::QueryID' has a wrong offset!");

// ScriptStruct AIModule.EnvOverlapData
// 0x0020 (0x0020 - 0x0000)
struct FEnvOverlapData final
{
public:
	float                                         ExtentX;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentY;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentZ;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShapeOffset;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OverlapChannel;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvOverlapShape                              OverlapShape;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOnlyBlockingHits : 1;                             // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverlapComplex : 1;                               // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipOverlapQuerier : 1;                           // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvOverlapData) == 0x000004, "Wrong alignment on FEnvOverlapData");
static_assert(sizeof(FEnvOverlapData) == 0x000020, "Wrong size on FEnvOverlapData");
static_assert(offsetof(FEnvOverlapData, ExtentX) == 0x000000, "Member 'FEnvOverlapData::ExtentX' has a wrong offset!");
static_assert(offsetof(FEnvOverlapData, ExtentY) == 0x000004, "Member 'FEnvOverlapData::ExtentY' has a wrong offset!");
static_assert(offsetof(FEnvOverlapData, ExtentZ) == 0x000008, "Member 'FEnvOverlapData::ExtentZ' has a wrong offset!");
static_assert(offsetof(FEnvOverlapData, ShapeOffset) == 0x00000C, "Member 'FEnvOverlapData::ShapeOffset' has a wrong offset!");
static_assert(offsetof(FEnvOverlapData, OverlapChannel) == 0x000018, "Member 'FEnvOverlapData::OverlapChannel' has a wrong offset!");
static_assert(offsetof(FEnvOverlapData, OverlapShape) == 0x000019, "Member 'FEnvOverlapData::OverlapShape' has a wrong offset!");

// ScriptStruct AIModule.EnvTraceData
// 0x0030 (0x0030 - 0x0000)
struct FEnvTraceData final
{
public:
	int32                                         VersionNum;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilter;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectDown;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectUp;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentX;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentY;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentZ;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProjectionVerticalOffset;                      // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SerializedChannel;                                 // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvTraceShape                                TraceShape;                                        // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvQueryTrace                                TraceMode;                                         // 0x002B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTraceComplex : 1;                                 // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyBlockingHits : 1;                             // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanTraceOnNavMesh : 1;                            // 0x002C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanTraceOnGeometry : 1;                           // 0x002C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanDisableTrace : 1;                              // 0x002C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanProjectDown : 1;                               // 0x002C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvTraceData) == 0x000008, "Wrong alignment on FEnvTraceData");
static_assert(sizeof(FEnvTraceData) == 0x000030, "Wrong size on FEnvTraceData");
static_assert(offsetof(FEnvTraceData, VersionNum) == 0x000000, "Member 'FEnvTraceData::VersionNum' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, NavigationFilter) == 0x000008, "Member 'FEnvTraceData::NavigationFilter' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, ProjectDown) == 0x000010, "Member 'FEnvTraceData::ProjectDown' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, ProjectUp) == 0x000014, "Member 'FEnvTraceData::ProjectUp' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, ExtentX) == 0x000018, "Member 'FEnvTraceData::ExtentX' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, ExtentY) == 0x00001C, "Member 'FEnvTraceData::ExtentY' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, ExtentZ) == 0x000020, "Member 'FEnvTraceData::ExtentZ' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, PostProjectionVerticalOffset) == 0x000024, "Member 'FEnvTraceData::PostProjectionVerticalOffset' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, TraceChannel) == 0x000028, "Member 'FEnvTraceData::TraceChannel' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, SerializedChannel) == 0x000029, "Member 'FEnvTraceData::SerializedChannel' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, TraceShape) == 0x00002A, "Member 'FEnvTraceData::TraceShape' has a wrong offset!");
static_assert(offsetof(FEnvTraceData, TraceMode) == 0x00002B, "Member 'FEnvTraceData::TraceMode' has a wrong offset!");

// ScriptStruct AIModule.EnvDirection
// 0x0020 (0x0020 - 0x0000)
struct FEnvDirection final
{
public:
	TSubclassOf<class UEnvQueryContext>           LineFrom;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           LineTo;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Rotation;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvDirection                                 DirMode;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvDirection) == 0x000008, "Wrong alignment on FEnvDirection");
static_assert(sizeof(FEnvDirection) == 0x000020, "Wrong size on FEnvDirection");
static_assert(offsetof(FEnvDirection, LineFrom) == 0x000000, "Member 'FEnvDirection::LineFrom' has a wrong offset!");
static_assert(offsetof(FEnvDirection, LineTo) == 0x000008, "Member 'FEnvDirection::LineTo' has a wrong offset!");
static_assert(offsetof(FEnvDirection, Rotation) == 0x000010, "Member 'FEnvDirection::Rotation' has a wrong offset!");
static_assert(offsetof(FEnvDirection, DirMode) == 0x000018, "Member 'FEnvDirection::DirMode' has a wrong offset!");

// ScriptStruct AIModule.EnvNamedValue
// 0x0010 (0x0010 - 0x0000)
struct FEnvNamedValue final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIParamType                                  ParamType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvNamedValue) == 0x000004, "Wrong alignment on FEnvNamedValue");
static_assert(sizeof(FEnvNamedValue) == 0x000010, "Wrong size on FEnvNamedValue");
static_assert(offsetof(FEnvNamedValue, ParamName) == 0x000000, "Member 'FEnvNamedValue::ParamName' has a wrong offset!");
static_assert(offsetof(FEnvNamedValue, ParamType) == 0x000008, "Member 'FEnvNamedValue::ParamType' has a wrong offset!");
static_assert(offsetof(FEnvNamedValue, Value) == 0x00000C, "Member 'FEnvNamedValue::Value' has a wrong offset!");

// ScriptStruct AIModule.GenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct FGenericTeamId final
{
public:
	uint8                                         TeamID;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGenericTeamId) == 0x000001, "Wrong alignment on FGenericTeamId");
static_assert(sizeof(FGenericTeamId) == 0x000001, "Wrong size on FGenericTeamId");
static_assert(offsetof(FGenericTeamId, TeamID) == 0x000000, "Member 'FGenericTeamId::TeamID' has a wrong offset!");

// ScriptStruct AIModule.PawnActionStack
// 0x0008 (0x0008 - 0x0000)
struct FPawnActionStack final
{
public:
	class UPawnAction*                            TopAction;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPawnActionStack) == 0x000008, "Wrong alignment on FPawnActionStack");
static_assert(sizeof(FPawnActionStack) == 0x000008, "Wrong size on FPawnActionStack");
static_assert(offsetof(FPawnActionStack, TopAction) == 0x000000, "Member 'FPawnActionStack::TopAction' has a wrong offset!");

// ScriptStruct AIModule.PawnActionEvent
// 0x0018 (0x0018 - 0x0000)
struct FPawnActionEvent final
{
public:
	class UPawnAction*                            Action;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnActionEvent) == 0x000008, "Wrong alignment on FPawnActionEvent");
static_assert(sizeof(FPawnActionEvent) == 0x000018, "Wrong size on FPawnActionEvent");
static_assert(offsetof(FPawnActionEvent, Action) == 0x000000, "Member 'FPawnActionEvent::Action' has a wrong offset!");

// ScriptStruct AIModule.RecastGraphWrapper
// 0x0098 (0x0098 - 0x0000)
struct FRecastGraphWrapper final
{
public:
	class ARecastNavMesh*                         RecastNavMeshActor;                                // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x90];                                       // 0x0008(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecastGraphWrapper) == 0x000008, "Wrong alignment on FRecastGraphWrapper");
static_assert(sizeof(FRecastGraphWrapper) == 0x000098, "Wrong size on FRecastGraphWrapper");
static_assert(offsetof(FRecastGraphWrapper, RecastNavMeshActor) == 0x000000, "Member 'FRecastGraphWrapper::RecastNavMeshActor' has a wrong offset!");

}

