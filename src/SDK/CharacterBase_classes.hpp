#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterBase

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CharacterBase_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class CharacterBase.CB_HumanAnimPackAsset
// 0x0030 (0x0060 - 0x0030)
class UCB_HumanAnimPackAsset final : public UDataAsset
{
public:
	struct FCB_HumanAnimPack                      _AnimPack;                                         // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_HumanAnimPackAsset">();
	}
	static class UCB_HumanAnimPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_HumanAnimPackAsset>();
	}
};
static_assert(alignof(UCB_HumanAnimPackAsset) == 0x000008, "Wrong alignment on UCB_HumanAnimPackAsset");
static_assert(sizeof(UCB_HumanAnimPackAsset) == 0x000060, "Wrong size on UCB_HumanAnimPackAsset");
static_assert(offsetof(UCB_HumanAnimPackAsset, _AnimPack) == 0x000030, "Member 'UCB_HumanAnimPackAsset::_AnimPack' has a wrong offset!");

// Class CharacterBase.CharacterBaseBpLib
// 0x0000 (0x0028 - 0x0028)
class UCharacterBaseBpLib final : public UBlueprintFunctionLibrary
{
public:
	class FString GetSoftClassPath(const class UObject* WorldContextObject, TSoftObjectPtr<class UAnimBlueprint> AnimBP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBaseBpLib">();
	}
	static class UCharacterBaseBpLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBaseBpLib>();
	}
};
static_assert(alignof(UCharacterBaseBpLib) == 0x000008, "Wrong alignment on UCharacterBaseBpLib");
static_assert(sizeof(UCharacterBaseBpLib) == 0x000028, "Wrong size on UCharacterBaseBpLib");

// Class CharacterBase.AnimInstanceCore
// 0x0000 (0x02C0 - 0x02C0)
class UAnimInstanceCore : public UAnimInstance
{
public:
	class AActor* GetLookAtTargetActor();
	class FString GetLookAtTargetActorBoneName();
	uint8 GetLookAtType();
	struct FVector GetLookAtWorldLocation();
	bool IsPlaySlotAnimation(class FName InAnimSlotName);
	void SetLookAtTargetActor(class AActor* TargetActor);
	void SetLookAtTargetActorBoneName(const class FString& BoneName);
	void SetLookAtType(uint8 LookAtType);
	void SetLookAtWorldLocation(const struct FVector& Location);
	void SetOverrideLocomotionNotMoveAnim(class UAnimSequence* InAnimSeq);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceCore">();
	}
	static class UAnimInstanceCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceCore>();
	}
};
static_assert(alignof(UAnimInstanceCore) == 0x000010, "Wrong alignment on UAnimInstanceCore");
static_assert(sizeof(UAnimInstanceCore) == 0x0002C0, "Wrong size on UAnimInstanceCore");

// Class CharacterBase.CB_HumanMeshPackAsset
// 0x0040 (0x0070 - 0x0030)
class UCB_HumanMeshPackAsset final : public UDataAsset
{
public:
	struct FCB_HumanMeshPack                      _MeshPack;                                         // 0x0030(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_HumanMeshPackAsset">();
	}
	static class UCB_HumanMeshPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_HumanMeshPackAsset>();
	}
};
static_assert(alignof(UCB_HumanMeshPackAsset) == 0x000008, "Wrong alignment on UCB_HumanMeshPackAsset");
static_assert(sizeof(UCB_HumanMeshPackAsset) == 0x000070, "Wrong size on UCB_HumanMeshPackAsset");
static_assert(offsetof(UCB_HumanMeshPackAsset, _MeshPack) == 0x000030, "Member 'UCB_HumanMeshPackAsset::_MeshPack' has a wrong offset!");

// Class CharacterBase.CB_PersonaMeshPackAsset
// 0x0010 (0x0040 - 0x0030)
class UCB_PersonaMeshPackAsset final : public UDataAsset
{
public:
	struct FCB_PersonaMeshPack                    _MeshPack;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_PersonaMeshPackAsset">();
	}
	static class UCB_PersonaMeshPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_PersonaMeshPackAsset>();
	}
};
static_assert(alignof(UCB_PersonaMeshPackAsset) == 0x000008, "Wrong alignment on UCB_PersonaMeshPackAsset");
static_assert(sizeof(UCB_PersonaMeshPackAsset) == 0x000040, "Wrong size on UCB_PersonaMeshPackAsset");
static_assert(offsetof(UCB_PersonaMeshPackAsset, _MeshPack) == 0x000030, "Member 'UCB_PersonaMeshPackAsset::_MeshPack' has a wrong offset!");

// Class CharacterBase.CB_PersonaAnimPackAsset
// 0x0010 (0x0040 - 0x0030)
class UCB_PersonaAnimPackAsset final : public UDataAsset
{
public:
	struct FCB_PersonaAnimPack                    _AnimPack;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_PersonaAnimPackAsset">();
	}
	static class UCB_PersonaAnimPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_PersonaAnimPackAsset>();
	}
};
static_assert(alignof(UCB_PersonaAnimPackAsset) == 0x000008, "Wrong alignment on UCB_PersonaAnimPackAsset");
static_assert(sizeof(UCB_PersonaAnimPackAsset) == 0x000040, "Wrong size on UCB_PersonaAnimPackAsset");
static_assert(offsetof(UCB_PersonaAnimPackAsset, _AnimPack) == 0x000030, "Member 'UCB_PersonaAnimPackAsset::_AnimPack' has a wrong offset!");

// Class CharacterBase.CB_NpcMeshPackAsset
// 0x0010 (0x0040 - 0x0030)
class UCB_NpcMeshPackAsset final : public UDataAsset
{
public:
	struct FCB_NpcMeshPack                        _MeshPack;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_NpcMeshPackAsset">();
	}
	static class UCB_NpcMeshPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_NpcMeshPackAsset>();
	}
};
static_assert(alignof(UCB_NpcMeshPackAsset) == 0x000008, "Wrong alignment on UCB_NpcMeshPackAsset");
static_assert(sizeof(UCB_NpcMeshPackAsset) == 0x000040, "Wrong size on UCB_NpcMeshPackAsset");
static_assert(offsetof(UCB_NpcMeshPackAsset, _MeshPack) == 0x000030, "Member 'UCB_NpcMeshPackAsset::_MeshPack' has a wrong offset!");

// Class CharacterBase.CB_NpcAnimPackAsset
// 0x0010 (0x0040 - 0x0030)
class UCB_NpcAnimPackAsset final : public UDataAsset
{
public:
	struct FCB_NpcAnimPack                        _AnimPack;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CB_NpcAnimPackAsset">();
	}
	static class UCB_NpcAnimPackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCB_NpcAnimPackAsset>();
	}
};
static_assert(alignof(UCB_NpcAnimPackAsset) == 0x000008, "Wrong alignment on UCB_NpcAnimPackAsset");
static_assert(sizeof(UCB_NpcAnimPackAsset) == 0x000040, "Wrong size on UCB_NpcAnimPackAsset");
static_assert(offsetof(UCB_NpcAnimPackAsset, _AnimPack) == 0x000030, "Member 'UCB_NpcAnimPackAsset::_AnimPack' has a wrong offset!");

// Class CharacterBase.CharacterBaseCore
// 0x00E0 (0x05A0 - 0x04C0)
class ACharacterBaseCore : public ACharacter
{
public:
	class UCBL_LoaderBase*                        _SkeletalMeshLoader;                               // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCBL_LoaderBase*                        _AnimBpLoader;                                     // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _SkeletalMeshCompArray;                            // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _RecalcBounds;                                     // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AutoLoading;                                      // 0x04D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DA[0x6];                                      // 0x04DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCB_HumanMeshPackAsset*                 _MeshPackAsset;                                    // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x40];                                     // 0x04E8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _PreviewMeshNo;                                    // 0x0528(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewCostumeNo;                                 // 0x052C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewHairNo;                                    // 0x0530(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewFaceNo;                                    // 0x0534(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCB_HumanAnimPackAsset*                 _AnimPackAsset;                                    // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x30];                                     // 0x0550(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _PreviewMeshAnimNo;                                // 0x0580(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewCostumeAnimNo;                             // 0x0584(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewHairAnimNo;                                // 0x0588(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x14];                                     // 0x058C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetCompLastRenderTimeOnScreen(class UPrimitiveComponent* MeshComp);

	float GetLastRenderTimeOnScreen();
	class FName GetMontageSectionName(class UAnimMontage* Montage, int32 Index_0);
	void LoadEndEvent();
	void ReCalculateBounds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBaseCore">();
	}
	static class ACharacterBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterBaseCore>();
	}
};
static_assert(alignof(ACharacterBaseCore) == 0x000010, "Wrong alignment on ACharacterBaseCore");
static_assert(sizeof(ACharacterBaseCore) == 0x0005A0, "Wrong size on ACharacterBaseCore");
static_assert(offsetof(ACharacterBaseCore, _SkeletalMeshLoader) == 0x0004B8, "Member 'ACharacterBaseCore::_SkeletalMeshLoader' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _AnimBpLoader) == 0x0004C0, "Member 'ACharacterBaseCore::_AnimBpLoader' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _SkeletalMeshCompArray) == 0x0004C8, "Member 'ACharacterBaseCore::_SkeletalMeshCompArray' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _RecalcBounds) == 0x0004D8, "Member 'ACharacterBaseCore::_RecalcBounds' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _AutoLoading) == 0x0004D9, "Member 'ACharacterBaseCore::_AutoLoading' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _MeshPackAsset) == 0x0004E0, "Member 'ACharacterBaseCore::_MeshPackAsset' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewMeshNo) == 0x000528, "Member 'ACharacterBaseCore::_PreviewMeshNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewCostumeNo) == 0x00052C, "Member 'ACharacterBaseCore::_PreviewCostumeNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewHairNo) == 0x000530, "Member 'ACharacterBaseCore::_PreviewHairNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewFaceNo) == 0x000534, "Member 'ACharacterBaseCore::_PreviewFaceNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _AnimPackAsset) == 0x000548, "Member 'ACharacterBaseCore::_AnimPackAsset' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewMeshAnimNo) == 0x000580, "Member 'ACharacterBaseCore::_PreviewMeshAnimNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewCostumeAnimNo) == 0x000584, "Member 'ACharacterBaseCore::_PreviewCostumeAnimNo' has a wrong offset!");
static_assert(offsetof(ACharacterBaseCore, _PreviewHairAnimNo) == 0x000588, "Member 'ACharacterBaseCore::_PreviewHairAnimNo' has a wrong offset!");

// Class CharacterBase.CBL_LoaderBase
// 0x0038 (0x0060 - 0x0028)
class UCBL_LoaderBase final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        _LoadedAsset;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CBL_LoaderBase">();
	}
	static class UCBL_LoaderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCBL_LoaderBase>();
	}
};
static_assert(alignof(UCBL_LoaderBase) == 0x000008, "Wrong alignment on UCBL_LoaderBase");
static_assert(sizeof(UCBL_LoaderBase) == 0x000060, "Wrong size on UCBL_LoaderBase");
static_assert(offsetof(UCBL_LoaderBase, _LoadedAsset) == 0x000050, "Member 'UCBL_LoaderBase::_LoadedAsset' has a wrong offset!");

// Class CharacterBase.CBL_LoaderTexture
// 0x0038 (0x0060 - 0x0028)
class UCBL_LoaderTexture final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        _LoadedAsset;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CBL_LoaderTexture">();
	}
	static class UCBL_LoaderTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCBL_LoaderTexture>();
	}
};
static_assert(alignof(UCBL_LoaderTexture) == 0x000008, "Wrong alignment on UCBL_LoaderTexture");
static_assert(sizeof(UCBL_LoaderTexture) == 0x000060, "Wrong size on UCBL_LoaderTexture");
static_assert(offsetof(UCBL_LoaderTexture, _LoadedAsset) == 0x000050, "Member 'UCBL_LoaderTexture::_LoadedAsset' has a wrong offset!");

// Class CharacterBase.CrowdNpcBaseCore
// 0x0000 (0x0280 - 0x0280)
class ACrowdNpcBaseCore final : public APawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowdNpcBaseCore">();
	}
	static class ACrowdNpcBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrowdNpcBaseCore>();
	}
};
static_assert(alignof(ACrowdNpcBaseCore) == 0x000008, "Wrong alignment on ACrowdNpcBaseCore");
static_assert(sizeof(ACrowdNpcBaseCore) == 0x000280, "Wrong size on ACrowdNpcBaseCore");

// Class CharacterBase.EnemySymbolBaseCore
// 0x0000 (0x04C0 - 0x04C0)
class AEnemySymbolBaseCore final : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySymbolBaseCore">();
	}
	static class AEnemySymbolBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySymbolBaseCore>();
	}
};
static_assert(alignof(AEnemySymbolBaseCore) == 0x000010, "Wrong alignment on AEnemySymbolBaseCore");
static_assert(sizeof(AEnemySymbolBaseCore) == 0x0004C0, "Wrong size on AEnemySymbolBaseCore");

// Class CharacterBase.MobBaseAiControllerCore
// 0x0050 (0x0378 - 0x0328)
class AMobBaseAiControllerCore final : public AAIController
{
public:
	float                                         MTargetDistance_;                                  // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTurnSpeed_;                                       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWalkMaxSpeed_;                                    // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWalkStopTurnSpeedRatio_;                          // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWalkInterpTurnSpeedMIN_;                          // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWalkInterpTurnSpeedMAX_;                          // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MShiftDirectionDistance_;                          // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MShiftDirectionMinInterpSpeed_;                    // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MShiftDirectionMaxInterpSpeed_;                    // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MShiftDirectionTimeOut_;                           // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFollowWarpDistance_;                              // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDeleteInterval_;                                  // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDeleteMoveMin_;                                   // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDeleteTime_;                                      // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMobWalkCharaBaseCore*                  MOwnerActor_;                                      // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MNowDeltaTime_;                                    // 0x0370(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MAnimeRatio_;                                      // 0x0374(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddPointIndex(int32 Value);
	int32 GetPointIndex();
	int32 GetPointIndexLAST();
	void ReStartAiCtrl();
	void SetPointIndex(int32 Value);
	void StartAiCtrl();
	void UpdateActorBlueprint(float WalkSpeedRatio, float DeltaTime);
	void UpdateProc(float DeltaTime);

	class AMobWalkCharaBaseCore* GetOwnerActor() const;
	struct FMobWalkRoutePoint GetRoutePointNEXT() const;
	struct FMobWalkRoutePoint GetRoutePointNOW() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobBaseAiControllerCore">();
	}
	static class AMobBaseAiControllerCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobBaseAiControllerCore>();
	}
};
static_assert(alignof(AMobBaseAiControllerCore) == 0x000008, "Wrong alignment on AMobBaseAiControllerCore");
static_assert(sizeof(AMobBaseAiControllerCore) == 0x000378, "Wrong size on AMobBaseAiControllerCore");
static_assert(offsetof(AMobBaseAiControllerCore, MTargetDistance_) == 0x000328, "Member 'AMobBaseAiControllerCore::MTargetDistance_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MTurnSpeed_) == 0x00032C, "Member 'AMobBaseAiControllerCore::MTurnSpeed_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MWalkMaxSpeed_) == 0x000330, "Member 'AMobBaseAiControllerCore::MWalkMaxSpeed_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MWalkStopTurnSpeedRatio_) == 0x000334, "Member 'AMobBaseAiControllerCore::MWalkStopTurnSpeedRatio_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MWalkInterpTurnSpeedMIN_) == 0x000338, "Member 'AMobBaseAiControllerCore::MWalkInterpTurnSpeedMIN_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MWalkInterpTurnSpeedMAX_) == 0x00033C, "Member 'AMobBaseAiControllerCore::MWalkInterpTurnSpeedMAX_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MShiftDirectionDistance_) == 0x000340, "Member 'AMobBaseAiControllerCore::MShiftDirectionDistance_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MShiftDirectionMinInterpSpeed_) == 0x000344, "Member 'AMobBaseAiControllerCore::MShiftDirectionMinInterpSpeed_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MShiftDirectionMaxInterpSpeed_) == 0x000348, "Member 'AMobBaseAiControllerCore::MShiftDirectionMaxInterpSpeed_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MShiftDirectionTimeOut_) == 0x00034C, "Member 'AMobBaseAiControllerCore::MShiftDirectionTimeOut_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MFollowWarpDistance_) == 0x000350, "Member 'AMobBaseAiControllerCore::MFollowWarpDistance_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MDeleteInterval_) == 0x000354, "Member 'AMobBaseAiControllerCore::MDeleteInterval_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MDeleteMoveMin_) == 0x000358, "Member 'AMobBaseAiControllerCore::MDeleteMoveMin_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MDeleteTime_) == 0x00035C, "Member 'AMobBaseAiControllerCore::MDeleteTime_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MOwnerActor_) == 0x000368, "Member 'AMobBaseAiControllerCore::MOwnerActor_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MNowDeltaTime_) == 0x000370, "Member 'AMobBaseAiControllerCore::MNowDeltaTime_' has a wrong offset!");
static_assert(offsetof(AMobBaseAiControllerCore, MAnimeRatio_) == 0x000374, "Member 'AMobBaseAiControllerCore::MAnimeRatio_' has a wrong offset!");

// Class CharacterBase.MobCharaBaseListener
// 0x0000 (0x0028 - 0x0028)
class IMobCharaBaseListener final : public IInterface
{
public:
	void UpdateMobChara(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobCharaBaseListener">();
	}
	static class IMobCharaBaseListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMobCharaBaseListener>();
	}
};
static_assert(alignof(IMobCharaBaseListener) == 0x000008, "Wrong alignment on IMobCharaBaseListener");
static_assert(sizeof(IMobCharaBaseListener) == 0x000028, "Wrong size on IMobCharaBaseListener");

// Class CharacterBase.MobWalkTarget
// 0x0008 (0x0228 - 0x0220)
class AMobWalkTarget : public ATargetPoint
{
public:
	EMobWalkTargetType                            MType_;                                            // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EMobWalkTargetType GetTargetType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobWalkTarget">();
	}
	static class AMobWalkTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobWalkTarget>();
	}
};
static_assert(alignof(AMobWalkTarget) == 0x000008, "Wrong alignment on AMobWalkTarget");
static_assert(sizeof(AMobWalkTarget) == 0x000228, "Wrong size on AMobWalkTarget");
static_assert(offsetof(AMobWalkTarget, MType_) == 0x000220, "Member 'AMobWalkTarget::MType_' has a wrong offset!");

// Class CharacterBase.MobWalkCharaBaseCore
// 0x0040 (0x0500 - 0x04C0)
class AMobWalkCharaBaseCore final : public ACharacter
{
public:
	int32                                         MBpIndex_;                                         // 0x04B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MOpacityCore_;                                     // 0x04BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMobWalkRoutePoint>             MPointList_;                                       // 0x04C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         MPointIndex_;                                      // 0x04D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MStartLocation_;                                   // 0x04D4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MWaitTime_;                                        // 0x04E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MFollowParent_;                                    // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MFollowRelativeLocation_;                          // 0x04F0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMobWalkStartState                            MStartState_;                                      // 0x04FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPointList(const struct FMobWalkRoutePoint& InPoint);
	int32 GetPointListMax();
	void InitPointList();
	void SetBpIndex(int32 Value);
	void SetFollowParent(class AActor* InParent);
	void SetFollowRelativeLocation(const struct FVector& InLocation);
	void SetOpacityCore(float Value);
	void SetPointIndex(int32 Value);
	void SetStartLocation(const struct FVector& InLocation);
	void SetWaitTime(float InTime);

	int32 GetBpIndex() const;
	class AActor* GetFollowParent() const;
	struct FVector GetFollowRelativeLocation() const;
	float GetOpacityCore() const;
	int32 GetPointIndex() const;
	struct FMobWalkRoutePoint GetPointList(int32 Index_0) const;
	struct FMobWalkRoutePoint GetPointList_LAST() const;
	struct FMobWalkRoutePoint GetPointList_START() const;
	struct FVector GetStartLocation() const;
	float GetWaitTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobWalkCharaBaseCore">();
	}
	static class AMobWalkCharaBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobWalkCharaBaseCore>();
	}
};
static_assert(alignof(AMobWalkCharaBaseCore) == 0x000010, "Wrong alignment on AMobWalkCharaBaseCore");
static_assert(sizeof(AMobWalkCharaBaseCore) == 0x000500, "Wrong size on AMobWalkCharaBaseCore");
static_assert(offsetof(AMobWalkCharaBaseCore, MBpIndex_) == 0x0004B8, "Member 'AMobWalkCharaBaseCore::MBpIndex_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MOpacityCore_) == 0x0004BC, "Member 'AMobWalkCharaBaseCore::MOpacityCore_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MPointList_) == 0x0004C0, "Member 'AMobWalkCharaBaseCore::MPointList_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MPointIndex_) == 0x0004D0, "Member 'AMobWalkCharaBaseCore::MPointIndex_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MStartLocation_) == 0x0004D4, "Member 'AMobWalkCharaBaseCore::MStartLocation_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MWaitTime_) == 0x0004E0, "Member 'AMobWalkCharaBaseCore::MWaitTime_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MFollowParent_) == 0x0004E8, "Member 'AMobWalkCharaBaseCore::MFollowParent_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MFollowRelativeLocation_) == 0x0004F0, "Member 'AMobWalkCharaBaseCore::MFollowRelativeLocation_' has a wrong offset!");
static_assert(offsetof(AMobWalkCharaBaseCore, MStartState_) == 0x0004FC, "Member 'AMobWalkCharaBaseCore::MStartState_' has a wrong offset!");

// Class CharacterBase.NpcAnimationBaseCore
// 0x0030 (0x02F0 - 0x02C0)
class UNpcAnimationBaseCore final : public UAnimInstance
{
public:
	ENpcAnimLookAtType                            LookAtType;                                        // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtWorldLocation;                               // 0x02BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LookAtTargetActor;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LookAtTargetActorBoneName;                         // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      IdolAnimSequence;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* GetIdolAnimSequnece();
	class AActor* GetLookAtTargetActor();
	class FString GetLookAtTargetActorBoneName();
	ENpcAnimLookAtType GetLookAtType();
	struct FVector GetLookAtWorldLocation();
	void SetIdolAnimSequnece(class UAnimSequenceBase* Anim);
	void SetLookAtTargetActor(class AActor* TargetActor);
	void SetLookAtTargetActorBoneName(const class FString& BoneName);
	void SetLookAtType(ENpcAnimLookAtType Type);
	void SetLookAtWorldLocation(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcAnimationBaseCore">();
	}
	static class UNpcAnimationBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcAnimationBaseCore>();
	}
};
static_assert(alignof(UNpcAnimationBaseCore) == 0x000010, "Wrong alignment on UNpcAnimationBaseCore");
static_assert(sizeof(UNpcAnimationBaseCore) == 0x0002F0, "Wrong size on UNpcAnimationBaseCore");
static_assert(offsetof(UNpcAnimationBaseCore, LookAtType) == 0x0002B8, "Member 'UNpcAnimationBaseCore::LookAtType' has a wrong offset!");
static_assert(offsetof(UNpcAnimationBaseCore, LookAtWorldLocation) == 0x0002BC, "Member 'UNpcAnimationBaseCore::LookAtWorldLocation' has a wrong offset!");
static_assert(offsetof(UNpcAnimationBaseCore, LookAtTargetActor) == 0x0002C8, "Member 'UNpcAnimationBaseCore::LookAtTargetActor' has a wrong offset!");
static_assert(offsetof(UNpcAnimationBaseCore, LookAtTargetActorBoneName) == 0x0002D0, "Member 'UNpcAnimationBaseCore::LookAtTargetActorBoneName' has a wrong offset!");
static_assert(offsetof(UNpcAnimationBaseCore, IdolAnimSequence) == 0x0002E0, "Member 'UNpcAnimationBaseCore::IdolAnimSequence' has a wrong offset!");

// Class CharacterBase.NpcBaseCore
// 0x0198 (0x0418 - 0x0280)
class ANpcBaseCore final : public APawn
{
public:
	class USceneComponent*                        Root;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCBL_LoaderBase*                        _SkeletalMeshLoader;                               // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCBL_LoaderBase*                        _AnimBpLoader;                                     // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCBL_LoaderTexture*                     _TextureLoader;                                    // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         _SkeletalMeshCompArray;                            // 0x02A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          _AutoLoading;                                      // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCB_HumanMeshPackAsset*                 _MeshPackAsset;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x40];                                     // 0x02C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _PreviewMeshNo;                                    // 0x0308(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewCostumeNo;                                 // 0x030C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewHairNo;                                    // 0x0310(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewFaceNo;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCB_HumanAnimPackAsset*                 _AnimPackAsset;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x30];                                     // 0x0330(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _PreviewMeshAnimNo;                                // 0x0360(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewCostumeAnimNo;                             // 0x0364(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PreviewHairAnimNo;                                // 0x0368(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x14];                                     // 0x036C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CostumeTexture;                                    // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HairTexture;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceTexture;                                       // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              _CostumeTexturePtr;                                // 0x0398(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              _HairTexturePtr;                                   // 0x03C0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              _FaceTexturePtr;                                   // 0x03E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinColorID;                                       // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightScale;                                       // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CommitModelSetting();
	class FName GetMontageSectionName(class UAnimMontage* Montage, int32 Index_0);

	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcBaseCore">();
	}
	static class ANpcBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcBaseCore>();
	}
};
static_assert(alignof(ANpcBaseCore) == 0x000008, "Wrong alignment on ANpcBaseCore");
static_assert(sizeof(ANpcBaseCore) == 0x000418, "Wrong size on ANpcBaseCore");
static_assert(offsetof(ANpcBaseCore, Root) == 0x000280, "Member 'ANpcBaseCore::Root' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, Mesh) == 0x000288, "Member 'ANpcBaseCore::Mesh' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _SkeletalMeshLoader) == 0x000290, "Member 'ANpcBaseCore::_SkeletalMeshLoader' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _AnimBpLoader) == 0x000298, "Member 'ANpcBaseCore::_AnimBpLoader' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _TextureLoader) == 0x0002A0, "Member 'ANpcBaseCore::_TextureLoader' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _SkeletalMeshCompArray) == 0x0002A8, "Member 'ANpcBaseCore::_SkeletalMeshCompArray' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _AutoLoading) == 0x0002B8, "Member 'ANpcBaseCore::_AutoLoading' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _MeshPackAsset) == 0x0002C0, "Member 'ANpcBaseCore::_MeshPackAsset' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewMeshNo) == 0x000308, "Member 'ANpcBaseCore::_PreviewMeshNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewCostumeNo) == 0x00030C, "Member 'ANpcBaseCore::_PreviewCostumeNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewHairNo) == 0x000310, "Member 'ANpcBaseCore::_PreviewHairNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewFaceNo) == 0x000314, "Member 'ANpcBaseCore::_PreviewFaceNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _AnimPackAsset) == 0x000328, "Member 'ANpcBaseCore::_AnimPackAsset' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewMeshAnimNo) == 0x000360, "Member 'ANpcBaseCore::_PreviewMeshAnimNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewCostumeAnimNo) == 0x000364, "Member 'ANpcBaseCore::_PreviewCostumeAnimNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _PreviewHairAnimNo) == 0x000368, "Member 'ANpcBaseCore::_PreviewHairAnimNo' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, CostumeTexture) == 0x000380, "Member 'ANpcBaseCore::CostumeTexture' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, HairTexture) == 0x000388, "Member 'ANpcBaseCore::HairTexture' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, FaceTexture) == 0x000390, "Member 'ANpcBaseCore::FaceTexture' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _CostumeTexturePtr) == 0x000398, "Member 'ANpcBaseCore::_CostumeTexturePtr' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _HairTexturePtr) == 0x0003C0, "Member 'ANpcBaseCore::_HairTexturePtr' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, _FaceTexturePtr) == 0x0003E8, "Member 'ANpcBaseCore::_FaceTexturePtr' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, SkinColorID) == 0x000410, "Member 'ANpcBaseCore::SkinColorID' has a wrong offset!");
static_assert(offsetof(ANpcBaseCore, HeightScale) == 0x000414, "Member 'ANpcBaseCore::HeightScale' has a wrong offset!");

// Class CharacterBase.PersonaBaseCore
// 0x0008 (0x0288 - 0x0280)
class APersonaBaseCore : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonaBaseCore">();
	}
	static class APersonaBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersonaBaseCore>();
	}
};
static_assert(alignof(APersonaBaseCore) == 0x000008, "Wrong alignment on APersonaBaseCore");
static_assert(sizeof(APersonaBaseCore) == 0x000288, "Wrong size on APersonaBaseCore");
static_assert(offsetof(APersonaBaseCore, Mesh) == 0x000280, "Member 'APersonaBaseCore::Mesh' has a wrong offset!");

// Class CharacterBase.ShadowBaseCore
// 0x0008 (0x0288 - 0x0280)
class AShadowBaseCore : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShadowBaseCore">();
	}
	static class AShadowBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShadowBaseCore>();
	}
};
static_assert(alignof(AShadowBaseCore) == 0x000008, "Wrong alignment on AShadowBaseCore");
static_assert(sizeof(AShadowBaseCore) == 0x000288, "Wrong size on AShadowBaseCore");
static_assert(offsetof(AShadowBaseCore, Mesh) == 0x000280, "Member 'AShadowBaseCore::Mesh' has a wrong offset!");

}

