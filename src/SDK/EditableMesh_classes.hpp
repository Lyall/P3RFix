#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EditableMesh

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "EditableMesh_structs.hpp"


namespace SDK
{

// Class EditableMesh.EditableMeshAdapter
// 0x0000 (0x0028 - 0x0028)
class UEditableMeshAdapter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMeshAdapter">();
	}
	static class UEditableMeshAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMeshAdapter>();
	}
};
static_assert(alignof(UEditableMeshAdapter) == 0x000008, "Wrong alignment on UEditableMeshAdapter");
static_assert(sizeof(UEditableMeshAdapter) == 0x000028, "Wrong size on UEditableMeshAdapter");

// Class EditableMesh.EditableGeometryCollectionAdapter
// 0x00B0 (0x00D8 - 0x0028)
class UEditableGeometryCollectionAdapter final : public UEditableMeshAdapter
{
public:
	class UGeometryCollection*                    GeometryCollection;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGeometryCollection*                    OriginalGeometryCollection;                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GeometryCollectionLODIndex;                        // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x9C];                                      // 0x003C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableGeometryCollectionAdapter">();
	}
	static class UEditableGeometryCollectionAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableGeometryCollectionAdapter>();
	}
};
static_assert(alignof(UEditableGeometryCollectionAdapter) == 0x000008, "Wrong alignment on UEditableGeometryCollectionAdapter");
static_assert(sizeof(UEditableGeometryCollectionAdapter) == 0x0000D8, "Wrong size on UEditableGeometryCollectionAdapter");
static_assert(offsetof(UEditableGeometryCollectionAdapter, GeometryCollection) == 0x000028, "Member 'UEditableGeometryCollectionAdapter::GeometryCollection' has a wrong offset!");
static_assert(offsetof(UEditableGeometryCollectionAdapter, OriginalGeometryCollection) == 0x000030, "Member 'UEditableGeometryCollectionAdapter::OriginalGeometryCollection' has a wrong offset!");
static_assert(offsetof(UEditableGeometryCollectionAdapter, GeometryCollectionLODIndex) == 0x000038, "Member 'UEditableGeometryCollectionAdapter::GeometryCollectionLODIndex' has a wrong offset!");

// Class EditableMesh.EditableMesh
// 0x06E0 (0x0708 - 0x0028)
class UEditableMesh final : public UObject
{
public:
	uint8                                         Pad_28[0x390];                                     // 0x0028(0x0390)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEditableMeshAdapter*>           Adapters;                                          // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextureCoordinateCount;                            // 0x03D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x148];                                    // 0x03D4(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PendingCompactCounter;                             // 0x051C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubdivisionCount;                                  // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_524[0x1E4];                                    // 0x0524(0x01E4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FEdgeID InvalidEdgeID();
	static struct FPolygonGroupID InvalidPolygonGroupID();
	static struct FPolygonID InvalidPolygonID();
	static struct FVertexID InvalidVertexID();
	static struct FEdgeID MakeEdgeID(const int32 EdgeIndex);
	static struct FPolygonGroupID MakePolygonGroupID(const int32 PolygonGroupIndex);
	static struct FPolygonID MakePolygonID(const int32 PolygonIndex);
	static struct FVertexID MakeVertexID(const int32 VertexIndex);

	void AssignPolygonsToPolygonGroups(const TArray<struct FPolygonGroupForPolygon>& PolygonGroupForPolygons, const bool bDeleteOrphanedPolygonGroups);
	void BevelPolygons(const TArray<struct FPolygonID>& PolygonIDs, const float BevelFixedDistance, const float BevelProgressTowardCenter, TArray<struct FPolygonID>* OutNewCenterPolygonIDs, TArray<struct FPolygonID>* OutNewSidePolygonIDs);
	void ChangePolygonsVertexInstances(const TArray<struct FChangeVertexInstancesForPolygon>& VertexInstancesForPolygons);
	void Commit();
	class UEditableMesh* CommitInstance(class UPrimitiveComponent* ComponentToInstanceTo);
	void CreateEdges(const TArray<struct FEdgeToCreate>& EdgesToCreate, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreateEmptyVertexRange(const int32 NumVerticesToCreate, TArray<struct FVertexID>* OutNewVertexIDs);
	void CreateMissingPolygonPerimeterEdges(const struct FPolygonID& PolygonID, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreatePolygonGroups(const TArray<struct FPolygonGroupToCreate>& PolygonGroupsToCreate, TArray<struct FPolygonGroupID>* OutNewPolygonGroupIDs);
	void CreatePolygons(const TArray<struct FPolygonToCreate>& PolygonsToCreate, TArray<struct FPolygonID>* OutNewPolygonIDs, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreateVertexInstances(const TArray<struct FVertexInstanceToCreate>& VertexInstancesToCreate, TArray<struct FVertexInstanceID>* OutNewVertexInstanceIDs);
	void CreateVertices(const TArray<struct FVertexToCreate>& VerticesToCreate, TArray<struct FVertexID>* OutNewVertexIDs);
	void DeleteEdgeAndConnectedPolygons(const struct FEdgeID& EdgeID, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
	void DeleteEdges(const TArray<struct FEdgeID>& EdgeIDsToDelete, const bool bDeleteOrphanedVertices);
	void DeleteOrphanVertices(const TArray<struct FVertexID>& VertexIDsToDelete);
	void DeletePolygonGroups(const TArray<struct FPolygonGroupID>& PolygonGroupIDs);
	void DeletePolygons(const TArray<struct FPolygonID>& PolygonIDsToDelete, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
	void DeleteVertexAndConnectedEdgesAndPolygons(const struct FVertexID& VertexID, const bool bDeleteOrphanedEdges, const bool bDeleteOrphanedVertices, const bool bDeleteOrphanedVertexInstances, const bool bDeleteEmptyPolygonGroups);
	void DeleteVertexInstances(const TArray<struct FVertexInstanceID>& VertexInstanceIDsToDelete, const bool bDeleteOrphanedVertices);
	void EndModification(const bool bFromUndo);
	void ExtendEdges(const TArray<struct FEdgeID>& EdgeIDs, const bool bWeldNeighbors, TArray<struct FEdgeID>* OutNewExtendedEdgeIDs);
	void ExtendVertices(const TArray<struct FVertexID>& VertexIDs, const bool bOnlyExtendClosestEdge, const struct FVector& ReferencePosition, TArray<struct FVertexID>* OutNewExtendedVertexIDs);
	void ExtrudePolygons(const TArray<struct FPolygonID>& Polygons, const float ExtrudeDistance, const bool bKeepNeighborsTogether, TArray<struct FPolygonID>* OutNewExtrudedFrontPolygons);
	void FlipPolygons(const TArray<struct FPolygonID>& PolygonIDs);
	void GeneratePolygonTangentsAndNormals(const TArray<struct FPolygonID>& PolygonIDs);
	void InitializeAdapters();
	void InsertEdgeLoop(const struct FEdgeID& EdgeID, const TArray<float>& Splits, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void InsetPolygons(const TArray<struct FPolygonID>& PolygonIDs, const float InsetFixedDistance, const float InsetProgressTowardCenter, const EInsetPolygonsMode Mode, TArray<struct FPolygonID>* OutNewCenterPolygonIDs, TArray<struct FPolygonID>* OutNewSidePolygonIDs);
	void MoveVertices(const TArray<struct FVertexToMove>& VerticesToMove);
	void PropagateInstanceChanges();
	void QuadrangulateMesh(TArray<struct FPolygonID>* OutNewPolygonIDs);
	void RebuildRenderMesh();
	void Revert();
	class UEditableMesh* RevertInstance();
	void SetAllowCompact(const bool bInAllowCompact);
	void SetAllowSpatialDatabase(const bool bInAllowSpatialDatabase);
	void SetAllowUndo(const bool bInAllowUndo);
	void SetEdgesAttributes(const TArray<struct FAttributesForEdge>& AttributesForEdges);
	void SetEdgesCreaseSharpness(const TArray<struct FEdgeID>& EdgeIDs, const TArray<float>& EdgesNewCreaseSharpness);
	void SetEdgesHardness(const TArray<struct FEdgeID>& EdgeIDs, const TArray<bool>& EdgesNewIsHard);
	void SetEdgesHardnessAutomatically(const TArray<struct FEdgeID>& EdgeIDs, const float MaxDotProductForSoftEdge);
	void SetPolygonsVertexAttributes(const TArray<struct FVertexAttributesForPolygon>& VertexAttributesForPolygons);
	void SetSubdivisionCount(const int32 NewSubdivisionCount);
	void SetTextureCoordinateCount(const int32 NumTexCoords);
	void SetVertexInstancesAttributes(const TArray<struct FAttributesForVertexInstance>& AttributesForVertexInstances);
	void SetVerticesAttributes(const TArray<struct FAttributesForVertex>& AttributesForVertices);
	void SetVerticesCornerSharpness(const TArray<struct FVertexID>& VertexIDs, const TArray<float>& VerticesNewCornerSharpness);
	void SplitEdge(const struct FEdgeID& EdgeID, const TArray<float>& Splits, TArray<struct FVertexID>* OutNewVertexIDs);
	void SplitPolygonalMesh(const struct FPlane& InPlane, TArray<struct FPolygonID>* PolygonIDs1, TArray<struct FPolygonID>* PolygonIDs2, TArray<struct FEdgeID>* BoundaryIDs);
	void SplitPolygons(const TArray<struct FPolygonToSplit>& PolygonsToSplit, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void StartModification(const EMeshModificationType MeshModificationType, const EMeshTopologyChange MeshTopologyChange);
	void TessellatePolygons(const TArray<struct FPolygonID>& PolygonIDs, const ETriangleTessellationMode TriangleTessellationMode, TArray<struct FPolygonID>* OutNewPolygonIDs);
	void TriangulatePolygons(const TArray<struct FPolygonID>& PolygonIDs, TArray<struct FPolygonID>* OutNewTrianglePolygons);
	void TryToRemovePolygonEdge(const struct FEdgeID& EdgeID, bool* bOutWasEdgeRemoved, struct FPolygonID* OutNewPolygonID);
	void TryToRemoveVertex(const struct FVertexID& VertexID, bool* bOutWasVertexRemoved, struct FEdgeID* OutNewEdgeID);
	void WeldVertices(const TArray<struct FVertexID>& VertexIDs, struct FVertexID* OutNewVertexID);

	bool AnyChangesToUndo() const;
	struct FBox ComputeBoundingBox() const;
	struct FBoxSphereBounds ComputeBoundingBoxAndSphere() const;
	struct FVector ComputePolygonCenter(const struct FPolygonID& PolygonID) const;
	struct FVector ComputePolygonNormal(const struct FPolygonID& PolygonID) const;
	struct FPlane ComputePolygonPlane(const struct FPolygonID& PolygonID) const;
	void ComputePolygonsSharedEdges(const TArray<struct FPolygonID>& PolygonIDs, TArray<struct FEdgeID>* OutSharedEdgeIDs) const;
	void FindPolygonLoop(const struct FEdgeID& EdgeID, TArray<struct FEdgeID>* OutEdgeLoopEdgeIDs, TArray<struct FEdgeID>* OutFlippedEdgeIDs, TArray<struct FEdgeID>* OutReversedEdgeIDPathToTake, TArray<struct FPolygonID>* OutPolygonIDsToSplit) const;
	int32 FindPolygonPerimeterEdgeNumberForVertices(const struct FPolygonID& PolygonID, const struct FVertexID& EdgeVertexID0, const struct FVertexID& EdgeVertexID1) const;
	int32 FindPolygonPerimeterVertexNumberForVertex(const struct FPolygonID& PolygonID, const struct FVertexID& VertexID) const;
	struct FPolygonID GetEdgeConnectedPolygon(const struct FEdgeID& EdgeID, const int32 ConnectedPolygonNumber) const;
	int32 GetEdgeConnectedPolygonCount(const struct FEdgeID& EdgeID) const;
	void GetEdgeConnectedPolygons(const struct FEdgeID& EdgeID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetEdgeCount() const;
	void GetEdgeLoopElements(const struct FEdgeID& EdgeID, TArray<struct FEdgeID>* EdgeLoopIDs) const;
	struct FEdgeID GetEdgeThatConnectsVertices(const struct FVertexID& VertexID0, const struct FVertexID& VertexID1) const;
	struct FVertexID GetEdgeVertex(const struct FEdgeID& EdgeID, const int32 EdgeVertexNumber) const;
	void GetEdgeVertices(const struct FEdgeID& EdgeID, struct FVertexID* OutEdgeVertexID0, struct FVertexID* OutEdgeVertexID1) const;
	struct FPolygonGroupID GetFirstValidPolygonGroup() const;
	struct FPolygonGroupID GetGroupForPolygon(const struct FPolygonID& PolygonID) const;
	void GetPolygonAdjacentPolygons(const struct FPolygonID& PolygonID, TArray<struct FPolygonID>* OutAdjacentPolygons) const;
	int32 GetPolygonCount() const;
	int32 GetPolygonCountInGroup(const struct FPolygonGroupID& PolygonGroupID) const;
	int32 GetPolygonGroupCount() const;
	struct FPolygonID GetPolygonInGroup(const struct FPolygonGroupID& PolygonGroupID, const int32 PolygonNumber) const;
	struct FEdgeID GetPolygonPerimeterEdge(const struct FPolygonID& PolygonID, const int32 PerimeterEdgeNumber, bool* bOutEdgeWindingIsReversedForPolygon) const;
	int32 GetPolygonPerimeterEdgeCount(const struct FPolygonID& PolygonID) const;
	void GetPolygonPerimeterEdges(const struct FPolygonID& PolygonID, TArray<struct FEdgeID>* OutPolygonPerimeterEdgeIDs) const;
	struct FVertexID GetPolygonPerimeterVertex(const struct FPolygonID& PolygonID, const int32 PolygonVertexNumber) const;
	int32 GetPolygonPerimeterVertexCount(const struct FPolygonID& PolygonID) const;
	struct FVertexInstanceID GetPolygonPerimeterVertexInstance(const struct FPolygonID& PolygonID, const int32 PolygonVertexNumber) const;
	void GetPolygonPerimeterVertexInstances(const struct FPolygonID& PolygonID, TArray<struct FVertexInstanceID>* OutPolygonPerimeterVertexInstanceIDs) const;
	void GetPolygonPerimeterVertices(const struct FPolygonID& PolygonID, TArray<struct FVertexID>* OutPolygonPerimeterVertexIDs) const;
	struct FTriangleID GetPolygonTriangulatedTriangle(const struct FPolygonID& PolygonID, int32 PolygonTriangleNumber) const;
	int32 GetPolygonTriangulatedTriangleCount(const struct FPolygonID& PolygonID) const;
	int32 GetSubdivisionCount() const;
	const struct FSubdivisionLimitData GetSubdivisionLimitData() const;
	int32 GetTextureCoordinateCount() const;
	void GetVertexAdjacentVertices(const struct FVertexID& VertexID, TArray<struct FVertexID>* OutAdjacentVertexIDs) const;
	struct FEdgeID GetVertexConnectedEdge(const struct FVertexID& VertexID, const int32 ConnectedEdgeNumber) const;
	int32 GetVertexConnectedEdgeCount(const struct FVertexID& VertexID) const;
	void GetVertexConnectedEdges(const struct FVertexID& VertexID, TArray<struct FEdgeID>* OutConnectedEdgeIDs) const;
	void GetVertexConnectedPolygons(const struct FVertexID& VertexID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetVertexCount() const;
	struct FPolygonID GetVertexInstanceConnectedPolygon(const struct FVertexInstanceID& VertexInstanceID, const int32 ConnectedPolygonNumber) const;
	int32 GetVertexInstanceConnectedPolygonCount(const struct FVertexInstanceID& VertexInstanceID) const;
	void GetVertexInstanceConnectedPolygons(const struct FVertexInstanceID& VertexInstanceID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetVertexInstanceCount() const;
	struct FVertexID GetVertexInstanceVertex(const struct FVertexInstanceID& VertexInstanceID) const;
	struct FEdgeID GetVertexPairEdge(const struct FVertexID& VertexID, const struct FVertexID& NextVertexID, bool* bOutEdgeWindingIsReversed) const;
	bool IsBeingModified() const;
	bool IsCommitted() const;
	bool IsCommittedAsInstance() const;
	bool IsCompactAllowed() const;
	bool IsOrphanedVertex(const struct FVertexID& VertexID) const;
	bool IsPreviewingSubdivisions() const;
	bool IsSpatialDatabaseAllowed() const;
	bool IsUndoAllowed() const;
	bool IsValidEdge(const struct FEdgeID& EdgeID) const;
	bool IsValidPolygon(const struct FPolygonID& PolygonID) const;
	bool IsValidPolygonGroup(const struct FPolygonGroupID& PolygonGroupID) const;
	bool IsValidVertex(const struct FVertexID& VertexID) const;
	void SearchSpatialDatabaseForPolygonsInVolume(const TArray<struct FPlane>& Planes, TArray<struct FPolygonID>* OutPolygons) const;
	void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(const struct FVector& LineSegmentStart, const struct FVector& LineSegmentEnd, TArray<struct FPolygonID>* OutPolygons) const;
	void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(const struct FPlane& InPlane, TArray<struct FPolygonID>* OutPolygons) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMesh">();
	}
	static class UEditableMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMesh>();
	}
};
static_assert(alignof(UEditableMesh) == 0x000008, "Wrong alignment on UEditableMesh");
static_assert(sizeof(UEditableMesh) == 0x000708, "Wrong size on UEditableMesh");
static_assert(offsetof(UEditableMesh, Adapters) == 0x0003B8, "Member 'UEditableMesh::Adapters' has a wrong offset!");
static_assert(offsetof(UEditableMesh, TextureCoordinateCount) == 0x0003D0, "Member 'UEditableMesh::TextureCoordinateCount' has a wrong offset!");
static_assert(offsetof(UEditableMesh, PendingCompactCounter) == 0x00051C, "Member 'UEditableMesh::PendingCompactCounter' has a wrong offset!");
static_assert(offsetof(UEditableMesh, SubdivisionCount) == 0x000520, "Member 'UEditableMesh::SubdivisionCount' has a wrong offset!");

// Class EditableMesh.EditableMeshFactory
// 0x0000 (0x0028 - 0x0028)
class UEditableMeshFactory final : public UObject
{
public:
	static class UEditableMesh* MakeEditableMesh(class UPrimitiveComponent* PrimitiveComponent, const int32 LODIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMeshFactory">();
	}
	static class UEditableMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMeshFactory>();
	}
};
static_assert(alignof(UEditableMeshFactory) == 0x000008, "Wrong alignment on UEditableMeshFactory");
static_assert(sizeof(UEditableMeshFactory) == 0x000028, "Wrong size on UEditableMeshFactory");

// Class EditableMesh.EditableStaticMeshAdapter
// 0x00B8 (0x00E0 - 0x0028)
class UEditableStaticMeshAdapter final : public UEditableMeshAdapter
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            OriginalStaticMesh;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StaticMeshLODIndex;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0xA4];                                      // 0x003C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableStaticMeshAdapter">();
	}
	static class UEditableStaticMeshAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableStaticMeshAdapter>();
	}
};
static_assert(alignof(UEditableStaticMeshAdapter) == 0x000008, "Wrong alignment on UEditableStaticMeshAdapter");
static_assert(sizeof(UEditableStaticMeshAdapter) == 0x0000E0, "Wrong size on UEditableStaticMeshAdapter");
static_assert(offsetof(UEditableStaticMeshAdapter, StaticMesh) == 0x000028, "Member 'UEditableStaticMeshAdapter::StaticMesh' has a wrong offset!");
static_assert(offsetof(UEditableStaticMeshAdapter, OriginalStaticMesh) == 0x000030, "Member 'UEditableStaticMeshAdapter::OriginalStaticMesh' has a wrong offset!");
static_assert(offsetof(UEditableStaticMeshAdapter, StaticMeshLODIndex) == 0x000038, "Member 'UEditableStaticMeshAdapter::StaticMeshLODIndex' has a wrong offset!");

}

